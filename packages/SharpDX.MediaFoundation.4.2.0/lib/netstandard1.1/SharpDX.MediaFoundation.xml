<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SharpDX.MediaFoundation</name>
    </assembly>
    <members>
        <member name="M:SharpDX.MediaFoundation.Activate.#ctor(System.String,SharpDX.ComObject)">
            <summary>	
            Creates an activation object for a Windows Runtime class.
            </summary>	
            <param name="activatableClassId"><dd> <p>The class identifier that is associated with the activatable runtime class.</p> </dd></param>	
            <param name="propertySet"><dd> <p>An optional friendly name for the activation object. The friendly name is stored in the object's <see cref="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftFriendlyNameAttribute"/> attribute. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
            <remarks>	
            <p>To create the Windows Runtime object, call <strong><see cref="M:SharpDX.MediaFoundation.Activate.ActivateObject(System.Guid,System.IntPtr@)"/></strong> or <strong>IClassFactory::CreateInstance</strong>.</p>	
            </remarks>	
            <msdn-id>hh162753</msdn-id>	
            <unmanaged>HRESULT MFCreateMediaExtensionActivate([In] const wchar_t* szActivatableClassId,[In, Optional] IUnknown* pConfiguration,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>	
            <unmanaged-short>MFCreateMediaExtensionActivate</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.Activate.ActivateObject``1(System.Guid)">
            <summary>	
            <p> Creates the object associated with this activation object. </p>	
            </summary>	
            <param name="riid"><dd> <p> Interface identifier (IID) of the requested interface. </p> </dd></param>	
            <returns><dd> <p> A reference to the requested interface. The caller must release the interface. </p> </dd></returns>	
            <remarks>	
            <p>Some Microsoft Media Foundation objects must be shut down before being released. If so, the caller is responsible for shutting down the object that is returned in <em>ppv</em>. To shut down the object, do one of the following:</p><ul> <li>Call <strong><see cref="M:SharpDX.MediaFoundation.Activate.ShutdownObject" /></strong> on the activation object, or</li> <li>Call the object-specific shutdown method. This method will depend on the type of object. Possibilities include:<ul> <li>Media sources: Call <strong><see cref="M:SharpDX.MediaFoundation.MediaSource.Shutdown" /></strong>.</li> <li>Media sinks: Call <strong><see cref="M:SharpDX.MediaFoundation.MediaSink.Shutdown" /></strong>.</li> <li>Any object that supports the <strong><see cref="T:SharpDX.MediaFoundation.Shutdownable" /></strong> interface: Call <strong><see cref="M:SharpDX.MediaFoundation.Shutdownable.Shutdown" /></strong>.</li> </ul> </li> </ul><p>The <strong><see cref="M:SharpDX.MediaFoundation.Activate.ShutdownObject" /></strong> method is generic to all object types. If the object does not require a shutdown method, <strong>ShutdownObject</strong> succeeds and has no effect. If you do not know the specific shutdown method for the object (or do not know the object type), call <strong><see cref="M:SharpDX.MediaFoundation.Activate.ShutdownObject" /></strong>.</p><p> After the first call to <strong>ActivateObject</strong>, subsequent calls return a reference to the same instance, until the client calls either <strong>ShutdownObject</strong> or <strong><see cref="M:SharpDX.MediaFoundation.Activate.DetachObject" /></strong>. </p>	
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IMFActivate::ActivateObject']/*" />	
            <msdn-id>ms694292</msdn-id>	
            <unmanaged>HRESULT IMFActivate::ActivateObject([In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>	
            <unmanaged-short>IMFActivate::ActivateObject</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.Activate.ActivateObject``1">
            <summary>	
            <p> Creates the object associated with this activation object. Riid is provided via reflection on the COM object type </p>	
            </summary>
            <returns><dd> <p> A reference to the requested interface. The caller must release the interface. </p> </dd></returns>	
            <remarks>	
            <p>Some Microsoft Media Foundation objects must be shut down before being released. If so, the caller is responsible for shutting down the object that is returned in <em>ppv</em>. To shut down the object, do one of the following:</p><ul> <li>Call <strong><see cref="M:SharpDX.MediaFoundation.Activate.ShutdownObject" /></strong> on the activation object, or</li> <li>Call the object-specific shutdown method. This method will depend on the type of object. Possibilities include:<ul> <li>Media sources: Call <strong><see cref="M:SharpDX.MediaFoundation.MediaSource.Shutdown" /></strong>.</li> <li>Media sinks: Call <strong><see cref="M:SharpDX.MediaFoundation.MediaSink.Shutdown" /></strong>.</li> <li>Any object that supports the <strong><see cref="T:SharpDX.MediaFoundation.Shutdownable" /></strong> interface: Call <strong><see cref="M:SharpDX.MediaFoundation.Shutdownable.Shutdown" /></strong>.</li> </ul> </li> </ul><p>The <strong><see cref="M:SharpDX.MediaFoundation.Activate.ShutdownObject" /></strong> method is generic to all object types. If the object does not require a shutdown method, <strong>ShutdownObject</strong> succeeds and has no effect. If you do not know the specific shutdown method for the object (or do not know the object type), call <strong><see cref="M:SharpDX.MediaFoundation.Activate.ShutdownObject" /></strong>.</p><p> After the first call to <strong>ActivateObject</strong>, subsequent calls return a reference to the same instance, until the client calls either <strong>ShutdownObject</strong> or <strong><see cref="M:SharpDX.MediaFoundation.Activate.DetachObject" /></strong>. </p>	
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IMFActivate::ActivateObject']/*" />	
            <msdn-id>ms694292</msdn-id>	
            <unmanaged>HRESULT IMFActivate::ActivateObject([In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>	
            <unmanaged-short>IMFActivate::ActivateObject</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.Activate.ActivateObject(System.Guid,System.IntPtr@)">
            <summary>
            <p> Creates the object associated with this activation object. </p>
            </summary>
            <param name = "riid"><dd> <p> Interface identifier (IID) of the requested interface. </p> </dd></param>
            <param name = "vOut"><dd> <p> Receives a reference to the requested interface. The caller must release the interface. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Some Microsoft Media Foundation objects must be shut down before being released. If so, the caller is responsible for shutting down the object that is returned in <em>ppv</em>. To shut down the object, do one of the following:</p><ul> <li>Call <strong>IMFActivate::ShutdownObject</strong> on the activation object, or</li> <li>Call the object-specific shutdown method. This method will depend on the type of object. Possibilities include:<ul> <li>Media sources: Call <strong>IMFMediaSource::Shutdown</strong>.</li> <li>Media sinks: Call <strong>IMFMediaSink::Shutdown</strong>.</li> <li>Any object that supports the <strong><see cref = "T:SharpDX.MediaFoundation.Shutdownable"/></strong> interface: Call <strong>IMFShutdown::Shutdown</strong>.</li> </ul> </li> </ul><p>The <strong>IMFActivate::ShutdownObject</strong> method is generic to all object types. If the object does not require a shutdown method, <strong>ShutdownObject</strong> succeeds and has no effect. If you do not know the specific shutdown method for the object (or do not know the object type), call <strong>IMFActivate::ShutdownObject</strong>.</p><p> After the first call to <strong>ActivateObject</strong>, subsequent calls return a reference to the same instance, until the client calls either <strong>ShutdownObject</strong> or <strong>IMFActivate::DetachObject</strong>. </p>
            </remarks>
            <doc-id>ms694292</doc-id>
            <unmanaged>HRESULT IMFActivate::ActivateObject([In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>
            <unmanaged-short>IMFActivate::ActivateObject</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Activate.ShutdownObject">
            <summary>
            <p> </p><p>Shuts down the created object.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If you create an object by calling <strong>IMFActivate::ActivateObject</strong>, call <strong>ShutdownObject</strong> when you are done using the object.</p><p>The component that calls <strong>ActivateObject</strong>?not the component that creates the activation object?is responsible for calling <strong>ShutdownObject</strong>. For example, in a typical playback application, the application creates activation objects for the media sinks, but the Media Session calls <strong>ActivateObject</strong>. Therefore the Media Session, not the application, calls <strong>ShutdownObject</strong>.</p><p>After <strong>ShutdownObject</strong> is called, the activation object releases all of its internal references to the created object. If you call <strong>ActivateObject</strong> again, the activation object will create a new instance of the other object.</p>
            </remarks>
            <doc-id>ms695228</doc-id>
            <unmanaged>HRESULT IMFActivate::ShutdownObject()</unmanaged>
            <unmanaged-short>IMFActivate::ShutdownObject</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Activate.DetachObject">
            <summary>
            <p> </p><p>Detaches the created object from the activation object.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>Not implemented.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The activation object releases all of its internal references to the created object. If you call <strong>ActivateObject</strong> again, the activation object will create a new instance of the other object.</p><p>The <strong>DetachObject</strong> method does not shut down the created object. If the <strong>DetachObject</strong> method succeeds, the client must shut down the created object. This rule applies only to objects that have a shutdown method or that support the <strong><see cref = "T:SharpDX.MediaFoundation.Shutdownable"/></strong> interface. See the remarks for <strong>IMFActivate::ActivateObject</strong>.</p><p>Implementation of this method is optional. If the activation object does not support this method, the method returns E_NOTIMPL.</p>
            </remarks>
            <doc-id>aa367342</doc-id>
            <unmanaged>HRESULT IMFActivate::DetachObject()</unmanaged>
            <unmanaged-short>IMFActivate::DetachObject</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.AssemblyDoc">
            <summary>
            The <see cref="A:SharpDX.MediaFoundation"/> assembly provides managed MediaFoundation API.
            </summary>
            <msdn-id></msdn-id>
            <unmanaged>MediaFoundation</unmanaged>	
            <unmanaged-short>MediaFoundation</unmanaged-short>	
        </member>
        <member name="T:SharpDX.MediaFoundation.AsyncCallbackBase">
            <summary>
            A default implementation of AsyncCallbackBase.
            </summary>
        </member>
        <member name="T:SharpDX.MediaFoundation.AsyncCallbackShadow">
            <summary>
            Internal AsyncCallback Callback
            </summary>
        </member>
        <member name="M:SharpDX.MediaFoundation.AsyncCallbackShadow.ToIntPtr(SharpDX.MediaFoundation.IAsyncCallback)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.MediaFoundation.AsyncCallbackShadow.AsyncCallbackVtbl.GetParametersDelegate">
            <unmanaged>HRESULT IMFAsyncCallback::GetParameters([Out] MFASYNC_CALLBACK_FLAGS* pdwFlags,[Out] unsigned int* pdwQueue)</unmanaged>	
        </member>
        <member name="T:SharpDX.MediaFoundation.AsyncCallbackShadow.AsyncCallbackVtbl.InvokeDelegate">
            <unmanaged>HRESULT IMFAsyncCallback::Invoke([In, Optional] IMFAsyncResult* pAsyncResult)</unmanaged>	
        </member>
        <member name="P:SharpDX.MediaFoundation.AsyncResult.State">
            <summary>
            Gets the state object specified by the caller in the asynchronous <strong>Begin</strong> method. If the value is not <strong><c>null</c></strong>, the caller must dispose.
            </summary>
            <value>The state.</value>
            <remarks>	
            <p>The caller of the asynchronous method specifies the state object, and can use it for any caller-defined purpose. The state object can be <strong><c>null</c></strong>. If the state object is <strong><c>null</c></strong>, <strong>GetState</strong> returns <strong>E_POINTER</strong>.</p><p>If you are implementing an asynchronous method, set the state object on the through the <em>punkState</em> parameter of the <strong><see cref="M:SharpDX.MediaFoundation.MediaFactory.CreateAsyncResult(SharpDX.IUnknown,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown,SharpDX.MediaFoundation.AsyncResult@)"/></strong> function.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>bb970576</msdn-id>	
            <unmanaged>HRESULT IMFAsyncResult::GetState([Out] IUnknown** ppunkState)</unmanaged>	
            <unmanaged-short>IMFAsyncResult::GetState</unmanaged-short>	
        </member>
        <member name="P:SharpDX.MediaFoundation.AsyncResult.Status">
            <summary>	
            <p>Get or sets the status of the asynchronous operation.</p>	
            </summary>	
            <value><p>The method returns an <strong><see cref="T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The operation completed successfully.</p> </td></tr> </table><p>?</p></value>	
            <remarks>	
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms702095</msdn-id>	
            <unmanaged>HRESULT IMFAsyncResult::GetStatus()</unmanaged>	
            <unmanaged-short>IMFAsyncResult::GetStatus</unmanaged-short>	
        </member>
        <member name="P:SharpDX.MediaFoundation.AsyncResult.PrivateObject">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> </p><p>Returns an object associated with the asynchronous operation. The type of object, if any, depends on the asynchronous method that was called.</p>	
            </summary>	
            <value><dd> <p>Receives a reference to the object's <strong><see cref="T:SharpDX.ComObject"/></strong> interface. If no object is associated with the operation, this parameter receives the value <strong><c>null</c></strong>. If the value is not <strong><c>null</c></strong>, the caller must release the interface.</p> </dd></value>	
            <remarks>	
            <p>Typically, this object is used by the component that implements the asynchronous method. It provides a way for the function that invokes the callback to pass information to the asynchronous <strong>End...</strong> method that completes the operation.</p><p>If you are implementing an asynchronous method, you can set the object through the <em>punkObject</em> parameter of the <strong><see cref="M:SharpDX.MediaFoundation.MediaFactory.CreateAsyncResult(SharpDX.IUnknown,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown,SharpDX.MediaFoundation.AsyncResult@)"/></strong> function.</p><p>If the asynchronous result object's internal <strong><see cref="T:SharpDX.ComObject"/></strong> reference is <strong><c>null</c></strong>, the method returns <strong>E_POINTER</strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>bb970500</msdn-id>	
            <unmanaged>HRESULT IMFAsyncResult::GetObjectW([Out] IUnknown** ppObject)</unmanaged>	
            <unmanaged-short>IMFAsyncResult::GetObjectW</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.AsyncResult.GetState(System.IntPtr@)">
            <summary>
            <p> </p><p>Returns the state object specified by the caller in the asynchronous <strong>Begin</strong> method.</p>
            </summary>
            <param name = "unkStateOut"><dd> <p>Receives a reference to the state object's <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface. If the value is not <strong><c>null</c></strong>, the caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>There is no state object associated with this asynchronous result.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The caller of the asynchronous method specifies the state object, and can use it for any caller-defined purpose. The state object can be <strong><c>null</c></strong>. If the state object is <strong><c>null</c></strong>, <strong>GetState</strong> returns <strong>E_POINTER</strong>.</p><p>If you are implementing an asynchronous method, set the state object on the through the <em>punkState</em> parameter of the <strong>MFCreateAsyncResult</strong> function.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970576</doc-id>
            <unmanaged>HRESULT IMFAsyncResult::GetState([Out] IUnknown** ppunkState)</unmanaged>
            <unmanaged-short>IMFAsyncResult::GetState</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.AsyncResult.GetStatus">
            <summary>
            <p> </p><p>Returns the status of the asynchronous operation.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The operation completed successfully.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms702095</doc-id>
            <unmanaged>HRESULT IMFAsyncResult::GetStatus()</unmanaged>
            <unmanaged-short>IMFAsyncResult::GetStatus</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.AsyncResult.SetStatus(SharpDX.Result)">
            <summary>
            <p> </p><p>Sets the status of the asynchronous operation.</p>
            </summary>
            <param name = "hrStatus"><dd> <p>The status of the asynchronous operation.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If you implement an asynchronous method, call <strong>SetStatus</strong> to set the status code for the operation.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970435</doc-id>
            <unmanaged>HRESULT IMFAsyncResult::SetStatus([In] HRESULT hrStatus)</unmanaged>
            <unmanaged-short>IMFAsyncResult::SetStatus</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.AsyncResult.GetObject(SharpDX.IUnknown@)">
            <summary>
            <p> </p><p>Returns an object associated with the asynchronous operation. The type of object, if any, depends on the asynchronous method that was called.</p>
            </summary>
            <param name = "objectOut"><dd> <p>Receives a reference to the object's <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface. If no object is associated with the operation, this parameter receives the value <strong><c>null</c></strong>. If the value is not <strong><c>null</c></strong>, the caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>There is no object associated with this asynchronous result.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Typically, this object is used by the component that implements the asynchronous method. It provides a way for the function that invokes the callback to pass information to the asynchronous <strong>End...</strong> method that completes the operation.</p><p>If you are implementing an asynchronous method, you can set the object through the <em>punkObject</em> parameter of the <strong>MFCreateAsyncResult</strong> function.</p><p>If the asynchronous result object's internal <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference is <strong><c>null</c></strong>, the method returns <strong>E_POINTER</strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970500</doc-id>
            <unmanaged>HRESULT IMFAsyncResult::GetObjectW([Out] IUnknown** ppObject)</unmanaged>
            <unmanaged-short>IMFAsyncResult::GetObjectW</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.AsyncResult.GetStateNoAddRef">
            <summary>
            <p> </p><p>Returns the state object specified by the caller in the asynchronous <strong>Begin</strong> method, without incrementing the object's reference count.</p>
            </summary>
            <returns><p>Returns a reference to the state object's <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface, or <strong><c>null</c></strong> if no object was set. This reference does not have an outstanding reference count. If you store this reference, you must call <strong>AddRef</strong> on the reference.</p></returns>
            <remarks>
            <p>This method cannot be called remotely.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms696238</doc-id>
            <unmanaged>IUnknown* IMFAsyncResult::GetStateNoAddRef()</unmanaged>
            <unmanaged-short>IMFAsyncResult::GetStateNoAddRef</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.AudioDecoder">
            <summary>
            Decoder from compressed audio (mp3, wma...etc.) to PCM.
            </summary>
            <remarks>
            This class was developed following the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd757929%28v=vs.85%29.aspx">"Tutorial: Decoding Audio"</a>
            </remarks>
        </member>
        <member name="M:SharpDX.MediaFoundation.AudioDecoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.MediaFoundation.AudioDecoder" /> class.
            </summary>
        </member>
        <member name="M:SharpDX.MediaFoundation.AudioDecoder.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.MediaFoundation.AudioDecoder" /> class.
            </summary>
            <param name="stream">The stream to read the compressed audio.</param>
        </member>
        <member name="M:SharpDX.MediaFoundation.AudioDecoder.SetSourceStream(System.IO.Stream)">
            <summary>
            Gets or sets the source stream. See remarks.
            </summary>
            <value>The source.</value>
            <remarks>
            The source must be set before calling <see cref="M:SharpDX.MediaFoundation.AudioDecoder.GetSamples"/>
            </remarks>
        </member>
        <member name="P:SharpDX.MediaFoundation.AudioDecoder.Duration">
            <summary>
            Gets the total duration in seconds.
            </summary>
            <value>The duration.</value>
        </member>
        <member name="P:SharpDX.MediaFoundation.AudioDecoder.WaveFormat">
            <summary>
            Gets the PCM wave format output by this decoder.
            </summary>
            <value>The wave format.</value>
        </member>
        <member name="M:SharpDX.MediaFoundation.AudioDecoder.GetSamples">
            <summary>
            Gets the decoded PCM samples. See remarks.
            </summary>
            <returns>An enumerator of pointer to PCM decoded data with the same format as returned by <see cref="P:SharpDX.MediaFoundation.AudioDecoder.WaveFormat"/>.</returns>
            <remarks>
            This method is only working as a single enumerator at a time.
            </remarks>
            <remarks>
            The <see cref="!:Source"/> must be set before calling <see cref="M:SharpDX.MediaFoundation.AudioDecoder.GetSamples"/>
            </remarks>
        </member>
        <member name="M:SharpDX.MediaFoundation.AudioDecoder.GetSamples(System.TimeSpan)">
            <summary>
            Gets the decoded PCM samples. See remarks.
            </summary>
            <param name="startingPositionInSeconds">The starting position in seconds.</param>
            <returns>An enumerator of pointer to PCM decoded data with the same format as returned by <see cref="P:SharpDX.MediaFoundation.AudioDecoder.WaveFormat"/>.</returns>
            <remarks>
            This method is only working as a single enumerator at a time.
            The <see cref="M:SharpDX.MediaFoundation.AudioDecoder.SetSourceStream(System.IO.Stream)"/> must be set before calling <see cref="M:SharpDX.MediaFoundation.AudioDecoder.GetSamples"/>
            </remarks>
        </member>
        <member name="T:SharpDX.MediaFoundation.ByteStream">
            <summary>
            ByteStream class used 
            </summary>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.#ctor(System.IO.Stream)">
            <summary>
            Instantiates a new instance <see cref="T:SharpDX.MediaFoundation.ByteStream"/> from a <see cref="T:System.IO.Stream"/>.
            </summary>
            <msdn-id>hh162754</msdn-id>	
            <unmanaged>HRESULT MFCreateMFByteStreamOnStreamEx([In] IUnknown* punkStream,[Out] IMFByteStream** ppByteStream)</unmanaged>	
            <unmanaged-short>MFCreateMFByteStreamOnStreamEx</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.#ctor(System.Byte[])">
            <summary>
            Instantiates a new instance <see cref="T:SharpDX.MediaFoundation.ByteStream"/> from a <see cref="T:System.IO.Stream"/>.
            </summary>
            <msdn-id>hh162754</msdn-id>	
            <unmanaged>HRESULT MFCreateMFByteStreamOnStreamEx([In] IUnknown* punkStream,[Out] IMFByteStream** ppByteStream)</unmanaged>	
            <unmanaged-short>MFCreateMFByteStreamOnStreamEx</unmanaged-short>	
        </member>
        <member name="P:SharpDX.MediaFoundation.ByteStream.Capabilities">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Retrieves the characteristics of the byte stream. </p>	
            </summary>	
            <returns>The capabilities of the stream.</returns>	
            <remarks>	
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms698962</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::GetCapabilities([Out] unsigned int* pdwCapabilities)</unmanaged>	
            <unmanaged-short>IMFByteStream::GetCapabilities</unmanaged-short>	
        </member>
        <member name="P:SharpDX.MediaFoundation.ByteStream.Length">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Retrieves the length of the stream. </p>	
            </summary>	
            <returns>The length of the stream, in bytes. If the length is unknown, this value is -1.</returns>	
            <remarks>	
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms698941</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::GetLength([Out] unsigned longlong* pqwLength)</unmanaged>	
            <unmanaged-short>IMFByteStream::GetLength</unmanaged-short>	
        </member>
        <member name="P:SharpDX.MediaFoundation.ByteStream.CurrentPosition">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Retrieves the current read or write position in the stream. </p>	
            </summary>	
            <returns>The current position, in bytes.</returns>	
            <remarks>	
            <p> The methods that update the current position are <strong>Read</strong>, <strong>BeginRead</strong>, <strong>Write</strong>, <strong>BeginWrite</strong>, <strong>SetCurrentPosition</strong>, and <strong>Seek</strong>. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms704059</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::GetCurrentPosition([Out] unsigned longlong* pqwPosition)</unmanaged>	
            <unmanaged-short>IMFByteStream::GetCurrentPosition</unmanaged-short>	
        </member>
        <member name="P:SharpDX.MediaFoundation.ByteStream.IsEndOfStream">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> </p><p>Queries whether the current position has reached the end of the stream.</p>	
            </summary>	
            <returns>true if the end of the stream has been reached</returns>	
            <remarks>	
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms697369</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::IsEndOfStream([Out] BOOL* pfEndOfStream)</unmanaged>	
            <unmanaged-short>IMFByteStream::IsEndOfStream</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Reads data from the stream. </p>	
            </summary>	
            <param name="bRef"><dd> <p> Pointer to a buffer that receives the data. The caller must allocate the buffer. </p> </dd></param>
            <param name="offset">Offset into the buffer.</param>
            <param name="count"><dd> <p> Size of the buffer in bytes. </p> </dd></param>	
            <returns>The number of bytes that are copied into the buffer</returns>	
            <remarks>	
            <p> This method reads at most <em>cb</em> bytes from the current position in the stream and copies them into the buffer provided by the caller. The number of bytes that were read is returned in the <em>pcbRead</em> parameter. The method does not return an error code on reaching the end of the file, so the application should check the value in <em>pcbRead</em> after the method returns. </p><p> This method is synchronous. It blocks until the read operation completes. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms698913</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::Read([Out, Buffer] unsigned char* pb,[In] unsigned int cb,[Out] unsigned int* pcbRead)</unmanaged>	
            <unmanaged-short>IMFByteStream::Read</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.BeginRead(System.Byte[],System.Int32,System.Int32,SharpDX.MediaFoundation.IAsyncCallback,System.Object)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Begins an asynchronous read operation from the stream. </p>	
            </summary>	
            <param name="bRef"><dd> <p> Pointer to a buffer that receives the data. The caller must allocate the buffer. </p> </dd></param>
            <param name="offset">The offset in the buffer to begin reading from.</param>
            <param name="count"><dd> <p> Size of the buffer in bytes. </p> </dd></param>	
            <param name="callbackRef"><dd> <p> Pointer to the <strong><see cref="T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>	
            <param name="context"><dd> <p> Pointer to the <strong><see cref="T:SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result"/></strong> error code.</p></returns>	
            <remarks>	
            <p> When all of the data has been read into the buffer, the callback object's <strong><see cref="M:SharpDX.MediaFoundation.IAsyncCallback.Invoke(SharpDX.MediaFoundation.AsyncResult)"/></strong> method is called. At that point, the application should call <strong><see cref="M:SharpDX.MediaFoundation.IByteStream.EndRead(SharpDX.MediaFoundation.AsyncResult)"/></strong> to complete the asynchronous request. </p><p> Do not read from, write to, free, or reallocate the buffer while an asynchronous read is pending. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms704810</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::BeginRead([Out, Buffer] unsigned char* pb,[In] unsigned int cb,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>	
            <unmanaged-short>IMFByteStream::BeginRead</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.EndRead(SharpDX.MediaFoundation.AsyncResult)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Completes an asynchronous read operation. </p>	
            </summary>	
            <param name="resultRef"><dd> <p> Pointer to the <strong><see cref="T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong><see cref="M:SharpDX.MediaFoundation.IAsyncCallback.Invoke(SharpDX.MediaFoundation.AsyncResult)"/></strong> method. </p> </dd></param>	
            <returns>The number of bytes that were read</returns>	
            <remarks>	
            <p> Call this method after the <strong><see cref="M:SharpDX.MediaFoundation.IByteStream.BeginRead(System.Byte[],System.Int32,System.Int32,SharpDX.MediaFoundation.IAsyncCallback,System.Object)"/></strong> method completes asynchronously. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms704042</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::EndRead([In] IMFAsyncResult* pResult,[Out] unsigned int* pcbRead)</unmanaged>	
            <unmanaged-short>IMFByteStream::EndRead</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> </p><p>Writes data to the stream.</p>	
            </summary>	
            <param name="bRef"><dd> <p> Pointer to a buffer that contains the data to write. </p> </dd></param>
            <param name="offset">The offset within the buffer to begin writing at.</param>
            <param name="count"><dd> <p> Size of the buffer in bytes. </p> </dd></param>	
            <returns>The number of bytes that are written.</returns>	
            <remarks>	
            <p> This method writes the contents of the <em>pb</em> buffer to the stream, starting at the current stream position. The number of bytes that were written is returned in the <em>pcbWritten</em> parameter. </p><p> This method is synchronous. It blocks until the write operation completes. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms703843</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::Write([In, Buffer] const unsigned char* pb,[In] unsigned int cb,[Out] unsigned int* pcbWritten)</unmanaged>	
            <unmanaged-short>IMFByteStream::Write</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.BeginWrite(System.Byte[],System.Int32,System.Int32,SharpDX.MediaFoundation.IAsyncCallback,System.Object)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Begins an asynchronous write operation to the stream. </p>	
            </summary>	
            <param name="bRef"><dd> <p> Pointer to a buffer containing the data to write. </p> </dd></param>
            <param name="offset">The offset within the buffer to begin writing at.</param>
            <param name="count"><dd> <p> Size of the buffer in bytes. </p> </dd></param>	
            <param name="callbackRef"><dd> <p> Pointer to the <strong><see cref="T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>	
            <param name="context"><dd> <p> Pointer to the <strong><see cref="T:SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result"/></strong> error code.</p></returns>	
            <remarks>	
            <p> When all of the data has been written to the stream, the callback object's <strong><see cref="M:SharpDX.MediaFoundation.IAsyncCallback.Invoke(SharpDX.MediaFoundation.AsyncResult)"/></strong> method is called. At that point, the application should call <strong><see cref="M:SharpDX.MediaFoundation.IByteStream.EndWrite(SharpDX.MediaFoundation.AsyncResult)"/></strong> to complete the asynchronous request. </p><p> Do not reallocate, free, or write to the buffer while an asynchronous write is still pending. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms694005</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::BeginWrite([In, Buffer] const unsigned char* pb,[In] unsigned int cb,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>	
            <unmanaged-short>IMFByteStream::BeginWrite</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.EndWrite(SharpDX.MediaFoundation.AsyncResult)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> </p><p>Completes an asynchronous write operation.</p>	
            </summary>	
            <param name="resultRef"><dd> <p>Pointer to the <strong><see cref="T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong><see cref="M:SharpDX.MediaFoundation.IAsyncCallback.Invoke(SharpDX.MediaFoundation.AsyncResult)"/></strong> method.</p> </dd></param>	
            <returns>The number of bytes that were written</returns>	
            <remarks>	
            <p> Call this method when the <strong><see cref="M:SharpDX.MediaFoundation.IByteStream.BeginWrite(System.Byte[],System.Int32,System.Int32,SharpDX.MediaFoundation.IAsyncCallback,System.Object)"/></strong> method completes asynchronously. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms703863</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::EndWrite([In] IMFAsyncResult* pResult,[Out] unsigned int* pcbWritten)</unmanaged>	
            <unmanaged-short>IMFByteStream::EndWrite</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.Seek(SharpDX.MediaFoundation.ByteStreamSeekOrigin,System.Int64,System.Int32)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> </p><p>Moves the current position in the stream by a specified offset.</p>	
            </summary>	
            <param name="seekOrigin"><dd> <p> Specifies the origin of the seek as a member of the <strong><see cref="!:SharpDX.MediaFoundation.BytestreamSeekOrigin"/></strong> enumeration. The offset is calculated relative to this position. </p> </dd></param>	
            <param name="llSeekOffset"><dd> <p> Specifies the new position, as a byte offset from the seek origin. </p> </dd></param>	
            <param name="dwSeekFlags"><dd> <p> Specifies zero or more flags. The following flags are defined. </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_SEEK_FLAG_CANCEL_PENDING_IO</strong></dt> </dl> </td><td> <p> All pending I/O requests are canceled after the seek request completes successfully. </p> </td></tr> </table> <p>?</p> </dd></param>	
            <returns>The new position after the seek</returns>	
            <remarks>	
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms697053</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::Seek([In] MFBYTESTREAM_SEEK_ORIGIN SeekOrigin,[In] longlong llSeekOffset,[In] unsigned int dwSeekFlags,[Out] unsigned longlong* pqwCurrentPosition)</unmanaged>	
            <unmanaged-short>IMFByteStream::Seek</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.Flush">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Clears any internal buffers used by the stream. If you are writing to the stream, the buffered data is written to the underlying file or device. </p>	
            </summary>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result"/></strong> error code.</p></returns>	
            <remarks>	
            <p> If the byte stream is read-only, this method has no effect.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms694833</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::Flush()</unmanaged>	
            <unmanaged-short>IMFByteStream::Flush</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.Close">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Closes the stream and releases any resources associated with the stream, such as sockets or file handles. This method also cancels any pending asynchronous I/O requests. </p>	
            </summary>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result"/></strong> error code.</p></returns>	
            <remarks>	
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms703909</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::Close()</unmanaged>	
            <unmanaged-short>IMFByteStream::Close</unmanaged-short>	
        </member>
        <member name="P:SharpDX.MediaFoundation.ByteStream.Capabilities_">
            <summary>
            <p> Retrieves the characteristics of the byte stream. </p>
            </summary>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms698962</doc-id>
            <unmanaged>GetCapabilities</unmanaged>
            <unmanaged-short>GetCapabilities</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.ByteStream.Length_">
            <summary>
            <p>Retrieves or sets the length of the stream. </p>
            </summary>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms698941</doc-id>
            <unmanaged>GetLength / SetLength</unmanaged>
            <unmanaged-short>GetLength</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.ByteStream.CurrentPosition_">
            <summary>
            <p>Retrieves or sets the current read or write position in the stream. </p>
            </summary>
            <remarks>
            <p> The methods that update the current position are <strong>Read</strong>, <strong>BeginRead</strong>, <strong>Write</strong>, <strong>BeginWrite</strong>, <strong>SetCurrentPosition</strong>, and <strong>Seek</strong>. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms704059</doc-id>
            <unmanaged>GetCurrentPosition / SetCurrentPosition</unmanaged>
            <unmanaged-short>GetCurrentPosition</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.ByteStream.IsEndOfStream_">
            <summary>
            <p> </p><p>Queries whether the current position has reached the end of the stream.</p>
            </summary>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms697369</doc-id>
            <unmanaged>IsEndOfStream</unmanaged>
            <unmanaged-short>IsEndOfStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.GetCapabilities_(System.Int32@)">
            <summary>
            <p> Retrieves the characteristics of the byte stream. </p>
            </summary>
            <param name = "dwCapabilitiesRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags. The following flags are defined.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_IS_READABLE</strong></dt> <dt>0x00000001</dt> </dl> </td><td> <p> The byte stream can be read. </p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_IS_WRITABLE</strong></dt> <dt>0x00000002</dt> </dl> </td><td> <p> The byte stream can be written to. </p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_IS_SEEKABLE</strong></dt> <dt>0x00000004</dt> </dl> </td><td> <p> The byte stream can be seeked. </p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_IS_REMOTE</strong></dt> <dt>0x00000008</dt> </dl> </td><td> <p> The byte stream is from a remote source, such as a network. </p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_IS_DIRECTORY</strong></dt> <dt>0x00000080</dt> </dl> </td><td> <p> The byte stream represents a file directory. </p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_HAS_SLOW_SEEK</strong></dt> <dt>0x00000100</dt> </dl> </td><td> <p> Seeking within this stream might be slow. For example, the byte stream might download from a network.</p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_IS_PARTIALLY_DOWNLOADED</strong></dt> <dt>0x00000200</dt> </dl> </td><td> <p>The byte stream is currently downloading data to a local cache. Read operations on the byte stream might take longer until the data is completely downloaded.</p> <p>This flag is cleared after all of the data has been downloaded.</p> <p>If the <strong>MFBYTESTREAM_HAS_SLOW_SEEK</strong> flag is also set, it means the byte stream must download the entire file sequentially. Otherwise, the byte stream can respond to seek requests by restarting the download from a new point in the stream.</p> </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_SHARE_WRITE</strong></dt> <dt>0x00000400</dt> </dl> </td><td> <p>Another thread or process can open this byte stream for writing. If this flag is present, the length of thebyte stream could change while it is being read. </p> <p>This flag can affect the behavior of byte-stream handlers. For more information, see <see cref = "!:HandlerAcceptsShareWrite"/>.</p> <strong>Note</strong>??Requires Windows?7 or later. ? </td></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_DOES_NOT_USE_NETWORK</strong></dt> <dt>0x00000800</dt> </dl> </td><td> <p>The byte stream is not currentlyusing the network to receive the content.  Networking hardwaremay enter a power saving state when this bit is set.</p> <strong>Note</strong>??Requires Windows?8 or later. ? </td></tr> </table> <p>?</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms698962</doc-id>
            <unmanaged>HRESULT IMFByteStream::GetCapabilities([Out] DWORD* pdwCapabilities)</unmanaged>
            <unmanaged-short>IMFByteStream::GetCapabilities</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.GetLength_(System.Int64@)">
            <summary>
            <p> Retrieves the length of the stream. </p>
            </summary>
            <param name = "qwLengthRef"><dd> <p> Receives the length of the stream, in bytes. If the length is unknown, this value is -1. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms698941</doc-id>
            <unmanaged>HRESULT IMFByteStream::GetLength([Out] unsigned longlong* pqwLength)</unmanaged>
            <unmanaged-short>IMFByteStream::GetLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.SetLength_(System.Int64)">
            <summary>
            <p> </p><p>Sets the length of the stream.</p>
            </summary>
            <param name = "qwLength"><dd> <p> Length of the stream in bytes. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms697225</doc-id>
            <unmanaged>HRESULT IMFByteStream::SetLength([In] unsigned longlong qwLength)</unmanaged>
            <unmanaged-short>IMFByteStream::SetLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.GetCurrentPosition_(System.Int64@)">
            <summary>
            <p> Retrieves the current read or write position in the stream. </p>
            </summary>
            <param name = "qwPositionRef"><dd> <p> Receives the current position, in bytes. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The methods that update the current position are <strong>Read</strong>, <strong>BeginRead</strong>, <strong>Write</strong>, <strong>BeginWrite</strong>, <strong>SetCurrentPosition</strong>, and <strong>Seek</strong>. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms704059</doc-id>
            <unmanaged>HRESULT IMFByteStream::GetCurrentPosition([Out] unsigned longlong* pqwPosition)</unmanaged>
            <unmanaged-short>IMFByteStream::GetCurrentPosition</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.SetCurrentPosition_(System.Int64)">
            <summary>
            <p> </p><p>Sets the current read or write position.</p>
            </summary>
            <param name = "qwPosition"><dd> <p>New position in the stream, as a byte offset from the start of the stream.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> Invalid argument. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> If the new position is larger than the length of the stream, the method returns E_INVALIDARG. </p><p><strong> Implementation notes:</strong> This method should update the current position in the stream by setting the current position to the value passed in to the <em>qwPosition</em> parameter. Other methods that can update the current position are <strong>Read</strong>, <strong>BeginRead</strong>, <strong>Write</strong>, <strong>BeginWrite</strong>, and <strong>Seek</strong>.
            </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms695238</doc-id>
            <unmanaged>HRESULT IMFByteStream::SetCurrentPosition([In] unsigned longlong qwPosition)</unmanaged>
            <unmanaged-short>IMFByteStream::SetCurrentPosition</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.IsEndOfStream__(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p> </p><p>Queries whether the current position has reached the end of the stream.</p>
            </summary>
            <param name = "fEndOfStreamRef"><dd> <p> Receives the value <strong>TRUE</strong> if the end of the stream has been reached, or <strong><see cref = "F:SharpDX.Result.False"/></strong> otherwise. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms697369</doc-id>
            <unmanaged>HRESULT IMFByteStream::IsEndOfStream([Out] BOOL* pfEndOfStream)</unmanaged>
            <unmanaged-short>IMFByteStream::IsEndOfStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.Read_(System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            <p> Reads data from the stream. </p>
            </summary>
            <param name = "bRef"><dd> <p> Pointer to a buffer that receives the data. The caller must allocate the buffer. </p> </dd></param>
            <param name = "cb"><dd> <p> Size of the buffer in bytes. </p> </dd></param>
            <param name = "cbReadRef"><dd> <p> Receives the number of bytes that are copied into the buffer. This parameter cannot be <strong><c>null</c></strong>. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> This method reads at most <em>cb</em> bytes from the current position in the stream and copies them into the buffer provided by the caller. The number of bytes that were read is returned in the <em>pcbRead</em> parameter. The method does not return an error code on reaching the end of the file, so the application should check the value in <em>pcbRead</em> after the method returns. </p><p> This method is synchronous. It blocks until the read operation completes. </p><p><strong> Implementation notes:</strong> This method should update the current position in the stream by adding the number of bytes that were read, which is specified by the value returned in the <em>pcbRead</em> parameter,  to the current position. Other methods that can update the current position are <strong>Read</strong>, <strong>Write</strong>, <strong>BeginWrite</strong>, <strong>Seek</strong>, and <strong>SetCurrentPosition</strong>. 
            </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms698913</doc-id>
            <unmanaged>HRESULT IMFByteStream::Read([In] unsigned char* pb,[In] ULONG cb,[Out] ULONG* pcbRead)</unmanaged>
            <unmanaged-short>IMFByteStream::Read</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.BeginRead_(System.IntPtr,System.Int32,SharpDX.MediaFoundation.IAsyncCallback,System.IntPtr)">
            <summary>
            <p> Begins an asynchronous read operation from the stream. </p>
            </summary>
            <param name = "bRef"><dd> <p> Pointer to a buffer that receives the data. The caller must allocate the buffer. </p> </dd></param>
            <param name = "cb"><dd> <p> Size of the buffer in bytes. </p> </dd></param>
            <param name = "callbackRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>
            <param name = "unkStateRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> When all of the data has been read into the buffer, the callback object's <strong>IMFAsyncCallback::Invoke</strong> method is called. At that point, the application should call <strong>IMFByteStream::EndRead</strong> to complete the asynchronous request. </p><p> Do not read from, write to, free, or reallocate the buffer while an asynchronous read is pending. </p><p><strong> Implementation notes:</strong> This method should update the current position in the stream by adding the number of bytes that will be read, which is specified by the value returned in the <em>pcbRead</em> parameter,  to the current position. Other methods that can update the current position are <strong>BeginRead</strong>, <strong>Write</strong>, <strong>BeginWrite</strong>, <strong>Seek</strong>, and <strong>SetCurrentPosition</strong>. 
            </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms704810</doc-id>
            <unmanaged>HRESULT IMFByteStream::BeginRead([In] unsigned char* pb,[In] ULONG cb,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>
            <unmanaged-short>IMFByteStream::BeginRead</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.EndRead_(SharpDX.MediaFoundation.AsyncResult,System.Int32@)">
            <summary>
            <p> Completes an asynchronous read operation. </p>
            </summary>
            <param name = "resultRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>IMFAsyncCallback::Invoke</strong> method. </p> </dd></param>
            <param name = "cbReadRef"><dd> <p> Receives the number of bytes that were read. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> Call this method after the <strong>IMFByteStream::BeginRead</strong> method completes asynchronously. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms704042</doc-id>
            <unmanaged>HRESULT IMFByteStream::EndRead([In] IMFAsyncResult* pResult,[Out] ULONG* pcbRead)</unmanaged>
            <unmanaged-short>IMFByteStream::EndRead</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.Write_(System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            <p> </p><p>Writes data to the stream.</p>
            </summary>
            <param name = "bRef"><dd> <p> Pointer to a buffer that contains the data to write. </p> </dd></param>
            <param name = "cb"><dd> <p> Size of the buffer in bytes. </p> </dd></param>
            <param name = "cbWrittenRef"><dd> <p> Receives the number of bytes that are written. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> This method writes the contents of the <em>pb</em> buffer to the stream, starting at the current stream position. The number of bytes that were written is returned in the <em>pcbWritten</em> parameter. </p><p> This method is synchronous. It blocks until the write operation completes. </p><p><strong>Implementation notes:</strong> This method should update the current position in the stream by adding the number of bytes that were written to the stream, which is specified by the value returned in the <em>pcbWritten</em>, to the current position offset. </p><p> Other methods that can update the current position are <strong>Read</strong>, <strong>BeginRead</strong>, <strong>BeginWrite</strong>, <strong>Seek</strong>, and <strong>SetCurrentPosition</strong>.
            </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms703843</doc-id>
            <unmanaged>HRESULT IMFByteStream::Write([In] const unsigned char* pb,[In] ULONG cb,[Out] ULONG* pcbWritten)</unmanaged>
            <unmanaged-short>IMFByteStream::Write</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.BeginWrite_(System.IntPtr,System.Int32,SharpDX.MediaFoundation.IAsyncCallback,System.IntPtr)">
            <summary>
            <p> Begins an asynchronous write operation to the stream. </p>
            </summary>
            <param name = "bRef"><dd> <p> Pointer to a buffer containing the data to write. </p> </dd></param>
            <param name = "cb"><dd> <p> Size of the buffer in bytes. </p> </dd></param>
            <param name = "callbackRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>
            <param name = "unkStateRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> When all of the data has been written to the stream, the callback object's <strong>IMFAsyncCallback::Invoke</strong> method is called. At that point, the application should call <strong>IMFByteStream::EndWrite</strong> to complete the asynchronous request. </p><p> Do not reallocate, free, or write to the buffer while an asynchronous write is still pending. </p><p><strong>Implementation notes:</strong> This method should update the current position in the stream by adding the number of bytes that will be written to the stream, which is specified by the value returned in the <em>pcbWritten</em>, to the current position. Other methods that can update the current position are <strong>Read</strong>, <strong>BeginRead</strong>, <strong>Write</strong>, <strong>Seek</strong>, and <strong>SetCurrentPosition</strong>.
            </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms694005</doc-id>
            <unmanaged>HRESULT IMFByteStream::BeginWrite([In] const unsigned char* pb,[In] ULONG cb,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>
            <unmanaged-short>IMFByteStream::BeginWrite</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.EndWrite_(SharpDX.MediaFoundation.AsyncResult,System.Int32@)">
            <summary>
            <p> </p><p>Completes an asynchronous write operation.</p>
            </summary>
            <param name = "resultRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>IMFAsyncCallback::Invoke</strong> method.</p> </dd></param>
            <param name = "cbWrittenRef"><dd> <p> Receives the number of bytes that were written. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> Call this method when the <strong>IMFByteStream::BeginWrite</strong> method completes asynchronously. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms703863</doc-id>
            <unmanaged>HRESULT IMFByteStream::EndWrite([In] IMFAsyncResult* pResult,[Out] ULONG* pcbWritten)</unmanaged>
            <unmanaged-short>IMFByteStream::EndWrite</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.Seek_(SharpDX.MediaFoundation.ByteStreamSeekOrigin,System.Int64,System.Int32,System.Int64@)">
            <summary>
            <p> </p><p>Moves the current position in the stream by a specified offset.</p>
            </summary>
            <param name = "seekOrigin"><dd> <p> Specifies the origin of the seek as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.ByteStreamSeekOrigin"/></strong> enumeration. The offset is calculated relative to this position. </p> </dd></param>
            <param name = "llSeekOffset"><dd> <p> Specifies the new position, as a byte offset from the seek origin. </p> </dd></param>
            <param name = "dwSeekFlags"><dd> <p> Specifies zero or more flags. The following flags are defined. </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_SEEK_FLAG_CANCEL_PENDING_IO</strong></dt> </dl> </td><td> <p> All pending I/O requests are canceled after the seek request completes successfully. </p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "qwCurrentPositionRef"><dd> <p> Receives the new position after the seek. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul><p><strong> Implementation notes:</strong> This method should update the current position in the stream by adding the <em>qwSeekOffset</em> to the seek <em>SeekOrigin</em> position. This should be the same value passed back in the <em>pqwCurrentPosition</em> parameter. 
            Other methods that can update the current position are <strong>Read</strong>, <strong>BeginRead</strong>, <strong>Write</strong>, <strong>BeginWrite</strong>, and <strong>SetCurrentPosition</strong>.
            </p>
            </remarks>
            <doc-id>ms697053</doc-id>
            <unmanaged>HRESULT IMFByteStream::Seek([In] MFBYTESTREAM_SEEK_ORIGIN SeekOrigin,[In] longlong llSeekOffset,[In] DWORD dwSeekFlags,[Out] unsigned longlong* pqwCurrentPosition)</unmanaged>
            <unmanaged-short>IMFByteStream::Seek</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.Flush_">
            <summary>
            <p> Clears any internal buffers used by the stream. If you are writing to the stream, the buffered data is written to the underlying file or device. </p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> If the byte stream is read-only, this method has no effect.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms694833</doc-id>
            <unmanaged>HRESULT IMFByteStream::Flush()</unmanaged>
            <unmanaged-short>IMFByteStream::Flush</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStream.Close_">
            <summary>
            <p> Closes the stream and releases any resources associated with the stream, such as sockets or file handles. This method also cancels any pending asynchronous I/O requests. </p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms703909</doc-id>
            <unmanaged>HRESULT IMFByteStream::Close()</unmanaged>
            <unmanaged-short>IMFByteStream::Close</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ClockStateSink.OnClockPause(System.Int64)">
            <summary>	
            Called when the presentation clock pauses.
            </summary>	
            <param name="hnsSystemTime"><para>The system time when the clock was paused, in 100-nanosecond units.</para></param>	
            <remarks>	
            When the presentation clock's Pause method is called, the clock notifies the presentation time source by calling the time source's OnClockPause method. This call occurs synchronously within the Pause method. If the time source returns an error from OnClockPause, the presentation clock's Pause method returns an error and the state change does not take place. For any object that is not the presentation time source, the OnClockPause method is called asynchronously, after the state change is completed. In that case, the return value from this method is ignored.
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file=".\Documentation\CodeComments.xml" path="/comments/comment[@id='IMFClockStateSink::OnClockPause']/*" />	
            <unmanaged>HRESULT IMFClockStateSink::OnClockPause([In] longlong hnsSystemTime)</unmanaged>
        </member>
        <member name="M:SharpDX.MediaFoundation.ClockStateSink.OnClockRestart(System.Int64)">
            <summary>	
            Called when the presentation clock restarts from the same position while paused.
            </summary>	
            <param name="hnsSystemTime"><para>The system time when the clock restarted, in 100-nanosecond units.</para></param>	
            <remarks>	
            This method is called if the presentation clock is paused and the Start method is called with the value PRESENTATION_CURRENT_POSITION. The clock notifies the presentation time source by calling the time source's OnClockRestart method. This call occurs synchronously within the Start method. If the time source returns an error from OnClockRestart, the presentation clock's Start method returns an error and the state change does not take place. For any object that is not the presentation time source, the OnClockRestart method is called asynchronously, after the state change is completed. In that case, the return value from this method is ignored.
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file=".\Documentation\CodeComments.xml" path="/comments/comment[@id='IMFClockStateSink::OnClockRestart']/*" />	
            <unmanaged>HRESULT IMFClockStateSink::OnClockRestart([In] longlong hnsSystemTime)</unmanaged>
        </member>
        <member name="M:SharpDX.MediaFoundation.ClockStateSink.OnClockSetRate(System.Int64,System.Single)">
            <summary>	
            Called when the rate changes on the presentation clock.
            </summary>	
            <param name="hnsSystemTime"><para>The system time when the rate was set, in 100-nanosecond units.</para></param>	
            <param name="flRate"><para>The new rate, as a multiplier of the normal playback rate.</para></param>	
            <remarks>	
            When the presentation clock's SetRate method is called, the clock notifies the presentation time source by calling the time source's OnClockSetRate method. This call occurs synchronously within the SetRate method. If the time source returns an error from OnClockSetRate, the presentation clock's SetRate method returns an error and the state change does not take place. For any object that is not the presentation time source, the OnClockSetRate method is called asynchronously, after the state change is completed. In that case, the return value from this method is ignored.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file=".\Documentation\CodeComments.xml" path="/comments/comment[@id='IMFClockStateSink::OnClockSetRate']/*" />	
            <unmanaged>HRESULT IMFClockStateSink::OnClockSetRate([In] longlong hnsSystemTime,[In] float flRate)</unmanaged>
        </member>
        <member name="M:SharpDX.MediaFoundation.ClockStateSink.OnClockStart(System.Int64,System.Int64)">
            <summary>	
            Called when the presentation clock starts.	
            </summary>	
            <param name="hnsSystemTime"><para>The system time when the clock started, in 100-nanosecond units.</para></param>	
            <param name="llClockStartOffset"><para>The new starting time for the clock, in 100-nanosecond units. This parameter can also equal PRESENTATION_CURRENT_POSITION, indicating the clock has started or restarted from its current position.</para></param>	
            <remarks>	
            This method is called whe the presentation clock's Start method is called, with the following exception: If the clock is paused and Start is called with the value PRESENTATION_CURRENT_POSITION, OnClockRestart is called instead of OnClockStart. The clock notifies the presentation time source by calling the time source's OnClockStart method. This call occurs synchronously within the Start method. If the time source returns an error from OnClockStart, the presentation clock's Start method returns an error and the state change does not take place. For any object that is not the presentation time source, the OnClockStart method is called asynchronously, after the state change is completed. In that case, the return value from this method is ignored. The value given in llClockStartOffset is the presentation time when the clock starts, so it is relative to the start of the presentation. Media sinks should not render any data with a presentation time earlier than llClockStartOffSet. If a sample straddles the offset?that is, if the offset falls between the sample's start and stop times?the sink should either trim the sample so that only data after llClockStartOffset is rendered, or else simply drop the sample.
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IMFClockStateSink::OnClockStart']/*" />	
            <unmanaged>HRESULT IMFClockStateSink::OnClockStart([In] longlong hnsSystemTime,[In] longlong llClockStartOffset)</unmanaged>
        </member>
        <member name="M:SharpDX.MediaFoundation.ClockStateSink.OnClockStop(System.Int64)">
            <summary>	
            Called when the presentation clock stops.
            </summary>	
            <param name="hnsSystemTime"><para>The system time when the clock stopped, in 100-nanosecond units.</para></param>	
            <remarks>	
            When the presentation clock's Stop method is called, the clock notifies the presentation time source by calling the presentation time source's OnClockStop method. This call occurs synchronously within the Stop method. If the time source returns an error from OnClockStop, the presentation clock's Stop method returns an error and the state change does not take place. For any object that is not the presentation time source, the OnClockStop method is called asynchronously, after the state change is completed. If an object is already stopped, it should return Ok from OnClockStop. It should not return an error code. Note??Although the header file mferror.h defines an error code named MF_E_SINK_ALREADYSTOPPED, it should not be returned in this situation.
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IMFClockStateSink::OnClockStop']/*" />	
            <unmanaged>HRESULT IMFClockStateSink::OnClockStop([In] longlong hnsSystemTime)</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.ClockStateSinkShadow">
            <summary>
            Internal ClockStateSink callback
            </summary>
        </member>
        <member name="M:SharpDX.MediaFoundation.ClockStateSinkShadow.ToIntPtr(SharpDX.MediaFoundation.ClockStateSink)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.MediaFoundation.ClockStateSinkShadow.ClockStateSinkVtbl.OnClockStartDelegate">
            <unmanaged>HRESULT IMFClockStateSink::OnClockStart([In] longlong hnsSystemTime,[In] longlong llClockStartOffset)</unmanaged>
        </member>
        <member name="M:SharpDX.MediaFoundation.ClockStateSinkShadow.ClockStateSinkVtbl.OnClockStopImpl(System.IntPtr,System.Int64)">
            <unmanaged>HRESULT IMFClockStateSink::OnClockStop([In] longlong hnsSystemTime)</unmanaged>	
        </member>
        <member name="M:SharpDX.MediaFoundation.ClockStateSinkShadow.ClockStateSinkVtbl.OnClockPauseImpl(System.IntPtr,System.Int64)">
            <unmanaged>HRESULT IMFClockStateSink::OnClockPause([In] longlong hnsSystemTime)</unmanaged>	
        </member>
        <member name="M:SharpDX.MediaFoundation.ClockStateSinkShadow.ClockStateSinkVtbl.OnClockRestartImpl(System.IntPtr,System.Int64)">
            <unmanaged>HRESULT IMFClockStateSink::OnClockRestart([In] longlong hnsSystemTime)</unmanaged>	
        </member>
        <member name="T:SharpDX.MediaFoundation.ClockStateSinkShadow.ClockStateSinkVtbl.OnClockSetRateDelegate">
            <unmanaged>HRESULT IMFClockStateSink::OnClockSetRate([In] longlong hnsSystemTime,[In] float flRate)</unmanaged>	
        </member>
        <member name="T:SharpDX.MediaFoundation.Dsp.NamespaceDoc">
            <summary>
            The <see cref="N:SharpDX.MediaFoundation.Dsp"/> namespace provides a managed MediaFoundation for Dsp API.
            </summary>
            <msdn-id></msdn-id>
            <unmanaged>MediaFoundation</unmanaged>	
            <unmanaged-short>MediaFoundation</unmanaged-short>	
        </member>
        <member name="F:SharpDX.MediaFoundation.DXGIDeviceManager.ResetToken">
            <summary>
            A token that identifies this instance of the DXGI Device Manager. Use this token when calling <strong><see cref="M:SharpDX.MediaFoundation.DXGIDeviceManager.ResetDevice(SharpDX.ComObject)"/></strong>
            </summary>
        </member>
        <member name="M:SharpDX.MediaFoundation.DXGIDeviceManager.#ctor">
            <summary>	
            <p>[This documentation is preliminary and is subject to change.]</p><p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Creates an instance of the Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager.</p>	
            </summary>	
            <msdn-id>hh162750</msdn-id>	
            <unmanaged>HRESULT MFCreateDXGIDeviceManager([Out] unsigned int* resetToken,[Out] IMFDXGIDeviceManager** ppDeviceManager)</unmanaged>	
            <unmanaged-short>MFCreateDXGIDeviceManager</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.DXGIDeviceManager.ResetDevice(SharpDX.ComObject)">
            <summary>	
            <p>[This documentation is preliminary and is subject to change.]</p><p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Sets the Microsoft Direct3D device or notifies the device manager that the Direct3D device was reset.</p>	
            </summary>	
            <param name="direct3D11Device"><dd> <p>A reference to the <strong><see cref="T:SharpDX.ComObject"/></strong> interface of the DXGI device.</p> </dd></param>	
            <remarks>	
            <p>When you first create the DXGI Device Manager, call this method with a reference to the Direct3D device. (The device manager does not create the device; the caller must provide the device reference initially.) Also call this method if the Direct3D device becomes lost and you need to reset the device or create a new device. </p><p>The <em>resetToken</em> parameter ensures that only the component that originally created the device manager can invalidate the current device.</p><p>If this method succeeds, all open device handles become invalid.</p>	
            </remarks>	
            <msdn-id>hh447911</msdn-id>	
            <unmanaged>HRESULT IMFDXGIDeviceManager::ResetDevice([In] IUnknown* pUnkDevice,[In] unsigned int resetToken)</unmanaged>	
            <unmanaged-short>IMFDXGIDeviceManager::ResetDevice</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.DXGIDeviceManager.UnlockDevice(System.IntPtr)">
            <summary>	
            <p>[This documentation is preliminary and is subject to change.]</p><p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Unlocks the Microsoft Direct3D device.</p>	
            </summary>	
            <param name="hDevice"><dd> <p>A handle to the Direct3D device. To get the device handle, call <strong><see cref="M:SharpDX.MediaFoundation.DXGIDeviceManager.OpenDeviceHandle"/></strong>.</p> </dd></param>	
            <remarks>	
            <p> Call this method to release the device after calling <strong><see cref="M:SharpDX.MediaFoundation.DXGIDeviceManager.LockDevice(System.IntPtr,System.Guid,SharpDX.Mathematics.Interop.RawBool)"/></strong>.</p>	
            </remarks>	
            <msdn-id>hh447913</msdn-id>	
            <unmanaged>HRESULT IMFDXGIDeviceManager::UnlockDevice([In] void* hDevice,[In] BOOL fSaveState)</unmanaged>	
            <unmanaged-short>IMFDXGIDeviceManager::UnlockDevice</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.DXGIDeviceManager.CloseDeviceHandle(System.IntPtr)">
            <summary>
            <p>Enables two threads to share the same Microsoft Direct3D?11 device.</p>
            </summary>
            <param name = "hDevice">No documentation.</param>
            <returns>No documentation.</returns>
            <remarks>
            <p>This interface is exposed by the Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager. To create the DXGI Device Manager, call the <strong>MFCreateDXGIDeviceManager</strong> function.</p><p>When you create an <strong><see cref = "T:SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> with <strong>MFCreateDXGIDeviceManager</strong>, a Direct3D?11 device is not associated with the device manager. To associate a Direct3D?11 device with the device manager, call <strong>IMFDXGIDeviceManager::ResetDevice</strong>, passing in the reference to the Direct3D?11 device. To create a Direct3D?11 device, call <strong>D3D11CreateDevice</strong>. The device should be created with the <strong>D3D11_CREATE_DEVICE_VIDEO_SUPPORT</strong> device creation flag which is defined in the <strong><see cref = "!:SharpDX.Direct3D11.DeviceCreationFlags"/></strong> enumeration.</p><p>For Microsoft Direct3D?9 devices, use the <strong>IDirect3DDeviceManager9</strong> interface.</p><p>Windows Store apps must use <strong><see cref = "T:SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> and Direct3D 11 Video APIs. </p>
            </remarks>
            <doc-id>hh447906</doc-id>
            <unmanaged>HRESULT IMFDXGIDeviceManager::CloseDeviceHandle([In] void* hDevice)</unmanaged>
            <unmanaged-short>IMFDXGIDeviceManager::CloseDeviceHandle</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DXGIDeviceManager.GetVideoService(System.IntPtr,System.Guid)">
            <summary>
            <p>Queries the Microsoft Direct3D device for an interface.</p>
            </summary>
            <param name = "hDevice"><dd> <p>A handle to the Direct3D device. To get the device handle, call <strong>IMFDXGIDeviceManager::OpenDeviceHandle</strong>.</p> </dd></param>
            <param name = "riid"><dd> <p>The interface identifier (IID) of the requested interface. The Direct3D device supports the following interfaces:</p> <ul> <li> <strong><see cref = "!:SharpDX.Direct3D11.Device"/></strong>. To get a reference to the Direct3D11 device, use <strong>IID_ID3D11Device</strong> as the <em>riid</em>.</li> <li> <strong><see cref = "!:SharpDX.Direct3D11.VideoDevice"/></strong>. To get a reference to the Direct3D11 video device, use <strong>IID_ID3D11VideoDevice</strong> as the <em>riid</em>.</li> </ul> </dd></param>
            <returns><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></returns>
            <remarks>
            <p>If the method returns <strong><see cref = "!:DxgiNewVideoDevice"/></strong>, call <strong>IMFDXGIDeviceManager::CloseDeviceHandle</strong> to close the handle and then call <strong>OpenDeviceHandle</strong> again to get a new handle. The  <strong>IMFDXGIDeviceManager::ResetDevice</strong> method invalidates all open device handles.</p><p>For more info see, Supporting Direct3D 11 Video Decoding in Media Foundation.</p>
            </remarks>
            <doc-id>hh447908</doc-id>
            <unmanaged>HRESULT IMFDXGIDeviceManager::GetVideoService([In] void* hDevice,[In] const GUID&amp; riid,[Out] void** ppService)</unmanaged>
            <unmanaged-short>IMFDXGIDeviceManager::GetVideoService</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DXGIDeviceManager.LockDevice(System.IntPtr,System.Guid,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Gives the caller exclusive access to the Microsoft Direct3D device.</p>
            </summary>
            <param name = "hDevice"><dd> <p>A handle to the Direct3D device. To get the device handle, call <strong>IMFDXGIDeviceManager::OpenDeviceHandle</strong>.</p> </dd></param>
            <param name = "riid"><dd> <p>The interface identifier (IID) of the requested interface. The Direct3D device will support the following interfaces:</p> <ul> <li> <strong><see cref = "!:SharpDX.Direct3D11.Device"/></strong> </li> <li> <strong><see cref = "!:SharpDX.Direct3D11.VideoContext"/></strong> </li> <li> <strong><see cref = "!:SharpDX.Direct3D11.VideoDevice"/></strong> </li> </ul> </dd></param>
            <param name = "fBlock"><dd> <p>Specifies whether to wait for the device lock. If the device is already locked and this parameter is <strong>TRUE</strong>, the method blocks until the device is unlocked. Otherwise, if the device is locked and this parameter is <strong><see cref = "F:SharpDX.Result.False"/></strong>, the method returns immediately with the error code <strong>DXVA2_E_VIDEO_DEVICE_LOCKED</strong>.</p> </dd></param>
            <returns><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></returns>
            <remarks>
            <p>When you are done using the Direct3D device, call <strong>IMFDXGIDeviceManager::UnlockDevice</strong> to unlock the device.</p><p>If the method returns <strong><see cref = "!:DxgiNewVideoDevice"/></strong>, call <strong>IMFDXGIDeviceManager::CloseDeviceHandle</strong> to close the handle and then call <strong>OpenDeviceHandle</strong> again to get a new handle. The  <strong>IMFDXGIDeviceManager::ResetDevice</strong> method invalidates all open device handles.</p><p>If <em>fBlock</em> is <strong>TRUE</strong>, this method can potentially deadlock. For example, it will deadlock if a thread calls <strong>LockDevice</strong> and then waits on another thread that calls <strong>LockDevice</strong>. It will also deadlock if a thread calls <strong>LockDevice</strong> twice without calling <strong>UnlockDevice</strong> in between.  </p>
            </remarks>
            <doc-id>hh447909</doc-id>
            <unmanaged>HRESULT IMFDXGIDeviceManager::LockDevice([In] void* hDevice,[In] const GUID&amp; riid,[Out] void** ppUnkDevice,[In] BOOL fBlock)</unmanaged>
            <unmanaged-short>IMFDXGIDeviceManager::LockDevice</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DXGIDeviceManager.OpenDeviceHandle">
            <summary>
            <p>Gets a handle to the Microsoft Direct3D device. </p>
            </summary>
            <returns><dd> <p>Receives the device handle.</p> </dd></returns>
            <doc-id>hh447910</doc-id>
            <unmanaged>HRESULT IMFDXGIDeviceManager::OpenDeviceHandle([Out] void** phDevice)</unmanaged>
            <unmanaged-short>IMFDXGIDeviceManager::OpenDeviceHandle</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DXGIDeviceManager.ResetDevice(SharpDX.IUnknown,System.Int32)">
            <summary>
            <p>Enables two threads to share the same Microsoft Direct3D?11 device.</p>
            </summary>
            <param name = "unkDeviceRef">No documentation.</param>
            <param name = "resetToken">No documentation.</param>
            <returns>No documentation.</returns>
            <remarks>
            <p>This interface is exposed by the Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager. To create the DXGI Device Manager, call the <strong>MFCreateDXGIDeviceManager</strong> function.</p><p>When you create an <strong><see cref = "T:SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> with <strong>MFCreateDXGIDeviceManager</strong>, a Direct3D?11 device is not associated with the device manager. To associate a Direct3D?11 device with the device manager, call <strong>IMFDXGIDeviceManager::ResetDevice</strong>, passing in the reference to the Direct3D?11 device. To create a Direct3D?11 device, call <strong>D3D11CreateDevice</strong>. The device should be created with the <strong>D3D11_CREATE_DEVICE_VIDEO_SUPPORT</strong> device creation flag which is defined in the <strong><see cref = "!:SharpDX.Direct3D11.DeviceCreationFlags"/></strong> enumeration.</p><p>For Microsoft Direct3D?9 devices, use the <strong>IDirect3DDeviceManager9</strong> interface.</p><p>Windows Store apps must use <strong><see cref = "T:SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> and Direct3D 11 Video APIs. </p>
            </remarks>
            <doc-id>hh447906</doc-id>
            <unmanaged>HRESULT IMFDXGIDeviceManager::ResetDevice([In] IUnknown* pUnkDevice,[In] unsigned int resetToken)</unmanaged>
            <unmanaged-short>IMFDXGIDeviceManager::ResetDevice</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DXGIDeviceManager.TestDevice(System.IntPtr)">
            <summary>
            <p>Tests whether a Microsoft Direct3D device handle is valid.</p>
            </summary>
            <param name = "hDevice"><dd> <p>A handle to the Direct3D device. To get the device handle, call <strong>IMFDXGIDeviceManager::OpenDeviceHandle</strong>.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong>E_HANDLE</strong></dt> </dl> </td><td> <p>The specified handle is not a Direct3D device handle.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:DxgiNewVideoDevice"/></strong></dt> </dl> </td><td> <p>The device handle is invalid. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the method returns <strong><see cref = "!:DxgiNewVideoDevice"/></strong>, call <strong>IMFDXGIDeviceManager::CloseDeviceHandle</strong> to close the handle and then call <strong>OpenDeviceHandle</strong> again to get a new handle. The  <strong>IMFDXGIDeviceManager::ResetDevice</strong> method invalidates all open device handles.</p>
            </remarks>
            <doc-id>hh447912</doc-id>
            <unmanaged>HRESULT IMFDXGIDeviceManager::TestDevice([In] void* hDevice)</unmanaged>
            <unmanaged-short>IMFDXGIDeviceManager::TestDevice</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DXGIDeviceManager.UnlockDevice(System.IntPtr,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Unlocks the Microsoft Direct3D device.</p>
            </summary>
            <param name = "hDevice"><dd> <p>A handle to the Direct3D device. To get the device handle, call <strong>IMFDXGIDeviceManager::OpenDeviceHandle</strong>.</p> </dd></param>
            <param name = "fSaveState"><dd> <p>Reserved.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> Call this method to release the device after calling <strong>IMFDXGIDeviceManager::LockDevice</strong>.</p>
            </remarks>
            <doc-id>hh447913</doc-id>
            <unmanaged>HRESULT IMFDXGIDeviceManager::UnlockDevice([In] void* hDevice,[In] BOOL fSaveState)</unmanaged>
            <unmanaged-short>IMFDXGIDeviceManager::UnlockDevice</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.IAsyncCallback.Flags">
            <summary>
            Gets a flag indicating the behavior of the callback object's <strong><see cref="M:SharpDX.MediaFoundation.IAsyncCallback.Invoke(SharpDX.MediaFoundation.AsyncResult)" /></strong> method. Default behavior should be <see cref="F:SharpDX.MediaFoundation.AsyncCallbackFlags.None"/>.
            </summary>
            <value>The a flag indicating the behavior of the callback object's <strong><see cref="M:SharpDX.MediaFoundation.IAsyncCallback.Invoke(SharpDX.MediaFoundation.AsyncResult)" /></strong> method.</value>
              <msdn-id>bb970381</msdn-id>
              <unmanaged>HRESULT IMFAsyncCallback::GetParameters([Out] MFASYNC_CALLBACK_FLAGS* pdwFlags,[Out] unsigned int* pdwQueue)</unmanaged>
              <unmanaged-short>IMFAsyncCallback::GetParameters</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.IAsyncCallback.WorkQueueId">
            <summary>
            Gets the identifier of the work queue on which the callback is dispatched. See remarks.
            </summary>
            <value>The work queue identifier.</value>
            <remarks>
            <p>This value can specify one of the standard Media Foundation work queues, or a work queue created by the application. For list of standard Media Foundation work queues, see <strong>Work Queue Identifiers</strong>. To create a new work queue, call <strong><see cref="M:SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueue(System.Int32@)" /></strong>. The default value is <strong><see cref="F:SharpDX.MediaFoundation.WorkQueueType.Standard" /></strong>.</p> <p>If the work queue is not compatible with the value returned in <em>pdwFlags</em>, the Media Foundation platform returns <strong><see cref="F:SharpDX.MediaFoundation.ResultCode.InvalidWorkqueue" /></strong> when it tries to dispatch the callback. (See <strong><see cref="M:SharpDX.MediaFoundation.MediaFactory.PutWorkItem(System.Int32,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)" /></strong>.)</p>
            </remarks>
              <msdn-id>bb970381</msdn-id>
              <unmanaged>HRESULT IMFAsyncCallback::GetParameters([Out] MFASYNC_CALLBACK_FLAGS* pdwFlags,[Out] unsigned int* pdwQueue)</unmanaged>
              <unmanaged-short>IMFAsyncCallback::GetParameters</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IAsyncCallback.Invoke(SharpDX.MediaFoundation.AsyncResult)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> </p><p>Called when an asynchronous operation is completed.</p>	
            </summary>	
            <param name="asyncResultRef"><dd> <p>Pointer to the <strong><see cref="T:SharpDX.MediaFoundation.AsyncResult" /></strong> interface. Pass this reference to the asynchronous <strong>End...</strong> method to complete the asynchronous call.</p> </dd></param>	
            <returns><p>The method returns an <strong><see cref="T:SharpDX.Result" /></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="F:SharpDX.Result.Ok" /></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>	
            <remarks>	
            <p>Within your implementation of <strong>Invoke</strong>, call the corresponding <strong>End...</strong> method.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IMFAsyncCallback::Invoke']/*" />	
            <msdn-id>bb970360</msdn-id>	
            <unmanaged>HRESULT IMFAsyncCallback::Invoke([In, Optional] IMFAsyncResult* pAsyncResult)</unmanaged>	
            <unmanaged-short>IMFAsyncCallback::Invoke</unmanaged-short>	
        </member>
        <member name="P:SharpDX.MediaFoundation.IByteStream.Capabilities">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Retrieves the characteristics of the byte stream. </p>	
            </summary>	
            <returns>The capabilities of the stream.</returns>	
            <remarks>	
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms698962</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::GetCapabilities([Out] unsigned int* pdwCapabilities)</unmanaged>	
            <unmanaged-short>IMFByteStream::GetCapabilities</unmanaged-short>	
        </member>
        <member name="P:SharpDX.MediaFoundation.IByteStream.Length">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Retrieves the length of the stream. </p>	
            </summary>	
            <returns>The length of the stream, in bytes. If the length is unknown, this value is -1.</returns>	
            <remarks>	
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms698941</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::GetLength([Out] unsigned longlong* pqwLength)</unmanaged>	
            <unmanaged-short>IMFByteStream::GetLength</unmanaged-short>	
        </member>
        <member name="P:SharpDX.MediaFoundation.IByteStream.CurrentPosition">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Retrieves the current read or write position in the stream. </p>	
            </summary>	
            <returns>The current position, in bytes.</returns>	
            <remarks>	
            <p> The methods that update the current position are <strong>Read</strong>, <strong>BeginRead</strong>, <strong>Write</strong>, <strong>BeginWrite</strong>, <strong>SetCurrentPosition</strong>, and <strong>Seek</strong>. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms704059</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::GetCurrentPosition([Out] unsigned longlong* pqwPosition)</unmanaged>	
            <unmanaged-short>IMFByteStream::GetCurrentPosition</unmanaged-short>	
        </member>
        <member name="P:SharpDX.MediaFoundation.IByteStream.IsEndOfStream">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> </p><p>Queries whether the current position has reached the end of the stream.</p>	
            </summary>	
            <returns>true if the end of the stream has been reached</returns>	
            <remarks>	
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms697369</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::IsEndOfStream([Out] BOOL* pfEndOfStream)</unmanaged>	
            <unmanaged-short>IMFByteStream::IsEndOfStream</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.IByteStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Reads data from the stream. </p>	
            </summary>	
            <param name="bRef"><dd> <p> Pointer to a buffer that receives the data. The caller must allocate the buffer. </p> </dd></param>
            <param name="offset">Offset to begin reading from</param>
            <param name="count"><dd> <p> Size of the buffer in bytes. </p> </dd></param>	
            <returns>The number of bytes that are copied into the buffer</returns>	
            <remarks>	
            <p> This method reads at most <em>cb</em> bytes from the current position in the stream and copies them into the buffer provided by the caller. The number of bytes that were read is returned in the <em>pcbRead</em> parameter. The method does not return an error code on reaching the end of the file, so the application should check the value in <em>pcbRead</em> after the method returns. </p><p> This method is synchronous. It blocks until the read operation completes. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms698913</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::Read([Out, Buffer] unsigned char* pb,[In] unsigned int cb,[Out] unsigned int* pcbRead)</unmanaged>	
            <unmanaged-short>IMFByteStream::Read</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.IByteStream.BeginRead(System.Byte[],System.Int32,System.Int32,SharpDX.MediaFoundation.IAsyncCallback,System.Object)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Begins an asynchronous read operation from the stream. </p>	
            </summary>	
            <param name="bRef"><dd> <p> Pointer to a buffer that receives the data. The caller must allocate the buffer. </p> </dd></param>
            <param name="offset">Offset within the buffer to begin reading at.</param>
            <param name="count"><dd> <p> Size of the buffer in bytes. </p> </dd></param>
            <param name="callbackRef"><dd> <p> Pointer to the <strong><see cref="!:SharpDX.MediaFoundation.AsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>	
            <param name="unkStateRef"><dd> <p> Pointer to the <strong><see cref="T:SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result"/></strong> error code.</p></returns>	
            <remarks>	
            <p> When all of the data has been read into the buffer, the callback object's <strong><see cref="!:SharpDX.MediaFoundation.AsyncCallback.Invoke"/></strong> method is called. At that point, the application should call <strong><see cref="M:SharpDX.MediaFoundation.IByteStream.EndRead(SharpDX.MediaFoundation.AsyncResult)"/></strong> to complete the asynchronous request. </p><p> Do not read from, write to, free, or reallocate the buffer while an asynchronous read is pending. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms704810</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::BeginRead([Out, Buffer] unsigned char* pb,[In] unsigned int cb,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>	
            <unmanaged-short>IMFByteStream::BeginRead</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.IByteStream.EndRead(SharpDX.MediaFoundation.AsyncResult)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Completes an asynchronous read operation. </p>	
            </summary>	
            <param name="resultRef"><dd> <p> Pointer to the <strong><see cref="T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong><see cref="!:SharpDX.MediaFoundation.AsyncCallback.Invoke"/></strong> method. </p> </dd></param>	
            <returns>The number of bytes that were read</returns>	
            <remarks>	
            <p> Call this method after the <strong><see cref="M:SharpDX.MediaFoundation.IByteStream.BeginRead(System.Byte[],System.Int32,System.Int32,SharpDX.MediaFoundation.IAsyncCallback,System.Object)"/></strong> method completes asynchronously. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms704042</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::EndRead([In] IMFAsyncResult* pResult,[Out] unsigned int* pcbRead)</unmanaged>	
            <unmanaged-short>IMFByteStream::EndRead</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.IByteStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> </p><p>Writes data to the stream.</p>	
            </summary>	
            <param name="bRef"><dd> <p> Pointer to a buffer that contains the data to write. </p> </dd></param>
            <param name="offset">The offset within the buffer to begin writing to.</param>
            <param name="count"><dd> <p> Size of the buffer in bytes. </p> </dd></param>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result"/></strong> error code.</p></returns>	
            <remarks>	
            <p> This method writes the contents of the <em>pb</em> buffer to the stream, starting at the current stream position. The number of bytes that were written is returned in the <em>pcbWritten</em> parameter. </p><p> This method is synchronous. It blocks until the write operation completes. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms703843</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::Write([In, Buffer] const unsigned char* pb,[In] unsigned int cb,[Out] unsigned int* pcbWritten)</unmanaged>	
            <unmanaged-short>IMFByteStream::Write</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.IByteStream.BeginWrite(System.Byte[],System.Int32,System.Int32,SharpDX.MediaFoundation.IAsyncCallback,System.Object)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Begins an asynchronous write operation to the stream. </p>	
            </summary>	
            <param name="bRef"><dd> <p> Pointer to a buffer containing the data to write. </p> </dd></param>
            <param name="offset">The offset within the buffer to begin writing at.</param>
            <param name="count"><dd> <p> Size of the buffer in bytes. </p> </dd></param>	
            <param name="callbackRef"><dd> <p> Pointer to the <strong><see cref="!:SharpDX.MediaFoundation.AsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>	
            <param name="unkStateRef"><dd> <p> Pointer to the <strong><see cref="T:SharpDX.ComObject"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result"/></strong> error code.</p></returns>	
            <remarks>	
            <p> When all of the data has been written to the stream, the callback object's <strong><see cref="!:SharpDX.MediaFoundation.AsyncCallback.Invoke"/></strong> method is called. At that point, the application should call <strong><see cref="M:SharpDX.MediaFoundation.IByteStream.EndWrite(SharpDX.MediaFoundation.AsyncResult)"/></strong> to complete the asynchronous request. </p><p> Do not reallocate, free, or write to the buffer while an asynchronous write is still pending. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms694005</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::BeginWrite([In, Buffer] const unsigned char* pb,[In] unsigned int cb,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>	
            <unmanaged-short>IMFByteStream::BeginWrite</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.IByteStream.EndWrite(SharpDX.MediaFoundation.AsyncResult)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> </p><p>Completes an asynchronous write operation.</p>	
            </summary>	
            <param name="resultRef"><dd> <p>Pointer to the <strong><see cref="T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong><see cref="!:SharpDX.MediaFoundation.AsyncCallback.Invoke"/></strong> method.</p> </dd></param>	
            <returns>The number of bytes that were written</returns>	
            <remarks>	
            <p> Call this method when the <strong><see cref="M:SharpDX.MediaFoundation.IByteStream.BeginWrite(System.Byte[],System.Int32,System.Int32,SharpDX.MediaFoundation.IAsyncCallback,System.Object)"/></strong> method completes asynchronously. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms703863</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::EndWrite([In] IMFAsyncResult* pResult,[Out] unsigned int* pcbWritten)</unmanaged>	
            <unmanaged-short>IMFByteStream::EndWrite</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.IByteStream.Seek(SharpDX.MediaFoundation.ByteStreamSeekOrigin,System.Int64,System.Int32)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> </p><p>Moves the current position in the stream by a specified offset.</p>	
            </summary>	
            <param name="seekOrigin"><dd> <p> Specifies the origin of the seek as a member of the <strong><see cref="!:SharpDX.MediaFoundation.BytestreamSeekOrigin"/></strong> enumeration. The offset is calculated relative to this position. </p> </dd></param>	
            <param name="llSeekOffset"><dd> <p> Specifies the new position, as a byte offset from the seek origin. </p> </dd></param>	
            <param name="dwSeekFlags"><dd> <p> Specifies zero or more flags. The following flags are defined. </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MFBYTESTREAM_SEEK_FLAG_CANCEL_PENDING_IO</strong></dt> </dl> </td><td> <p> All pending I/O requests are canceled after the seek request completes successfully. </p> </td></tr> </table> <p>?</p> </dd></param>	
            <returns>The new position after the seek</returns>	
            <remarks>	
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms697053</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::Seek([In] MFBYTESTREAM_SEEK_ORIGIN SeekOrigin,[In] longlong llSeekOffset,[In] unsigned int dwSeekFlags,[Out] unsigned longlong* pqwCurrentPosition)</unmanaged>	
            <unmanaged-short>IMFByteStream::Seek</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.IByteStream.Flush">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Clears any internal buffers used by the stream. If you are writing to the stream, the buffered data is written to the underlying file or device. </p>	
            </summary>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result"/></strong> error code.</p></returns>	
            <remarks>	
            <p> If the byte stream is read-only, this method has no effect.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms694833</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::Flush()</unmanaged>	
            <unmanaged-short>IMFByteStream::Flush</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.IByteStream.Close">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Closes the stream and releases any resources associated with the stream, such as sockets or file handles. This method also cancels any pending asynchronous I/O requests. </p>	
            </summary>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result"/></strong> error code.</p></returns>	
            <remarks>	
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms703909</msdn-id>	
            <unmanaged>HRESULT IMFByteStream::Close()</unmanaged>	
            <unmanaged-short>IMFByteStream::Close</unmanaged-short>	
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaAttributeKey">
            <summary>
            Associate an attribute key with a type used to retrieve keys from a <see cref="T:SharpDX.MediaFoundation.MediaAttributes"/> instance.
            </summary>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributeKey.#ctor(System.Guid,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.MediaFoundation.MediaAttributeKey"/> struct.
            </summary>
            <param name="guid">The attribute GUID.</param>
            <param name="type">The attribute type.</param>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributeKey.#ctor(System.Guid,System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.MediaFoundation.MediaAttributeKey"/> struct.
            </summary>
            <param name="guid">The attribute GUID.</param>
            <param name="type">The attribute type.</param>
            <param name="name">The attribute name, useful for debugging.</param>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaAttributeKey.Guid">
            <summary>
            Gets  the attribute GUID.
            </summary>
            <value>
            The attribute GUID.
            </value>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaAttributeKey.Type">
            <summary>
            Gets  the attribute type.
            </summary>
            <value>
            The attribute type.
            </value>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaAttributeKey.Name">
            <summary>
            Gets the attribute name.
            </summary>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaAttributeKey`1">
            <summary>
            Generic version of <see cref="T:SharpDX.MediaFoundation.MediaAttributeKey"/>.
            </summary>
            <typeparam name="T">Type of the value of this key.</typeparam>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributeKey`1.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.MediaFoundation.MediaAttributeKey`1"/> class.
            </summary>
            <param name="guid">The attribute GUID.</param>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributeKey`1.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.MediaFoundation.MediaAttributeKey`1"/> class.
            </summary>
            <param name="guid">The GUID.</param>
            <param name="name">The attribute name, useful for debugging.</param>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributeKey`1.#ctor(System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.MediaFoundation.MediaAttributeKey`1"/> class.
            </summary>
            <param name="guid">The GUID.</param>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributeKey`1.#ctor(System.Guid,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.MediaFoundation.MediaAttributeKey`1"/> class.
            </summary>
            <param name="guid">The GUID.</param>
            /// <param name="name">The attribute name, useful for debugging.</param>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.MediaFoundation.MediaAttributes"/> class.
            </summary>
            <param name="initialSizeInBytes">The initial number of elements allocated for the attribute store. The attribute store grows as needed. Default is 0</param>
            <remarks>	
            <p>Attributes are used throughout Microsoft Media Foundation to configure objects, describe media formats, query object properties, and other purposes. For more information, see Attributes in Media Foundation.</p><p>For a complete list of all the defined attribute GUIDs in Media Foundation, see Media Foundation Attributes.</p>	
            </remarks>	
            <msdn-id>ms701878</msdn-id>
            <unmanaged>HRESULT MFCreateAttributes([Out] IMFAttributes** ppMFAttributes,[In] unsigned int cInitialSize)</unmanaged>
            <unmanaged-short>MFCreateAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.Get(System.Guid)">
            <summary>	
            Gets an item value
            </summary>	
            <param name="guidKey">GUID of the key.</param>	
            <returns>The value associated to this key.</returns>	
            <msdn-id>ms704598</msdn-id>	
            <unmanaged>HRESULT IMFAttributes::GetItem([In] const GUID&amp; guidKey,[In] void* pValue)</unmanaged>	
            <unmanaged-short>IMFAttributes::GetItem</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.GetByIndex(System.Int32,System.Guid@)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> </p><p>Retrieves an attribute at the specified index.</p>	
            </summary>	
            <param name="index"><dd> <p>Index of the attribute to retrieve. To get the number of attributes, call <strong><see cref="M:SharpDX.MediaFoundation.MediaAttributes.GetCount(System.Int32@)"/></strong>.</p> </dd></param>	
            <param name="guidKey"><dd> <p>Receives the <see cref="T:System.Guid"/> that identifies this attribute.</p> </dd></param>	
            <returns>The value associated to this index</returns>	
            <remarks>	
            <p>To enumerate all of an object's attributes in a thread-safe way, do the following:</p><ol> <li> <p>Call <strong><see cref="M:SharpDX.MediaFoundation.MediaAttributes.LockStore"/></strong> to prevent another thread from adding or deleting attributes.</p> </li> <li> <p>Call <strong><see cref="M:SharpDX.MediaFoundation.MediaAttributes.GetCount(System.Int32@)"/></strong> to find the number of attributes.</p> </li> <li> <p>Call <strong>GetItemByIndex</strong> to get each attribute by index.</p> </li> <li> <p>Call <strong><see cref="M:SharpDX.MediaFoundation.MediaAttributes.UnlockStore"/></strong> to unlock the attribute store.</p> </li> </ol><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>bb970331</msdn-id>	
            <unmanaged>HRESULT IMFAttributes::GetItemByIndex([In] unsigned int unIndex,[Out] GUID* pguidKey,[InOut, Optional] PROPVARIANT* pValue)</unmanaged>	
            <unmanaged-short>IMFAttributes::GetItemByIndex</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.Get``1(System.Guid)">
            <summary>	
            Gets an item value
            </summary>	
            <param name="guidKey">GUID of the key.</param>	
            <returns>The value associated to this key.</returns>	
            <msdn-id>ms704598</msdn-id>	
            <unmanaged>HRESULT IMFAttributes::GetItem([In] const GUID&amp; guidKey,[In] void* pValue)</unmanaged>	
            <unmanaged-short>IMFAttributes::GetItem</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.Get``1(SharpDX.MediaFoundation.MediaAttributeKey{``0})">
            <summary>	
            Gets an item value
            </summary>	
            <param name="guidKey">GUID of the key.</param>	
            <returns>The value associated to this key.</returns>	
            <msdn-id>ms704598</msdn-id>	
            <unmanaged>HRESULT IMFAttributes::GetItem([In] const GUID&amp; guidKey,[In] void* pValue)</unmanaged>	
            <unmanaged-short>IMFAttributes::GetItem</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.Set``1(System.Guid,``0)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Adds an attribute value with a specified key. </p>	
            </summary>	
            <param name="guidKey"><dd> <p> A <see cref="T:System.Guid"/> that identifies the value to set. If this key already exists, the method overwrites the old value. </p> </dd></param>	
            <param name="value"><dd> <p> A <strong><see cref="T:SharpDX.Win32.Variant"/></strong> that contains the attribute value. The method copies the value. The <strong><see cref="T:SharpDX.Win32.Variant"/></strong> type must be one of the types listed in the <strong><see cref="T:SharpDX.MediaFoundation.AttributeType"/></strong> enumeration. </p> </dd></param>	
            <returns><p> The method returns an <strong><see cref="T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_OUTOFMEMORY</strong></dt> </dl> </td><td> <p> Insufficient memory. </p> </td></tr> <tr><td> <dl> <dt><strong>MF_E_INVALIDTYPE</strong></dt> </dl> </td><td> <p> Invalid attribute type. </p> </td></tr> </table><p>?</p></returns>	
            <remarks>	
            <p> This method checks whether the <strong><see cref="T:SharpDX.Win32.Variant"/></strong> type is one of the attribute types defined in <strong><see cref="T:SharpDX.MediaFoundation.AttributeType"/></strong>, and fails if an unsupported type is used. However, this method does not check whether the <strong><see cref="T:SharpDX.Win32.Variant"/></strong> is the correct type for the specified attribute <see cref="T:System.Guid"/>. (There is no programmatic way to associate attribute GUIDs with property types.) For a list of Media Foundation attributes and their data types, see Media Foundation Attributes. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>bb970346</msdn-id>	
            <unmanaged>HRESULT IMFAttributes::SetItem([In] const GUID&amp; guidKey,[In] const PROPVARIANT&amp; Value)</unmanaged>	
            <unmanaged-short>IMFAttributes::SetItem</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.Set``1(SharpDX.MediaFoundation.MediaAttributeKey{``0},``0)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Adds an attribute value with a specified key. </p>	
            </summary>	
            <param name="guidKey"><dd> <p> A <see cref="T:System.Guid"/> that identifies the value to set. If this key already exists, the method overwrites the old value. </p> </dd></param>	
            <param name="value"><dd> <p> A <strong><see cref="T:SharpDX.Win32.Variant"/></strong> that contains the attribute value. The method copies the value. The <strong><see cref="T:SharpDX.Win32.Variant"/></strong> type must be one of the types listed in the <strong><see cref="T:SharpDX.MediaFoundation.AttributeType"/></strong> enumeration. </p> </dd></param>	
            <returns><p> The method returns an <strong><see cref="T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_OUTOFMEMORY</strong></dt> </dl> </td><td> <p> Insufficient memory. </p> </td></tr> <tr><td> <dl> <dt><strong>MF_E_INVALIDTYPE</strong></dt> </dl> </td><td> <p> Invalid attribute type. </p> </td></tr> </table><p>?</p></returns>	
            <remarks>	
            <p> This method checks whether the <strong><see cref="T:SharpDX.Win32.Variant"/></strong> type is one of the attribute types defined in <strong><see cref="T:SharpDX.MediaFoundation.AttributeType"/></strong>, and fails if an unsupported type is used. However, this method does not check whether the <strong><see cref="T:SharpDX.Win32.Variant"/></strong> is the correct type for the specified attribute <see cref="T:System.Guid"/>. (There is no programmatic way to associate attribute GUIDs with property types.) For a list of Media Foundation attributes and their data types, see Media Foundation Attributes. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>bb970346</msdn-id>	
            <unmanaged>HRESULT IMFAttributes::SetItem([In] const GUID&amp; guidKey,[In] const PROPVARIANT&amp; Value)</unmanaged>	
            <unmanaged-short>IMFAttributes::SetItem</unmanaged-short>	
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaAttributes.Count">
            <summary>
            <p> </p><p>Retrieves the number of attributes that are set on this object.</p>
            </summary>
            <remarks>
            <p>To enumerate all of the attributes, call <strong>IMFAttributes::GetItemByIndex</strong> for each index value.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970413</doc-id>
            <unmanaged>GetCount</unmanaged>
            <unmanaged-short>GetCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.GetItem(System.Guid,System.IntPtr)">
            <summary>
            <p> </p><p>Retrieves the value associated with a key.</p>
            </summary>
            <param name = "guidKey"><dd> <p> A <see cref = "T:System.Guid"/> that identifies which value to retrieve. </p> </dd></param>
            <param name = "valueRef"><dd> <p>A reference to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that receives the value. The method fills the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> with a copy of the stored value, if the value is found. Call <strong>PropVariantClear</strong> to free the memory allocated by this method. This parameter can be <strong><c>null</c></strong>. If this parameter is <strong><c>null</c></strong>, the method searches for the key and returns <see cref = "F:SharpDX.Result.Ok"/> if the key is found, but does not copy the value.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Attributenotfound"/></strong></dt> </dl> </td><td> <p> The specified key was not found. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970450</doc-id>
            <unmanaged>HRESULT IMFAttributes::GetItem([In] const GUID&amp; guidKey,[In] PROPVARIANT* pValue)</unmanaged>
            <unmanaged-short>IMFAttributes::GetItem</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.GetItemType(System.Guid)">
            <summary>
            <p> </p><p>Retrieves the data type of the value associated with a key.</p>
            </summary>
            <param name = "guidKey"><dd> <p><see cref = "T:System.Guid"/> that identifies which value to query.</p> </dd></param>
            <returns><dd> <p>Receives a member of the <strong><see cref = "T:SharpDX.MediaFoundation.AttributeType"/></strong> enumeration.</p> </dd></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970369</doc-id>
            <unmanaged>HRESULT IMFAttributes::GetItemType([In] const GUID&amp; guidKey,[Out] MF_ATTRIBUTE_TYPE* pType)</unmanaged>
            <unmanaged-short>IMFAttributes::GetItemType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.CompareItem(System.Guid,SharpDX.Win32.Variant)">
            <summary>
            <p> </p><p>Queries whether a stored attribute value equals to a specified <strong><see cref = "T:SharpDX.Win32.Variant"/></strong>.</p>
            </summary>
            <param name = "guidKey"><dd> <p><see cref = "T:System.Guid"/> that identifies which value to query.</p> </dd></param>
            <param name = "value"><dd> <p><strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that contains the value to compare.</p> </dd></param>
            <returns><dd> <p>Receives a Boolean value indicating whether the attribute matches the value given in <em>Value</em>. See Remarks. This parameter must not be <strong><c>null</c></strong>. If this parameter is <strong><c>null</c></strong>, an access violation occurs.</p> </dd></returns>
            <remarks>
            <p>The method sets <em>pbResult</em> to <strong><see cref = "F:SharpDX.Result.False"/></strong> for any of the following reasons:</p><ul> <li> <p>No attribute is found whose key matches the one given in <em>guidKey</em>.</p> </li> <li> <p>The attribute's <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> type does not match the type given in <em>Value</em>.</p> </li> <li> <p>The attribute value does not match the value given in <em>Value</em>.</p> </li> <li> <p>The method fails.</p> </li> </ul><p>Otherwise, the method sets <em>pbResult</em> to <strong>TRUE</strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970566</doc-id>
            <unmanaged>HRESULT IMFAttributes::CompareItem([In] const GUID&amp; guidKey,[In] const PROPVARIANT&amp; Value,[Out] BOOL* pbResult)</unmanaged>
            <unmanaged-short>IMFAttributes::CompareItem</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.Compare(SharpDX.MediaFoundation.MediaAttributes,SharpDX.MediaFoundation.AttributesMatchType)">
            <summary>
            <p> </p><p>Compares the attributes on this object with the attributes on another object.</p>
            </summary>
            <param name = "theirsRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of the object to compare with this object.</p> </dd></param>
            <param name = "matchType"><dd> <p>Member of the <strong><see cref = "T:SharpDX.MediaFoundation.AttributesMatchType"/></strong> enumeration, specifying the type of comparison to make.</p> </dd></param>
            <returns><dd> <p>Receives a Boolean value. The value is <strong>TRUE</strong> if the two sets of attributes match in the way specified by the <em>MatchType</em> parameter. Otherwise, the value is <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></returns>
            <remarks>
            <p>If <em>pThis</em> is the object whose <strong>Compare</strong> method is called, and <em>pTheirs</em> is the object passed in as the <em>pTheirs</em> parameter, the following comparisons are defined by <em>MatchType</em>.</p><table> <tr><th>Match type</th><th>Returns <strong>TRUE</strong> if and only if</th></tr> <tr><td><strong>MF_ATTRIBUTES_MATCH_OUR_ITEMS</strong></td><td>For every attribute in <em>pThis</em>, an attribute with the same key and value exists in <em>pTheirs</em>.</td></tr> <tr><td><strong>MF_ATTRIBUTES_MATCH_THEIR_ITEMS</strong></td><td>For every attribute in <em>pTheirs</em>, an attribute with the same key and value exists in <em>pThis</em>.</td></tr> <tr><td><strong>MF_ATTRIBUTES_MATCH_ALL_ITEMS</strong></td><td>The key/value pairs are identical in both objects.</td></tr> <tr><td><strong>MF_ATTRIBUTES_MATCH_INTERSECTION</strong></td><td>Take the intersection of the keys in <em>pThis</em> and the keys in <em>pTheirs</em>. The values associated with those keys are identical in both <em>pThis</em> and <em>pTheirs</em>.</td></tr> <tr><td><strong>MF_ATTRIBUTES_MATCH_SMALLER</strong></td><td>Take the object with the smallest number of attributes. For every attribute in that object, an attribute with the same key and value exists in the other object.</td></tr> </table><p>?</p><p>The <em>pTheirs</em> and <em>pbResult</em> parameters must not be <strong><c>null</c></strong>. If either parameter is <strong><c>null</c></strong>, an access violation occurs.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970349</doc-id>
            <unmanaged>HRESULT IMFAttributes::Compare([In, Optional] IMFAttributes* pTheirs,[In] MF_ATTRIBUTES_MATCH_TYPE MatchType,[Out] BOOL* pbResult)</unmanaged>
            <unmanaged-short>IMFAttributes::Compare</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.GetInt(System.Guid)">
            <summary>
            <p> </p><p>Retrieves a <strong>UINT32</strong> value associated with a key.</p>
            </summary>
            <param name = "guidKey"><dd> <p><see cref = "T:System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong>MF_ATTRIBUTE_UINT32</strong>.</p> </dd></param>
            <returns><dd> <p>Receives a <strong>UINT32</strong> value. If the key is found and the data type is <strong>UINT32</strong>, the method copies the value into this parameter. Otherwise, the original value of this parameter is not changed.</p> </dd></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970551</doc-id>
            <unmanaged>HRESULT IMFAttributes::GetUINT32([In] const GUID&amp; guidKey,[Out] unsigned int* punValue)</unmanaged>
            <unmanaged-short>IMFAttributes::GetUINT32</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.GetLong(System.Guid)">
            <summary>
            <p> </p><p>Retrieves a <strong>UINT64</strong> value associated with a key.</p>
            </summary>
            <param name = "guidKey"><dd> <p><see cref = "T:System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong>MF_ATTRIBUTE_UINT64</strong>.</p> </dd></param>
            <returns><dd> <p>Receives a <strong>UINT64</strong> value. If the key is found and the data type is <strong>UINT64</strong>, the method copies the value into this parameter. Otherwise, the original value of this parameter is not changed.</p> </dd></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970569</doc-id>
            <unmanaged>HRESULT IMFAttributes::GetUINT64([In] const GUID&amp; guidKey,[Out] unsigned longlong* punValue)</unmanaged>
            <unmanaged-short>IMFAttributes::GetUINT64</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.GetDouble(System.Guid)">
            <summary>
            <p> </p><p>Retrieves a <strong>double</strong> value associated with a key.</p>
            </summary>
            <param name = "guidKey"><dd> <p><see cref = "T:System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong>MF_ATTRIBUTE_DOUBLE</strong>.</p> </dd></param>
            <returns><dd> <p>Receives a <strong>double</strong> value. If the key is found and the data type is <strong>double</strong>, the method copies the value into this parameter. Otherwise, the original value of this parameter is not changed.</p> </dd></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970418</doc-id>
            <unmanaged>HRESULT IMFAttributes::GetDouble([In] const GUID&amp; guidKey,[Out] double* pfValue)</unmanaged>
            <unmanaged-short>IMFAttributes::GetDouble</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.GetGUID(System.Guid)">
            <summary>
            <p> </p><p>Retrieves a <see cref = "T:System.Guid"/> value associated with a key.</p>
            </summary>
            <param name = "guidKey"><dd> <p><see cref = "T:System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong>MF_ATTRIBUTE_GUID</strong>.</p> </dd></param>
            <returns><dd> <p>Receives a <see cref = "T:System.Guid"/> value. If the key is found and the data type is <see cref = "T:System.Guid"/>, the method copies the value into this parameter. Otherwise, the original value of this parameter is not changed.</p> </dd></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970426</doc-id>
            <unmanaged>HRESULT IMFAttributes::GetGUID([In] const GUID&amp; guidKey,[Out] GUID* pguidValue)</unmanaged>
            <unmanaged-short>IMFAttributes::GetGUID</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.GetStringLength(System.Guid)">
            <summary>
            <p> </p><p>Retrieves the length of a string value associated with a key.</p>
            </summary>
            <param name = "guidKey"><dd> <p><see cref = "T:System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong>MF_ATTRIBUTE_STRING</strong>.</p> </dd></param>
            <returns><dd> <p>If the key is found and the value is a string type, this parameter receives the number of characters in the string, not including the terminating <strong><c>null</c></strong> character. To get the string value, call <strong>IMFAttributes::GetString</strong>.</p> </dd></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970425</doc-id>
            <unmanaged>HRESULT IMFAttributes::GetStringLength([In] const GUID&amp; guidKey,[Out] unsigned int* pcchLength)</unmanaged>
            <unmanaged-short>IMFAttributes::GetStringLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.GetString(System.Guid,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            <p> </p><p>Retrieves a wide-character string associated with a key.</p>
            </summary>
            <param name = "guidKey"><dd> <p><see cref = "T:System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong>MF_ATTRIBUTE_STRING</strong>.</p> </dd></param>
            <param name = "wszValueRef"><dd> <p>Pointer to a wide-character array allocated by the caller. The array must be large enough to hold the string, including the terminating <strong><c>null</c></strong> character. If the key is found and the value is a string type, the method copies the string into this buffer. To find the length of the string, call <strong>IMFAttributes::GetStringLength</strong>.</p> </dd></param>
            <param name = "cchBufSize"><dd> <p>The size of the <em>pwszValue</em> array, in characters. This value includes the terminating <c>null</c> character.</p> </dd></param>
            <param name = "cchLengthRef"><dd> <p>Receives the number of characters in the string, excluding the terminating <strong><c>null</c></strong> character. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_OUTOFMEMORY</strong></dt> </dl> </td><td> <p>The length of the string is too large to fit in a <strong>UINT32</strong> value.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOT_SUFFICIENT_BUFFER</strong></dt> </dl> </td><td> <p>The buffer is not large enough to hold the string.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Attributenotfound"/></strong></dt> </dl> </td><td> <p>The specified key was not found.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidType"/></strong></dt> </dl> </td><td> <p>The attribute value is not a string.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>You can also use the <strong>IMFAttributes::GetAllocatedString</strong> method, which allocates the buffer to hold the string.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970430</doc-id>
            <unmanaged>HRESULT IMFAttributes::GetString([In] const GUID&amp; guidKey,[Out, Buffer] wchar_t* pwszValue,[In] unsigned int cchBufSize,[InOut, Optional] unsigned int* pcchLength)</unmanaged>
            <unmanaged-short>IMFAttributes::GetString</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.GetAllocatedString(System.Guid,System.String,System.Int32@)">
            <summary>
            <p> Gets a wide-character string associated with a key. This method allocates the memory for the string. </p>
            </summary>
            <param name = "guidKey"><dd> <p>A <see cref = "T:System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong>MF_ATTRIBUTE_STRING</strong>. </p> </dd></param>
            <param name = "wszValueOut"><dd> <p>If the key is found and the value is a string type, this parameter receives a copy of the string. The caller must free the memory for the string by calling <strong>CoTaskMemFree</strong>. </p> </dd></param>
            <param name = "cchLengthRef"><dd> <p> Receives the number of characters in the string, excluding the terminating <strong><c>null</c></strong> character. This parameter must not be <strong><c>null</c></strong>. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Attributenotfound"/></strong></dt> </dl> </td><td> <p> The specified key was not found. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidType"/></strong></dt> </dl> </td><td> <p> The attribute value is not a string. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To copy a string value into a caller-allocated buffer, use the <strong>IMFAttributes::GetString</strong> method.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul><strong>Note</strong>??An earlier version of the documentation incorrectly stated that the <em>pcchLength</em> parameter can be <strong><c>null</c></strong>. Setting this parameter to <strong><c>null</c></strong> might succeed in some cases, but is not guaranteed. The caller must pass a non-<strong><c>null</c></strong> reference for this parameter.?
            </remarks>
            <doc-id>bb970406</doc-id>
            <unmanaged>HRESULT IMFAttributes::GetAllocatedString([In] const GUID&amp; guidKey,[Buffer, Optional] wchar_t** ppwszValue,[Out] unsigned int* pcchLength)</unmanaged>
            <unmanaged-short>IMFAttributes::GetAllocatedString</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.GetBlobSize(System.Guid)">
            <summary>
            <p> </p><p>Retrieves the length of a byte array associated with a key.</p>
            </summary>
            <param name = "guidKey"><dd> <p><see cref = "T:System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong>MF_ATTRIBUTE_BLOB</strong>.</p> </dd></param>
            <returns><dd> <p>If the key is found and the value is a byte array, this parameter receives the size of the array, in bytes.</p> </dd></returns>
            <remarks>
            <p>To get the byte array, call <strong>IMFAttributes::GetBlob</strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970459</doc-id>
            <unmanaged>HRESULT IMFAttributes::GetBlobSize([In] const GUID&amp; guidKey,[Out] unsigned int* pcbBlobSize)</unmanaged>
            <unmanaged-short>IMFAttributes::GetBlobSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.GetBlob(System.Guid,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            <p> </p><p>Retrieves a byte array associated with a key. This method copies the array into a caller-allocated buffer.</p>
            </summary>
            <param name = "guidKey"><dd> <p><see cref = "T:System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong>MF_ATTRIBUTE_BLOB</strong>.</p> </dd></param>
            <param name = "bufRef"><dd> <p>Pointer to a buffer allocated by the caller. If the key is found and the value is a byte array, the method copies the array into this buffer. To find the required size of the buffer, call <strong>IMFAttributes::GetBlobSize</strong>.</p> </dd></param>
            <param name = "cbBufSize"><dd> <p>The size of the <em>pBuf</em> buffer, in bytes.</p> </dd></param>
            <param name = "cbBlobSizeRef"><dd> <p>Receives the size of the byte array. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_NOT_SUFFICIENT_BUFFER</strong></strong></dt> </dl> </td><td> <p>The buffer is not large enough to the array.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:Attributenotfound"/></strong></strong></dt> </dl> </td><td> <p>The specified key was not found.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidType"/></strong></strong></dt> </dl> </td><td> <p>The attribute value is not a byte array.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>You can also use the <strong>IMFAttributes::GetAllocatedBlob</strong> method, which allocates the buffer to hold the byte array.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970421</doc-id>
            <unmanaged>HRESULT IMFAttributes::GetBlob([In] const GUID&amp; guidKey,[In] unsigned char* pBuf,[In] unsigned int cbBufSize,[InOut, Optional] unsigned int* pcbBlobSize)</unmanaged>
            <unmanaged-short>IMFAttributes::GetBlob</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.GetAllocatedBlob(System.Guid,System.Byte[],System.Int32@)">
            <summary>
            <p>Provides a generic way to store key/value pairs on an object. The keys are <strong><see cref = "T:System.Guid"/></strong>s, and the values can be any of the following data types: <strong>UINT32</strong>, <strong>UINT64</strong>, <strong>double</strong>, <strong><see cref = "T:System.Guid"/></strong>, wide-character string, byte array, or <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference. The standard implementation of this interface holds a thread lock while values are added, deleted, or retrieved.</p><p>For a list of predefined attribute <strong><see cref = "T:System.Guid"/></strong>s, see Media Foundation Attributes. Each attribute <strong><see cref = "T:System.Guid"/></strong> has an expected data type. The various "set" methods in <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> do not validate the type against the attribute <strong><see cref = "T:System.Guid"/></strong>. It is the application's responsibility to set the correct type for the attribute.</p><p>To create an empty attribute store, call <strong>MFCreateAttributes</strong>.</p>
            </summary>
            <param name = "guidKey">No documentation.</param>
            <param name = "bufOut">No documentation.</param>
            <param name = "cbSizeRef">No documentation.</param>
            <returns>No documentation.</returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms704598</doc-id>
            <unmanaged>HRESULT IMFAttributes::GetAllocatedBlob([In] const GUID&amp; guidKey,[Buffer, Optional] unsigned char** ppBuf,[Out] unsigned int* pcbSize)</unmanaged>
            <unmanaged-short>IMFAttributes::GetAllocatedBlob</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.GetUnknown(System.Guid,System.Guid,System.IntPtr@)">
            <summary>
            <p> </p><p>Retrieves an interface reference associated with a key.</p>
            </summary>
            <param name = "guidKey"><dd> <p><see cref = "T:System.Guid"/> that identifies which value to retrieve. The attribute type must be <strong>MF_ATTRIBUTE_IUNKNOWN</strong>.</p> </dd></param>
            <param name = "riid"><dd> <p>Interface identifier (IID) of the interface to retrieve.</p> </dd></param>
            <param name = "vOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOINTERFACE</strong></dt> </dl> </td><td> <p>The attribute value is an <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference but does not support requested interface.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Attributenotfound"/></strong></dt> </dl> </td><td> <p>The specified key was not found.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidType"/></strong></dt> </dl> </td><td> <p>The attribute value is not an <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970481</doc-id>
            <unmanaged>HRESULT IMFAttributes::GetUnknown([In] const GUID&amp; guidKey,[In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>
            <unmanaged-short>IMFAttributes::GetUnknown</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.Set(System.Guid,SharpDX.Win32.Variant)">
            <summary>
            <p> Adds an attribute value with a specified key. </p>
            </summary>
            <param name = "guidKey"><dd> <p> A <see cref = "T:System.Guid"/> that identifies the value to set. If this key already exists, the method overwrites the old value. </p> </dd></param>
            <param name = "value"><dd> <p> A <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that contains the attribute value. The method copies the value. The <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> type must be one of the types listed in the <strong><see cref = "T:SharpDX.MediaFoundation.AttributeType"/></strong> enumeration. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_OUTOFMEMORY</strong></dt> </dl> </td><td> <p> Insufficient memory. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidType"/></strong></dt> </dl> </td><td> <p> Invalid attribute type. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> This method checks whether the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> type is one of the attribute types defined in <strong><see cref = "T:SharpDX.MediaFoundation.AttributeType"/></strong>, and fails if an unsupported type is used. However, this method does not check whether the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> is the correct type for the specified attribute <see cref = "T:System.Guid"/>. (There is no programmatic way to associate attribute GUIDs with property types.) For a list of Media Foundation attributes and their data types, see Media Foundation Attributes. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970346</doc-id>
            <unmanaged>HRESULT IMFAttributes::SetItem([In] const GUID&amp; guidKey,[In] const PROPVARIANT&amp; Value)</unmanaged>
            <unmanaged-short>IMFAttributes::SetItem</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.DeleteItem(System.Guid)">
            <summary>
            <p> </p><p>Removes a key/value pair from the object's attribute list.</p>
            </summary>
            <param name = "guidKey"><dd> <p><see cref = "T:System.Guid"/> that identifies the value to delete.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the specified key does not exist, the method returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970486</doc-id>
            <unmanaged>HRESULT IMFAttributes::DeleteItem([In] const GUID&amp; guidKey)</unmanaged>
            <unmanaged-short>IMFAttributes::DeleteItem</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.DeleteAllItems">
            <summary>
            <p> </p><p>Removes all key/value pairs from the object's attribute list.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms700200</doc-id>
            <unmanaged>HRESULT IMFAttributes::DeleteAllItems()</unmanaged>
            <unmanaged-short>IMFAttributes::DeleteAllItems</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.Set(System.Guid,System.Int32)">
            <summary>
            <p> </p><p>Associates a <strong>UINT32</strong> value with a key.</p>
            </summary>
            <param name = "guidKey"><dd> <p><see cref = "T:System.Guid"/> that identifies the value to set. If this key already exists, the method overwrites the old value.</p> </dd></param>
            <param name = "unValue"><dd> <p>New value for this key.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To retrieve the <strong>UINT32</strong> value, call <strong>IMFAttributes::GetUINT32</strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970467</doc-id>
            <unmanaged>HRESULT IMFAttributes::SetUINT32([In] const GUID&amp; guidKey,[In] unsigned int unValue)</unmanaged>
            <unmanaged-short>IMFAttributes::SetUINT32</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.Set(System.Guid,System.Int64)">
            <summary>
            <p> </p><p>Associates a <strong>UINT64</strong> value with a key.</p>
            </summary>
            <param name = "guidKey"><dd> <p><see cref = "T:System.Guid"/> that identifies the value to set. If this key already exists, the method overwrites the old value.</p> </dd></param>
            <param name = "unValue"><dd> <p>New value for this key.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To retrieve the <strong>UINT64</strong> value, call <strong>IMFAttributes::GetUINT64</strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970439</doc-id>
            <unmanaged>HRESULT IMFAttributes::SetUINT64([In] const GUID&amp; guidKey,[In] unsigned longlong unValue)</unmanaged>
            <unmanaged-short>IMFAttributes::SetUINT64</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.Set(System.Guid,System.Double)">
            <summary>
            <p> </p><p>Associates a <strong>double</strong> value with a key.</p>
            </summary>
            <param name = "guidKey"><dd> <p><see cref = "T:System.Guid"/> that identifies the value to set. If this key already exists, the method overwrites the old value.</p> </dd></param>
            <param name = "fValue"><dd> <p>New value for this key.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To retrieve the double value, call <strong>IMFAttributes::GetDouble</strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970505</doc-id>
            <unmanaged>HRESULT IMFAttributes::SetDouble([In] const GUID&amp; guidKey,[In] double fValue)</unmanaged>
            <unmanaged-short>IMFAttributes::SetDouble</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.Set(System.Guid,System.Guid)">
            <summary>
            <p> </p><p>Associates a <see cref = "T:System.Guid"/> value with a key.</p>
            </summary>
            <param name = "guidKey"><dd> <p><see cref = "T:System.Guid"/> that identifies the value to set. If this key already exists, the method overwrites the old value.</p> </dd></param>
            <param name = "guidValue"><dd> <p>New value for this key.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_OUTOFMEMORY</strong></dt> </dl> </td><td> <p>Insufficient memory.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To retrieve the <see cref = "T:System.Guid"/> value, call <strong>IMFAttributes::GetGUID</strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970530</doc-id>
            <unmanaged>HRESULT IMFAttributes::SetGUID([In] const GUID&amp; guidKey,[In] const GUID&amp; guidValue)</unmanaged>
            <unmanaged-short>IMFAttributes::SetGUID</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.Set(System.Guid,System.String)">
            <summary>
            <p> </p><p>Associates a wide-character string with a key.</p>
            </summary>
            <param name = "guidKey"><dd> <p><see cref = "T:System.Guid"/> that identifies the value to set. If this key already exists, the method overwrites the old value.</p> </dd></param>
            <param name = "wszValue"><dd> <p>Null-terminated wide-character string to associate with this key. The method stores a copy of the string.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To retrieve the string, call <strong>IMFAttributes::GetString</strong> or <strong>IMFAttributes::GetAllocatedString</strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970404</doc-id>
            <unmanaged>HRESULT IMFAttributes::SetString([In] const GUID&amp; guidKey,[In] const wchar_t* wszValue)</unmanaged>
            <unmanaged-short>IMFAttributes::SetString</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.SetBlob(System.Guid,System.IntPtr,System.Int32)">
            <summary>
            <p> </p><p>Associates a byte array with a key.</p>
            </summary>
            <param name = "guidKey"><dd> <p><see cref = "T:System.Guid"/> that identifies the value to set. If this key already exists, the method overwrites the old value.</p> </dd></param>
            <param name = "bufRef"><dd> <p>Pointer to a byte array to associate with this key. The method stores a copy of the array.</p> </dd></param>
            <param name = "cbBufSize"><dd> <p>Size of the array, in bytes.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To retrieve the byte array, call <strong>IMFAttributes::GetBlob</strong> or <strong>IMFAttributes::GetAllocatedBlob</strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970395</doc-id>
            <unmanaged>HRESULT IMFAttributes::SetBlob([In] const GUID&amp; guidKey,[In] const unsigned char* pBuf,[In] unsigned int cbBufSize)</unmanaged>
            <unmanaged-short>IMFAttributes::SetBlob</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.Set(System.Guid,SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Associates an <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference with a key.</p>
            </summary>
            <param name = "guidKey"><dd> <p><see cref = "T:System.Guid"/> that identifies the value to set. If this key already exists, the method overwrites the old value.</p> </dd></param>
            <param name = "unknownRef"><dd> <p><strong><see cref = "T:SharpDX.IUnknown"/></strong> reference to be associated with this key.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To retrieve the <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference, call <strong>IMFAttributes::GetUnknown</strong>.</p><p>It is not an error to call <strong>SetUnknown</strong> with <em>pUnknown</em> equal to <strong><c>null</c></strong>. However, <strong>GetUnknown</strong> will return <strong><see cref = "!:InvalidType"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970533</doc-id>
            <unmanaged>HRESULT IMFAttributes::SetUnknown([In] const GUID&amp; guidKey,[In, Optional] IUnknown* pUnknown)</unmanaged>
            <unmanaged-short>IMFAttributes::SetUnknown</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.LockStore">
            <summary>
            <p> </p><p>Locks the attribute store so that no other thread can access it. If the attribute store is already locked by another thread, this method blocks until the other thread unlocks the object. After calling this method, call <strong>IMFAttributes::UnlockStore</strong> to unlock the object.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method can cause a deadlock if a thread that calls <strong>LockStore</strong> waits on a thread that calls any other <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> methods on the same object.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms698926</doc-id>
            <unmanaged>HRESULT IMFAttributes::LockStore()</unmanaged>
            <unmanaged-short>IMFAttributes::LockStore</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.UnlockStore">
            <summary>
            <p> </p><p>Unlocks the attribute store after a call to the <strong>IMFAttributes::LockStore</strong> method. While the object is unlocked, multiple threads can access the object's attributes.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms697545</doc-id>
            <unmanaged>HRESULT IMFAttributes::UnlockStore()</unmanaged>
            <unmanaged-short>IMFAttributes::UnlockStore</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.GetCount(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the number of attributes that are set on this object.</p>
            </summary>
            <param name = "cItemsRef"><dd> <p>Receives the number of attributes. This parameter must not be <strong><c>null</c></strong>. If this parameter is <strong><c>null</c></strong>, an access violation occurs.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To enumerate all of the attributes, call <strong>IMFAttributes::GetItemByIndex</strong> for each index value.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970413</doc-id>
            <unmanaged>HRESULT IMFAttributes::GetCount([Out] unsigned int* pcItems)</unmanaged>
            <unmanaged-short>IMFAttributes::GetCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.GetItemByIndex(System.Int32,System.Guid@,System.IntPtr)">
            <summary>
            <p> </p><p>Retrieves an attribute at the specified index.</p>
            </summary>
            <param name = "unIndex"><dd> <p>Index of the attribute to retrieve. To get the number of attributes, call <strong>IMFAttributes::GetCount</strong>.</p> </dd></param>
            <param name = "guidKeyRef"><dd> <p>Receives the <see cref = "T:System.Guid"/> that identifies this attribute.</p> </dd></param>
            <param name = "valueRef"><dd> <p>Pointer to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that receives the value. This parameter can be <strong><c>null</c></strong>. If it is not <strong><c>null</c></strong>, the method fills the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> with a copy of the attribute value. Call <strong>PropVariantClear</strong> to free the memory allocated by this method.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid index.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To enumerate all of an object's attributes in a thread-safe way, do the following:</p><ol> <li> <p>Call <strong>IMFAttributes::LockStore</strong> to prevent another thread from adding or deleting attributes.</p> </li> <li> <p>Call <strong>IMFAttributes::GetCount</strong> to find the number of attributes.</p> </li> <li> <p>Call <strong>GetItemByIndex</strong> to get each attribute by index.</p> </li> <li> <p>Call <strong>IMFAttributes::UnlockStore</strong> to unlock the attribute store.</p> </li> </ol><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970331</doc-id>
            <unmanaged>HRESULT IMFAttributes::GetItemByIndex([In] unsigned int unIndex,[Out] GUID* pguidKey,[InOut, Optional] PROPVARIANT* pValue)</unmanaged>
            <unmanaged-short>IMFAttributes::GetItemByIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaAttributes.CopyAllItems(SharpDX.MediaFoundation.MediaAttributes)">
            <summary>
            <p> Copies all of the attributes from this object into another attribute store. </p>
            </summary>
            <param name = "destRef"><dd> <p> A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of the attribute store that receives the copy. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> This method deletes all of the attributes originally stored in <em>pDest</em>. </p><strong>Note</strong>??<p>When you call <strong>CopyAllItems</strong> on an <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong>, which inherits this method, the sample time, duration, and flags are not copied to the destination sample. You must copy these values to the new sample manually.</p>?<p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970330</doc-id>
            <unmanaged>HRESULT IMFAttributes::CopyAllItems([In, Optional] IMFAttributes* pDest)</unmanaged>
            <unmanaged-short>IMFAttributes::CopyAllItems</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaEngineNotifyDelegate">
            <summary>
            Delegate MediaEngineNotifyDelegate {CC2D43FA-BBC4-448A-9D0B-7B57ADF2655C}
            </summary>
            <param name="mediaEvent">The media event.</param>
            <param name="param1">The param1.</param>
            <param name="param2">The param2.</param>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.#ctor(SharpDX.MediaFoundation.MediaEngineClassFactory,SharpDX.MediaFoundation.MediaEngineAttributes,SharpDX.MediaFoundation.MediaEngineCreateFlags,SharpDX.MediaFoundation.MediaEngineNotifyDelegate)">
            <summary>
            Initializes an instance of the <see cref="T:SharpDX.MediaFoundation.MediaEngine"/> class.
            </summary>
            <param name="factory"></param>
            <param name="attributes"></param>
            <param name="createFlags"> </param>
            <param name="playbackCallback"></param>
            <msdn-id>hh447921</msdn-id>	
            <unmanaged>HRESULT IMFMediaEngineClassFactory::CreateInstance([In] MF_MEDIA_ENGINE_CREATEFLAGS dwFlags,[In] IMFAttributes* pAttr,[Out, Fast] IMFMediaEngine** ppPlayer)</unmanaged>	
            <unmanaged-short>IMFMediaEngineClassFactory::CreateInstance</unmanaged-short>	
        </member>
        <member name="E:SharpDX.MediaFoundation.MediaEngine.PlaybackEvent">
            <summary>
            Media engine playback event.
            </summary>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.OnVideoStreamTick(System.Int64@)">
            <summary>	
            <p>[This documentation is preliminary and is subject to change.]</p><p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Queries the Media Engine to find out whether a new video frame is ready.</p>	
            </summary>	
            <param name="ptsRef"><dd> <p>If a new frame is ready, receives the presentation time of the frame.</p> </dd></param>	
            <returns>true if new video frame is ready for display.</returns>	
            <remarks>	
            <p>In frame-server mode, the application should call this method whenever a vertical blank occurs in the display device. If the method returns <strong><see cref="F:SharpDX.Result.Ok"/></strong>, call <strong><see cref="M:SharpDX.MediaFoundation.MediaEngine.TransferVideoFrame(SharpDX.IUnknown,System.Nullable{SharpDX.MediaFoundation.VideoNormalizedRect},SharpDX.Mathematics.Interop.RawRectangle,System.Nullable{SharpDX.Mathematics.Interop.RawColorBGRA})"/></strong> to blit the frame to the render target. If the method returns <strong>S_FALSE</strong>, wait for the next vertical blank and call the method again.</p><p>Do not call this method in rendering mode or audio-only mode. </p>	
            </remarks>	
            <msdn-id>hh448006</msdn-id>	
            <unmanaged>HRESULT IMFMediaEngine::OnVideoStreamTick([Out] longlong* pPts)</unmanaged>	
            <unmanaged-short>IMFMediaEngine::OnVideoStreamTick</unmanaged-short>	
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.Source">
            <summary>	
            <p>[This documentation is preliminary and is subject to change.]</p><p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Sets the URL of a media resource.</p>	
            </summary>	
            <param name="urlRef"><dd> <p>The URL of the media resource.</p> </dd></param>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok" /></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result" /></strong> error code.</p></returns>	
            <remarks>	
            <p>This method corresponds to setting the <strong>src</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>The URL specified by this method takes precedence over media resources specified in the <strong><see cref="M:SharpDX.MediaFoundation.MediaEngine.SetSourceElements(SharpDX.MediaFoundation.MediaEngineSrcElements)" /></strong> method. To load the URL, call <strong><see cref="M:SharpDX.MediaFoundation.MediaEngine.Load" /></strong>.</p><p>This method asynchronously loads the URL. When the operation starts, the Media Engine sends an <strong><see cref="F:SharpDX.MediaFoundation.MediaEngineEvent.LoadStart" /></strong> event. If no errors occur during the <strong>Load</strong> operation, several other events are generated, including the following.</p><ul> <li><strong><see cref="F:SharpDX.MediaFoundation.MediaEngineEvent.LoadedMetadata" /></strong></li> <li><strong><see cref="F:SharpDX.MediaFoundation.MediaEngineEvent.LoadedData" /></strong></li> <li><strong><see cref="F:SharpDX.MediaFoundation.MediaEngineEvent.CanPlay" /></strong></li> <li><strong><see cref="F:SharpDX.MediaFoundation.MediaEngineEvent.CanPlayThrough" /></strong></li> </ul><p>If the Media Engine is unable to load the URL, the Media Engine sends an <strong><see cref="F:SharpDX.MediaFoundation.MediaEngineEvent.Error" /></strong> event. </p><p>For more information about event handling in the Media Engine, see <strong><see cref="T:SharpDX.MediaFoundation.MediaEngineNotify" /></strong>.</p>	
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IMFMediaEngine::SetSource']/*" />	
            <msdn-id>hh448017</msdn-id>	
            <unmanaged>HRESULT IMFMediaEngine::SetSource([In] wchar_t* pUrl)</unmanaged>	
            <unmanaged-short>IMFMediaEngine::SetSource</unmanaged-short>	
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.Error">
            <summary>
            <p>Gets the most recent error status.</p>
            </summary>
            <remarks>
            <p>This method returns the last error status, if any, that resulted from loading the media source. If there has not been an error, <em>ppError</em> receives the value <strong><c>null</c></strong>.</p><p>This method corresponds to the <strong>error</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh447985</doc-id>
            <unmanaged>GetError</unmanaged>
            <unmanaged-short>GetError</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.ErrorCode">
            <summary>
            <p>Sets the current error code.</p>
            </summary>
            <doc-id>hh448012</doc-id>
            <unmanaged>SetErrorCode</unmanaged>
            <unmanaged-short>SetErrorCode</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.SourceElements">
            <summary>
            <p>Sets a list of media sources.</p>
            </summary>
            <remarks>
            <p>This method corresponds to adding a list of <strong>source</strong> elements to a media element in HTML5. </p><p>The Media Engine tries to load each item in the <em>pSrcElements</em> list, until it finds one that loads successfully. After this method is called, the application can use the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineSrcElements"/></strong> interface to update the list at any time. To reload the list, call <strong>IMFMediaEngine::Load</strong>.</p><p>This method completes asynchronously. When the operation starts, the Media Engine sends an <strong>MF_MEDIA_ENGINE_EVENT_LOADSTART</strong> event. If no errors occur during the <strong>Load</strong> operation, several other events are generated, including the following.</p><ul> <li><strong>MF_MEDIA_ENGINE_EVENT_LOADEDMETADATA</strong></li> <li><strong>MF_MEDIA_ENGINE_EVENT_LOADEDDATA</strong></li> <li><strong>MF_MEDIA_ENGINE_EVENT_CANPLAY</strong></li> <li><strong>MF_MEDIA_ENGINE_EVENT_CANPLAYTHROUGH</strong></li> </ul><p>If the Media Engine is unable to load a URL, it sends an <strong>MF_MEDIA_ENGINE_EVENT_ERROR</strong> event. </p><p>For more information about event handling in the Media Engine, see <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineNotify"/></strong>.</p><p>If the application also calls <strong>IMFMediaEngine::SetSource</strong>, the URL passed to <strong>SetSource</strong> takes precedence over the list given to <strong>SetSourceElements</strong>.</p>
            </remarks>
            <doc-id>hh448018</doc-id>
            <unmanaged>SetSourceElements</unmanaged>
            <unmanaged-short>SetSourceElements</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.NetworkState">
            <summary>
            <p>Gets the current network state of the media engine.</p>
            </summary>
            <remarks>
            <p>This method corresponds to the <strong>networkState</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh447989</doc-id>
            <unmanaged>GetNetworkState</unmanaged>
            <unmanaged-short>GetNetworkState</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.Preload">
            <summary>
            <p>Gets or sets the preload flag.</p>
            </summary>
            <remarks>
            <p>This method corresponds to the <strong>preload</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5. The value is a hint to the user-agent whether to preload the media resource.</p>
            </remarks>
            <doc-id>hh447992</doc-id>
            <unmanaged>GetPreload / SetPreload</unmanaged>
            <unmanaged-short>GetPreload</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.Buffered">
            <summary>
            <p>Queries how much resource data the media engine has buffered.</p>
            </summary>
            <remarks>
            <p>This method corresponds to the <strong>buffered</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>The returned  <strong><see cref = "T:SharpDX.MediaFoundation.MediaTimeRange"/></strong> interface represents a list of time ranges. The time ranges indicate which portions of the media resource have been downloaded. The time range list can be empty.</p>
            </remarks>
            <doc-id>hh447980</doc-id>
            <unmanaged>GetBuffered</unmanaged>
            <unmanaged-short>GetBuffered</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.ReadyState">
            <summary>
            <p>Gets the ready state, which indicates whether the current media resource can be rendered.</p>
            </summary>
            <remarks>
            <p>This method corresponds to the <strong>readyState</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh447993</doc-id>
            <unmanaged>GetReadyState</unmanaged>
            <unmanaged-short>GetReadyState</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.IsSeeking">
            <summary>
            <p>Queries whether the Media Engine is currently seeking to a new playback position.</p>
            </summary>
            <remarks>
            <p>This method corresponds to the <strong>seeking</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh448004</doc-id>
            <unmanaged>IsSeeking</unmanaged>
            <unmanaged-short>IsSeeking</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.CurrentTime">
            <summary>
            <p>Gets or sets the current playback position.</p>
            </summary>
            <remarks>
            <p>This method corresponds to the <strong>currentTime</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5. </p>
            </remarks>
            <doc-id>hh447982</doc-id>
            <unmanaged>GetCurrentTime / SetCurrentTime</unmanaged>
            <unmanaged-short>GetCurrentTime</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.StartTime">
            <summary>
            <p>Gets the initial playback position.</p>
            </summary>
            <remarks>
            <p>This method corresponds to the <strong>initialTime</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh447995</doc-id>
            <unmanaged>GetStartTime</unmanaged>
            <unmanaged-short>GetStartTime</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.Duration">
            <summary>
            <p>Gets the duration of the media resource.</p>
            </summary>
            <remarks>
            <p>This method corresponds to the <strong>duration</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>If the duration changes, the Media Engine sends an <strong>MF_MEDIA_ENGINE_EVENT_DURATIONCHANGE</strong> event. See <strong>IMFMediaEngineNotify::EventNotify</strong>.</p>
            </remarks>
            <doc-id>hh447984</doc-id>
            <unmanaged>GetDuration</unmanaged>
            <unmanaged-short>GetDuration</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.IsPaused">
            <summary>
            <p>Queries whether playback is currently paused.</p>
            </summary>
            <remarks>
            <p>This method corresponds to the <strong>paused</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh448003</doc-id>
            <unmanaged>IsPaused</unmanaged>
            <unmanaged-short>IsPaused</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.DefaultPlaybackRate">
            <summary>
            <p>Gets or sets the default playback rate.</p>
            </summary>
            <remarks>
            <p>This method corresponds to getting the <strong>defaultPlaybackRate</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5. </p><p>The default playback rate is used for the next call to the <strong>IMFMediaEngine::Play</strong> method. To change the current playback rate, call <strong>IMFMediaEngine::SetPlaybackRate</strong>.</p>
            </remarks>
            <doc-id>hh447983</doc-id>
            <unmanaged>GetDefaultPlaybackRate / SetDefaultPlaybackRate</unmanaged>
            <unmanaged-short>GetDefaultPlaybackRate</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.PlaybackRate">
            <summary>
            <p>Gets or sets the current playback rate.</p>
            </summary>
            <remarks>
            <p>This method corresponds to getting the <strong>playbackRate</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5. </p>
            </remarks>
            <doc-id>hh447990</doc-id>
            <unmanaged>GetPlaybackRate / SetPlaybackRate</unmanaged>
            <unmanaged-short>GetPlaybackRate</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.Played">
            <summary>
            <p>Gets the time ranges that have been rendered.</p>
            </summary>
            <remarks>
            <p>This method corresponds to the <strong>played</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh447991</doc-id>
            <unmanaged>GetPlayed</unmanaged>
            <unmanaged-short>GetPlayed</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.Seekable">
            <summary>
            <p>Gets the time ranges to which the Media Engine can currently seek.</p>
            </summary>
            <remarks>
            <p>This method corresponds to the <strong>seekable</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>To find out whether the media source supports seeking, call <strong>IMFMediaEngineEx::GetResourceCharacteristics</strong>.</p>
            </remarks>
            <doc-id>hh447994</doc-id>
            <unmanaged>GetSeekable</unmanaged>
            <unmanaged-short>GetSeekable</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.IsEnded">
            <summary>
            <p>Queries whether playback has ended.</p>
            </summary>
            <remarks>
            <p>This method corresponds to the <strong>ended</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh448002</doc-id>
            <unmanaged>IsEnded</unmanaged>
            <unmanaged-short>IsEnded</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.AutoPlay">
            <summary>
            <p>Queries whether the Media Engine automatically begins playback.</p>
            </summary>
            <remarks>
            <p>This method corresponds to the <strong>autoplay</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>If this method returns <strong>TRUE</strong>, playback begins automatically after the <strong>IMFMediaEngine::Load</strong> method completes. Otherwise, playback begins when the application calls <strong>IMFMediaEngine::Play</strong>.</p>
            </remarks>
            <doc-id>hh447979</doc-id>
            <unmanaged>GetAutoPlay / SetAutoPlay</unmanaged>
            <unmanaged-short>GetAutoPlay</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.Loop">
            <summary>
            <p>Queries whether the Media Engine will loop playback.</p>
            </summary>
            <remarks>
            <p>This method corresponds to getting the <strong>loop</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>If looping is enabled, the Media Engine seeks to the start of the content when playback reaches the end.</p>
            </remarks>
            <doc-id>hh447986</doc-id>
            <unmanaged>GetLoop / SetLoop</unmanaged>
            <unmanaged-short>GetLoop</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.Muted">
            <summary>
            <p>Queries whether the audio is muted. </p>
            </summary>
            <doc-id>hh447987</doc-id>
            <unmanaged>GetMuted / SetMuted</unmanaged>
            <unmanaged-short>GetMuted</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngine.Volume">
            <summary>
            <p>Gets or sets the audio volume level.</p>
            </summary>
            <doc-id>hh447997</doc-id>
            <unmanaged>GetVolume / SetVolume</unmanaged>
            <unmanaged-short>GetVolume</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.GetError(SharpDX.MediaFoundation.MediaError@)">
            <summary>
            <p>Gets the most recent error status.</p>
            </summary>
            <param name = "errorOut"><dd> <p>Receives either a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaError"/></strong> interface, or the value <strong><c>null</c></strong>. If the value is <strong>non-<c>null</c></strong>, the caller must release the interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method returns the last error status, if any, that resulted from loading the media source. If there has not been an error, <em>ppError</em> receives the value <strong><c>null</c></strong>.</p><p>This method corresponds to the <strong>error</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh447985</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::GetError([Out] IMFMediaError** ppError)</unmanaged>
            <unmanaged-short>IMFMediaEngine::GetError</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.SetErrorCode(SharpDX.MediaFoundation.MediaEngineErr)">
            <summary>
            <p>Sets the current error code.</p>
            </summary>
            <param name = "error"><dd> <p>The error code, as an <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineErr"/></strong> value.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh448012</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::SetErrorCode([In] MF_MEDIA_ENGINE_ERR error)</unmanaged>
            <unmanaged-short>IMFMediaEngine::SetErrorCode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.SetSourceElements(SharpDX.MediaFoundation.MediaEngineSrcElements)">
            <summary>
            <p>Sets a list of media sources.</p>
            </summary>
            <param name = "srcElementsRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineSrcElements"/></strong> interface. The caller must implement this interface. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method corresponds to adding a list of <strong>source</strong> elements to a media element in HTML5. </p><p>The Media Engine tries to load each item in the <em>pSrcElements</em> list, until it finds one that loads successfully. After this method is called, the application can use the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineSrcElements"/></strong> interface to update the list at any time. To reload the list, call <strong>IMFMediaEngine::Load</strong>.</p><p>This method completes asynchronously. When the operation starts, the Media Engine sends an <strong>MF_MEDIA_ENGINE_EVENT_LOADSTART</strong> event. If no errors occur during the <strong>Load</strong> operation, several other events are generated, including the following.</p><ul> <li><strong>MF_MEDIA_ENGINE_EVENT_LOADEDMETADATA</strong></li> <li><strong>MF_MEDIA_ENGINE_EVENT_LOADEDDATA</strong></li> <li><strong>MF_MEDIA_ENGINE_EVENT_CANPLAY</strong></li> <li><strong>MF_MEDIA_ENGINE_EVENT_CANPLAYTHROUGH</strong></li> </ul><p>If the Media Engine is unable to load a URL, it sends an <strong>MF_MEDIA_ENGINE_EVENT_ERROR</strong> event. </p><p>For more information about event handling in the Media Engine, see <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineNotify"/></strong>.</p><p>If the application also calls <strong>IMFMediaEngine::SetSource</strong>, the URL passed to <strong>SetSource</strong> takes precedence over the list given to <strong>SetSourceElements</strong>.</p>
            </remarks>
            <doc-id>hh448018</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::SetSourceElements([In] IMFMediaEngineSrcElements* pSrcElements)</unmanaged>
            <unmanaged-short>IMFMediaEngine::SetSourceElements</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.SetSource(System.IntPtr)">
            <summary>
            <p>Sets the URL of a media resource.</p>
            </summary>
            <param name = "urlRef"><dd> <p>The URL of the media resource.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method corresponds to setting the <strong>src</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>The URL specified by this method takes precedence over media resources specified in the <strong>IMFMediaEngine::SetSourceElements</strong> method. To load the URL, call <strong>IMFMediaEngine::Load</strong>.</p><p>This method asynchronously loads the URL. When the operation starts, the Media Engine sends an <strong>MF_MEDIA_ENGINE_EVENT_LOADSTART</strong> event. If no errors occur during the <strong>Load</strong> operation, several other events are generated, including the following.</p><ul> <li><strong>MF_MEDIA_ENGINE_EVENT_LOADEDMETADATA</strong></li> <li><strong>MF_MEDIA_ENGINE_EVENT_LOADEDDATA</strong></li> <li><strong>MF_MEDIA_ENGINE_EVENT_CANPLAY</strong></li> <li><strong>MF_MEDIA_ENGINE_EVENT_CANPLAYTHROUGH</strong></li> </ul><p>If the Media Engine is unable to load the URL, the Media Engine sends an <strong>MF_MEDIA_ENGINE_EVENT_ERROR</strong> event. </p><p>For more information about event handling in the Media Engine, see <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineNotify"/></strong>.</p>
            </remarks>
            <doc-id>hh448017</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::SetSource([In] wchar_t* pUrl)</unmanaged>
            <unmanaged-short>IMFMediaEngine::SetSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.GetCurrentSource(System.IntPtr)">
            <summary>
            <p>Gets the URL of the current media resource, or an empty string if no media resource is present.</p>
            </summary>
            <param name = "urlOut"><dd> <p>Receives a <strong>BSTR</strong> that contains the URL of the current media resource. If there is no media resource, <em>ppUrl</em> receives an empty string. The caller must free the  <strong>BSTR</strong> by calling <strong>SysFreeString</strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>currentSrc</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>Initially, the current media resource is empty. It is updated when the Media Engine performs the resource selection algorithm.</p>
            </remarks>
            <doc-id>hh447981</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::GetCurrentSource([Out] wchar_t** ppUrl)</unmanaged>
            <unmanaged-short>IMFMediaEngine::GetCurrentSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.GetNetworkState">
            <summary>
            <p>Gets the current network state of the media engine.</p>
            </summary>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineNetwork"/></strong> enumeration value.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>networkState</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh447989</doc-id>
            <unmanaged>unsigned short IMFMediaEngine::GetNetworkState()</unmanaged>
            <unmanaged-short>IMFMediaEngine::GetNetworkState</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.GetPreload">
            <summary>
            <p>Gets the preload flag.</p>
            </summary>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.MediaFoundation.MediaEnginePreload"/></strong> enumeration value.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>preload</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5. The value is a hint to the user-agent whether to preload the media resource.</p>
            </remarks>
            <doc-id>hh447992</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_PRELOAD IMFMediaEngine::GetPreload()</unmanaged>
            <unmanaged-short>IMFMediaEngine::GetPreload</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.SetPreload(SharpDX.MediaFoundation.MediaEnginePreload)">
            <summary>
            <p>Sets the preload flag.</p>
            </summary>
            <param name = "preload"><dd> <p>An <strong><see cref = "T:SharpDX.MediaFoundation.MediaEnginePreload"/></strong> value equal to  the preload flag.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method corresponds to setting the <strong>preload</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5. The value is a hint to the user-agent whether to preload the media resource.</p>
            </remarks>
            <doc-id>hh448016</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::SetPreload([In] MF_MEDIA_ENGINE_PRELOAD Preload)</unmanaged>
            <unmanaged-short>IMFMediaEngine::SetPreload</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.GetBuffered(SharpDX.MediaFoundation.MediaTimeRange@)">
            <summary>
            <p>Queries how much resource data the media engine has buffered.</p>
            </summary>
            <param name = "bufferedOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaTimeRange"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>buffered</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>The returned  <strong><see cref = "T:SharpDX.MediaFoundation.MediaTimeRange"/></strong> interface represents a list of time ranges. The time ranges indicate which portions of the media resource have been downloaded. The time range list can be empty.</p>
            </remarks>
            <doc-id>hh447980</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::GetBuffered([Out] IMFMediaTimeRange** ppBuffered)</unmanaged>
            <unmanaged-short>IMFMediaEngine::GetBuffered</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.Load">
            <summary>
            <p>Loads the current media source.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The main purpose of this method is to reload a list of source elements after updating the list. For more information, see <strong>SetSourceElements</strong>. Otherwise, calling this method is generally not required. To load a new media source, call <strong>IMFMediaEngine::SetSource</strong> or <strong>IMFMediaEngine::SetSourceElements</strong>.</p><p>The <strong>Load</strong> method explictly invokes the Media Engine's media resource loading algorithm. Before calling this method, you must set the media resource by calling <strong>IMFMediaEngine::SetSource</strong> or <strong>IMFMediaEngine::SetSourceElements</strong>. </p><p>This method completes asynchronously. When the <strong>Load</strong> operation starts, the Media Engine sends an <strong>MF_MEDIA_ENGINE_EVENT_LOADSTART</strong> event. If no errors occur during the <strong>Load</strong> operation, several other events are generated, including the following.</p><ul> <li><strong>MF_MEDIA_ENGINE_EVENT_LOADEDMETADATA</strong></li> <li><strong>MF_MEDIA_ENGINE_EVENT_LOADEDDATA</strong></li> <li><strong>MF_MEDIA_ENGINE_EVENT_CANPLAY</strong></li> <li><strong>MF_MEDIA_ENGINE_EVENT_CANPLAYTHROUGH</strong></li> </ul><p>If the Media Engine is unable to load the file, the Media Engine sends an <strong>MF_MEDIA_ENGINE_EVENT_ERROR</strong> event. </p><p>For more information about event handling in the Media Engine, see <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineNotify"/></strong>.</p><p>This method corresponds to the <strong>load</strong> method of the <strong>HTMLMediaElement</strong> interface in HTML5. </p>
            </remarks>
            <doc-id>hh448005</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::Load()</unmanaged>
            <unmanaged-short>IMFMediaEngine::Load</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.CanPlayType(System.String,SharpDX.MediaFoundation.MediaEngineCanPlay@)">
            <summary>
            <p>Queries how likely it is that the Media Engine can play a specified type of media resource.</p>
            </summary>
            <param name = "type"><dd> <p>A string that contains a MIME type with an optional codecs parameter, as defined in RFC 4281.</p> </dd></param>
            <param name = "answerRef"><dd> <p>Receives an <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineCanPlay"/></strong> enumeration value.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>canPlayType</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>The <strong>canPlayType</strong> attribute defines the following values.</p><table> <tr><th>Value</th><th>Description</th></tr> <tr><td>"" (empty string)</td><td>The user-agent cannot play the resource, or the resource type is "application/octet-stream".</td></tr> <tr><td>"probably"</td><td>The user-agent probably can play the resource.</td></tr> <tr><td>"maybe"</td><td>Neither of the previous values applies.</td></tr> </table><p>?</p><p>The value "probably" is used because a MIME type for a media resource is generally not a complete description of the resource. For example, "video/mp4" specifies an MP4 file with video, but does not describe the codec. Even with the optional codecs parameter, the MIME type omits some information, such as the actual coded bit rate. Therefore, it is usually impossible to be certain that playback is possible until the actual media resource is opened.</p>
            </remarks>
            <doc-id>hh447978</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::CanPlayType([In] wchar_t* type,[Out] MF_MEDIA_ENGINE_CANPLAY* pAnswer)</unmanaged>
            <unmanaged-short>IMFMediaEngine::CanPlayType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.GetReadyState">
            <summary>
            <p>Gets the ready state, which indicates whether the current media resource can be rendered.</p>
            </summary>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineReady"/></strong> enumeration value.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>readyState</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh447993</doc-id>
            <unmanaged>unsigned short IMFMediaEngine::GetReadyState()</unmanaged>
            <unmanaged-short>IMFMediaEngine::GetReadyState</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.IsSeeking_">
            <summary>
            <p>Queries whether the Media Engine is currently seeking to a new playback position.</p>
            </summary>
            <returns><p>Returns <strong>TRUE</strong> if the Media Engine is seeking, or <strong><see cref = "F:SharpDX.Result.False"/></strong> otherwise.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>seeking</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh448004</doc-id>
            <unmanaged>BOOL IMFMediaEngine::IsSeeking()</unmanaged>
            <unmanaged-short>IMFMediaEngine::IsSeeking</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.GetCurrentTime">
            <summary>
            <p>Gets the current playback position.</p>
            </summary>
            <returns><p>Returns the playback position, in seconds.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>currentTime</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5. </p>
            </remarks>
            <doc-id>hh447982</doc-id>
            <unmanaged>double IMFMediaEngine::GetCurrentTime()</unmanaged>
            <unmanaged-short>IMFMediaEngine::GetCurrentTime</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.SetCurrentTime(System.Double)">
            <summary>
            <p>Seeks to a new playback position.</p>
            </summary>
            <param name = "seekTime"><dd> <p>The new playback position, in seconds.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method corresponds to setting the <strong>currentTime</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>The method completes asynchronously. When the seek operation starts, the Media Engine sends an <strong>MF_MEDIA_ENGINE_EVENT_SEEKING</strong> event. When the seek operation completes, the Media Engine sends an <strong>MF_MEDIA_ENGINE_EVENT_SEEKED</strong> event. See <strong>IMFMediaEventNotify::EventNotify</strong>.</p>
            </remarks>
            <doc-id>hh448010</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::SetCurrentTime([In] double seekTime)</unmanaged>
            <unmanaged-short>IMFMediaEngine::SetCurrentTime</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.GetStartTime">
            <summary>
            <p>Gets the initial playback position.</p>
            </summary>
            <returns><p>Returns the initial playback position, in seconds.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>initialTime</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh447995</doc-id>
            <unmanaged>double IMFMediaEngine::GetStartTime()</unmanaged>
            <unmanaged-short>IMFMediaEngine::GetStartTime</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.GetDuration">
            <summary>
            <p>Gets the duration of the media resource.</p>
            </summary>
            <returns><p>Returns the duration, in seconds. If no media data is available, the method returns not-a-number (NaN). If the duration is unbounded, the method returns an infinite value.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>duration</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>If the duration changes, the Media Engine sends an <strong>MF_MEDIA_ENGINE_EVENT_DURATIONCHANGE</strong> event. See <strong>IMFMediaEngineNotify::EventNotify</strong>.</p>
            </remarks>
            <doc-id>hh447984</doc-id>
            <unmanaged>double IMFMediaEngine::GetDuration()</unmanaged>
            <unmanaged-short>IMFMediaEngine::GetDuration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.IsPaused_">
            <summary>
            <p>Queries whether playback is currently paused.</p>
            </summary>
            <returns><p>Returns <strong>TRUE</strong> if playback is paused, or  <strong><see cref = "F:SharpDX.Result.False"/></strong> otherwise.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>paused</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh448003</doc-id>
            <unmanaged>BOOL IMFMediaEngine::IsPaused()</unmanaged>
            <unmanaged-short>IMFMediaEngine::IsPaused</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.GetDefaultPlaybackRate">
            <summary>
            <p>Gets the default playback rate.</p>
            </summary>
            <returns><p>Returns the default playback rate, as a multiple of normal (1?) playback. A negative value indicates reverse playback.</p></returns>
            <remarks>
            <p>This method corresponds to getting the <strong>defaultPlaybackRate</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5. </p><p>The default playback rate is used for the next call to the <strong>IMFMediaEngine::Play</strong> method. To change the current playback rate, call <strong>IMFMediaEngine::SetPlaybackRate</strong>.</p>
            </remarks>
            <doc-id>hh447983</doc-id>
            <unmanaged>double IMFMediaEngine::GetDefaultPlaybackRate()</unmanaged>
            <unmanaged-short>IMFMediaEngine::GetDefaultPlaybackRate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.SetDefaultPlaybackRate(System.Double)">
            <summary>
            <p>Sets the default playback rate.</p>
            </summary>
            <param name = "rate"><dd> <p>The default playback rate, as a multiple of normal (1?) playback. A negative value indicates reverse playback.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method corresponds to setting the <strong>defaultPlaybackRate</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh448011</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::SetDefaultPlaybackRate([In] double Rate)</unmanaged>
            <unmanaged-short>IMFMediaEngine::SetDefaultPlaybackRate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.GetPlaybackRate">
            <summary>
            <p>Gets the current playback rate.</p>
            </summary>
            <returns><p>Returns the playback rate, as a multiple of normal (1?) playback. A negative value indicates reverse playback.</p></returns>
            <remarks>
            <p>This method corresponds to getting the <strong>playbackRate</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5. </p>
            </remarks>
            <doc-id>hh447990</doc-id>
            <unmanaged>double IMFMediaEngine::GetPlaybackRate()</unmanaged>
            <unmanaged-short>IMFMediaEngine::GetPlaybackRate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.SetPlaybackRate(System.Double)">
            <summary>
            <p>Sets the current playback rate.</p>
            </summary>
            <param name = "rate"><dd> <p>The playback rate, as a multiple of normal (1?) playback. A negative value indicates reverse playback.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method corresponds to setting the <strong>playbackRate</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh448015</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::SetPlaybackRate([In] double Rate)</unmanaged>
            <unmanaged-short>IMFMediaEngine::SetPlaybackRate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.GetPlayed(SharpDX.MediaFoundation.MediaTimeRange@)">
            <summary>
            <p>Gets the time ranges that have been rendered.</p>
            </summary>
            <param name = "playedOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaTimeRange"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>played</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh447991</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::GetPlayed([Out] IMFMediaTimeRange** ppPlayed)</unmanaged>
            <unmanaged-short>IMFMediaEngine::GetPlayed</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.GetSeekable(SharpDX.MediaFoundation.MediaTimeRange@)">
            <summary>
            <p>Gets the time ranges to which the Media Engine can currently seek.</p>
            </summary>
            <param name = "seekableOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaTimeRange"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>seekable</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>To find out whether the media source supports seeking, call <strong>IMFMediaEngineEx::GetResourceCharacteristics</strong>.</p>
            </remarks>
            <doc-id>hh447994</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::GetSeekable([Out] IMFMediaTimeRange** ppSeekable)</unmanaged>
            <unmanaged-short>IMFMediaEngine::GetSeekable</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.IsEnded_">
            <summary>
            <p>Queries whether playback has ended.</p>
            </summary>
            <returns><p>Returns <strong>TRUE</strong> if the direction of playback is forward and playback has reached the end of the media resource. Returns <strong><see cref = "F:SharpDX.Result.False"/></strong> otherwise.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>ended</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh448002</doc-id>
            <unmanaged>BOOL IMFMediaEngine::IsEnded()</unmanaged>
            <unmanaged-short>IMFMediaEngine::IsEnded</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.GetAutoPlay">
            <summary>
            <p>Queries whether the Media Engine automatically begins playback.</p>
            </summary>
            <returns><p>Returns <strong>TRUE</strong> if the Media Engine automatically begins playback, or <strong><see cref = "F:SharpDX.Result.False"/></strong> otherwise.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>autoplay</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>If this method returns <strong>TRUE</strong>, playback begins automatically after the <strong>IMFMediaEngine::Load</strong> method completes. Otherwise, playback begins when the application calls <strong>IMFMediaEngine::Play</strong>.</p>
            </remarks>
            <doc-id>hh447979</doc-id>
            <unmanaged>BOOL IMFMediaEngine::GetAutoPlay()</unmanaged>
            <unmanaged-short>IMFMediaEngine::GetAutoPlay</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.SetAutoPlay(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Specifies whether the Media Engine automatically begins playback.</p>
            </summary>
            <param name = "autoPlay"><dd> <p>If <strong>TRUE</strong>, the Media Engine automatically begins playback after it loads a media source. Otherwise, playback does not begin until the application calls <strong>IMFMediaEngine::Play</strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method corresponds to setting the <strong>autoplay</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh448009</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::SetAutoPlay([In] BOOL AutoPlay)</unmanaged>
            <unmanaged-short>IMFMediaEngine::SetAutoPlay</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.GetLoop">
            <summary>
            <p>Queries whether the Media Engine will loop playback.</p>
            </summary>
            <returns><p>Returns <strong>TRUE</strong> if looping is enabled, or <strong><see cref = "F:SharpDX.Result.False"/></strong> otherwise.</p></returns>
            <remarks>
            <p>This method corresponds to getting the <strong>loop</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>If looping is enabled, the Media Engine seeks to the start of the content when playback reaches the end.</p>
            </remarks>
            <doc-id>hh447986</doc-id>
            <unmanaged>BOOL IMFMediaEngine::GetLoop()</unmanaged>
            <unmanaged-short>IMFMediaEngine::GetLoop</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.SetLoop(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Specifies whether the Media Engine loops playback.</p>
            </summary>
            <param name = "loop"><dd> <p>Specify <strong>TRUE</strong> to enable looping, or <strong><see cref = "F:SharpDX.Result.False"/></strong> to disable looping.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If <em>Loop</em> is <strong>TRUE</strong>, playback loops back to the beginning when it reaches the end of the source.</p><p>This method corresponds to setting the <strong>loop</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </remarks>
            <doc-id>hh448013</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::SetLoop([In] BOOL Loop)</unmanaged>
            <unmanaged-short>IMFMediaEngine::SetLoop</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.Play">
            <summary>
            <p>Starts playback.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>play</strong> method of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>The method completes asynchronously. When the operation starts, the Media Engine sends an <strong>MF_MEDIA_ENGINE_EVENT_PLAY</strong> event. When playback is under way, the Media Engine sends an <strong>MF_MEDIA_ENGINE_EVENT_PLAYING</strong> event. See <strong>IMFMediaEventNotify::EventNotify</strong>.</p>
            </remarks>
            <doc-id>hh448008</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::Play()</unmanaged>
            <unmanaged-short>IMFMediaEngine::Play</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.Pause">
            <summary>
            <p>Pauses playback.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>pause</strong> method of the <strong>HTMLMediaElement</strong> interface in HTML5.</p><p>The method completes asynchronously. When the transition to paused is complete, the Media Engine sends an <strong>MF_MEDIA_ENGINE_EVENT_PAUSE                </strong> event. See <strong>IMFMediaEventNotify::EventNotify</strong>.</p>
            </remarks>
            <doc-id>hh448007</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::Pause()</unmanaged>
            <unmanaged-short>IMFMediaEngine::Pause</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.GetMuted">
            <summary>
            <p>Queries whether the audio is muted. </p>
            </summary>
            <returns><p>Returns <strong>TRUE</strong> if the audio is muted, or <strong><see cref = "F:SharpDX.Result.False"/></strong> otherwise.</p></returns>
            <doc-id>hh447987</doc-id>
            <unmanaged>BOOL IMFMediaEngine::GetMuted()</unmanaged>
            <unmanaged-short>IMFMediaEngine::GetMuted</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.SetMuted(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Mutes or unmutes the audio. </p>
            </summary>
            <param name = "muted"><dd> <p>Specify <strong>TRUE</strong> to mute the audio, or <strong><see cref = "F:SharpDX.Result.False"/></strong> to unmute the audio. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh448014</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::SetMuted([In] BOOL Muted)</unmanaged>
            <unmanaged-short>IMFMediaEngine::SetMuted</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.GetVolume">
            <summary>
            <p>Gets the audio volume level.</p>
            </summary>
            <returns><p>Returns the volume level. Volume is expressed as an attenuation level, where 0.0 indicates silence and 1.0 indicates full volume (no attenuation).</p></returns>
            <doc-id>hh447997</doc-id>
            <unmanaged>double IMFMediaEngine::GetVolume()</unmanaged>
            <unmanaged-short>IMFMediaEngine::GetVolume</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.SetVolume(System.Double)">
            <summary>
            <p>Sets the audio volume level.</p>
            </summary>
            <param name = "volume"><dd> <p>The volume level. Volume is expressed as an attenuation level, where 0.0 indicates silence and 1.0 indicates full volume (no attenuation). </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>When the audio balance changes, the Media Engine sends an <strong>MF_MEDIA_ENGINE_EVENT_VOLUMECHANGE</strong> event. See <strong>IMFMediaEventNotify::EventNotify</strong>.</p>
            </remarks>
            <doc-id>hh448019</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::SetVolume([In] double Volume)</unmanaged>
            <unmanaged-short>IMFMediaEngine::SetVolume</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.HasVideo">
            <summary>
            <p>Queries whether the current media resource contains a video stream.</p>
            </summary>
            <returns><p>Returns <strong>TRUE</strong> if the current media resource contains a video stream. Returns <strong><see cref = "F:SharpDX.Result.False"/></strong> if there is no media resource or the media resource does not contain a video stream.</p></returns>
            <doc-id>hh448001</doc-id>
            <unmanaged>BOOL IMFMediaEngine::HasVideo()</unmanaged>
            <unmanaged-short>IMFMediaEngine::HasVideo</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.HasAudio">
            <summary>
            <p>Queries whether the current media resource contains an audio stream.</p>
            </summary>
            <returns><p>Returns <strong>TRUE</strong> if the current media resource contains an audio stream. Returns <strong><see cref = "F:SharpDX.Result.False"/></strong> if there is no media resource or the media resource does not contain an audio stream.</p></returns>
            <doc-id>hh447998</doc-id>
            <unmanaged>BOOL IMFMediaEngine::HasAudio()</unmanaged>
            <unmanaged-short>IMFMediaEngine::HasAudio</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.GetNativeVideoSize(System.Int32@,System.Int32@)">
            <summary>
            <p>Gets the size of the video frame, adjusted for aspect ratio.</p>
            </summary>
            <param name = "cx"><dd> <p>Receives the width in pixels.</p> </dd></param>
            <param name = "cy"><dd> <p>Receives the height in pixels.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method adjusts for the correct picture aspect ratio.
            For example, if the encoded frame is 720 ? 420 and the picture aspect ratio is 4:3, the method will return a size equal to 640 ? 480 pixels.</p>
            </remarks>
            <doc-id>hh447988</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::GetNativeVideoSize([Out, Optional] DWORD* cx,[Out, Optional] DWORD* cy)</unmanaged>
            <unmanaged-short>IMFMediaEngine::GetNativeVideoSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.GetVideoAspectRatio(System.Int32@,System.Int32@)">
            <summary>
            <p>Gets the picture aspect ratio of the video stream.</p>
            </summary>
            <param name = "cx"><dd> <p>Receives the x component of the aspect ratio.</p> </dd></param>
            <param name = "cy"><dd> <p>Receives the y component of the aspect ratio.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The Media Engine automatically converts the pixel aspect ratio to 1:1 (square pixels).</p>
            </remarks>
            <doc-id>hh447996</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::GetVideoAspectRatio([Out, Optional] DWORD* cx,[Out, Optional] DWORD* cy)</unmanaged>
            <unmanaged-short>IMFMediaEngine::GetVideoAspectRatio</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.Shutdown">
            <summary>
            <p>Shuts down the Media Engine and releases the resources it is using. </p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh448020</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::Shutdown()</unmanaged>
            <unmanaged-short>IMFMediaEngine::Shutdown</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.TransferVideoFrame(SharpDX.IUnknown,System.Nullable{SharpDX.MediaFoundation.VideoNormalizedRect},SharpDX.Mathematics.Interop.RawRectangle,System.Nullable{SharpDX.Mathematics.Interop.RawColorBGRA})">
            <summary>
            <p>Copies the current video frame to a DXGI surface or WIC bitmap.</p>
            </summary>
            <param name = "dstSurfRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of the destination surface. </p> </dd></param>
            <param name = "srcRef"><dd> <p>A reference to an <strong><see cref = "T:SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure that specifies the source rectangle.</p> </dd></param>
            <param name = "dstRef"><dd> <p>A reference to a <strong><see cref = "T:SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that specifies the destination rectangle.</p> </dd></param>
            <param name = "borderClrRef"><dd> <p>A reference to an <strong><see cref = "T:SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> structure that specifies the border color. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>In frame-server mode, call this method to blit the video frame to a DXGI or WIC surface. The application can call this method at any time after the Media Engine loads a video resource. Typically, however, the application calls <strong>IMFMediaEngine::OnVideoStreamTick</strong> first, to determine whether a new frame is available. If <strong>OnVideoStreamTick</strong> returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>, the application then calls <strong>TransferVideoFrame</strong>.</p><p>The Media Engine scales and letterboxes the video to fit the destination rectangle. It fills the letterbox area with the border color.</p><p>For protected content, call the <strong>IMFMediaEngineProtectedContent::TransferVideoFrame</strong> method instead of this method.</p>
            </remarks>
            <doc-id>hh448021</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::TransferVideoFrame([In] IUnknown* pDstSurf,[In, Optional] const MFVideoNormalizedRect* pSrc,[In] const RECT* pDst,[In, Optional] const MFARGB* pBorderClr)</unmanaged>
            <unmanaged-short>IMFMediaEngine::TransferVideoFrame</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngine.OnVideoStreamTick_(System.Int64@)">
            <summary>
            <p>Queries the Media Engine to find out whether a new video frame is ready.</p>
            </summary>
            <param name = "ptsRef"><dd> <p>If a new frame is ready, receives the presentation time of the frame.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p>The method succeeded, but the Media Engine does not have a new frame.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>A new video frame is ready for display.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>In frame-server mode, the application should call this method whenever a vertical blank occurs in the display device. If the method returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>, call <strong>IMFMediaEngine::TransferVideoFrame</strong> to blit the frame to the render target. If the method returns <strong>S_FALSE</strong>, wait for the next vertical blank and call the method again.</p><p>Do not call this method in rendering mode or audio-only mode. </p>
            </remarks>
            <doc-id>hh448006</doc-id>
            <unmanaged>HRESULT IMFMediaEngine::OnVideoStreamTick([Out] longlong* pPts)</unmanaged>
            <unmanaged-short>IMFMediaEngine::OnVideoStreamTick</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaEngineAttributes">
            <summary>
            Attributes used when instantiating <see cref="T:SharpDX.MediaFoundation.MediaEngine"/> class.
            </summary>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineAttributes.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.MediaFoundation.MediaEngineAttributes"/> class.
            </summary>
            <param name="nativePtr">A native COM pointer to a MediaEngineAttributes</param>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineAttributes.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.MediaFoundation.MediaEngineAttributes"/> class.
            </summary>
            <param name="initialSizeInBytes">Size of the data to allocate</param>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineClassFactory.ClsidMFMediaEngineClassFactory">
            <summary>Constant ClsidMFMediaEngineClassFactory</summary>
            <unmanaged>CLSID_MFMediaEngineClassFactory</unmanaged>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineClassFactory.CreateInstance(SharpDX.MediaFoundation.MediaEngineCreateFlags,SharpDX.MediaFoundation.MediaAttributes,SharpDX.MediaFoundation.MediaEngine)">
            <summary>
            <p>Creates a new instance of the Media Engine.</p>
            </summary>
            <param name = "flags"><dd> <p>A bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineCreateFlags"/></strong> enumeration.</p> </dd></param>
            <param name = "attrRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of an attribute store. </p> <p>This parameter  specifies configuration attributes for the Media Engine. Call <strong>MFCreateAttributes</strong> to create the attribute store. Then, set one or more attributes from the list of Media Engine Attributes. For details, see Remarks.</p> </dd></param>
            <param name = "playerOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngine"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Attributenotfound"/></strong></dt> </dl> </td><td> <p>A required attribute was missing from <em>pAttr</em>, or an invalid combination of attributes was used.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Before calling this method, call <strong>MFStartup</strong>.</p><p>The Media Engine supports three distinct modes:</p><table> <tr><th>Mode</th><th>Description</th></tr> <tr><td>Frame-server mode</td><td> <p>In this mode, the Media Engine delivers uncompressed video frames to the application. The application is responsible for displaying each frame, using Microsoft Direct3D or any other rendering technique. </p> <p>The Media Engine renders the audio; the application is not responsible for audio rendering.</p> <p>Frame-server mode is the default mode. </p> </td></tr> <tr><td>Rendering mode</td><td> <p>In this mode, the Media Engine renders both audio and video. The video is rendered to a window or Microsoft DirectComposition visual provided by the application.</p> <p>To enable rendering mode, set either the <see cref = "!:PlaybackHwnd"/> attribute or the  <see cref = "!:PlaybackVisual"/> attribute.</p> </td></tr> <tr><td>Audio  mode</td><td> <p>In this mode, the Media Engine renders audio only, with no video.</p> <p>To enable audio mode, set the <strong>MF_MEDIA_ENGINE_AUDIOONLY</strong> flag in the <em>dwFlags</em> parameter.</p> </td></tr> </table><p>?</p>
            </remarks>
            <doc-id>hh447921</doc-id>
            <unmanaged>HRESULT IMFMediaEngineClassFactory::CreateInstance([In] DWORD dwFlags,[In] IMFAttributes* pAttr,[Out, Fast] IMFMediaEngine** ppPlayer)</unmanaged>
            <unmanaged-short>IMFMediaEngineClassFactory::CreateInstance</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineClassFactory.CreateTimeRange(SharpDX.MediaFoundation.MediaTimeRange)">
            <summary>
            <p>Creates a time range object.</p>
            </summary>
            <param name = "timeRangeOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaTimeRange"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447922</doc-id>
            <unmanaged>HRESULT IMFMediaEngineClassFactory::CreateTimeRange([Out, Fast] IMFMediaTimeRange** ppTimeRange)</unmanaged>
            <unmanaged-short>IMFMediaEngineClassFactory::CreateTimeRange</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineClassFactory.CreateError(SharpDX.MediaFoundation.MediaError)">
            <summary>
            <p>Creates a media error object.</p>
            </summary>
            <param name = "errorOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaError"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447920</doc-id>
            <unmanaged>HRESULT IMFMediaEngineClassFactory::CreateError([Out, Fast] IMFMediaError** ppError)</unmanaged>
            <unmanaged-short>IMFMediaEngineClassFactory::CreateError</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.SetSourceFromByteStream(SharpDX.MediaFoundation.ByteStream,System.String)">
            <summary>	
            <p>[This documentation is preliminary and is subject to change.]</p><p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Opens a media resource from a byte stream.</p>	
            </summary>	
            <param name="byteStream"><dd> <p>A reference to the <strong><see cref="T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of the byte stream.</p> </dd></param>	
            <param name="url"><dd> <p>The URL of the byte stream.</p> </dd></param>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result"/></strong> error code.</p></returns>	
            <msdn-id>hh447956</msdn-id>	
            <unmanaged>HRESULT IMFMediaEngineEx::SetSourceFromByteStream([In] IMFByteStream* pByteStream,[In] wchar_t* pURL)</unmanaged>	
            <unmanaged-short>IMFMediaEngineEx::SetSourceFromByteStream</unmanaged-short>	
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngineEx.Balance">
            <summary>
            <p>Gets or sets the audio balance. </p>
            </summary>
            <doc-id>hh447934</doc-id>
            <unmanaged>GetBalance / SetBalance</unmanaged>
            <unmanaged-short>GetBalance</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngineEx.ResourceCharacteristics">
            <summary>
            <p>Gets various flags that describe the media resource.</p>
            </summary>
            <doc-id>hh447939</doc-id>
            <unmanaged>GetResourceCharacteristics</unmanaged>
            <unmanaged-short>GetResourceCharacteristics</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngineEx.NumberOfStreams">
            <summary>
            <p>Gets the number of streams in the media resource.</p>
            </summary>
            <doc-id>hh447937</doc-id>
            <unmanaged>GetNumberOfStreams</unmanaged>
            <unmanaged-short>GetNumberOfStreams</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngineEx.IsProtected">
            <summary>
            <p>Queries whether the media resource contains protected content. </p>
            </summary>
            <doc-id>hh447950</doc-id>
            <unmanaged>IsProtected</unmanaged>
            <unmanaged-short>IsProtected</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngineEx.TimelineMarkerTimer">
            <summary>
            <p>Gets or sets the time of the next timeline marker, if any.</p>
            </summary>
            <doc-id>hh447945</doc-id>
            <unmanaged>GetTimelineMarkerTimer / SetTimelineMarkerTimer</unmanaged>
            <unmanaged-short>GetTimelineMarkerTimer</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngineEx.IsStereo3D">
            <summary>
            <p>Queries whether the media resource contains stereoscopic 3D video.</p>
            </summary>
            <doc-id>hh447951</doc-id>
            <unmanaged>IsStereo3D</unmanaged>
            <unmanaged-short>IsStereo3D</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngineEx.Stereo3DFramePackingMode">
            <summary>
            <p>For stereoscopic 3D video, gets the layout of the two views within a video frame.</p>
            </summary>
            <doc-id>hh447941</doc-id>
            <unmanaged>GetStereo3DFramePackingMode / SetStereo3DFramePackingMode</unmanaged>
            <unmanaged-short>GetStereo3DFramePackingMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngineEx.Stereo3DRenderMode">
            <summary>
            <p>For stereoscopic 3D video, queries how the Media Engine renders the 3D video content.</p>
            </summary>
            <doc-id>hh447942</doc-id>
            <unmanaged>GetStereo3DRenderMode / SetStereo3DRenderMode</unmanaged>
            <unmanaged-short>GetStereo3DRenderMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngineEx.VideoSwapchainHandle">
            <summary>
            <p>Gets a handle to the windowless swap chain.</p>
            </summary>
            <remarks>
            <p>To enable windowless swap-chain mode, call <strong>IMFMediaEngineEx::EnableWindowlessSwapchainMode</strong>.</p>
            </remarks>
            <doc-id>hh447946</doc-id>
            <unmanaged>GetVideoSwapchainHandle</unmanaged>
            <unmanaged-short>GetVideoSwapchainHandle</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngineEx.AudioStreamCategory">
            <summary>
            <p>Gets or sets the audio stream category used for the next call to <strong>SetSource</strong> or <strong>Load</strong>. </p>
            </summary>
            <remarks>
            <p>For information on audio stream categories, see <strong><see cref = "T:SharpDX.Multimedia.AudioStreamCategory"/> enumeration</strong>.</p>
            </remarks>
            <doc-id>jj128310</doc-id>
            <unmanaged>GetAudioStreamCategory / SetAudioStreamCategory</unmanaged>
            <unmanaged-short>GetAudioStreamCategory</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngineEx.AudioEndpointRole">
            <summary>
            <p>Gets or sets the audio device endpoint role used for the next  call to <strong>SetSource</strong> or <strong>Load</strong>. </p>
            </summary>
            <remarks>
            <p>For information on audio endpoint roles, see <strong>ERole  enumeration</strong>.</p>
            </remarks>
            <doc-id>jj128309</doc-id>
            <unmanaged>GetAudioEndpointRole / SetAudioEndpointRole</unmanaged>
            <unmanaged-short>GetAudioEndpointRole</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngineEx.RealTimeMode">
            <summary>
            <p>Gets or sets the real time mode used for the next call to <strong>SetSource</strong> or <strong>Load</strong>. </p>
            </summary>
            <doc-id>jj128311</doc-id>
            <unmanaged>GetRealTimeMode / SetRealTimeMode</unmanaged>
            <unmanaged-short>GetRealTimeMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.SetSourceFromByteStream(SharpDX.MediaFoundation.IByteStream,System.IntPtr)">
            <summary>
            <p>Opens a media resource from a byte stream.</p>
            </summary>
            <param name = "byteStreamRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of the byte stream.</p> </dd></param>
            <param name = "uRLRef"><dd> <p>The URL of the byte stream.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447956</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::SetSourceFromByteStream([In] IMFByteStream* pByteStream,[In] wchar_t* pURL)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::SetSourceFromByteStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.GetStatistics(SharpDX.MediaFoundation.MediaEngineStatistic,SharpDX.Win32.Variant@)">
            <summary>
            <p>Gets a playback statistic from the Media Engine.</p>
            </summary>
            <param name = "statisticID"><dd> <p>A member of the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineStatistic"/></strong> enumeration that identifies the statistic to get.</p> </dd></param>
            <param name = "statisticRef"><dd> <p>A reference to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that receives the statistic. The data type and meaning of this value depends on the value of <em>StatisticID</em>. The caller must free the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> by calling <strong>PropVariantClear</strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447940</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::GetStatistics([In] MF_MEDIA_ENGINE_STATISTIC StatisticID,[Out] PROPVARIANT* pStatistic)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::GetStatistics</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.UpdateVideoStream(System.Nullable{SharpDX.MediaFoundation.VideoNormalizedRect},System.Nullable{SharpDX.Mathematics.Interop.RawRectangle},System.Nullable{SharpDX.Mathematics.Interop.RawColorBGRA})">
            <summary>
            <p>Updates the source rectangle, destination rectangle, and border color for the video.</p>
            </summary>
            <param name = "srcRef"><dd> <p>A reference to an <strong><see cref = "T:SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure that specifies the source rectangle. The source rectangle defines the area of the video frame that is displayed. If this parameter is <strong><c>null</c></strong>, the entire video frame is displayed.</p> </dd></param>
            <param name = "dstRef"><dd> <p>A reference to a <strong><see cref = "T:SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that specifies the destination rectangle. The destination rectangle defines the area of the window or DirectComposition visual where the video is drawn.</p> </dd></param>
            <param name = "borderClrRef"><dd> <p>A reference to an <strong><see cref = "T:SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> structure that specifies the border color. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>In rendering mode, call this method to reposition the video, update the border color, or repaint the video frame. If all of the parameters are <strong><c>null</c></strong>, the method repaints the most recent video frame.</p><p>In frame-server mode, this method has no effect.</p><p>See <strong>Video Processor MFT</strong> for info regarding source and destination rectangles in the <strong>Video Processor MFT</strong>.   </p>
            </remarks>
            <doc-id>hh447961</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::UpdateVideoStream([In, Optional] const MFVideoNormalizedRect* pSrc,[In, Optional] const RECT* pDst,[In, Optional] const MFARGB* pBorderClr)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::UpdateVideoStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.GetBalance">
            <summary>
            <p>Gets the audio balance. </p>
            </summary>
            <returns><p>Returns the balance. The value can be any number in the following range (inclusive). </p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt>-1</dt> </dl> </td><td> <p>The left channel is at full volume; the right channel is silent.</p> </td></tr> <tr><td> <dl> <dt>1</dt> </dl> </td><td> <p>The right channel is at full volume; the left channel is silent.</p> </td></tr> </table><p>?</p><p>If the value is zero, the left and right channels are at equal volumes. The default value is zero. </p></returns>
            <doc-id>hh447934</doc-id>
            <unmanaged>double IMFMediaEngineEx::GetBalance()</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::GetBalance</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.SetBalance(System.Double)">
            <summary>
            <p>Sets the audio balance.</p>
            </summary>
            <param name = "balance"><dd> <p>The audio balance. The value can be any number in the following range (inclusive). </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>-1</dt> </dl> </td><td> <p>The left channel is at full volume; the right channel is silent.</p> </td></tr> <tr><td> <dl> <dt>1</dt> </dl> </td><td> <p>The right channel is at full volume; the left channel is silent.</p> </td></tr> </table> <p>?</p> <p>If the value is zero, the left and right channels are at equal volumes. The default value is zero. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>When the audio balance changes, the Media Engine sends an <strong>MF_MEDIA_ENGINE_EVENT_BALANCECHANGE</strong> event. See <strong>IMFMediaEventNotify::EventNotify</strong>.</p>
            </remarks>
            <doc-id>hh447954</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::SetBalance([In] double balance)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::SetBalance</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.IsPlaybackRateSupported(System.Double)">
            <summary>
            <p>Queries whether the Media Engine can play at a specified playback rate.</p>
            </summary>
            <param name = "rate"><dd> <p>The requested playback rate.</p> </dd></param>
            <returns><p>Returns <strong>TRUE</strong> if the playback rate is supported, or <strong><see cref = "F:SharpDX.Result.False"/></strong> otherwise.</p></returns>
            <remarks>
            <p>Playback rates are expressed as a ratio of the current rate to the normal rate. For example, 1.0 is normal playback speed, 0.5 is half speed, and 2.0 is 2? speed. Positive values mean forward playback, and negative values mean reverse playback.</p><p>The results of this method can vary depending on the media resource that is currently loaded. Some media formats might support faster playback rates than others. Also, some formats might not support reverse play.</p>
            </remarks>
            <doc-id>hh447949</doc-id>
            <unmanaged>BOOL IMFMediaEngineEx::IsPlaybackRateSupported([In] double rate)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::IsPlaybackRateSupported</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.FrameStep(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Steps forward or backward one frame.</p>
            </summary>
            <param name = "forward"><dd> <p>Specify <strong>TRUE</strong> to step forward or <strong><see cref = "F:SharpDX.Result.False"/></strong> to step backward.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The frame-step direction is independent of the current playback direction.</p><p>This method completes asynchronously. When the operation completes, the Media Engine sends an <strong>MF_MEDIA_ENGINE_EVENT_FRAMESTEPCOMPLETED</strong> event and enters the paused state.</p>
            </remarks>
            <doc-id>hh447933</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::FrameStep([In] BOOL Forward)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::FrameStep</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.GetResourceCharacteristics(SharpDX.MediaFoundation.ResourceCharacteristics@)">
            <summary>
            <p>Gets various flags that describe the media resource.</p>
            </summary>
            <param name = "characteristicsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSourceCharacteristics"/> enumeration</strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447939</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::GetResourceCharacteristics([Out] DWORD* pCharacteristics)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::GetResourceCharacteristics</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.GetPresentationAttribute(System.Guid,SharpDX.Win32.Variant@)">
            <summary>
            <p>Gets a presentation attribute from the media resource.</p>
            </summary>
            <param name = "guidMFAttribute"><dd> <p>The attribute to query. For a list of presentation attributes, see Presentation Descriptor Attributes.</p> </dd></param>
            <param name = "vValueRef"><dd> <p>A reference to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that receives the value. The method fills the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> with a copy of the stored value. The caller must free the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> by calling <strong>PropVariantClear</strong>. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447938</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::GetPresentationAttribute([In] const GUID&amp; guidMFAttribute,[Out] PROPVARIANT* pvValue)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::GetPresentationAttribute</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.GetNumberOfStreams(System.Int32@)">
            <summary>
            <p>Gets the number of streams in the media resource.</p>
            </summary>
            <param name = "dwStreamCountRef"><dd> <p>Receives the number of streams.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447937</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::GetNumberOfStreams([Out] DWORD* pdwStreamCount)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::GetNumberOfStreams</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.GetStreamAttribute(System.Int32,System.Guid,SharpDX.Win32.Variant@)">
            <summary>
            <p>Gets a stream-level attribute from the media resource.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The zero-based index of the stream. To get the number of streams, call <strong>IMFMediaEngineEx::GetNumberOfStreams</strong>.</p> </dd></param>
            <param name = "guidMFAttribute"><dd> <p>The attribute to query. Possible values are listed in the following topics:</p> <ul> <li> Stream Descriptor Attributes </li> <li> Media Type Attributes </li> </ul> </dd></param>
            <param name = "vValueRef"><dd> <p>A reference to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that receives the value. The method fills the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> with a copy of the stored value. Call <strong>PropVariantClear</strong> to free the memory allocated by the method. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447943</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::GetStreamAttribute([In] DWORD dwStreamIndex,[In] const GUID&amp; guidMFAttribute,[Out] PROPVARIANT* pvValue)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::GetStreamAttribute</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.GetStreamSelection(System.Int32,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Queries whether a stream is selected to play.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The zero-based index of the stream. To get the number of streams, call <strong>IMFMediaEngineEx::GetNumberOfStreams</strong>.</p> </dd></param>
            <param name = "enabledRef"><dd> <p>Receives a Boolean value.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong>TRUE</strong></strong></dt> </dl> </td><td> <p>The stream is selected. During playback, this stream will play.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref = "F:SharpDX.Result.False"/></strong></strong></dt> </dl> </td><td> <p>The stream is not selected. During playback, this stream will not play.</p> </td></tr> </table> <p>?</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447944</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::GetStreamSelection([In] DWORD dwStreamIndex,[Out] BOOL* pEnabled)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::GetStreamSelection</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.SetStreamSelection(System.Int32,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Selects or deselects a stream for playback. </p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The zero-based index of the stream. To get the number of streams, call <strong>IMFMediaEngineEx::GetNumberOfStreams</strong>.</p> </dd></param>
            <param name = "enabled"><dd> <p>Specifies whether to select or deselect the stream.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong>TRUE</strong></strong></dt> </dl> </td><td> <p>The stream is selected. During playback, this stream will play.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref = "F:SharpDX.Result.False"/></strong></strong></dt> </dl> </td><td> <p>The stream is not selected. During playback, this stream will not play.</p> </td></tr> </table> <p>?</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447959</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::SetStreamSelection([In] DWORD dwStreamIndex,[In] BOOL Enabled)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::SetStreamSelection</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.ApplyStreamSelections">
            <summary>
            <p>Applies the stream selections from previous calls to <strong>SetStreamSelection</strong>.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>jj151917</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::ApplyStreamSelections()</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::ApplyStreamSelections</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.IsProtected_(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Queries whether the media resource contains protected content. </p>
            </summary>
            <param name = "protectedRef"><dd> <p>Receives the value <strong>TRUE</strong> if the media resource contains protected content, or <strong><see cref = "F:SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447950</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::IsProtected([Out] BOOL* pProtected)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::IsProtected</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.InsertVideoEffect(SharpDX.IUnknown,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Inserts a video effect.</p>
            </summary>
            <param name = "effectRef"><dd> <p>One of the following: </p> <ul> <li>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> interface of a Media Foundation transform (MFT) that implements the video effect.</li> <li>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface of an activation object. The activation object must create an MFT for the video effect.</li> </ul> </dd></param>
            <param name = "fOptional"><dd> <p>Specifies whether the effect is optional.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong>TRUE</strong></strong></dt> </dl> </td><td> <p>The effect is optional. If the Media Engine cannot add the effect, it ignores the effect and  continues playback.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref = "F:SharpDX.Result.False"/></strong></strong></dt> </dl> </td><td> <p>The effect is required. If the Media Engine object cannot add the effect, a playback error occurs.</p> </td></tr> </table> <p>?</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The maximum number of video effects was reached.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The effect is applied when the next media resource is loaded.</p>
            </remarks>
            <doc-id>hh447948</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::InsertVideoEffect([In] IUnknown* pEffect,[In] BOOL fOptional)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::InsertVideoEffect</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.InsertAudioEffect(SharpDX.IUnknown,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Inserts an audio effect.</p>
            </summary>
            <param name = "effectRef"><dd> <p>One of the following: </p> <ul> <li>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> interface of a Media Foundation transform (MFT) that implements the audio effect.</li> <li>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface of an activation object. The activation object must create an MFT for the audio effect.</li> </ul> </dd></param>
            <param name = "fOptional"><dd> <p>Specifies whether the effect is optional.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong>TRUE</strong></strong></dt> </dl> </td><td> <p>The effect is optional. If the Media Engine cannot add the effect, it ignores the effect and  continues playback.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref = "F:SharpDX.Result.False"/></strong></strong></dt> </dl> </td><td> <p>The effect is required. If the Media Engine object cannot add the effect, a playback error occurs.</p> </td></tr> </table> <p>?</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The maximum number of audio effects was reached.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The effect is applied when the next media resource is loaded.</p>
            </remarks>
            <doc-id>hh447947</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::InsertAudioEffect([In] IUnknown* pEffect,[In] BOOL fOptional)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::InsertAudioEffect</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.RemoveAllEffects">
            <summary>
            <p>Removes all audio and video effects.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> Call this method to remove all of the effects that were added with the <strong>InsertAudioEffect</strong> and <strong>InsertVideoEffect</strong> methods. </p>
            </remarks>
            <doc-id>hh447952</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::RemoveAllEffects()</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::RemoveAllEffects</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.SetTimelineMarkerTimer(System.Double)">
            <summary>
            <p>Specifies a presentation time when the Media Engine will send a marker event.</p>
            </summary>
            <param name = "timeToFire"><dd> <p>The presentation time for the marker event, in seconds.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>When playback reaches the time specified by <em>timeToFire</em>, the Media Engine sends an <strong>MF_MEDIA_ENGINE_EVENT_TIMELINE_MARKER</strong> event through the <strong>IMFMediaEngineNotify::EventNotify</strong> method. Calling this method cancels any previous marker that is still pending. </p><p>If the application seeks past the marker point, the Media Engine cancels the marker and does not send the event.</p><p>During  forward playback, set <em>timeToFire</em> to a value greater than the current playback position. During reverse playback, set <em>timeToFire</em> to a value less than the playback position.</p><p>To cancel a marker, call <strong>IMFMediaEngineEx::CancelTimelineMarkerTimer</strong>.</p>
            </remarks>
            <doc-id>hh447960</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::SetTimelineMarkerTimer([In] double timeToFire)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::SetTimelineMarkerTimer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.GetTimelineMarkerTimer(System.Double@)">
            <summary>
            <p>Gets the time of the next timeline marker, if any.</p>
            </summary>
            <param name = "timeToFireRef"><dd> <p>Receives the marker time, in seconds. If no marker is set, this parameter receives the value <strong>NaN</strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447945</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::GetTimelineMarkerTimer([Out] double* pTimeToFire)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::GetTimelineMarkerTimer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.CancelTimelineMarkerTimer">
            <summary>
            <p>Cancels the next pending timeline marker.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Call this method to cancel the <strong>IMFMediaEngineEx::SetTimelineMarkerTimer</strong> method.</p>
            </remarks>
            <doc-id>hh447929</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::CancelTimelineMarkerTimer()</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::CancelTimelineMarkerTimer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.IsStereo3D_">
            <summary>
            <p>Queries whether the media resource contains stereoscopic 3D video.</p>
            </summary>
            <returns><p>Returns <strong>TRUE</strong> if the media resource contains 3D video, or <strong><see cref = "F:SharpDX.Result.False"/></strong> otherwise.</p></returns>
            <doc-id>hh447951</doc-id>
            <unmanaged>BOOL IMFMediaEngineEx::IsStereo3D()</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::IsStereo3D</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.GetStereo3DFramePackingMode(SharpDX.MediaFoundation.MediaEngineS3DPackingMode@)">
            <summary>
            <p>For stereoscopic 3D video, gets the layout of the two views within a video frame.</p>
            </summary>
            <param name = "ackModeRef"><dd> <p>Receives a member of the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineS3DPackingMode"/></strong> enumeration.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447941</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::GetStereo3DFramePackingMode([Out] MF_MEDIA_ENGINE_S3D_PACKING_MODE* packMode)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::GetStereo3DFramePackingMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.SetStereo3DFramePackingMode(SharpDX.MediaFoundation.MediaEngineS3DPackingMode)">
            <summary>
            <p>For stereoscopic 3D video, sets the layout of the two views within a video frame.</p>
            </summary>
            <param name = "packMode"><dd> <p>A member of the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineS3DPackingMode"/></strong> enumeration that specifies the layout. The two views can be arranged side-by-side, or top-to-bottom.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447957</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::SetStereo3DFramePackingMode([In] MF_MEDIA_ENGINE_S3D_PACKING_MODE packMode)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::SetStereo3DFramePackingMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.GetStereo3DRenderMode(SharpDX.MediaFoundation.Video3DOutputType@)">
            <summary>
            <p>For stereoscopic 3D video, queries how the Media Engine renders the 3D video content.</p>
            </summary>
            <param name = "outputType"><dd> <p>Receives a member of the <strong><see cref = "T:SharpDX.MediaFoundation.Video3DOutputType"/></strong> enumeration.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447942</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::GetStereo3DRenderMode([Out] MF3DVideoOutputType* outputType)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::GetStereo3DRenderMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.SetStereo3DRenderMode(SharpDX.MediaFoundation.Video3DOutputType)">
            <summary>
            <p>For stereoscopic 3D video, specifies how the Media Engine renders the 3D video content.</p>
            </summary>
            <param name = "outputType"><dd> <p>A member of the <strong><see cref = "T:SharpDX.MediaFoundation.Video3DOutputType"/></strong> enumeration that specifies the 3D video rendering mode.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447958</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::SetStereo3DRenderMode([In] MF3DVideoOutputType outputType)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::SetStereo3DRenderMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.EnableWindowlessSwapchainMode(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Enables or disables windowless swap-chain mode.</p>
            </summary>
            <param name = "fEnable"><dd> <p>If <strong>TRUE</strong>, windowless swap-chain mode is enabled. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>In windowless swap-chain mode, the Media Engine creates a windowless swap chain and presents video frames to the swap chain. To render the video, call <strong>IMFMediaEngineEx::GetVideoSwapchainHandle</strong> to get a handle to the swap chain, and then associate the handle with a Microsoft DirectComposition visual.  </p>
            </remarks>
            <doc-id>hh447932</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::EnableWindowlessSwapchainMode([In] BOOL fEnable)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::EnableWindowlessSwapchainMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.GetVideoSwapchainHandle(System.IntPtr@)">
            <summary>
            <p>Gets a handle to the windowless swap chain.</p>
            </summary>
            <param name = "hSwapchainRef"><dd> <p>Receives a handle to the swap chain.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>To enable windowless swap-chain mode, call <strong>IMFMediaEngineEx::EnableWindowlessSwapchainMode</strong>.</p>
            </remarks>
            <doc-id>hh447946</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::GetVideoSwapchainHandle([Out] void** phSwapchain)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::GetVideoSwapchainHandle</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.EnableHorizontalMirrorMode(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Enables or disables mirroring of the video.</p>
            </summary>
            <param name = "fEnable"><dd> <p>If <strong>TRUE</strong>, the video is mirrored horizontally. Otherwise, the video is displayed normally.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447931</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::EnableHorizontalMirrorMode([In] BOOL fEnable)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::EnableHorizontalMirrorMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.GetAudioStreamCategory(System.Int32@)">
            <summary>
            <p>Gets the audio stream category used for the next call to <strong>SetSource</strong> or <strong>Load</strong>. </p>
            </summary>
            <param name = "categoryRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>For information on audio stream categories, see <strong><see cref = "T:SharpDX.Multimedia.AudioStreamCategory"/> enumeration</strong>.</p>
            </remarks>
            <doc-id>jj128310</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::GetAudioStreamCategory([Out] unsigned int* pCategory)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::GetAudioStreamCategory</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.SetAudioStreamCategory(System.Int32)">
            <summary>
            <p>Sets the audio stream category for the next call to  <strong>SetSource</strong> or <strong>Load</strong>. </p>
            </summary>
            <param name = "category">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>For information on audio stream categories, see <strong><see cref = "T:SharpDX.Multimedia.AudioStreamCategory"/> enumeration</strong>.</p>
            </remarks>
            <doc-id>jj128313</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::SetAudioStreamCategory([In] unsigned int category)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::SetAudioStreamCategory</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.GetAudioEndpointRole(System.Int32@)">
            <summary>
            <p>Gets the audio device endpoint role used for the next  call to <strong>SetSource</strong> or <strong>Load</strong>. </p>
            </summary>
            <param name = "roleRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>For information on audio endpoint roles, see <strong>ERole  enumeration</strong>.</p>
            </remarks>
            <doc-id>jj128309</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::GetAudioEndpointRole([Out] unsigned int* pRole)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::GetAudioEndpointRole</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.SetAudioEndpointRole(System.Int32)">
            <summary>
            <p>Sets the audio device endpoint used for the next call to <strong>SetSource</strong> or <strong>Load</strong>. </p>
            </summary>
            <param name = "role">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>For information on audio endpoint roles, see <strong>ERole  enumeration</strong>.</p>
            </remarks>
            <doc-id>jj128312</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::SetAudioEndpointRole([In] unsigned int role)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::SetAudioEndpointRole</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.GetRealTimeMode(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Gets the real time mode used for the next call to <strong>SetSource</strong> or <strong>Load</strong>. </p>
            </summary>
            <param name = "fEnabledRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>jj128311</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::GetRealTimeMode([Out] BOOL* pfEnabled)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::GetRealTimeMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.SetRealTimeMode(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Sets the real time mode used for the next call to  <strong>SetSource</strong> or <strong>Load</strong>. </p>
            </summary>
            <param name = "fEnable">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>jj128315</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::SetRealTimeMode([In] BOOL fEnable)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::SetRealTimeMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.SetCurrentTimeEx(System.Double,SharpDX.MediaFoundation.MediaEngineSeekMode)">
            <summary>
            <p>Seeks to a new playback position using the  specified <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineSeekMode"/></strong>.</p>
            </summary>
            <param name = "seekTime">No documentation.</param>
            <param name = "seekMode">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>jj128314</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::SetCurrentTimeEx([In] double seekTime,[In] MF_MEDIA_ENGINE_SEEK_MODE seekMode)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::SetCurrentTimeEx</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEx.EnableTimeUpdateTimer(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Enables or disables the time update timer.</p>
            </summary>
            <param name = "fEnableTimer"><dd> <p>If <strong>TRUE</strong>, the update timer is enabled. Otherwise, the timer is disabled.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>jj128308</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEx::EnableTimeUpdateTimer([In] BOOL fEnableTimer)</unmanaged>
            <unmanaged-short>IMFMediaEngineEx::EnableTimeUpdateTimer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineNotify.OnPlaybackEvent(SharpDX.MediaFoundation.MediaEngineEvent,System.Int64,System.Int32)">
            <summary>	
            <p>[This documentation is preliminary and is subject to change.]</p><p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Notifies the application when a playback event occurs.</p>	
            </summary>	
            <param name="mediaEngineEvent"><dd> <p>A member of the <strong><see cref="T:SharpDX.MediaFoundation.MediaEngineEvent"/></strong> enumeration that specifies the event.</p> </dd></param>	
            <param name="param1"><dd> <p>The first event parameter. The meaning of this parameter depends on the event code.</p> </dd></param>	
            <param name="param2"><dd> <p>The second event parameter. The meaning of this parameter depends on the event code.</p> </dd></param>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result"/></strong> error code.</p></returns>	
            <msdn-id>hh447963</msdn-id>	
            <unmanaged>HRESULT IMFMediaEngineNotify::EventNotify([In] unsigned int event,[In] ULONG_PTR param1,[In] unsigned int param2)</unmanaged>	
            <unmanaged-short>IMFMediaEngineNotify::EventNotify</unmanaged-short>	
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaEngineNotifyShadow">
            <summary>
            Internal MediaEngineNotify Callback
            </summary>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineNotifyShadow.ToIntPtr(SharpDX.MediaFoundation.MediaEngineNotify)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaEngineNotifyShadow.MediaEngineNotifyVtbl.EventNotifyDelegate">
            <unmanaged>HRESULT IMFMediaEngineNotify::EventNotify([In] unsigned int event,[In] ULONG_PTR param1,[In] unsigned int param2)</unmanaged>	
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEventGenerator.GetEvent(System.Boolean)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> </p><p>Retrieves the next event in the queue. This method is synchronous.</p>	
            </summary>	
            <param name="isBlocking"><c>true</c> if the method blocks until the event generator queues an event, <c>false</c> otherwise.</param>
            <returns>a reference to the <strong><see cref="T:SharpDX.MediaFoundation.MediaEvent"/></strong> interface. The caller must release the interface.</returns>	
            <remarks>	
            <p>This method executes synchronously.</p><p>If the queue already contains an event, the method returns <see cref="F:SharpDX.Result.Ok"/> immediately. If the queue does not contain an event, the behavior depends on the value of <em>dwFlags</em>:</p><ul> <li> <p>If <em>dwFlags</em> is 0, the method blocks indefinitely until a new event is queued, or until the event generator is shut down.</p> </li> <li> <p>If <em>dwFlags</em> is MF_EVENT_FLAG_NO_WAIT, the method fails immediately with the return code <see cref="F:SharpDX.MediaFoundation.ResultCode.NoEventsAvailable"/>.</p> </li> </ul><p>This method returns <see cref="F:SharpDX.MediaFoundation.ResultCode.MultipleSubScribers"/> if you previously called <strong><see cref="!:SharpDX.MediaFoundation.MediaEventGenerator.BeginGetEvent_"/></strong> and have not yet called <strong><see cref="M:SharpDX.MediaFoundation.MediaEventGenerator.EndGetEvent(SharpDX.MediaFoundation.AsyncResult)"/></strong>.</p>	
            </remarks>	
            <msdn-id>ms704754</msdn-id>	
            <unmanaged>HRESULT IMFMediaEventGenerator::GetEvent([In] unsigned int dwFlags,[Out] IMFMediaEvent** ppEvent)</unmanaged>	
            <unmanaged-short>IMFMediaEventGenerator::GetEvent</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEventGenerator.BeginGetEvent(SharpDX.MediaFoundation.IAsyncCallback,System.Object)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> </p><p>Begins an asynchronous request for the next event in the queue.</p>	
            </summary>	
            <param name="callback"><dd> <p>Pointer to the <strong><see cref="T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The client must implement this interface.</p> </dd></param>	
            <param name="stateObject">A reference to a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</param>	
            <remarks>	
            <p>When a new event is available, the event generator calls the <strong><see cref="M:SharpDX.MediaFoundation.IAsyncCallback.Invoke(SharpDX.MediaFoundation.AsyncResult)"/></strong> method. The <strong>Invoke</strong> method should call <strong><see cref="M:SharpDX.MediaFoundation.MediaEventGenerator.EndGetEvent(SharpDX.MediaFoundation.AsyncResult)"/></strong> to get a reference to the <strong><see cref="T:SharpDX.MediaFoundation.MediaEvent"/></strong> interface, and use that interface to examine the event.</p><p>Do not call <strong>BeginGetEvent</strong> a second time before calling <strong>EndGetEvent</strong>. While the first call is still pending, additional calls to the same object will fail. Also, the <strong><see cref="M:SharpDX.MediaFoundation.MediaEventGenerator.GetEvent(System.Boolean)"/></strong> method fails if an asynchronous request is still pending.</p>	
            </remarks>	
            <msdn-id>ms701637</msdn-id>	
            <unmanaged>HRESULT IMFMediaEventGenerator::BeginGetEvent([In] IMFAsyncCallback* pCallback,[In] void* punkState)</unmanaged>	
            <unmanaged-short>IMFMediaEventGenerator::BeginGetEvent</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEventGenerator.GetEvent(System.Int32,SharpDX.MediaFoundation.MediaEvent@)">
            <summary>
            <p> </p><p>Retrieves the next event in the queue. This method is synchronous.</p>
            </summary>
            <param name = "dwFlags"><dd> <p>Specifies one of the following values.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>0</strong></dt> </dl> </td><td> <p>The method blocks until the event generator queues an event.</p> </td></tr> <tr><td><dl> <dt><strong>MF_EVENT_FLAG_NO_WAIT</strong></dt> </dl> </td><td> <p>The method returns immediately.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "eventOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEvent"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><c>null</c> reference argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:MultipleSubScribers"/></strong></dt> </dl> </td><td> <p>There is a pending request.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NoEventsAvailable"/></strong></dt> </dl> </td><td> <p>There are no events in the queue.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The object was shut down.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method executes synchronously.</p><p>If the queue already contains an event, the method returns <see cref = "F:SharpDX.Result.Ok"/> immediately. If the queue does not contain an event, the behavior depends on the value of <em>dwFlags</em>:</p><ul> <li> <p>If <em>dwFlags</em> is 0, the method blocks indefinitely until a new event is queued, or until the event generator is shut down.</p> </li> <li> <p>If <em>dwFlags</em> is MF_EVENT_FLAG_NO_WAIT, the method fails immediately with the return code <see cref = "!:NoEventsAvailable"/>.</p> </li> </ul><p>This method returns <see cref = "!:MultipleSubScribers"/> if you previously called <strong>IMFMediaEventGenerator::BeginGetEvent</strong> and have not yet called <strong>IMFMediaEventGenerator::EndGetEvent</strong>.</p>
            </remarks>
            <doc-id>ms704754</doc-id>
            <unmanaged>HRESULT IMFMediaEventGenerator::GetEvent([In] DWORD dwFlags,[Out] IMFMediaEvent** ppEvent)</unmanaged>
            <unmanaged-short>IMFMediaEventGenerator::GetEvent</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEventGenerator.BeginGetEvent(SharpDX.MediaFoundation.IAsyncCallback,System.IntPtr)">
            <summary>
            <p> </p><p>Begins an asynchronous request for the next event in the queue.</p>
            </summary>
            <param name = "callbackRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The client must implement this interface.</p> </dd></param>
            <param name = "unkStateRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><strong><c>null</c></strong> reference argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:MultipleBegin"/></strong></dt> </dl> </td><td> <p>There is a pending request with the same callback reference and a different state object.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:MultipleSubScribers"/></strong></dt> </dl> </td><td> <p>There is a pending request with a different callback reference.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The object was shut down.</p> </td></tr> <tr><td> <dl> <dt><strong>MF_S_MULTIPLE_BEGIN</strong></dt> </dl> </td><td> <p>There is a pending request with the same callback reference and state object.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>When a new event is available, the event generator calls the <strong>IMFAsyncCallback::Invoke</strong> method. The <strong>Invoke</strong> method should call <strong>IMFMediaEventGenerator::EndGetEvent</strong> to get a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEvent"/></strong> interface, and use that interface to examine the event.</p><p>Do not call <strong>BeginGetEvent</strong> a second time before calling <strong>EndGetEvent</strong>. While the first call is still pending, additional calls to the same object will fail. Also, the <strong>IMFMediaEventGenerator::GetEvent</strong> method fails if an asynchronous request is still pending.</p>
            </remarks>
            <doc-id>ms701637</doc-id>
            <unmanaged>HRESULT IMFMediaEventGenerator::BeginGetEvent([In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>
            <unmanaged-short>IMFMediaEventGenerator::BeginGetEvent</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEventGenerator.EndGetEvent(SharpDX.MediaFoundation.AsyncResult)">
            <summary>
            <p> </p><p>Completes an asynchronous request for the next event in the queue.</p>
            </summary>
            <param name = "resultRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>Invoke</strong> method.</p> </dd></param>
            <returns><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEvent"/></strong> interface. The caller must release the interface.</p> </dd></returns>
            <remarks>
            <p>Call this method from inside your application's <strong>IMFAsyncCallback::Invoke</strong> method. For example code, see <strong>IMFMediaEventGenerator::BeginGetEvent</strong>.</p>
            </remarks>
            <doc-id>ms698866</doc-id>
            <unmanaged>HRESULT IMFMediaEventGenerator::EndGetEvent([In] IMFAsyncResult* pResult,[Out] IMFMediaEvent** ppEvent)</unmanaged>
            <unmanaged-short>IMFMediaEventGenerator::EndGetEvent</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEventGenerator.QueueEvent(System.Int32,System.Guid,SharpDX.Result,System.Nullable{SharpDX.Win32.Variant})">
            <summary>
            <p> </p><p>Puts a new event in the object's queue.</p>
            </summary>
            <param name = "met"><dd> <p>Specifies the event type. The event type is returned by the event's <strong>IMFMediaEvent::GetType</strong> method. For a list of event types, see Media Foundation Events.</p> </dd></param>
            <param name = "guidExtendedType"><dd> <p>The extended type. If the event does not have an extended type, use the value GUID_NULL. The extended type is returned by the event's <strong>IMFMediaEvent::GetExtendedType</strong> method.</p> </dd></param>
            <param name = "hrStatus"><dd> <p>A success or failure code indicating the status of the event. This value is returned by the event's <strong>IMFMediaEvent::GetStatus</strong> method.</p> </dd></param>
            <param name = "vValueRef"><dd> <p>Pointer to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that contains the event value. This parameter can be <strong><c>null</c></strong>. This value is returned by the event's <strong>IMFMediaEvent::GetValue</strong> method.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The object was shut down.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms696255</doc-id>
            <unmanaged>HRESULT IMFMediaEventGenerator::QueueEvent([In] DWORD met,[In] const GUID&amp; guidExtendedType,[In] HRESULT hrStatus,[In, Optional] const PROPVARIANT* pvValue)</unmanaged>
            <unmanaged-short>IMFMediaEventGenerator::QueueEvent</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaManager.Startup(System.Boolean)">
            <summary>
              <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Initializes Microsoft Media Foundation.</p>
            </summary>
            <param name="useLightVersion">If true, do not initialize the sockets library, else full initialization. Default is false</param>
            <msdn-id>ms702238</msdn-id>
            <unmanaged>HRESULT MFStartup([In] unsigned int Version,[In] unsigned int dwFlags)</unmanaged>
            <unmanaged-short>MFStartup</unmanaged-short>
            <remarks>
              <p> An application must call this function before using Media Foundation. Before your application quits, call <strong><see cref="M:SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> once for every previous call to <strong><see cref="M:SharpDX.MediaFoundation.MediaFactory.Startup(System.Int32,System.Int32)"/></strong>. </p><p> Do not call <strong><see cref="M:SharpDX.MediaFoundation.MediaFactory.Startup(System.Int32,System.Int32)"/></strong> or <strong><see cref="M:SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong> from work queue threads. For more information about work queues, see Work Queues. </p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul>
            		<li>Windows?XP with Service Pack?2 (SP2) and later.</li>
            		<li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li>
            	</ul>
            </remarks>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaManager.Shutdown">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Shuts down the Microsoft Media Foundation platform. Call this function once for every call to <strong><see cref="M:SharpDX.MediaFoundation.MediaFactory.Startup(System.Int32,System.Int32)"/></strong>. Do not call this function from work queue threads.</p>	
            </summary>	
            <returns><p>If this function succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result"/></strong> error code.</p></returns>	
            <remarks>	
            <p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <msdn-id>ms694273</msdn-id>	
            <unmanaged>HRESULT MFShutdown()</unmanaged>	
            <unmanaged-short>MFShutdown</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaType.#ctor">
            <summary>	
            Creates an empty media type.	
            </summary>	
            <remarks>	
            <p> The media type is created without any attributes. </p>	
            </remarks>	
            <msdn-id>ms693861</msdn-id>	
            <unmanaged>HRESULT MFCreateMediaType([Out] IMFMediaType** ppMFType)</unmanaged>	
            <unmanaged-short>MFCreateMediaType</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaType.ExtracttWaveFormat(System.Int32@,SharpDX.MediaFoundation.WaveFormatExConvertFlags)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> </p><p>Converts a Media Foundation audio media type to a <strong><see cref="T:SharpDX.Multimedia.WaveFormat"/></strong> structure.</p>	
            </summary>	
            <param name="bufferSize"><dd> <p>Receives the size of the <strong><see cref="T:SharpDX.Multimedia.WaveFormat"/></strong> structure.</p> </dd></param>	
            <param name="flags"><dd> <p>Contains a flag from the <strong><see cref="T:SharpDX.MediaFoundation.WaveFormatExConvertFlags"/></strong> enumeration.</p> </dd></param>	
            <returns>a reference to the <strong><see cref="T:SharpDX.Multimedia.WaveFormat"/></strong> structure.</returns>	
            <remarks>	
            <p>If the <strong>wFormatTag</strong> member of the returned structure is <strong><see cref="F:SharpDX.Multimedia.WaveFormatEncoding.Extensible"/></strong>, you can cast the reference to a <strong><see cref="T:SharpDX.Multimedia.WaveFormatExtensible"/></strong> structure.</p>	
            </remarks>	
            <msdn-id>ms702177</msdn-id>	
            <unmanaged>HRESULT MFCreateWaveFormatExFromMFMediaType([In] IMFMediaType* pMFType,[Out] void** ppWF,[Out, Optional] unsigned int* pcbSize,[In] unsigned int Flags)</unmanaged>	
            <unmanaged-short>MFCreateWaveFormatExFromMFMediaType</unmanaged-short>	
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaType.MajorType">
            <summary>
            <p>Gets the major type of the format. </p>
            </summary>
            <remarks>
            <p> This method is equivalent to getting the <strong><see cref = "P:SharpDX.MediaFoundation.MediaType.MajorType"/></strong> attribute from the media type. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms701588</doc-id>
            <unmanaged>GetMajorType</unmanaged>
            <unmanaged-short>GetMajorType</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaType.IsCompressedFormat">
            <summary>
            <p> Queries whether the media type is a temporally compressed format. Temporal compression uses information from previously decoded samples when decompressing the current sample.</p>
            </summary>
            <remarks>
            <p> This method returns <strong><see cref = "F:SharpDX.Result.False"/></strong> in <em>pfCompressed</em> if the media type's <strong><see cref = "!:AllSamplesIndependent"/></strong> attribute is <strong>TRUE</strong>. If the <strong><see cref = "!:AllSamplesIndependent"/></strong> attribute is <strong><see cref = "F:SharpDX.Result.False"/></strong> or not set, the method returns <strong>TRUE</strong>. </p><p> If the method returns <strong>TRUE</strong> in <em>pfCompressed</em>, it is a hint that the format has temporal compression applied to it. If the method returns <strong><see cref = "F:SharpDX.Result.False"/></strong>, the format does not use temporal compression, although it might use intra-frame compression. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms703821</doc-id>
            <unmanaged>IsCompressedFormat</unmanaged>
            <unmanaged-short>IsCompressedFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaType.GetMajorType(System.Guid@)">
            <summary>
            <p>Gets the major type of the format. </p>
            </summary>
            <param name = "guidMajorTypeRef"><dd> <p>Receives the major type <strong><see cref = "T:System.Guid"/></strong>. The major type describes the broad category of the format, such as audio or video. For a list of possible values, see Major Media Types. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Attributenotfound"/></strong></dt> </dl> </td><td> <p> The major type is not set. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> This method is equivalent to getting the <strong><see cref = "P:SharpDX.MediaFoundation.MediaType.MajorType"/></strong> attribute from the media type. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms701588</doc-id>
            <unmanaged>HRESULT IMFMediaType::GetMajorType([Out] GUID* pguidMajorType)</unmanaged>
            <unmanaged-short>IMFMediaType::GetMajorType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaType.IsCompressedFormat_(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p> Queries whether the media type is a temporally compressed format. Temporal compression uses information from previously decoded samples when decompressing the current sample.</p>
            </summary>
            <param name = "fCompressedRef"><dd> <p>Receives a Boolean value. The value is <strong>TRUE</strong> if the format uses temporal compression, or <strong><see cref = "F:SharpDX.Result.False"/></strong> if the format does not use temporal compression.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> This method returns <strong><see cref = "F:SharpDX.Result.False"/></strong> in <em>pfCompressed</em> if the media type's <strong><see cref = "!:AllSamplesIndependent"/></strong> attribute is <strong>TRUE</strong>. If the <strong><see cref = "!:AllSamplesIndependent"/></strong> attribute is <strong><see cref = "F:SharpDX.Result.False"/></strong> or not set, the method returns <strong>TRUE</strong>. </p><p> If the method returns <strong>TRUE</strong> in <em>pfCompressed</em>, it is a hint that the format has temporal compression applied to it. If the method returns <strong><see cref = "F:SharpDX.Result.False"/></strong>, the format does not use temporal compression, although it might use intra-frame compression. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms703821</doc-id>
            <unmanaged>HRESULT IMFMediaType::IsCompressedFormat([Out] BOOL* pfCompressed)</unmanaged>
            <unmanaged-short>IMFMediaType::IsCompressedFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaType.IsEqual(SharpDX.MediaFoundation.MediaType,System.Int32@)">
            <summary>
            <p> Compares two media types and determines whether they are identical. If they are not identical, the method indicates how the two formats differ. </p>
            </summary>
            <param name = "iMediaTypeRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type to compare.</p> </dd></param>
            <param name = "dwFlagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags, indicating the degree of similarity between the two media types. The following flags are defined.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MF_MEDIATYPE_EQUAL_MAJOR_TYPES</strong></dt> <dt>0x00000001</dt> </dl> </td><td> <p>The major types are the same. The major type is specified by the <strong><see cref = "P:SharpDX.MediaFoundation.MediaType.MajorType"/></strong> attribute.</p> </td></tr> <tr><td><dl> <dt><strong>MF_MEDIATYPE_EQUAL_FORMAT_TYPES</strong></dt> <dt>0x00000002</dt> </dl> </td><td> <p>The subtypes are the same, or neither media type has a subtype. The subtype is specified by the <strong><see cref = "!:Subtype"/></strong> attribute.</p> </td></tr> <tr><td><dl> <dt><strong>MF_MEDIATYPE_EQUAL_FORMAT_DATA</strong></dt> <dt>0x00000004</dt> </dl> </td><td> <p>The attributes in one of the media types are a  subset of the attributes in the other, and the values of these attributes match, excluding the value of the <strong><see cref = "!:UserData"/></strong>, <see cref = "!:FrameRateRangeMin"/>,  and <see cref = "!:FrameRateRangeMax"/> attributes.</p> <p>Specifically, the method takes the media type with the smaller number of attributes and checks whether each attribute from that type is present in the other media type and has the same value (not including <strong><see cref = "!:UserData"/></strong>, <see cref = "!:FrameRateRangeMin"/>,  and <see cref = "!:FrameRateRangeMax"/>). </p> <p>To perform other comparisons, use the <strong>IMFAttributes::Compare</strong> method. For example, the <strong>Compare</strong> method can test for identical attributes, or test the intersection of the two attribute sets. For more information, see <strong><see cref = "T:SharpDX.MediaFoundation.AttributesMatchType"/></strong>.</p> </td></tr> <tr><td><dl> <dt><strong>MF_MEDIATYPE_EQUAL_FORMAT_USER_DATA</strong></dt> <dt>0x00000008</dt> </dl> </td><td> <p>The user data is identical, or neither media type contains user data. User data is specified by the <strong><see cref = "!:UserData"/></strong> attribute.</p> </td></tr> </table> <p>?</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p> The types are not equal. Examine the <em>pdwFlags</em> parameter to determine how the types differ. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The types are equal. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> One or both media types are invalid. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> Both of the media types must have a major type, or the method returns <strong>E_INVALIDARG</strong>. </p><p> If the method succeeds and all of the comparison flags are set in <em>pdwFlags</em>, the return value is <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If the method succeeds but one or more comparison flags are not set, the method returns <strong>S_FALSE</strong>. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms696980</doc-id>
            <unmanaged>HRESULT IMFMediaType::IsEqual([In, Optional] IMFMediaType* pIMediaType,[Out] DWORD* pdwFlags)</unmanaged>
            <unmanaged-short>IMFMediaType::IsEqual</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaType.GetRepresentation(System.Guid,System.IntPtr@)">
            <summary>
            <p> </p><p>Retrieves an alternative representation of the media type. Currently only the DirectShow <strong><see cref = "!:SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure is supported.</p>
            </summary>
            <param name = "guidRepresentation"><dd> <p> <see cref = "T:System.Guid"/> that specifies the representation to retrieve. The following values are defined. </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>AM_MEDIA_TYPE_REPRESENTATION</strong></dt> </dl> </td><td> <p> Convert the media type to a DirectShow <strong><see cref = "!:SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure. The method selects the most appropriate format structure (<strong>pbFormat</strong>). </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_MFVideoFormat</strong></dt> </dl> </td><td> <p> Convert the media type to a DirectShow <strong><see cref = "!:SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure with an <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> format structure. </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_VideoInfo</strong></dt> </dl> </td><td> <p> Convert the media type to a DirectShow <strong><see cref = "!:SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure with a <strong><see cref = "!:SharpDX.Win32.Unsupported.VideoInfoHeader"/></strong> format structure. </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_VideoInfo2</strong></dt> </dl> </td><td> <p> Convert the media type to a DirectShow <strong><see cref = "!:SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure with a <strong><see cref = "!:SharpDX.MediaFoundation.VideoInformationHeader2"/></strong> format structure. </p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "vRepresentationOut"><dd> <p> Receives a reference to a structure that contains the representation. The method allocates the memory for the structure. The caller must release the memory by calling <strong>IMFMediaType::FreeRepresentation</strong>. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Attributenotfound"/></strong></dt> </dl> </td><td> <p> The details of the media type do not match the requested representation. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidMediaType"/></strong></dt> </dl> </td><td> <p> The media type is not valid. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedRepresentation"/></strong></dt> </dl> </td><td> <p> The media type does not support the requested representation. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> If you request a specific format structure in the <em>guidRepresentation</em> parameter, such as <strong><see cref = "!:SharpDX.Win32.Unsupported.VideoInfoHeader"/></strong>, you might lose some of the format information. </p><p> You can also use the <strong>MFInitAMMediaTypeFromMFMediaType</strong> function to convert a Media Foundation media type into a DirectShow media type. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms695248</doc-id>
            <unmanaged>HRESULT IMFMediaType::GetRepresentation([In] GUID guidRepresentation,[Out] void** ppvRepresentation)</unmanaged>
            <unmanaged-short>IMFMediaType::GetRepresentation</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaType.FreeRepresentation(System.Guid,System.IntPtr)">
            <summary>
            <p> </p><p>Retrieves an alternative representation of the media type. Currently only the DirectShow <strong><see cref = "!:SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure is supported.</p>
            </summary>
            <param name = "guidRepresentation"><dd> <p> <see cref = "T:System.Guid"/> that specifies the representation to retrieve. The following values are defined. </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>AM_MEDIA_TYPE_REPRESENTATION</strong></dt> </dl> </td><td> <p> Convert the media type to a DirectShow <strong><see cref = "!:SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure. The method selects the most appropriate format structure (<strong>pbFormat</strong>). </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_MFVideoFormat</strong></dt> </dl> </td><td> <p> Convert the media type to a DirectShow <strong><see cref = "!:SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure with an <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> format structure. </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_VideoInfo</strong></dt> </dl> </td><td> <p> Convert the media type to a DirectShow <strong><see cref = "!:SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure with a <strong><see cref = "!:SharpDX.Win32.Unsupported.VideoInfoHeader"/></strong> format structure. </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_VideoInfo2</strong></dt> </dl> </td><td> <p> Convert the media type to a DirectShow <strong><see cref = "!:SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure with a <strong><see cref = "!:SharpDX.MediaFoundation.VideoInformationHeader2"/></strong> format structure. </p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "vRepresentationRef"><dd> <p> Receives a reference to a structure that contains the representation. The method allocates the memory for the structure. The caller must release the memory by calling <strong>IMFMediaType::FreeRepresentation</strong>. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Attributenotfound"/></strong></dt> </dl> </td><td> <p> The details of the media type do not match the requested representation. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidMediaType"/></strong></dt> </dl> </td><td> <p> The media type is not valid. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedRepresentation"/></strong></dt> </dl> </td><td> <p> The media type does not support the requested representation. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> If you request a specific format structure in the <em>guidRepresentation</em> parameter, such as <strong><see cref = "!:SharpDX.Win32.Unsupported.VideoInfoHeader"/></strong>, you might lose some of the format information. </p><p> You can also use the <strong>MFInitAMMediaTypeFromMFMediaType</strong> function to convert a Media Foundation media type into a DirectShow media type. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms695248</doc-id>
            <unmanaged>HRESULT IMFMediaType::FreeRepresentation([In] GUID guidRepresentation,[In] void* pvRepresentation)</unmanaged>
            <unmanaged-short>IMFMediaType::FreeRepresentation</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaTypeHandler.GetMediaTypeByIndex(System.Int32)">
            <summary>	
            <p> </p><p>Retrieves a media type from the object's list of supported media types.</p>	
            </summary>	
            <param name="dwIndex"><dd> <p> Zero-based index of the media type to retrieve. To get the number of media types in the list, call <strong><see cref="M:SharpDX.MediaFoundation.MediaTypeHandler.GetMediaTypeCount(System.Int32@)" /></strong>. </p> </dd></param>	
            <param name="typeOut"><dd> <p> Receives a reference to the <strong><see cref="T:SharpDX.MediaFoundation.MediaType" /></strong> interface. The caller must release the interface. </p> </dd></param>	
            <returns><p>The method returns an <strong><see cref="T:SharpDX.Result" /></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="F:SharpDX.Result.Ok" /></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref="F:SharpDX.MediaFoundation.ResultCode.NoMoreTypes" /></strong></dt> </dl> </td><td> <p> The <em>dwIndex</em> parameter is out of range. </p> </td></tr> </table><p>?</p></returns>	
            <remarks>	
            <p>Media types are returned in the approximate order of preference. The list of supported types is not guaranteed to be complete. To test whether a particular media type is supported, call <strong><see cref="M:SharpDX.MediaFoundation.MediaTypeHandler.IsMediaTypeSupported(SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.MediaType@)" /></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IMFMediaTypeHandler::GetMediaTypeByIndex']/*" />	
            <msdn-id>bb970473</msdn-id>	
            <unmanaged>HRESULT IMFMediaTypeHandler::GetMediaTypeByIndex([In] unsigned int dwIndex,[Out] IMFMediaType** ppType)</unmanaged>	
            <unmanaged-short>IMFMediaTypeHandler::GetMediaTypeByIndex</unmanaged-short>	
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaTypeHandler.MediaTypeCount">
            <summary>
            <p> </p><p>Retrieves the number of media types in the object's list of supported media types.</p>
            </summary>
            <remarks>
            <p> To get the supported media types, call <strong>IMFMediaTypeHandler::GetMediaTypeByIndex</strong>. </p><p> For a media source, the media type handler for each stream must contain at least one supported media type. For media sinks, the media type handler for each stream might contain zero media types. In that case, the application must provide the media type. To test whether a particular media type is supported, call <strong>IMFMediaTypeHandler::IsMediaTypeSupported</strong>. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970517</doc-id>
            <unmanaged>GetMediaTypeCount</unmanaged>
            <unmanaged-short>GetMediaTypeCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaTypeHandler.CurrentMediaType">
            <summary>
            <p> </p><p>Retrieves the current media type of the object.</p>
            </summary>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970492</doc-id>
            <unmanaged>GetCurrentMediaType / SetCurrentMediaType</unmanaged>
            <unmanaged-short>GetCurrentMediaType</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaTypeHandler.MajorType">
            <summary>
            <p>Gets the major media type of the object. </p>
            </summary>
            <remarks>
            <p>The major type identifies what kind of data is in the stream, such as audio or video. To get the specific details of the format, call <strong>IMFMediaTypeHandler::GetCurrentMediaType</strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970337</doc-id>
            <unmanaged>GetMajorType</unmanaged>
            <unmanaged-short>GetMajorType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaTypeHandler.IsMediaTypeSupported(SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            <p> </p><p>Queries whether the object supports a specified media type.</p>
            </summary>
            <param name = "mediaTypeRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type to check. </p> </dd></param>
            <param name = "mediaTypeOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of the closest matching media type, or receives the value <strong><c>null</c></strong>. If non-<strong><c>null</c></strong>, the caller must release the interface. This parameter can be <strong><c>null</c></strong>. See Remarks. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidMediaType"/></strong></dt> </dl> </td><td> <p> The object does not support this media type. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> If the object supports the media type given in <em>pMediaType</em>, the method returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. For a media source, it means the source can generate data that conforms to that media type. For a media sink, it means the sink can receive data that conforms to that media type. If the object does not support the media type, the method fails. </p><p> The <em>ppMediaType</em> parameter is optional. If the method fails, the object might use <em>ppMediaType</em> to return a media type that the object does support, and which closely matches the one given in <em>pMediaType</em>. The method is not guaranteed to return a media type in <em>ppMediaType</em>. If no type is returned, this parameter receives a <strong><c>null</c></strong> reference. If the method succeeds, this parameter receives a <strong><c>null</c></strong> reference. If the caller sets <em>ppMediaType</em> to <strong><c>null</c></strong>, this parameter is ignored. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with SP2 and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970559</doc-id>
            <unmanaged>HRESULT IMFMediaTypeHandler::IsMediaTypeSupported([In] IMFMediaType* pMediaType,[Out, Optional] IMFMediaType** ppMediaType)</unmanaged>
            <unmanaged-short>IMFMediaTypeHandler::IsMediaTypeSupported</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaTypeHandler.GetMediaTypeCount(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the number of media types in the object's list of supported media types.</p>
            </summary>
            <param name = "dwTypeCountRef"><dd> <p>Receives the number of media types in the list.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> To get the supported media types, call <strong>IMFMediaTypeHandler::GetMediaTypeByIndex</strong>. </p><p> For a media source, the media type handler for each stream must contain at least one supported media type. For media sinks, the media type handler for each stream might contain zero media types. In that case, the application must provide the media type. To test whether a particular media type is supported, call <strong>IMFMediaTypeHandler::IsMediaTypeSupported</strong>. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970517</doc-id>
            <unmanaged>HRESULT IMFMediaTypeHandler::GetMediaTypeCount([Out] DWORD* pdwTypeCount)</unmanaged>
            <unmanaged-short>IMFMediaTypeHandler::GetMediaTypeCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaTypeHandler.GetMediaTypeByIndex(System.Int32,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            <p> </p><p>Retrieves a media type from the object's list of supported media types.</p>
            </summary>
            <param name = "dwIndex"><dd> <p> Zero-based index of the media type to retrieve. To get the number of media types in the list, call <strong>IMFMediaTypeHandler::GetMediaTypeCount</strong>. </p> </dd></param>
            <param name = "typeOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NoMoreTypes"/></strong></dt> </dl> </td><td> <p> The <em>dwIndex</em> parameter is out of range. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Media types are returned in the approximate order of preference. The list of supported types is not guaranteed to be complete. To test whether a particular media type is supported, call <strong>IMFMediaTypeHandler::IsMediaTypeSupported</strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970473</doc-id>
            <unmanaged>HRESULT IMFMediaTypeHandler::GetMediaTypeByIndex([In] DWORD dwIndex,[Out] IMFMediaType** ppType)</unmanaged>
            <unmanaged-short>IMFMediaTypeHandler::GetMediaTypeByIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaTypeHandler.SetCurrentMediaType(SharpDX.MediaFoundation.MediaType)">
            <summary>
            <p> </p><p>Sets the object's media type.</p>
            </summary>
            <param name = "mediaTypeRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of the new media type.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p> Invalid request. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>For media sources, setting the media type means the source will generate data that conforms to that media type. For media sinks, setting the media type means the sink can receive data that conforms to that media type.</p><p>Any implementation of this method should check whether <em>pMediaType</em> differs from the object's current media type. If the types are identical, the method should return <see cref = "F:SharpDX.Result.Ok"/> but avoid releasing and recreating resources unnecessarily. If the types are not identical, the method should validate the new type.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970432</doc-id>
            <unmanaged>HRESULT IMFMediaTypeHandler::SetCurrentMediaType([In] IMFMediaType* pMediaType)</unmanaged>
            <unmanaged-short>IMFMediaTypeHandler::SetCurrentMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaTypeHandler.GetCurrentMediaType(SharpDX.MediaFoundation.MediaType@)">
            <summary>
            <p> </p><p>Retrieves the current media type of the object.</p>
            </summary>
            <param name = "mediaTypeOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotInitializeD"/></strong></dt> </dl> </td><td> <p> No media type is set. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970492</doc-id>
            <unmanaged>HRESULT IMFMediaTypeHandler::GetCurrentMediaType([Out] IMFMediaType** ppMediaType)</unmanaged>
            <unmanaged-short>IMFMediaTypeHandler::GetCurrentMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaTypeHandler.GetMajorType(System.Guid@)">
            <summary>
            <p>Gets the major media type of the object. </p>
            </summary>
            <param name = "guidMajorTypeRef"><dd> <p>Receives a <see cref = "T:System.Guid"/> that identifies the major type. For a list of possible values, see Major Media Types. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The major type identifies what kind of data is in the stream, such as audio or video. To get the specific details of the format, call <strong>IMFMediaTypeHandler::GetCurrentMediaType</strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970337</doc-id>
            <unmanaged>HRESULT IMFMediaTypeHandler::GetMajorType([Out] GUID* pguidMajorType)</unmanaged>
            <unmanaged-short>IMFMediaTypeHandler::GetMajorType</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.NamespaceDoc">
            <summary>
            The <see cref="N:SharpDX.MediaFoundation"/> namespace provides a managed MediaFoundation API.
            </summary>
            <msdn-id></msdn-id>
            <unmanaged>MediaFoundation</unmanaged>	
            <unmanaged-short>MediaFoundation</unmanaged-short>	
        </member>
        <member name="T:SharpDX.MediaFoundation.OPM.NamespaceDoc">
            <summary>
            The <see cref="N:SharpDX.MediaFoundation.OPM"/> namespace provides a managed MediaFoundation for OPM API.
            </summary>
            <msdn-id></msdn-id>
            <unmanaged>MediaFoundation</unmanaged>	
            <unmanaged-short>MediaFoundation</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.PresentationDescriptor.GetStreamDescriptorByIndex(System.Int32,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>	
            <p> </p><p>Retrieves a stream descriptor for a stream in the presentation. The stream descriptor contains information about the stream.</p>	
            </summary>	
            <param name="dwIndex"><dd> <p>Zero-based index of the stream. To find the number of streams in the presentation, call the <strong><see cref="M:SharpDX.MediaFoundation.PresentationDescriptor.GetStreamDescriptorCount(System.Int32@)" /></strong> method.</p> </dd></param>	
            <param name="fSelectedRef"><dd> <p>Receives a Boolean value. The value is <strong>TRUE</strong> if the stream is currently selected, or <strong><see cref="F:SharpDX.Result.False" /></strong> if the stream is currently deselected. If a stream is selected, the media source generates data for that stream when <strong><see cref="M:SharpDX.MediaFoundation.MediaSource.Start(SharpDX.MediaFoundation.PresentationDescriptor,System.Nullable{System.Guid},System.Nullable{SharpDX.Win32.Variant})" /></strong> is called. The media source will not generated data for deselected streams. To select a stream, call <strong><see cref="M:SharpDX.MediaFoundation.PresentationDescriptor.SelectStream(System.Int32)" /></strong>.To deselect a stream, call <strong><see cref="M:SharpDX.MediaFoundation.PresentationDescriptor.DeselectStream(System.Int32)" /></strong>.</p> </dd></param>	
            <param name="descriptorOut"><dd> <p>Receives a reference to the stream descriptor's <strong><see cref="T:SharpDX.MediaFoundation.StreamDescriptor" /></strong> interface. The caller must release the interface.</p> </dd></param>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok" /></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result" /></strong> error code.</p></returns>	
            <remarks>	
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>	
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IMFPresentationDescriptor::GetStreamDescriptorByIndex']/*" />	
            <msdn-id>ms694924</msdn-id>	
            <unmanaged>HRESULT IMFPresentationDescriptor::GetStreamDescriptorByIndex([In] unsigned int dwIndex,[Out] BOOL* pfSelected,[Out] IMFStreamDescriptor** ppDescriptor)</unmanaged>	
            <unmanaged-short>IMFPresentationDescriptor::GetStreamDescriptorByIndex</unmanaged-short>	
        </member>
        <member name="P:SharpDX.MediaFoundation.PresentationDescriptor.StreamDescriptorCount">
            <summary>
            <p> </p><p>Retrieves the number of stream descriptors in the presentation. Each stream descriptor contains information about one stream in the media source. To retrieve a stream descriptor, call the <strong>IMFPresentationDescriptor::GetStreamDescriptorByIndex</strong> method.</p>
            </summary>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms701621</doc-id>
            <unmanaged>GetStreamDescriptorCount</unmanaged>
            <unmanaged-short>GetStreamDescriptorCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PresentationDescriptor.GetStreamDescriptorCount(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the number of stream descriptors in the presentation. Each stream descriptor contains information about one stream in the media source. To retrieve a stream descriptor, call the <strong>IMFPresentationDescriptor::GetStreamDescriptorByIndex</strong> method.</p>
            </summary>
            <param name = "dwDescriptorCountRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms701621</doc-id>
            <unmanaged>HRESULT IMFPresentationDescriptor::GetStreamDescriptorCount([Out] DWORD* pdwDescriptorCount)</unmanaged>
            <unmanaged-short>IMFPresentationDescriptor::GetStreamDescriptorCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PresentationDescriptor.GetStreamDescriptorByIndex(System.Int32,SharpDX.Mathematics.Interop.RawBool@,SharpDX.MediaFoundation.StreamDescriptor@)">
            <summary>
            <p> </p><p>Retrieves a stream descriptor for a stream in the presentation. The stream descriptor contains information about the stream.</p>
            </summary>
            <param name = "dwIndex"><dd> <p>Zero-based index of the stream. To find the number of streams in the presentation, call the <strong>IMFPresentationDescriptor::GetStreamDescriptorCount</strong> method.</p> </dd></param>
            <param name = "fSelectedRef"><dd> <p>Receives a Boolean value. The value is <strong>TRUE</strong> if the stream is currently selected, or <strong><see cref = "F:SharpDX.Result.False"/></strong> if the stream is currently deselected. If a stream is selected, the media source generates data for that stream when <strong>IMFMediaSource::Start</strong> is called. The media source will not generated data for deselected streams. To select a stream, call <strong>IMFPresentationDescriptor::SelectStream</strong>.To deselect a stream, call <strong>IMFPresentationDescriptor::DeselectStream</strong>.</p> </dd></param>
            <param name = "descriptorOut"><dd> <p>Receives a reference to the stream descriptor's <strong><see cref = "T:SharpDX.MediaFoundation.StreamDescriptor"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms694924</doc-id>
            <unmanaged>HRESULT IMFPresentationDescriptor::GetStreamDescriptorByIndex([In] DWORD dwIndex,[Out] BOOL* pfSelected,[Out] IMFStreamDescriptor** ppDescriptor)</unmanaged>
            <unmanaged-short>IMFPresentationDescriptor::GetStreamDescriptorByIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PresentationDescriptor.SelectStream(System.Int32)">
            <summary>
            <p> </p><p>Selects a stream in the presentation.</p>
            </summary>
            <param name = "dwDescriptorIndex"><dd> <p>The stream number to select, indexed from zero. To find the number of streams in the presentation, call <strong>IMFPresentationDescriptor::GetStreamDescriptorCount</strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>dwDescriptorIndex</em> is out of range.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> If a stream is selected, the media source will generate data for that stream. The media source will not generated data for deselected streams. To deselect a stream, call <strong>IMFPresentationDescriptor::DeselectStream</strong>. </p><p> To query whether a stream is selected, call <strong>IMFPresentationDescriptor::GetStreamDescriptorByIndex</strong>. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms696272</doc-id>
            <unmanaged>HRESULT IMFPresentationDescriptor::SelectStream([In] DWORD dwDescriptorIndex)</unmanaged>
            <unmanaged-short>IMFPresentationDescriptor::SelectStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PresentationDescriptor.DeselectStream(System.Int32)">
            <summary>
            <p> </p><p>Deselects a stream in the presentation.</p>
            </summary>
            <param name = "dwDescriptorIndex"><dd> <p> The stream number to deselect, indexed from zero. To find the number of streams in the presentation, call the <strong>IMFPresentationDescriptor::GetStreamDescriptorCount</strong> method. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>dwDescriptorIndex</em> is out of range. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> If a stream is deselected, no data is generated for that stream. To select the stream again, call <strong>IMFPresentationDescriptor::SelectStream</strong>. </p><p> To query whether a stream is selected, call <strong>IMFPresentationDescriptor::GetStreamDescriptorByIndex</strong>. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms696266</doc-id>
            <unmanaged>HRESULT IMFPresentationDescriptor::DeselectStream([In] DWORD dwDescriptorIndex)</unmanaged>
            <unmanaged-short>IMFPresentationDescriptor::DeselectStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PresentationDescriptor.Clone(SharpDX.MediaFoundation.PresentationDescriptor@)">
            <summary>
            <p> </p><p>Creates a copy of this presentation descriptor.</p>
            </summary>
            <param name = "presentationDescriptorOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the new presentation descriptor. The caller must release the interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> This method performs a shallow copy of the presentation descriptor. The stream descriptors are not cloned. Therefore, use caution when modifying the presentation presentation descriptor or its stream descriptors. </p><p> If the original presentation descriptor is from a media source, do not modify the presentation descriptor unless the source is stopped. If you use the presentation descriptor to configure a media sink, do not modify the presentation descriptor after the sink is configured. </p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms694028</doc-id>
            <unmanaged>HRESULT IMFPresentationDescriptor::Clone([Out] IMFPresentationDescriptor** ppPresentationDescriptor)</unmanaged>
            <unmanaged-short>IMFPresentationDescriptor::Clone</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.ResourceCharacteristics">
            <summary>
            Resource characteristics returned by <see cref="P:SharpDX.MediaFoundation.MediaEngineEx.ResourceCharacteristics"/>.
            </summary>
            <msdn-id>hh447939</msdn-id>	
            <unmanaged>HRESULT IMFMediaEngineEx::GetResourceCharacteristics([Out] unsigned int* pCharacteristics)</unmanaged>	
            <unmanaged-short>IMFMediaEngineEx::GetResourceCharacteristics</unmanaged-short>	
        </member>
        <member name="F:SharpDX.MediaFoundation.ResourceCharacteristics.None">
            <summary>
            None flag.
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResourceCharacteristics.LiveSource">
            <summary>
            The media resource represents a live data source, such as a video camera. If playback is stopped and then restarted, there will be a gap in the content.
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResourceCharacteristics.CanSeek">
            <summary>
            The media resource supports seeking. To get the seekable range, call IMFMediaEngine::GetSeekable.
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResourceCharacteristics.CanPause">
            <summary>
            The media resource can be paused.
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResourceCharacteristics.LongTimeToSeek">
            <summary>
            Seeking this resource can take a long time. For example, it might download through HTTP.
            </summary>
        </member>
        <member name="M:SharpDX.MediaFoundation.SampleGrabberSinkCallback.OnShutdown">
            <summary>	
            Called when the sample-grabber sink is shut down.
            </summary>	
            <remarks>	
            This method is called when the sink's Shutdown method is called. The OnShutdown method should return quickly, or it might interfere with playback. Do not block the thread, wait on events, or perform other lengthy operations inside this method.
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IMFSampleGrabberSinkCallback::OnShutdown']/*" />	
            <unmanaged>HRESULT IMFSampleGrabberSinkCallback::OnShutdown()</unmanaged>
        </member>
        <member name="M:SharpDX.MediaFoundation.SampleGrabberSinkCallback.OnSetPresentationClock(SharpDX.MediaFoundation.PresentationClock)">
            <summary>	
            Called when the presentation clock is set on the sample-grabber sink.
            </summary>	
            <param name="presentationClockRef"><para>Pointer to the presentation clock's PresentationClock interface.</para></param>	
            <remarks>	
            This method should return quickly, or it might interfere with playback. Do not block the thread, wait on events, or perform other lengthy operations inside this method.
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IMFSampleGrabberSinkCallback::OnSetPresentationClock']/*" />	
            <unmanaged>HRESULT IMFSampleGrabberSinkCallback::OnSetPresentationClock([In] IMFPresentationClock* pPresentationClock)</unmanaged>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SharpDX.MediaFoundation.SampleGrabberSinkCallback.OnProcessSample(System.Guid,System.Int32,System.Int64,System.Int64,System.IntPtr,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:SharpDX.MediaFoundation.SampleGrabberSinkCallback2.OnProcessSampleEx(System.Guid,System.Int32,System.Int64,System.Int64,System.IntPtr,System.Int32,SharpDX.MediaFoundation.MediaAttributes)" -->
        <member name="M:SharpDX.MediaFoundation.SampleGrabberSinkCallbackShadow.ToIntPtr(SharpDX.MediaFoundation.SampleGrabberSinkCallback)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.MediaFoundation.SampleGrabberSinkCallbackShadow.SampleGrabberSinkCallbackVtbl.PresentationClockDelegate">
            <unmanaged>HRESULT IMFSampleGrabberSinkCallback::OnSetPresentationClock([in] IMFPresentationClock *pPresentationClock);</unmanaged>	
        </member>
        <member name="T:SharpDX.MediaFoundation.SampleGrabberSinkCallbackShadow.SampleGrabberSinkCallbackVtbl.OnProcessSampleDelegate">
            <unmanaged>HRESULT OnProcessSample([in] REFGUID guidMajorMediaType, [in] DWORD dwSampleFlags, [in] LONGLONG llSampleTime, [in] LONGLONG llSampleDuration, [in] const BYTE *pSampleBuffer, [in] DWORD dwSampleSize);</unmanaged>	
        </member>
        <member name="T:SharpDX.MediaFoundation.SampleGrabberSinkCallbackShadow.SampleGrabberSinkCallbackVtbl.ShutdownDelegate">
            <unmanaged>HRESULT IMFSampleGrabberSinkCallback::OnShutdown();</unmanaged>
        </member>
        <member name="M:SharpDX.MediaFoundation.SampleGrabberSinkCallback2Shadow.ToIntPtr(SharpDX.MediaFoundation.SampleGrabberSinkCallback2)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:SharpDX.MediaFoundation.SampleGrabberSinkCallback2Shadow.SampleGrabberSinkCallback2Vtbl.ProcessSampleExDelegate" -->
        <member name="M:SharpDX.MediaFoundation.ServiceProvider.GetService``1(System.Guid)">
            <summary>
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> </p><p>Retrieves a service interface.</p>
            </summary>
            <typeparam name="T">Type of the interface to retrieve</typeparam>
            <param name="guidService"><dd> <p>The service identifier (SID) of the service. For a list of service identifiers, see Service Interfaces.</p> </dd></param>
            <returns>An instance of T if the service is supported</returns>
            <exception cref="T:SharpDX.SharpDXException">if the service is not supported</exception>
              <msdn-id>ms696978</msdn-id>
              <unmanaged>HRESULT IMFGetService::GetService([In] const GUID&amp; guidService,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>
              <unmanaged-short>IMFGetService::GetService</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ServiceProvider.GetService(System.Guid,System.Guid)">
            <summary>
            <p> </p><p>Retrieves a service interface.</p>
            </summary>
            <param name = "guidService"><dd> <p>The service identifier (SID) of the service. For a list of service identifiers, see Service Interfaces.</p> </dd></param>
            <param name = "riid"><dd> <p>The interface identifier (IID) of the interface being requested.</p> </dd></param>
            <returns><dd> <p>Receives the interface reference. The caller must release the interface.</p> </dd></returns>
            <doc-id>ms696978</doc-id>
            <unmanaged>HRESULT IMFGetService::GetService([In] const GUID&amp; guidService,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>
            <unmanaged-short>IMFGetService::GetService</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SinkWriter.GetStatistics(System.Int32,SharpDX.MediaFoundation.SinkWriterStatistics@)">
            <summary>	
            <p>Gets statistics about the performance of the sink writer.</p>	
            </summary>	
            <param name="dwStreamIndex"><dd> <p>The zero-based index of a stream to query, or <strong><see cref="F:SharpDX.MediaFoundation.SinkWriterIndex.AllStreams" /> </strong> to query the media sink itself.</p> </dd></param>	
            <param name="statsRef"><dd> <p>A reference to an <strong><see cref="T:SharpDX.MediaFoundation.SinkWriterStatistics" /></strong> structure. Before calling the method, set the <strong>cb</strong> member to the size of the structure in bytes. The method fills the structure with statistics from the sink writer.</p> </dd></param>	
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref="F:SharpDX.Result.Ok" /></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref="F:SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber" /></strong></dt> </dl> </td><td> <p>Invalid stream number.</p> </td></tr> </table><p>?</p></returns>	
            <remarks>	
            <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
            </remarks>	
            <!-- Failed to insert some or all of included XML --><include file=".\..\..\Documentation\CodeComments.xml" path="/comments/comment[@id='IMFSinkWriter::GetStatistics']/*" />	
            <msdn-id>dd374650</msdn-id>	
            <unmanaged>HRESULT IMFSinkWriter::GetStatistics([In] unsigned int dwStreamIndex,[Out] MF_SINK_WRITER_STATISTICS* pStats)</unmanaged>	
            <unmanaged-short>IMFSinkWriter::GetStatistics</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SinkWriter.AddStream(SharpDX.MediaFoundation.MediaType,System.Int32@)">
            <summary>
            <p>Adds a stream to the sink writer.</p>
            </summary>
            <param name = "targetMediaTypeRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of a media type. This media type specifies the format of the samples that will be written to the file. It does not need to match the input format. To set the input format, call <strong>IMFSinkWriter::SetInputMediaType</strong>.</p> </dd></param>
            <param name = "dwStreamIndexRef"><dd> <p>Receives the zero-based index of the new stream.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374646</doc-id>
            <unmanaged>HRESULT IMFSinkWriter::AddStream([In] IMFMediaType* pTargetMediaType,[Out] DWORD* pdwStreamIndex)</unmanaged>
            <unmanaged-short>IMFSinkWriter::AddStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SinkWriter.SetInputMediaType(System.Int32,SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.MediaAttributes)">
            <summary>
            <p>Sets the input format for a stream on the sink writer.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The zero-based index of the stream. The index is received by the <em>pdwStreamIndex</em> parameter of the <strong>IMFSinkWriter::AddStream</strong> method.</p> </dd></param>
            <param name = "inputMediaTypeRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of a media type. The media type specifies the input format.</p> </dd></param>
            <param name = "encodingParametersRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of an attribute store. Use the attribute store to configure the encoder. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidMediaType"/></strong></strong></dt> </dl> </td><td> <p>The underlying media sink does not support the format, no conversion is possible, or a dynamic format change is not possible.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidStreamNumber"/></strong></strong></dt> </dl> </td><td> <p>The <em>dwStreamIndex</em> parameter is invalid.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:TopoCodecNotFound"/></strong></strong></dt> </dl> </td><td> <p>Could not find an encoder for the encoded format.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The input format does not have to match the target format that is written to the media sink. If the formats do not match, the method attempts to load an encoder that can encode from the input format to the target format.</p><p>After streaming begins?that is, after the  first call to <strong>IMFSinkWriter::WriteSample</strong>?you can call this method at any time to change the input format.  However, the underlying encoder and media sink must support dynamic format changes.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374653</doc-id>
            <unmanaged>HRESULT IMFSinkWriter::SetInputMediaType([In] DWORD dwStreamIndex,[In] IMFMediaType* pInputMediaType,[In, Optional] IMFAttributes* pEncodingParameters)</unmanaged>
            <unmanaged-short>IMFSinkWriter::SetInputMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SinkWriter.BeginWriting">
            <summary>
            <p>Initializes the sink writer for writing.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The request is invalid.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this method after you configure the input streams and before you send any data to the sink writer. </p><p>You must call <strong>BeginWriting</strong> before calling any of the following methods:</p><ul> <li> <strong>IMFSinkWriter::Finalize</strong> </li> <li> <strong>IMFSinkWriter::Flush</strong> </li> <li> <strong>IMFSinkWriter::NotifyEndOfSegment</strong> </li> <li> <strong>IMFSinkWriter::PlaceMarker</strong> </li> <li> <strong>IMFSinkWriter::SendStreamTick</strong> </li> <li> <strong>IMFSinkWriter::WriteSample</strong> </li> </ul><p>The underlying media sink must have at least one input stream. Otherwise, <strong>BeginWriting</strong> returns <strong><see cref = "!:InvalidRequest"/></strong>. To add input streams, call the <strong>IMFSinkWriter::AddStream</strong> method.</p><p>If <strong>BeginWriting</strong> succeeds, any further calls to <strong>BeginWriting</strong> return <strong><see cref = "!:InvalidRequest"/></strong>.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374647</doc-id>
            <unmanaged>HRESULT IMFSinkWriter::BeginWriting()</unmanaged>
            <unmanaged-short>IMFSinkWriter::BeginWriting</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SinkWriter.WriteSample(System.Int32,SharpDX.MediaFoundation.Sample)">
            <summary>
            <p>Delivers a sample to the sink writer.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The zero-based index of the stream for this sample.</p> </dd></param>
            <param name = "sampleRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface of the sample.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The request is invalid.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>You must call <strong>IMFSinkWriter::BeginWriting</strong> before calling this method. Otherwise, the method returns <strong><see cref = "!:InvalidRequest"/></strong>.</p><p>By default, the sink writer limits the rate of incoming data by blocking the calling thread inside the <strong>WriteSample</strong> method. This prevents the application from delivering samples too quickly. To disable this behavior, set the <see cref = "!:DisableThrottling"/> attribute when you create the sink writer.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374654</doc-id>
            <unmanaged>HRESULT IMFSinkWriter::WriteSample([In] DWORD dwStreamIndex,[In] IMFSample* pSample)</unmanaged>
            <unmanaged-short>IMFSinkWriter::WriteSample</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SinkWriter.SendStreamTick(System.Int32,System.Int64)">
            <summary>
            <p>Indicates a gap in an input stream.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The zero-based index of the stream.</p> </dd></param>
            <param name = "llTimestamp"><dd> <p>The position in the stream where the gap in the data occurs. The value is given in 100-nanosecond units, relative to the start of the stream.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>For video, call this method once for each missing frame. For audio, call this method at least once per second during a gap in the audio. Set the <strong><see cref = "!:Discontinuity"/></strong> attribute on the first media sample after the gap.</p><p>Internally, this method calls <strong>IMFStreamSink::PlaceMarker</strong> on the media sink.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374652</doc-id>
            <unmanaged>HRESULT IMFSinkWriter::SendStreamTick([In] DWORD dwStreamIndex,[In] longlong llTimestamp)</unmanaged>
            <unmanaged-short>IMFSinkWriter::SendStreamTick</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SinkWriter.PlaceMarker(System.Int32,System.IntPtr)">
            <summary>
            <p>Places a marker in the specified stream.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The zero-based index of the stream.</p> </dd></param>
            <param name = "vContextRef"><dd> <p>Pointer to an application-defined value. The value of this parameter is returned to the caller in the <em>pvContext</em> parameter of the caller's <strong>IMFSinkWriterCallback::OnMarker</strong> callback method. The application is responsible for any memory allocation associated with this data. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The request is invalid.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To use this method, you must provide an asynchronous callback when you create the sink writer. Otherwise, the method returns <strong><see cref = "!:InvalidRequest"/></strong>. For more information, see <see cref = "!:AsyncCallback"/>.</p><p>Markers provide a way to be notified when the media sink consumes all of the samples in a stream up to a certain point. The media sink does not process the marker until it has processed all of the samples that came before the marker. When the media sink processes the marker, the sink writer calls the application's <strong>OnMarker</strong> method. When the callback is invoked, you know that the sink has consumed all of the previous samples for that stream.</p><p>For example, to change the format midstream, call <strong>PlaceMarker</strong> at the point where the format changes. When <strong>OnMarker</strong> is called, it is safe to call <strong>IMFSinkWriter::SetInputMediaType</strong> to change the input type (assuming that the media sink supports dynamic format changes).</p><p>Internally, this method calls <strong>IMFStreamSink::PlaceMarker</strong> on the media sink.</p><p> </p><strong>Note</strong>??The <em>pvContext</em> parameter of the <strong>IMFSinkWriter::PlaceMarker</strong> method is not passed to the <em>pvarContextValue</em> parameter of the <strong>IMFStreamSink::PlaceMarker</strong> method. These two parameters are not directly related.?<p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374651</doc-id>
            <unmanaged>HRESULT IMFSinkWriter::PlaceMarker([In] DWORD dwStreamIndex,[In] void* pvContext)</unmanaged>
            <unmanaged-short>IMFSinkWriter::PlaceMarker</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SinkWriter.NotifyEndOfSegment(System.Int32)">
            <summary>
            <p>Notifies the media sink that a stream has reached the end of a segment.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The zero-based index of a stream, or <strong>MF_SINK_WRITER_ALL_STREAMS</strong> to signal that all streams have reached the end of a segment.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The request is invalid.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>You must call <strong>IMFSinkWriter::BeginWriting</strong> before calling this method. Otherwise, the method returns <strong><see cref = "!:InvalidRequest"/></strong>.</p><p>This method sends an <strong>MFSTREAMSINK_MARKER_ENDOFSEGMENT</strong> marker to the media sink for the specified streams. For more information, see <strong>IMFStreamSink::PlaceMarker</strong>.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd743366</doc-id>
            <unmanaged>HRESULT IMFSinkWriter::NotifyEndOfSegment([In] DWORD dwStreamIndex)</unmanaged>
            <unmanaged-short>IMFSinkWriter::NotifyEndOfSegment</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SinkWriter.Flush(System.Int32)">
            <summary>
            <p>Flushes one or more streams.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The zero-based index of the stream to flush, or <strong>MF_SINK_WRITER_ALL_STREAMS</strong> to flush all of the streams.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The request is invalid.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>You must call <strong>IMFSinkWriter::BeginWriting</strong> before calling this method. Otherwise, the method returns <strong><see cref = "!:InvalidRequest"/></strong>.</p><p>For each stream that is flushed, the sink writer drops all pending samples, flushes the encoder, and sends an <strong>MFSTREAMSINK_MARKER_ENDOFSEGMENT</strong> marker to the media sink.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd743365</doc-id>
            <unmanaged>HRESULT IMFSinkWriter::Flush([In] DWORD dwStreamIndex)</unmanaged>
            <unmanaged-short>IMFSinkWriter::Flush</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SinkWriter.Finalize">
            <summary>
            <p>Completes all writing operations on the sink writer.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Call this method after you send all of the input samples to the sink writer. The method performs any operations needed to create the final output from the media sink.</p><p>If you provide a callback interface when you create the sink writer, this method completes asynchronously. When the operation completes, the <strong>IMFSinkWriterCallback::OnFinalize</strong> method of your callback is called. For more information, see <see cref = "!:AsyncCallback"/>.  Otherwise, if you do not provide a callback, the <strong>Finalize</strong> method blocks until the operation completes.</p><p>Internally, this method calls <strong>IMFStreamSink::PlaceMarker</strong> to place end-of-segment markers for each stream on the media sink. It also calls <strong>IMFFinalizableMediaSink::BeginFinalize</strong> and <strong>EndFinalize</strong> if the media sink supports the <strong><see cref = "T:SharpDX.MediaFoundation.FinalizableMediaSink"/></strong> interface.</p><p>After this method is called, the following methods will fail:</p><ul> <li> <strong>IMFSinkWriter::PlaceMarker</strong> </li> <li> <strong>IMFSinkWriter::SendStreamTick</strong> </li> <li> <strong>IMFSinkWriter::WriteSample</strong> </li> </ul><p>If you do not call <strong>Finalize</strong>, the output from the media sink might be incomplete or invalid. For example, required file headers might be missing from the output file.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374648</doc-id>
            <unmanaged>HRESULT IMFSinkWriter::Finalize()</unmanaged>
            <unmanaged-short>IMFSinkWriter::Finalize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SinkWriter.GetServiceForStream(System.Int32,System.Guid,System.Guid,System.IntPtr@)">
            <summary>
            <p>Queries the underlying media sink or encoder for an interface.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The zero-based index of a stream to query, or <strong>MF_SINK_WRITER_MEDIASINK</strong> to query the media sink itself.</p> </dd></param>
            <param name = "guidService"><dd> <p>A service identifier <see cref = "T:System.Guid"/>, or <strong>GUID_NULL</strong>.  If the value is <strong>GUID_NULL</strong>, the method calls <strong>QueryInterface</strong> to get the requested interface. Otherwise, the method calls <strong>IMFGetService::GetService</strong>. For a list of service identifiers, see Service Interfaces.</p> </dd></param>
            <param name = "riid"><dd> <p>The interface identifier (IID) of the interface being requested. </p> </dd></param>
            <param name = "vObjectOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If the <em>dwStreamIndex</em> parameter equals <strong>MF_SINK_WRITER_MEDIASINK</strong>, the method attempts to get the interface from the media sink. Otherwise, it attempts to get the interface from the encoder for the stream at the specified index. If that fails, or if no encoder is present, the method attempts to get the interface from the stream on the media sink.</p><p> If the input and output types of the sink are identical and compressed, it's possible that no encoding is required and the video encoder will not be instantiated. In that case, <strong>GetServiceForStream</strong> will return <see cref = "!:UnsupportedService"/>. </p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374649</doc-id>
            <unmanaged>HRESULT IMFSinkWriter::GetServiceForStream([In] DWORD dwStreamIndex,[In] const GUID&amp; guidService,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>
            <unmanaged-short>IMFSinkWriter::GetServiceForStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SinkWriter.GetStatistics_(System.Int32,System.IntPtr)">
            <summary>
            <p>Gets statistics about the performance of the sink writer.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The zero-based index of a stream to query, or <strong>MF_SINK_WRITER_ALL_STREAMS </strong> to query the media sink itself.</p> </dd></param>
            <param name = "statsRef"><dd> <p>A reference to an <strong><see cref = "T:SharpDX.MediaFoundation.SinkWriterStatistics"/></strong> structure. Before calling the method, set the <strong>cb</strong> member to the size of the structure in bytes. The method fills the structure with statistics from the sink writer.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>Invalid stream number.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374650</doc-id>
            <unmanaged>HRESULT IMFSinkWriter::GetStatistics([In] DWORD dwStreamIndex,[In] MF_SINK_WRITER_STATISTICS* pStats)</unmanaged>
            <unmanaged-short>IMFSinkWriter::GetStatistics</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.#ctor(System.String,SharpDX.MediaFoundation.MediaAttributes)">
            <summary>
            Creates the source reader from a URL
            </summary>
            <param name="url">The URL of a media file to open.</param>
            <param name="attributes"><dd> <p>Pointer to the <strong><see cref="T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this parameter to configure the source reader. For more information, see Source Reader Attributes. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
            <remarks>	
            <p>Call <strong>CoInitialize(Ex)</strong> and <strong><see cref="M:SharpDX.MediaFoundation.MediaFactory.Startup(System.Int32,System.Int32)"/></strong> before calling this function.</p><p> Internally, the source reader calls the <strong><see cref="!:SharpDX.MediaFoundation.SourceResolver.CreateObjectFromURL_"/></strong> method to create a media source from the byte stream. Therefore, a byte-stream handler must be registered for the byte stream. For more information about byte-stream handlers, see Scheme Handlers and Byte-Stream Handlers. </p><p>This function is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
            </remarks>
            <msdn-id>dd388110</msdn-id>
            <unmanaged>HRESULT MFCreateSourceReaderFromURL([In] const wchar_t* pwszURL,[In, Optional] IMFAttributes* pAttributes,[Out, Fast] IMFSourceReader** ppSourceReader)</unmanaged>	
            <unmanaged-short>MFCreateSourceReaderFromURL</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.#ctor(System.Byte[],SharpDX.MediaFoundation.MediaAttributes)">
            <summary>	
            Creates the source reader from a byte stream.
            </summary>	
            <param name="buffer"><dd> <p>A reference to the <strong><see cref="T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream. This byte stream will provide the source data for the source reader.</p> </dd></param>	
            <param name="attributes"><dd> <p>Pointer to the <strong><see cref="T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this parameter to configure the source reader. For more information, see Source Reader Attributes. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
            <remarks>	
            <p>Call <strong>CoInitialize(Ex)</strong> and <strong><see cref="M:SharpDX.MediaFoundation.MediaFactory.Startup(System.Int32,System.Int32)"/></strong> before calling this function.</p><p> Internally, the source reader calls the <strong><see cref="!:SharpDX.MediaFoundation.SourceResolver.CreateObjectFromByteStream_"/></strong> method to create a media source from the byte stream. Therefore, a byte-stream handler must be registered for the byte stream. For more information about byte-stream handlers, see Scheme Handlers and Byte-Stream Handlers. </p><p>This function is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
            </remarks>	
            <msdn-id>dd388106</msdn-id>	
            <unmanaged>HRESULT MFCreateSourceReaderFromByteStream([In] IMFByteStream* pByteStream,[In, Optional] IMFAttributes* pAttributes,[Out, Fast] IMFSourceReader** ppSourceReader)</unmanaged>	
            <unmanaged-short>MFCreateSourceReaderFromByteStream</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.#ctor(System.IO.Stream,SharpDX.MediaFoundation.MediaAttributes)">
            <summary>	
            Creates the source reader from a byte stream.
            </summary>	
            <param name="buffer"><dd> <p>A reference to the <strong><see cref="T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream. This byte stream will provide the source data for the source reader.</p> </dd></param>	
            <param name="attributes"><dd> <p>Pointer to the <strong><see cref="T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this parameter to configure the source reader. For more information, see Source Reader Attributes. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
            <remarks>	
            <p>Call <strong>CoInitialize(Ex)</strong> and <strong><see cref="M:SharpDX.MediaFoundation.MediaFactory.Startup(System.Int32,System.Int32)"/></strong> before calling this function.</p><p> Internally, the source reader calls the <strong><see cref="!:SharpDX.MediaFoundation.SourceResolver.CreateObjectFromByteStream_"/></strong> method to create a media source from the byte stream. Therefore, a byte-stream handler must be registered for the byte stream. For more information about byte-stream handlers, see Scheme Handlers and Byte-Stream Handlers. </p><p>This function is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
            </remarks>	
            <msdn-id>dd388106</msdn-id>	
            <unmanaged>HRESULT MFCreateSourceReaderFromByteStream([In] IMFByteStream* pByteStream,[In, Optional] IMFAttributes* pAttributes,[Out, Fast] IMFSourceReader** ppSourceReader)</unmanaged>	
            <unmanaged-short>MFCreateSourceReaderFromByteStream</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.#ctor(SharpDX.MediaFoundation.MediaSource,SharpDX.MediaFoundation.MediaAttributes)">
            <summary>
            Creates the source reader from a <see cref="T:SharpDX.MediaFoundation.MediaSource"/>
            </summary>
            <param name="source">Reference to the mediasource interface</param>
            <param name="attributes"><dd> <p>Pointer to the <strong><see cref="T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this parameter to configure the source reader. For more information, see Source Reader Attributes. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>	
            <remarks>	
            <p>Call <strong>CoInitialize(Ex)</strong> and <strong><see cref="M:SharpDX.MediaFoundation.MediaFactory.Startup(System.Int32,System.Int32)"/></strong> before calling this function.</p><p>By default, when the application releases the source reader, the source reader shuts down the media source by calling <strong><see cref="M:SharpDX.MediaFoundation.MediaSource.Shutdown"/></strong> on the media source. At that point, the application can no longer use the media source.</p><p>To change this default behavior, set the <see cref="F:SharpDX.MediaFoundation.SourceReaderAttributeKeys.DisconnectMediasourceOnShutdown"/> attribute in the <em>pAttributes</em> parameter. If this attribute is <strong>TRUE</strong>, the application is responsible for  shutting down the media source.</p><p>When using the Source Reader, do not call any of the following methods on the media source:</p><ul> <li> <strong><see cref="M:SharpDX.MediaFoundation.MediaSource.Pause"/></strong> </li> <li> <strong><see cref="M:SharpDX.MediaFoundation.MediaSource.Start(SharpDX.MediaFoundation.PresentationDescriptor,System.Nullable{System.Guid},System.Nullable{SharpDX.Win32.Variant})"/></strong> </li> <li> <strong><see cref="M:SharpDX.MediaFoundation.MediaSource.Stop"/></strong> </li> <li>All <strong><see cref="T:SharpDX.MediaFoundation.MediaEventGenerator"/></strong> methods</li> </ul><p>This function is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p><p><strong>Windows Phone 8.1:</strong> This API is supported.</p>	
            </remarks>	
            <msdn-id>dd388108</msdn-id>	
            <unmanaged>HRESULT MFCreateSourceReaderFromMediaSource([In] IMFMediaSource* pMediaSource,[In, Optional] IMFAttributes* pAttributes,[Out, Fast] IMFSourceReader** ppSourceReader)</unmanaged>	
            <unmanaged-short>MFCreateSourceReaderFromMediaSource</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.GetNativeMediaType(SharpDX.MediaFoundation.SourceReaderIndex,System.Int32)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Gets a format that is supported natively by the media source.</p>	
            </summary>	
            <param name="readerIndex"><dd> <p>Specifies which stream to query. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream"/></strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream"/></strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>	
            <param name="dwMediaTypeIndex"><dd> <p>The zero-based index of the media type to retrieve.</p> </dd></param>	
            <returns><dd> <p>Receives a reference to the <strong><see cref="T:SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface.</p> </dd></returns>	
            <remarks>	
            <p>This method queries the underlying media source for its native output format. Potentially, each source stream can produce more than one output format. Use the <em>dwMediaTypeIndex</em> parameter to loop through the available formats. Generally, file sources offer just one format per stream, but capture devices might offer several formats.</p><p> The method returns a copy of the media type, so it is safe to modify the object received in the <em> ppMediaType</em> parameter.</p><p>To set  the output type for a stream, call the <strong><see cref="M:SharpDX.MediaFoundation.SourceReader.SetCurrentMediaType(SharpDX.MediaFoundation.SourceReaderIndex,SharpDX.MediaFoundation.MediaType)"/></strong> method.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
            </remarks>	
            <msdn-id>dd374661</msdn-id>	
            <unmanaged>HRESULT IMFSourceReader::GetNativeMediaType([In] unsigned int dwStreamIndex,[In] unsigned int dwMediaTypeIndex,[Out] IMFMediaType** ppMediaType)</unmanaged>	
            <unmanaged-short>IMFSourceReader::GetNativeMediaType</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.SetStreamSelection(SharpDX.MediaFoundation.SourceReaderIndex,SharpDX.Mathematics.Interop.RawBool)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Selects or deselects one or more streams.</p>	
            </summary>	
            <param name="readerIndex"><dd> <p>The stream to set. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream"/></strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream"/></strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.AllStreams"/></strong></strong></dt> <dt>0xFFFFFFFE</dt> </dl> </td><td> <p>All streams.</p> </td></tr> </table> <p>?</p> </dd></param>	
            <param name="fSelected"><dd> <p>Specify <strong>TRUE</strong> to select streams or <strong><see cref="F:SharpDX.Result.False"/></strong> to deselect streams. If a stream is deselected, it will not generate data.</p> </dd></param>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result"/></strong> error code.</p></returns>	
            <remarks>	
            <p>There are two common uses for this method:</p><ul> <li>To change the default stream selection. Some media files contain multiple streams of the same type. For example, a file might include audio streams for multiple languages. You can use this method to change which of the streams is selected. To get information about each stream, call <strong><see cref="M:SharpDX.MediaFoundation.SourceReader.GetPresentationAttribute(SharpDX.MediaFoundation.SourceReaderIndex,System.Guid)"/></strong> or <strong><see cref="M:SharpDX.MediaFoundation.SourceReader.GetNativeMediaType(SharpDX.MediaFoundation.SourceReaderIndex,System.Int32)"/></strong>.</li> <li>If you will not need data from one of the streams, it is a good idea to deselect that stream. If the stream is selected, the media source might hold onto a queue of unread data, and the queue might grow indefinitely, consuming memory. </li> </ul><p>For an example of deselecting a stream, see Tutorial: Decoding Audio.</p><p>If a stream is deselected, the <strong><see cref="M:SharpDX.MediaFoundation.SourceReader.ReadSample(SharpDX.MediaFoundation.SourceReaderIndex,SharpDX.MediaFoundation.SourceReaderControlFlags,System.Int32@,SharpDX.MediaFoundation.SourceReaderFlags@,System.Int64@)"/></strong> method returns <strong>MF_E_INVALIDREQUEST</strong> for that stream. Other <strong><see cref="T:SharpDX.MediaFoundation.SourceReader"/></strong> methods are valid for deselected streams.</p><p>Stream selection does not affect how the source reader loads or unloads decoders in memory. In particular, deselecting a stream does not force the source reader to unload the decoder for that stream.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
            </remarks>	
            <msdn-id>dd374669</msdn-id>	
            <unmanaged>HRESULT IMFSourceReader::SetStreamSelection([In] unsigned int dwStreamIndex,[In] BOOL fSelected)</unmanaged>	
            <unmanaged-short>IMFSourceReader::SetStreamSelection</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.SetCurrentMediaType(SharpDX.MediaFoundation.SourceReaderIndex,SharpDX.MediaFoundation.MediaType)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Sets the media type for a stream.</p><p>This media type defines that format that the Source Reader produces as output. It can differ from the native format provided by the media source. See Remarks for more information.</p>	
            </summary>	
            <param name="readerIndex">No documentation.</param>	
            <param name="mediaTypeRef">No documentation.</param>	
            <returns><p>The method returns an <strong><see cref="T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>MF_E_INVALIDMEDIATYPE</strong></strong></dt> </dl> </td><td> <p>At least one decoder was found for the native stream type, but the type specified by <em>pMediaType</em> was rejected.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>MF_E_INVALIDREQUEST</strong></strong></dt> </dl> </td><td> <p>One or more sample requests are still pending.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>MF_E_INVALIDSTREAMNUMBER</strong></strong></dt> </dl> </td><td> <p>The <em>dwStreamIndex</em> parameter is invalid.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>MF_E_TOPO_CODEC_NOT_FOUND</strong></strong></dt> </dl> </td><td> <p>Could not find a decoder for the native stream type.</p> </td></tr> </table><p>?</p></returns>	
            <remarks>	
            <p>For each stream, you can set the media type to any of the following:</p><ul> <li>One of the native types offered by the media source. To enumerate the native types, call <strong><see cref="M:SharpDX.MediaFoundation.SourceReader.GetNativeMediaType(SharpDX.MediaFoundation.SourceReaderIndex,System.Int32)"/></strong>.</li> <li>If the native media type is compressed, you can specify a corresponding uncompressed format. The Source Reader will search for a decoder that can decode from the native format to the specified uncompressed format.</li> </ul><p>The source reader does not support audio resampling. If you need to resample the audio, you can use the <strong>Audio Resampler DSP</strong>.</p><p>If you set the <see cref="F:SharpDX.MediaFoundation.SourceReaderAttributeKeys.EnableVideoProcessing"/> attribute to <strong>TRUE</strong> when you create the Source Reader, the Source Reader will convert YUV video to RGB-32. This conversion is not optimized for real-time video playback.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
            </remarks>	
            <msdn-id>dd374667</msdn-id>	
            <unmanaged>HRESULT IMFSourceReader::SetCurrentMediaType([In] unsigned int dwStreamIndex,[In] unsigned int* pdwReserved,[In] IMFMediaType* pMediaType)</unmanaged>	
            <unmanaged-short>IMFSourceReader::SetCurrentMediaType</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.SetCurrentMediaType(System.Int32,SharpDX.MediaFoundation.MediaType)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Sets the media type for a stream.</p><p>This media type defines that format that the Source Reader produces as output. It can differ from the native format provided by the media source. See Remarks for more information.</p>	
            </summary>	
            <param name="readerIndex">No documentation.</param>	
            <param name="mediaTypeRef">No documentation.</param>	
            <returns><p>The method returns an <strong><see cref="T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref="F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>MF_E_INVALIDMEDIATYPE</strong></strong></dt> </dl> </td><td> <p>At least one decoder was found for the native stream type, but the type specified by <em>pMediaType</em> was rejected.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>MF_E_INVALIDREQUEST</strong></strong></dt> </dl> </td><td> <p>One or more sample requests are still pending.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>MF_E_INVALIDSTREAMNUMBER</strong></strong></dt> </dl> </td><td> <p>The <em>dwStreamIndex</em> parameter is invalid.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>MF_E_TOPO_CODEC_NOT_FOUND</strong></strong></dt> </dl> </td><td> <p>Could not find a decoder for the native stream type.</p> </td></tr> </table><p>?</p></returns>	
            <remarks>	
            <p>For each stream, you can set the media type to any of the following:</p><ul> <li>One of the native types offered by the media source. To enumerate the native types, call <strong><see cref="M:SharpDX.MediaFoundation.SourceReader.GetNativeMediaType(SharpDX.MediaFoundation.SourceReaderIndex,System.Int32)"/></strong>.</li> <li>If the native media type is compressed, you can specify a corresponding uncompressed format. The Source Reader will search for a decoder that can decode from the native format to the specified uncompressed format.</li> </ul><p>The source reader does not support audio resampling. If you need to resample the audio, you can use the <strong>Audio Resampler DSP</strong>.</p><p>If you set the <see cref="F:SharpDX.MediaFoundation.SourceReaderAttributeKeys.EnableVideoProcessing"/> attribute to <strong>TRUE</strong> when you create the Source Reader, the Source Reader will convert YUV video to RGB-32. This conversion is not optimized for real-time video playback.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
            </remarks>	
            <msdn-id>dd374667</msdn-id>	
            <unmanaged>HRESULT IMFSourceReader::SetCurrentMediaType([In] unsigned int dwStreamIndex,[In] unsigned int* pdwReserved,[In] IMFMediaType* pMediaType)</unmanaged>	
            <unmanaged-short>IMFSourceReader::SetCurrentMediaType</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.SetCurrentPosition(System.Int64)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Seeks to a new position in the media source.</p>	
            </summary>	
            <param name="position">The position from which playback will be started. 100-nanosecond units.</param>	
            <remarks>	
            <p>The <strong>SetCurrentPosition</strong> method does not guarantee exact seeking. The accuracy of the seek depends on the media content. If the media content contains a video stream, the <strong>SetCurrentPosition</strong> method typically seeks to the nearest key frame before the desired position. The distance between key frames depends on several factors, including the encoder implementation, the video content, and the particular encoding settings used to encode the content. The distance between key frame can vary within a single video file (for example, depending on scene complexity).</p><p>After seeking, the application should call <strong><see cref="M:SharpDX.MediaFoundation.SourceReader.ReadSample(SharpDX.MediaFoundation.SourceReaderIndex,SharpDX.MediaFoundation.SourceReaderControlFlags,System.Int32@,SharpDX.MediaFoundation.SourceReaderFlags@,System.Int64@)"/></strong> and advance to the desired position. </p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
            </remarks>	
            <msdn-id>dd374668</msdn-id>	
            <unmanaged>HRESULT IMFSourceReader::SetCurrentPosition([In] const GUID&amp; guidTimeFormat,[In] const PROPVARIANT&amp; varPosition)</unmanaged>	
            <unmanaged-short>IMFSourceReader::SetCurrentPosition</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.GetCurrentMediaType(SharpDX.MediaFoundation.SourceReaderIndex)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Gets the current media type for a stream.</p>	
            </summary>	
            <param name="readerIndex"><dd> <p>The stream to query. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream"/></strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream"/></strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>	
            <returns><dd> <p>Receives a reference to the <strong><see cref="T:SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface.</p> </dd></returns>	
            <remarks>	
            <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
            </remarks>	
            <msdn-id>dd374660</msdn-id>	
            <unmanaged>HRESULT IMFSourceReader::GetCurrentMediaType([In] unsigned int dwStreamIndex,[Out] IMFMediaType** ppMediaType)</unmanaged>	
            <unmanaged-short>IMFSourceReader::GetCurrentMediaType</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.ReadSample(SharpDX.MediaFoundation.SourceReaderIndex,SharpDX.MediaFoundation.SourceReaderControlFlags,System.Int32@,SharpDX.MediaFoundation.SourceReaderFlags@,System.Int64@)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Reads the next sample from the media source.</p>	
            </summary>	
            <param name="dwStreamIndex"><dd> <p>The stream to pull data from. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream"/></strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream"/></strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.AnyStream"/></strong></strong></dt> <dt>0xFFFFFFFE</dt> </dl> </td><td> <p>Get the next available sample, regardless of which stream.</p> </td></tr> </table> <p>?</p> </dd></param>	
            <param name="dwControlFlags"><dd> <p>A bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="T:SharpDX.MediaFoundation.SourceReaderControlFlags"/></strong> enumeration.</p> </dd></param>	
            <param name="dwActualStreamIndexRef"><dd> <p>Receives the zero-based index of the stream.</p> </dd></param>	
            <param name="dwStreamFlagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref="T:SharpDX.MediaFoundation.SourceReaderFlags"/></strong> enumeration.</p> </dd></param>	
            <param name="llTimestampRef"><dd> <p>Receives the time stamp of the sample, or the time of the stream event indicated in <em>pdwStreamFlags</em>. The time is given in 100-nanosecond units.</p> </dd></param>	
            <returns><dd> <p>Receives a reference to the <strong><see cref="T:SharpDX.MediaFoundation.Sample"/></strong> interface or the value <strong><c>null</c></strong> (see Remarks). If this parameter receives a non-<strong><c>null</c></strong> reference, the caller must release the interface.</p> </dd></returns>	
            <remarks>	
            <p>If the requested stream is not selected, the return code is <strong>MF_E_INVALIDREQUEST</strong>. See <strong><see cref="M:SharpDX.MediaFoundation.SourceReader.SetStreamSelection(SharpDX.MediaFoundation.SourceReaderIndex,SharpDX.Mathematics.Interop.RawBool)"/></strong>.</p><p> This method can complete synchronously or asynchronously. If you provide a callback reference when you create the source reader, the method is asynchronous. Otherwise, the method is synchronous. For more information about setting the callback reference, see <see cref="F:SharpDX.MediaFoundation.SourceReaderAttributeKeys.AsyncCallback"/>.</p>Asynchronous Mode<p>In asynchronous mode:</p><ul> <li>All of the <code>[out]</code> parameters must be <strong><c>null</c></strong>. Otherwise, the method returns <strong>E_INVALIDARG</strong>.</li> <li>The method returns immediately.</li> <li>When the operation completes, the application's <strong><see cref="M:SharpDX.MediaFoundation.SourceReaderCallback.OnReadSample(SharpDX.Result,System.Int32,System.Int32,System.Int64,SharpDX.MediaFoundation.Sample)"/></strong> method is called.</li> <li>If an error occurs, the method can fail either synchronously or asynchronously. Check the return value of <strong>ReadSample</strong>, and also check the <em>hrStatus</em> parameter of <strong><see cref="M:SharpDX.MediaFoundation.SourceReaderCallback.OnReadSample(SharpDX.Result,System.Int32,System.Int32,System.Int64,SharpDX.MediaFoundation.Sample)"/></strong>.</li> </ul>Synchronous Mode<p>In synchronous mode:</p><ul> <li>The <em>pdwStreamFlags</em> and <em>ppSample</em> parameters cannot be <strong><c>null</c></strong>. Otherwise, the method returns <strong>E_POINTER</strong>.</li> <li>The <em>pdwActualStreamIndex</em> and <em>pllTimestamp</em> parameters can be <strong><c>null</c></strong>.</li> <li>The method blocks until the next sample is available.</li> </ul><p> In synchronous mode, if the <em>dwStreamIndex</em> parameter is <strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.AnyStream"/></strong>, you should pass a non-<strong><c>null</c></strong> value for <em>pdwActualStreamIndex</em>, so that you know which stream delivered the sample.</p><p>This method can return flags in the <em>pdwStreamFlags</em> parameter without returning a media sample in <em>ppSample</em>. Therefore, the <em>ppSample</em> parameter can receive a <strong><c>null</c></strong> reference even when the method succeeds. For example, when the source reader reaches the end of the stream, it returns the <strong><see cref="!:SharpDX.MediaFoundation.SourceReaderFlags.FEndofstream"/></strong> flag in <em>pdwStreamFlags</em> and sets <em>ppSample</em> to <strong><c>null</c></strong>.</p><p>If there is a gap in the stream, <em>pdwStreamFlags</em> receives the <see cref="!:SharpDX.MediaFoundation.SourceReaderFlags.FStreamtick"/> flag, <em>ppSample</em> is <strong><c>null</c></strong>, and <em>pllTimestamp</em> indicates the time when the gap occurred. </p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
            </remarks>	
            <msdn-id>dd374665</msdn-id>	
            <unmanaged>HRESULT IMFSourceReader::ReadSample([In] unsigned int dwStreamIndex,[In] unsigned int dwControlFlags,[Out, Optional] unsigned int* pdwActualStreamIndex,[Out, Optional] unsigned int* pdwStreamFlags,[Out, Optional] longlong* pllTimestamp,[Out, Optional] IMFSample** ppSample)</unmanaged>	
            <unmanaged-short>IMFSourceReader::ReadSample</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.Flush(SharpDX.MediaFoundation.SourceReaderIndex)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Flushes one or more streams.</p>	
            </summary>	
            <param name="dwStreamIndex"><dd> <p>The stream to flush. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream" /></strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream" /></strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.AllStreams" /></strong></strong></dt> <dt>0xFFFFFFFE</dt> </dl> </td><td> <p>All streams.</p> </td></tr> </table> <p>?</p> </dd></param>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok" /></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result" /></strong> error code.</p></returns>	
            <remarks>	
            <p>The <strong>Flush</strong> method discards all queued samples and cancels all pending sample requests.</p><p>This method can complete either synchronously or asynchronously. If you provide a callback reference when you create the source reader, the method is asynchronous. Otherwise, the method is synchronous. For more information about the setting the callback reference, see <see cref="F:SharpDX.MediaFoundation.SourceReaderAttributeKeys.AsyncCallback" />.</p><p>In synchronous mode, the method blocks until the operation is complete.</p><p>In asynchronous mode, the application's <strong><see cref="M:SharpDX.MediaFoundation.SourceReaderCallback.OnFlush(System.Int32)" /></strong> method is called when the flush operation completes. While a flush operation is pending, the <strong><see cref="M:SharpDX.MediaFoundation.SourceReader.ReadSample(SharpDX.MediaFoundation.SourceReaderIndex,SharpDX.MediaFoundation.SourceReaderControlFlags,System.Int32@,SharpDX.MediaFoundation.SourceReaderFlags@,System.Int64@)" /></strong> method returns <strong>MF_E_NOTACCEPTING</strong>.</p><p><strong>Note</strong>??In Windows?7, there was a bug in the implementation of this method, which causes <strong>OnFlush</strong> to be called before the flush operation completes. A hotfix is available that fixes this bug. For more information, see http://support.microsoft.com/kb/979567.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IMFSourceReader::Flush']/*" />	
            <msdn-id>dd374659</msdn-id>	
            <unmanaged>HRESULT IMFSourceReader::Flush([In] unsigned int dwStreamIndex)</unmanaged>	
            <unmanaged-short>IMFSourceReader::Flush</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.GetServiceForStream(SharpDX.MediaFoundation.SourceReaderIndex,System.Guid,System.Guid)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Queries the underlying media source or decoder for an interface.</p>	
            </summary>	
            <param name="dwStreamIndex"><dd> <p>The stream or object to query. If the value is <strong><see cref="!:SharpDX.MediaFoundation.SourceReaderIndex.Mediasource"/></strong>, the method queries the media source. Otherwise, it queries the decoder that is associated with the specified stream. The following values are possible.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream"/></strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream"/></strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="!:SharpDX.MediaFoundation.SourceReaderIndex.Mediasource"/></strong></strong></dt> <dt>0xFFFFFFFF</dt> </dl> </td><td> <p>The media source.</p> </td></tr> </table> <p>?</p> </dd></param>	
            <param name="guidService"><dd> <p>A service identifier <see cref="T:System.Guid"/>.  If the value is <strong>GUID_NULL</strong>, the method calls <strong>QueryInterface</strong> to get the requested interface. Otherwise, the method calls the <strong><see cref="M:SharpDX.MediaFoundation.ServiceProvider.GetService(System.Guid,System.Guid)"/></strong> method. For a list of service identifiers, see Service Interfaces.</p> </dd></param>	
            <param name="riid"><dd> <p>The interface identifier (IID) of the interface being requested. </p> </dd></param>	
            <returns><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></returns>	
            <remarks>	
            <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
            </remarks>	
            <msdn-id>dd374663</msdn-id>	
            <unmanaged>HRESULT IMFSourceReader::GetServiceForStream([In] unsigned int dwStreamIndex,[In] const GUID&amp; guidService,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>	
            <unmanaged-short>IMFSourceReader::GetServiceForStream</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.GetPresentationAttribute``1(SharpDX.MediaFoundation.SourceReaderIndex,SharpDX.MediaFoundation.MediaAttributeKey{``0})">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Gets an attribute from the underlying media source.</p>	
            </summary>	
            <param name="dwStreamIndex"><dd> <p>The stream or object to query. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream"/></strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream"/></strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="!:SharpDX.MediaFoundation.SourceReaderIndex.Mediasource"/></strong></strong></dt> <dt>0xFFFFFFFF</dt> </dl> </td><td> <p>The media source.</p> </td></tr> </table> <p>?</p> </dd></param>	
            <param name="guidAttribute"><dd> <p>A <see cref="T:System.Guid"/> that identifies the attribute to retrieve. If the <em>dwStreamIndex</em> parameter equals  <strong><see cref="!:SharpDX.MediaFoundation.SourceReaderIndex.Mediasource"/></strong>, <em>guidAttribute</em> can specify one of the following:</p> <ul> <li>A presentation descriptor attribute. For a list of values, see Presentation Descriptor Attributes.</li> <li> <see cref="F:SharpDX.MediaFoundation.SourceReaderAttributeKeys.MediaSourceCharacteristics"/>. Use this value to get characteristics flags from the media source.</li> </ul> <p>Otherwise, if the <em>dwStreamIndex</em> parameter specifies a stream, <em>guidAttribute</em> specifies a stream descriptor attribute. For a list of values, see Stream Descriptor Attributes.</p> </dd></param>	
            <returns>a <strong><see cref="T:SharpDX.Win32.Variant"/></strong> that receives the value of the attribute.</returns>	
            <remarks>	
            <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
            </remarks>	
            <msdn-id>dd374662</msdn-id>	
            <unmanaged>HRESULT IMFSourceReader::GetPresentationAttribute([In] unsigned int dwStreamIndex,[In] const GUID&amp; guidAttribute,[Out] PROPVARIANT* pvarAttribute)</unmanaged>	
            <unmanaged-short>IMFSourceReader::GetPresentationAttribute</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.GetPresentationAttribute(SharpDX.MediaFoundation.SourceReaderIndex,System.Guid)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Gets an attribute from the underlying media source.</p>	
            </summary>	
            <param name="dwStreamIndex"><dd> <p>The stream or object to query. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream"/></strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="F:SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream"/></strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref="!:SharpDX.MediaFoundation.SourceReaderIndex.Mediasource"/></strong></strong></dt> <dt>0xFFFFFFFF</dt> </dl> </td><td> <p>The media source.</p> </td></tr> </table> <p>?</p> </dd></param>	
            <param name="guidAttribute"><dd> <p>A <see cref="T:System.Guid"/> that identifies the attribute to retrieve. If the <em>dwStreamIndex</em> parameter equals  <strong><see cref="!:SharpDX.MediaFoundation.SourceReaderIndex.Mediasource"/></strong>, <em>guidAttribute</em> can specify one of the following:</p> <ul> <li>A presentation descriptor attribute. For a list of values, see Presentation Descriptor Attributes.</li> <li> <see cref="F:SharpDX.MediaFoundation.SourceReaderAttributeKeys.MediaSourceCharacteristics"/>. Use this value to get characteristics flags from the media source.</li> </ul> <p>Otherwise, if the <em>dwStreamIndex</em> parameter specifies a stream, <em>guidAttribute</em> specifies a stream descriptor attribute. For a list of values, see Stream Descriptor Attributes.</p> </dd></param>	
            <returns>a <strong><see cref="T:SharpDX.Win32.Variant"/></strong> that receives the value of the attribute.</returns>	
            <remarks>	
            <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>	
            </remarks>	
            <msdn-id>dd374662</msdn-id>	
            <unmanaged>HRESULT IMFSourceReader::GetPresentationAttribute([In] unsigned int dwStreamIndex,[In] const GUID&amp; guidAttribute,[Out] PROPVARIANT* pvarAttribute)</unmanaged>	
            <unmanaged-short>IMFSourceReader::GetPresentationAttribute</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.GetStreamSelection(System.Int32,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Queries whether a stream is selected.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The stream to query. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "fSelectedRef"><dd> <p>Receives <strong>TRUE</strong> if the stream is selected and will generate data. Receives <strong><see cref = "F:SharpDX.Result.False"/></strong> if the stream is not selected and will not generate data.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374664</doc-id>
            <unmanaged>HRESULT IMFSourceReader::GetStreamSelection([In] DWORD dwStreamIndex,[Out] BOOL* pfSelected)</unmanaged>
            <unmanaged-short>IMFSourceReader::GetStreamSelection</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.SetStreamSelection(System.Int32,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Selects or deselects one or more streams.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The stream to set. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_ALL_STREAMS</strong></strong></dt> <dt>0xFFFFFFFE</dt> </dl> </td><td> <p>All streams.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "fSelected"><dd> <p>Specify <strong>TRUE</strong> to select streams or <strong><see cref = "F:SharpDX.Result.False"/></strong> to deselect streams. If a stream is deselected, it will not generate data.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>There are two common uses for this method:</p><ul> <li>To change the default stream selection. Some media files contain multiple streams of the same type. For example, a file might include audio streams for multiple languages. You can use this method to change which of the streams is selected. To get information about each stream, call <strong>IMFSourceReader::GetPresentationAttribute</strong> or <strong>IMFSourceReader::GetNativeMediaType</strong>.</li> <li>If you will not need data from one of the streams, it is a good idea to deselect that stream. If the stream is selected, the media source might hold onto a queue of unread data, and the queue might grow indefinitely, consuming memory. </li> </ul><p>For an example of deselecting a stream, see Tutorial: Decoding Audio.</p><p>If a stream is deselected, the <strong>IMFSourceReader::ReadSample</strong> method returns <strong><see cref = "!:InvalidRequest"/></strong> for that stream. Other <strong><see cref = "T:SharpDX.MediaFoundation.SourceReader"/></strong> methods are valid for deselected streams.</p><p>Stream selection does not affect how the source reader loads or unloads decoders in memory. In particular, deselecting a stream does not force the source reader to unload the decoder for that stream.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374669</doc-id>
            <unmanaged>HRESULT IMFSourceReader::SetStreamSelection([In] DWORD dwStreamIndex,[In] BOOL fSelected)</unmanaged>
            <unmanaged-short>IMFSourceReader::SetStreamSelection</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.GetNativeMediaType(System.Int32,System.Int32)">
            <summary>
            <p>Gets a format that is supported natively by the media source.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>Specifies which stream to query. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "dwMediaTypeIndex"><dd> <p>The zero-based index of the media type to retrieve.</p> </dd></param>
            <returns><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface.</p> </dd></returns>
            <remarks>
            <p>This method queries the underlying media source for its native output format. Potentially, each source stream can produce more than one output format. Use the <em>dwMediaTypeIndex</em> parameter to loop through the available formats. Generally, file sources offer just one format per stream, but capture devices might offer several formats.</p><p> The method returns a copy of the media type, so it is safe to modify the object received in the <em> ppMediaType</em> parameter.</p><p>To set  the output type for a stream, call the <strong>IMFSourceReader::SetCurrentMediaType</strong> method.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374661</doc-id>
            <unmanaged>HRESULT IMFSourceReader::GetNativeMediaType([In] DWORD dwStreamIndex,[In] DWORD dwMediaTypeIndex,[Out] IMFMediaType** ppMediaType)</unmanaged>
            <unmanaged-short>IMFSourceReader::GetNativeMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.GetCurrentMediaType(System.Int32)">
            <summary>
            <p>Gets the current media type for a stream.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The stream to query. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>
            <returns><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface.</p> </dd></returns>
            <remarks>
            <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374660</doc-id>
            <unmanaged>HRESULT IMFSourceReader::GetCurrentMediaType([In] DWORD dwStreamIndex,[Out] IMFMediaType** ppMediaType)</unmanaged>
            <unmanaged-short>IMFSourceReader::GetCurrentMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.SetCurrentMediaType(System.Int32,System.IntPtr,SharpDX.MediaFoundation.MediaType)">
            <summary>
            <p>Sets the media type for a stream.</p><p>This media type defines that format that the Source Reader produces as output. It can differ from the native format provided by the media source. See Remarks for more information.</p>
            </summary>
            <param name = "dwStreamIndex">No documentation.</param>
            <param name = "dwReservedRef">No documentation.</param>
            <param name = "mediaTypeRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidMediaType"/></strong></strong></dt> </dl> </td><td> <p>At least one decoder was found for the native stream type, but the type specified by <em>pMediaType</em> was rejected.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>One or more sample requests are still pending.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidStreamNumber"/></strong></strong></dt> </dl> </td><td> <p>The <em>dwStreamIndex</em> parameter is invalid.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:TopoCodecNotFound"/></strong></strong></dt> </dl> </td><td> <p>Could not find a decoder for the native stream type.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>For each stream, you can set the media type to any of the following:</p><ul> <li>One of the native types offered by the media source. To enumerate the native types, call <strong>IMFSourceReader::GetNativeMediaType</strong>.</li> <li>If the native media type is compressed, you can specify a corresponding uncompressed format. The Source Reader will search for a decoder that can decode from the native format to the specified uncompressed format.</li> </ul><p>Audio resampling support was added to the source reader with Windows?8.  In versions of Windows prior to  Windows?8, the source reader does not support audio resampling. If you need to resample the audio in versions of Windows earlier than Windows?8, you can use the <strong>Audio Resampler DSP</strong>.</p><p>If you set the <see cref = "!:EnableVideoProcessing"/> attribute to <strong>TRUE</strong> when you create the Source Reader, the Source Reader will convert YUV video to RGB-32. This conversion is not optimized for real-time video playback.</p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374667</doc-id>
            <unmanaged>HRESULT IMFSourceReader::SetCurrentMediaType([In] DWORD dwStreamIndex,[In] DWORD* pdwReserved,[In] IMFMediaType* pMediaType)</unmanaged>
            <unmanaged-short>IMFSourceReader::SetCurrentMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.SetCurrentPosition(System.Guid,SharpDX.Win32.Variant)">
            <summary>
            <p>Seeks to a new position in the media source.</p>
            </summary>
            <param name = "guidTimeFormat"><dd> <p>A <see cref = "T:System.Guid"/> that specifies the <em>time format</em>. The time format defines the units for the <em>varPosition</em> parameter. The following value is defined for all media sources:</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>GUID_NULL</strong></dt> </dl> </td><td> <p>100-nanosecond units.</p> </td></tr> </table> <p>?</p> <p>Some media sources might support additional values. </p> </dd></param>
            <param name = "varPosition"><dd> <p>The position from which playback will be started. The units are specified by the <em>guidTimeFormat</em> parameter. If the <em>guidTimeFormat</em> parameter is <strong>GUID_NULL</strong>, set the variant type to <strong>VT_I8</strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>One or more sample requests are still pending.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The <strong>SetCurrentPosition</strong> method does not guarantee exact seeking. The accuracy of the seek depends on the media content. If the media content contains a video stream, the <strong>SetCurrentPosition</strong> method typically seeks to the nearest key frame before the desired position. The distance between key frames depends on several factors, including the encoder implementation, the video content, and the particular encoding settings used to encode the content. The distance between key frame can vary within a single video file (for example, depending on scene complexity).</p><p>After seeking, the application should call <strong>IMFSourceReader::ReadSample</strong> and advance to the desired position. </p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374668</doc-id>
            <unmanaged>HRESULT IMFSourceReader::SetCurrentPosition([In] const GUID&amp; guidTimeFormat,[In] const PROPVARIANT&amp; varPosition)</unmanaged>
            <unmanaged-short>IMFSourceReader::SetCurrentPosition</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.ReadSample(System.Int32,SharpDX.MediaFoundation.SourceReaderControlFlags,System.Int32@,SharpDX.MediaFoundation.SourceReaderFlags@,System.Int64@)">
            <summary>
            <p>Reads the next sample from the media source.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The stream to pull data from. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_ANY_STREAM</strong></strong></dt> <dt>0xFFFFFFFE</dt> </dl> </td><td> <p>Get the next available sample, regardless of which stream.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "dwControlFlags"><dd> <p>A bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.SourceReaderControlFlags"/></strong> enumeration.</p> </dd></param>
            <param name = "dwActualStreamIndexRef"><dd> <p>Receives the zero-based index of the stream.</p> </dd></param>
            <param name = "dwStreamFlagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.SourceReaderFlags"/></strong> enumeration.</p> </dd></param>
            <param name = "llTimestampRef"><dd> <p>Receives the time stamp of the sample, or the time of the stream event indicated in <em>pdwStreamFlags</em>. The time is given in 100-nanosecond units.</p> </dd></param>
            <returns><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface or the value <strong><c>null</c></strong> (see Remarks). If this parameter receives a non-<strong><c>null</c></strong> reference, the caller must release the interface.</p> </dd></returns>
            <remarks>
            <p>If the requested stream is not selected, the return code is <strong><see cref = "!:InvalidRequest"/></strong>. See <strong>IMFSourceReader::SetStreamSelection</strong>.</p><p> This method can complete synchronously or asynchronously. If you provide a callback reference when you create the source reader, the method is asynchronous. Otherwise, the method is synchronous. For more information about setting the callback reference, see <see cref = "!:AsyncCallback"/>.</p>
            </remarks>
            <doc-id>dd374665</doc-id>
            <unmanaged>HRESULT IMFSourceReader::ReadSample([In] DWORD dwStreamIndex,[In] DWORD dwControlFlags,[Out, Optional] DWORD* pdwActualStreamIndex,[Out, Optional] DWORD* pdwStreamFlags,[Out, Optional] longlong* pllTimestamp,[Out, Optional] IMFSample** ppSample)</unmanaged>
            <unmanaged-short>IMFSourceReader::ReadSample</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.Flush(System.Int32)">
            <summary>
            <p>Flushes one or more streams.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The stream to flush. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_ALL_STREAMS</strong></strong></dt> <dt>0xFFFFFFFE</dt> </dl> </td><td> <p>All streams.</p> </td></tr> </table> <p>?</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The <strong>Flush</strong> method discards all queued samples and cancels all pending sample requests.</p><p>This method can complete either synchronously or asynchronously. If you provide a callback reference when you create the source reader, the method is asynchronous. Otherwise, the method is synchronous. For more information about the setting the callback reference, see <see cref = "!:AsyncCallback"/>.</p><p>In synchronous mode, the method blocks until the operation is complete.</p><p>In asynchronous mode, the application's <strong>IMFSourceReaderCallback::OnFlush</strong> method is called when the flush operation completes. While a flush operation is pending, the <strong>IMFSourceReader::ReadSample</strong> method returns <strong><see cref = "!:NotAccepting"/></strong>.</p><strong>Note</strong>??In Windows?7, there was a bug in the implementation of this method, which causes <strong>OnFlush</strong> to be called before the flush operation completes. A hotfix is available that fixes this bug. For more information, see http://support.microsoft.com/kb/979567.?<p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374659</doc-id>
            <unmanaged>HRESULT IMFSourceReader::Flush([In] DWORD dwStreamIndex)</unmanaged>
            <unmanaged-short>IMFSourceReader::Flush</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.GetServiceForStream(System.Int32,System.Guid,System.Guid)">
            <summary>
            <p>Queries the underlying media source or decoder for an interface.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The stream or object to query. If the value is <strong>MF_SOURCE_READER_MEDIASOURCE</strong>, the method queries the media source. Otherwise, it queries the decoder that is associated with the specified stream. The following values are possible.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_MEDIASOURCE</strong></strong></dt> <dt>0xFFFFFFFF</dt> </dl> </td><td> <p>The media source.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "guidService"><dd> <p>A service identifier <see cref = "T:System.Guid"/>.  If the value is <strong>GUID_NULL</strong>, the method calls <strong>QueryInterface</strong> to get the requested interface. Otherwise, the method calls the <strong>IMFGetService::GetService</strong> method. For a list of service identifiers, see Service Interfaces.</p> </dd></param>
            <param name = "riid"><dd> <p>The interface identifier (IID) of the interface being requested. </p> </dd></param>
            <returns><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></returns>
            <remarks>
            <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374663</doc-id>
            <unmanaged>HRESULT IMFSourceReader::GetServiceForStream([In] DWORD dwStreamIndex,[In] const GUID&amp; guidService,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>
            <unmanaged-short>IMFSourceReader::GetServiceForStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReader.GetPresentationAttribute(System.Int32,System.Guid)">
            <summary>
            <p>Gets an attribute from the underlying media source.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The stream or object to query. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_MEDIASOURCE</strong></strong></dt> <dt>0xFFFFFFFF</dt> </dl> </td><td> <p>The media source.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "guidAttribute"><dd> <p>A <see cref = "T:System.Guid"/> that identifies the attribute to retrieve. If the <em>dwStreamIndex</em> parameter equals  <strong>MF_SOURCE_READER_MEDIASOURCE</strong>, <em>guidAttribute</em> can specify one of the following:</p> <ul> <li>A presentation descriptor attribute. For a list of values, see Presentation Descriptor Attributes.</li> <li> <see cref = "T:SharpDX.MediaFoundation.MediaSourceCharacteristics"/>. Use this value to get characteristics flags from the media source.</li> </ul> <p>Otherwise, if the <em>dwStreamIndex</em> parameter specifies a stream, <em>guidAttribute</em> specifies a stream descriptor attribute. For a list of values, see Stream Descriptor Attributes.</p> </dd></param>
            <returns><dd> <p>A reference to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that receives the value of the attribute. Call the <strong>PropVariantClear</strong> function to free the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong>. </p> </dd></returns>
            <remarks>
            <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374662</doc-id>
            <unmanaged>HRESULT IMFSourceReader::GetPresentationAttribute([In] DWORD dwStreamIndex,[In] const GUID&amp; guidAttribute,[Out] PROPVARIANT* pvarAttribute)</unmanaged>
            <unmanaged-short>IMFSourceReader::GetPresentationAttribute</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceResolver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.MediaFoundation.SourceResolver"/> class which is used to create a media source from a 
            URL or byte stream.
            </summary>
            <msdn-id>ms697433</msdn-id>	
            <unmanaged>HRESULT MFCreateSourceResolver([Out] IMFSourceResolver** ppISourceResolver)</unmanaged>	
            <unmanaged-short>MFCreateSourceResolver</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceResolver.CreateObjectFromURL(System.String,SharpDX.MediaFoundation.SourceResolverFlags)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Creates a media source or a byte stream from a URL. This method is synchronous. </p>	
            </summary>	
            <param name="url"><dd> <p> Null-terminated string that contains the URL to resolve. </p> </dd></param>	
            <param name="flags"><dd> <p> Bitwise OR of one or more flags. See <strong>Source Resolver Flags</strong>. </p> </dd></param>	
            <returns>A reference to the object's <strong><see cref="T:SharpDX.ComObject"/></strong> interface. The caller must release the interface.</returns>	
            <remarks>	
            <p>The <em>dwFlags</em> parameter must contain either the <strong><see cref="F:SharpDX.MediaFoundation.SourceResolverFlags.MediaSource"/></strong> flag or the <strong><see cref="F:SharpDX.MediaFoundation.SourceResolverFlags.ByteStream"/></strong> flag, but should not contain both.</p><p>For local files, you can pass the file name in the <em>pwszURL</em> parameter; the <code>file:</code> scheme is not required.</p><p><strong>Note</strong>??This method cannot be called remotely.</p>	
            </remarks>	
            <msdn-id>ms702279</msdn-id>	
            <unmanaged>HRESULT IMFSourceResolver::CreateObjectFromURL([In] const wchar_t* pwszURL,[In] unsigned int dwFlags,[In] IPropertyStore* pProps,[Out] MF_OBJECT_TYPE* pObjectType,[Out] IUnknown** ppObject)</unmanaged>	
            <unmanaged-short>IMFSourceResolver::CreateObjectFromURL</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceResolver.CreateObjectFromURL(System.String,SharpDX.MediaFoundation.SourceResolverFlags,SharpDX.MediaFoundation.ObjectType@)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Creates a media source or a byte stream from a URL. This method is synchronous. </p>	
            </summary>	
            <param name="url"><dd> <p> Null-terminated string that contains the URL to resolve. </p> </dd></param>	
            <param name="flags"><dd> <p> Bitwise OR of one or more flags. See <strong>Source Resolver Flags</strong>. </p> </dd></param>	
            <param name="objectType"><dd> <p> Receives a member of the <strong><see cref="T:SharpDX.MediaFoundation.ObjectType"/></strong> enumeration, specifying the type of object that was created. </p> </dd></param>	
            <returns>A reference to the object's <strong><see cref="T:SharpDX.ComObject"/></strong> interface. The caller must release the interface.</returns>	
            <remarks>	
            <p>The <em>dwFlags</em> parameter must contain either the <strong><see cref="F:SharpDX.MediaFoundation.SourceResolverFlags.MediaSource"/></strong> flag or the <strong><see cref="F:SharpDX.MediaFoundation.SourceResolverFlags.ByteStream"/></strong> flag, but should not contain both.</p><p>For local files, you can pass the file name in the <em>pwszURL</em> parameter; the <code>file:</code> scheme is not required.</p><p><strong>Note</strong>??This method cannot be called remotely.</p>	
            </remarks>	
            <msdn-id>ms702279</msdn-id>	
            <unmanaged>HRESULT IMFSourceResolver::CreateObjectFromURL([In] const wchar_t* pwszURL,[In] unsigned int dwFlags,[In] IPropertyStore* pProps,[Out] MF_OBJECT_TYPE* pObjectType,[Out] IUnknown** ppObject)</unmanaged>	
            <unmanaged-short>IMFSourceResolver::CreateObjectFromURL</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceResolver.CreateObjectFromURL(System.String,SharpDX.MediaFoundation.SourceResolverFlags,SharpDX.ComObject,SharpDX.MediaFoundation.ObjectType@)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Creates a media source or a byte stream from a URL. This method is synchronous. </p>	
            </summary>	
            <param name="url"><dd> <p> Null-terminated string that contains the URL to resolve. </p> </dd></param>	
            <param name="flags"><dd> <p> Bitwise OR of one or more flags. See <strong>Source Resolver Flags</strong>. </p> </dd></param>	
            <param name="propertyStore"><dd> <p> Pointer to the <strong><see cref="T:SharpDX.ComObject"/></strong> interface of a property store. The method passes the property store to the scheme handler or byte-stream handler that creates the object. The handler can use the property store to configure the object. This parameter can be <strong><c>null</c></strong>. For more information, see Configuring a Media Source. </p> </dd></param>	
            <param name="objectType"><dd> <p> Receives a member of the <strong><see cref="T:SharpDX.MediaFoundation.ObjectType"/></strong> enumeration, specifying the type of object that was created. </p> </dd></param>	
            <returns>A reference to the object's <strong><see cref="T:SharpDX.ComObject"/></strong> interface. The caller must release the interface.</returns>	
            <remarks>	
            <p>The <em>dwFlags</em> parameter must contain either the <strong><see cref="F:SharpDX.MediaFoundation.SourceResolverFlags.MediaSource"/></strong> flag or the <strong><see cref="F:SharpDX.MediaFoundation.SourceResolverFlags.ByteStream"/></strong> flag, but should not contain both.</p><p>For local files, you can pass the file name in the <em>pwszURL</em> parameter; the <code>file:</code> scheme is not required.</p><p><strong>Note</strong>??This method cannot be called remotely.</p>	
            </remarks>	
            <msdn-id>ms702279</msdn-id>	
            <unmanaged>HRESULT IMFSourceResolver::CreateObjectFromURL([In] const wchar_t* pwszURL,[In] unsigned int dwFlags,[In] IPropertyStore* pProps,[Out] MF_OBJECT_TYPE* pObjectType,[Out] IUnknown** ppObject)</unmanaged>	
            <unmanaged-short>IMFSourceResolver::CreateObjectFromURL</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceResolver.CreateObjectFromStream(SharpDX.MediaFoundation.ByteStream,System.String,SharpDX.MediaFoundation.SourceResolverFlags)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Creates a media source from a byte stream. This method is synchronous. </p>	
            </summary>	
            <param name="stream"><dd> <p> Pointer to the byte stream's <strong><see cref="T:SharpDX.MediaFoundation.IByteStream"/></strong> interface. </p> </dd></param>	
            <param name="url"><dd> <p> Null-terminated string that contains the URL of the byte stream. The URL is optional and can be <strong><c>null</c></strong>. See Remarks for more information. </p> </dd></param>	
            <param name="flags"><dd> <p> Bitwise <strong>OR</strong> of flags. See <strong>Source Resolver Flags</strong>. </p> </dd></param>	
            <returns>a reference to the media source's <strong><see cref="T:SharpDX.ComObject"/></strong> interface. The caller must release the interface.</returns>	
            <remarks>	
            <p>The <em>dwFlags</em> parameter must contain the <strong><see cref="F:SharpDX.MediaFoundation.SourceResolverFlags.MediaSource"/></strong> flag and should not contain the <strong><see cref="F:SharpDX.MediaFoundation.SourceResolverFlags.ByteStream"/></strong> flag.</p><p>The source resolver attempts to find one or more byte-stream handlers for the byte stream, based on the file name extension of the URL, or the MIME type of the byte stream (or both). The URL is specified in the optional <em>pwszURL</em> parameter, and the MIME type may be specified in the <strong><see cref="F:SharpDX.MediaFoundation.ByteStreamAttributeKeys.ContentType"/></strong> attribute on the byte stream. Byte-stream handlers are registered by file name extension or MIME type, or both, as described in Scheme Handlers and Byte-Stream Handlers. The caller should specify at least one of these values (both if possible):</p><ul> <li> Specify the URL in the <em>pwszURL</em> parameter. </li> <li> Specify the MIME type by setting the <strong><see cref="F:SharpDX.MediaFoundation.ByteStreamAttributeKeys.ContentType"/></strong> attribute on the byte stream. (This attribute might be set already when you create the byte stream, depending on how the byte stream was created.) </li> </ul><p><strong>Note</strong>??This method cannot be called remotely.</p>	
            </remarks>	
            <msdn-id>ms704671</msdn-id>	
            <unmanaged>HRESULT IMFSourceResolver::CreateObjectFromByteStream([In] IMFByteStream* pByteStream,[In] const wchar_t* pwszURL,[In] unsigned int dwFlags,[In] IPropertyStore* pProps,[Out] MF_OBJECT_TYPE* pObjectType,[Out] IUnknown** ppObject)</unmanaged>	
            <unmanaged-short>IMFSourceResolver::CreateObjectFromByteStream</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceResolver.CreateObjectFromStream(SharpDX.MediaFoundation.ByteStream,System.String,SharpDX.MediaFoundation.SourceResolverFlags,SharpDX.MediaFoundation.ObjectType@)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Creates a media source from a byte stream. This method is synchronous. </p>	
            </summary>	
            <param name="stream"><dd> <p> Pointer to the byte stream's <strong><see cref="T:SharpDX.MediaFoundation.IByteStream"/></strong> interface. </p> </dd></param>	
            <param name="url"><dd> <p> Null-terminated string that contains the URL of the byte stream. The URL is optional and can be <strong><c>null</c></strong>. See Remarks for more information. </p> </dd></param>	
            <param name="flags"><dd> <p> Bitwise <strong>OR</strong> of flags. See <strong>Source Resolver Flags</strong>. </p> </dd></param>	
            <param name="objectType"><dd> <p> Receives a member of the <strong><see cref="T:SharpDX.MediaFoundation.ObjectType"/></strong> enumeration, specifying the type of object that was created. </p> </dd></param>	
            <returns>a reference to the media source's <strong><see cref="T:SharpDX.ComObject"/></strong> interface. The caller must release the interface.</returns>	
            <remarks>	
            <p>The <em>dwFlags</em> parameter must contain the <strong><see cref="F:SharpDX.MediaFoundation.SourceResolverFlags.MediaSource"/></strong> flag and should not contain the <strong><see cref="F:SharpDX.MediaFoundation.SourceResolverFlags.ByteStream"/></strong> flag.</p><p>The source resolver attempts to find one or more byte-stream handlers for the byte stream, based on the file name extension of the URL, or the MIME type of the byte stream (or both). The URL is specified in the optional <em>pwszURL</em> parameter, and the MIME type may be specified in the <strong><see cref="F:SharpDX.MediaFoundation.ByteStreamAttributeKeys.ContentType"/></strong> attribute on the byte stream. Byte-stream handlers are registered by file name extension or MIME type, or both, as described in Scheme Handlers and Byte-Stream Handlers. The caller should specify at least one of these values (both if possible):</p><ul> <li> Specify the URL in the <em>pwszURL</em> parameter. </li> <li> Specify the MIME type by setting the <strong><see cref="F:SharpDX.MediaFoundation.ByteStreamAttributeKeys.ContentType"/></strong> attribute on the byte stream. (This attribute might be set already when you create the byte stream, depending on how the byte stream was created.) </li> </ul><p><strong>Note</strong>??This method cannot be called remotely.</p>	
            </remarks>	
            <msdn-id>ms704671</msdn-id>	
            <unmanaged>HRESULT IMFSourceResolver::CreateObjectFromByteStream([In] IMFByteStream* pByteStream,[In] const wchar_t* pwszURL,[In] unsigned int dwFlags,[In] IPropertyStore* pProps,[Out] MF_OBJECT_TYPE* pObjectType,[Out] IUnknown** ppObject)</unmanaged>	
            <unmanaged-short>IMFSourceResolver::CreateObjectFromByteStream</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceResolver.CreateObjectFromStream(SharpDX.MediaFoundation.ByteStream,System.String,SharpDX.MediaFoundation.SourceResolverFlags,SharpDX.ComObject,SharpDX.MediaFoundation.ObjectType@)">
            <summary>	
            <p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p> Creates a media source from a byte stream. This method is synchronous. </p>	
            </summary>	
            <param name="stream"><dd> <p> Pointer to the byte stream's <strong><see cref="T:SharpDX.MediaFoundation.IByteStream"/></strong> interface. </p> </dd></param>	
            <param name="url"><dd> <p> Null-terminated string that contains the URL of the byte stream. The URL is optional and can be <strong><c>null</c></strong>. See Remarks for more information. </p> </dd></param>	
            <param name="flags"><dd> <p> Bitwise <strong>OR</strong> of flags. See <strong>Source Resolver Flags</strong>. </p> </dd></param>	
            <param name="propertyStore"><dd> <p> Pointer to the <strong><see cref="T:SharpDX.ComObject"/></strong> interface of a property store. The method passes the property store to the byte-stream handler. The byte-stream handler can use the property store to configure the media source. This parameter can be <strong><c>null</c></strong>. For more information, see Configuring a Media Source. </p> </dd></param>	
            <param name="objectType"><dd> <p> Receives a member of the <strong><see cref="T:SharpDX.MediaFoundation.ObjectType"/></strong> enumeration, specifying the type of object that was created. </p> </dd></param>	
            <returns>a reference to the media source's <strong><see cref="T:SharpDX.ComObject"/></strong> interface. The caller must release the interface.</returns>	
            <remarks>	
            <p>The <em>dwFlags</em> parameter must contain the <strong><see cref="F:SharpDX.MediaFoundation.SourceResolverFlags.MediaSource"/></strong> flag and should not contain the <strong><see cref="F:SharpDX.MediaFoundation.SourceResolverFlags.ByteStream"/></strong> flag.</p><p>The source resolver attempts to find one or more byte-stream handlers for the byte stream, based on the file name extension of the URL, or the MIME type of the byte stream (or both). The URL is specified in the optional <em>pwszURL</em> parameter, and the MIME type may be specified in the <strong><see cref="F:SharpDX.MediaFoundation.ByteStreamAttributeKeys.ContentType"/></strong> attribute on the byte stream. Byte-stream handlers are registered by file name extension or MIME type, or both, as described in Scheme Handlers and Byte-Stream Handlers. The caller should specify at least one of these values (both if possible):</p><ul> <li> Specify the URL in the <em>pwszURL</em> parameter. </li> <li> Specify the MIME type by setting the <strong><see cref="F:SharpDX.MediaFoundation.ByteStreamAttributeKeys.ContentType"/></strong> attribute on the byte stream. (This attribute might be set already when you create the byte stream, depending on how the byte stream was created.) </li> </ul><p><strong>Note</strong>??This method cannot be called remotely.</p>	
            </remarks>	
            <msdn-id>ms704671</msdn-id>	
            <unmanaged>HRESULT IMFSourceResolver::CreateObjectFromByteStream([In] IMFByteStream* pByteStream,[In] const wchar_t* pwszURL,[In] unsigned int dwFlags,[In] IPropertyStore* pProps,[Out] MF_OBJECT_TYPE* pObjectType,[Out] IUnknown** ppObject)</unmanaged>	
            <unmanaged-short>IMFSourceResolver::CreateObjectFromByteStream</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceResolver.CreateObjectFromURL(System.String,System.Int32,SharpDX.ComObject,SharpDX.MediaFoundation.ObjectType@,SharpDX.IUnknown@)">
            <summary>
            <p> Creates a media source or a byte stream from a URL. This method is synchronous. </p>
            </summary>
            <param name = "wszURLRef"><dd> <p> Null-terminated string that contains the URL to resolve. </p> </dd></param>
            <param name = "dwFlags"><dd> <p> Bitwise OR of one or more flags. See <strong>Source Resolver Flags</strong>. See remarks below.</p> </dd></param>
            <param name = "propsRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.ComObject"/></strong> interface of a property store. The method passes the property store to the scheme handler or byte-stream handler that creates the object. The handler can use the property store to configure the object. This parameter can be <strong><c>null</c></strong>. For more information, see Configuring a Media Source. </p> </dd></param>
            <param name = "objectTypeRef"><dd> <p> Receives a member of the <strong><see cref = "T:SharpDX.MediaFoundation.ObjectType"/></strong> enumeration, specifying the type of object that was created. </p> </dd></param>
            <param name = "objectOut"><dd> <p> Receives a reference to the object's <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:SourceResolverMutuallyExclusiveFlags"/></strong></dt> </dl> </td><td> <p> The <em>dwFlags</em> parameter contains mutually exclusive flags. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedScheme"/></strong></dt> </dl> </td><td> <p> The URL scheme is not supported. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The <em>dwFlags</em> parameter must contain either the <strong>MF_RESOLUTION_MEDIASOURCE</strong> flag or the <strong>MF_RESOLUTION_BYTESTREAM</strong> flag, but should not contain both.</p><p>It is recommended that you do not set <strong>MF_RESOLUTION_WRITE</strong> on the input argument <em>dwFlags</em> unless it is necessary for your scenario. For most use-cases, media sources do not need to be created with write capability. Creating a media source with write capability may have a lower probability of success than creating a media source without write capability. This is because there can be stricter checks on the content represented by the URL when creating a media source with write capability.</p><p>For local files, you can pass the file name in the <em>pwszURL</em> parameter; the <code>file:</code> scheme is not required.</p><strong>Note</strong>??This method cannot be called remotely.?
            </remarks>
            <doc-id>ms702279</doc-id>
            <unmanaged>HRESULT IMFSourceResolver::CreateObjectFromURL([In] const wchar_t* pwszURL,[In] DWORD dwFlags,[In] IPropertyStore* pProps,[Out] MF_OBJECT_TYPE* pObjectType,[Out] IUnknown** ppObject)</unmanaged>
            <unmanaged-short>IMFSourceResolver::CreateObjectFromURL</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceResolver.CreateObjectFromByteStream(SharpDX.MediaFoundation.IByteStream,System.String,System.Int32,SharpDX.ComObject,SharpDX.MediaFoundation.ObjectType@,SharpDX.IUnknown@)">
            <summary>
            <p> Creates a media source from a byte stream. This method is synchronous. </p>
            </summary>
            <param name = "byteStreamRef"><dd> <p> Pointer to the byte stream's <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface. </p> </dd></param>
            <param name = "wszURLRef"><dd> <p> Null-terminated string that contains the URL of the byte stream. The URL is optional and can be <strong><c>null</c></strong>. See Remarks for more information. </p> </dd></param>
            <param name = "dwFlags"><dd> <p> Bitwise <strong>OR</strong> of flags. See <strong>Source Resolver Flags</strong>. </p> </dd></param>
            <param name = "propsRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.ComObject"/></strong> interface of a property store. The method passes the property store to the byte-stream handler. The byte-stream handler can use the property store to configure the media source. This parameter can be <strong><c>null</c></strong>. For more information, see Configuring a Media Source. </p> </dd></param>
            <param name = "objectTypeRef"><dd> <p> Receives a member of the <strong><see cref = "T:SharpDX.MediaFoundation.ObjectType"/></strong> enumeration, specifying the type of object that was created. </p> </dd></param>
            <param name = "objectOut"><dd> <p> Receives a reference to the media source's <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:SourceResolverMutuallyExclusiveFlags"/></strong></dt> </dl> </td><td> <p> The <em>dwFlags</em> parameter contains mutually exclusive flags. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedByteStreamType"/></strong></dt> </dl> </td><td> <p> This byte stream is not supported. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The <em>dwFlags</em> parameter must contain the <strong>MF_RESOLUTION_MEDIASOURCE</strong> flag and should not contain the <strong>MF_RESOLUTION_BYTESTREAM</strong> flag.</p><p>The source resolver attempts to find one or more byte-stream handlers for the byte stream, based on the file name extension of the URL, or the MIME type of the byte stream (or both). The URL is specified in the optional <em>pwszURL</em> parameter, and the MIME type may be specified in the <strong><see cref = "!:ContentType"/></strong> attribute on the byte stream. Byte-stream handlers are registered by file name extension or MIME type, or both, as described in Scheme Handlers and Byte-Stream Handlers. The caller should specify at least one of these values (both if possible):</p><ul> <li> Specify the URL in the <em>pwszURL</em> parameter. </li> <li> Specify the MIME type by setting the <strong><see cref = "!:ContentType"/></strong> attribute on the byte stream. (This attribute might be set already when you create the byte stream, depending on how the byte stream was created.) </li> </ul><strong>Note</strong>??This method cannot be called remotely.?
            </remarks>
            <doc-id>ms704671</doc-id>
            <unmanaged>HRESULT IMFSourceResolver::CreateObjectFromByteStream([In] IMFByteStream* pByteStream,[In] const wchar_t* pwszURL,[In] DWORD dwFlags,[In] IPropertyStore* pProps,[Out] MF_OBJECT_TYPE* pObjectType,[Out] IUnknown** ppObject)</unmanaged>
            <unmanaged-short>IMFSourceResolver::CreateObjectFromByteStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceResolver.BeginCreateObjectFromURL(System.String,System.Int32,SharpDX.ComObject,SharpDX.IUnknown@,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Begins an asynchronous request to create a media source or a byte stream from a URL.</p>
            </summary>
            <param name = "wszURLRef"><dd> <p>Null-terminated string that contains the URL to resolve.</p> </dd></param>
            <param name = "dwFlags"><dd> <p>Bitwise OR of flags. See <strong>Source Resolver Flags</strong>.</p> </dd></param>
            <param name = "propsRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.ComObject"/></strong> interface of a property store. The method passes the property store to the scheme handler or byte-stream handler that creates the object. The handler can use the property store to configure the object. This parameter can be <strong><c>null</c></strong>. For more information, see Configuring a Media Source.</p> </dd></param>
            <param name = "iUnknownCancelCookieOut"><dd> <p>Receives an <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference or the value <strong><c>null</c></strong>. If the value is not <strong><c>null</c></strong>, you can cancel the asynchronous operation by passing this reference to the <strong>IMFSourceResolver::CancelObjectCreation</strong> method. The caller must release the interface. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "callbackRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>
            <param name = "unkStateRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:SourceResolverMutuallyExclusiveFlags"/></strong></dt> </dl> </td><td> <p>The <em>dwFlags</em> parameter contains mutually exclusive flags.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedScheme"/></strong></dt> </dl> </td><td> <p>The URL scheme is not supported.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The <em>dwFlags</em> parameter must contain either the MF_RESOLUTION_MEDIASOURCE flag or the MF_RESOLUTION_BYTESTREAM flag, but should not contain both.</p><p>For local files, you can pass the file name in the <em>pwszURL</em> parameter; the <code>file:</code> scheme is not required.</p><p>When the operation completes, the source resolver calls the <strong>IMFAsyncCallback::Invoke</strong> method. The <strong>Invoke</strong> method should call <strong>IMFSourceResolver::EndCreateObjectFromURL</strong> to get a reference to the object that was created.</p><p>The usage of the <em>pProps</em> parameter depends on the implementation of the media source. </p>
            </remarks>
            <doc-id>ms702995</doc-id>
            <unmanaged>HRESULT IMFSourceResolver::BeginCreateObjectFromURL([In] const wchar_t* pwszURL,[In] DWORD dwFlags,[In] IPropertyStore* pProps,[Out, Optional] IUnknown** ppIUnknownCancelCookie,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>
            <unmanaged-short>IMFSourceResolver::BeginCreateObjectFromURL</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceResolver.EndCreateObjectFromURL(SharpDX.MediaFoundation.AsyncResult,SharpDX.MediaFoundation.ObjectType@,SharpDX.IUnknown@)">
            <summary>
            <p> Completes an asynchronous request to create an object from a URL. </p>
            </summary>
            <param name = "resultRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>Invoke</strong> method. </p> </dd></param>
            <param name = "objectTypeRef"><dd> <p> Receives a member of the <strong><see cref = "T:SharpDX.MediaFoundation.ObjectType"/></strong> enumeration, specifying the type of object that was created. </p> </dd></param>
            <param name = "objectOut"><dd> <p> Receives a reference to the media source's <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_ABORT</strong></dt> </dl> </td><td> <p> The operation was canceled. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this method from inside your application's <strong>IMFAsyncCallback::Invoke</strong> method.</p>
            </remarks>
            <doc-id>ms702134</doc-id>
            <unmanaged>HRESULT IMFSourceResolver::EndCreateObjectFromURL([In] IMFAsyncResult* pResult,[Out] MF_OBJECT_TYPE* pObjectType,[Out] IUnknown** ppObject)</unmanaged>
            <unmanaged-short>IMFSourceResolver::EndCreateObjectFromURL</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceResolver.BeginCreateObjectFromByteStream(SharpDX.MediaFoundation.IByteStream,System.String,System.Int32,SharpDX.ComObject,SharpDX.IUnknown@,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Begins an asynchronous request to create a media source from a byte stream.</p>
            </summary>
            <param name = "byteStreamRef"><dd> <p>A reference to the byte stream's <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface. </p> </dd></param>
            <param name = "wszURLRef"><dd> <p>A null-terminated string that contains the original URL of the byte stream. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
            <param name = "dwFlags"><dd> <p>A bitwise <strong>OR</strong> of one or more flags. See <strong>Source Resolver Flags</strong>. </p> </dd></param>
            <param name = "propsRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.ComObject"/></strong> interface of a property store. The method passes the property store to the byte-stream handler. The byte-stream handler can use the property store to configure the media source. This parameter can be <strong><c>null</c></strong>. For more information, see Configuring a Media Source. </p> </dd></param>
            <param name = "iUnknownCancelCookieOut"><dd> <p>Receives an <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference or the value <strong><c>null</c></strong>. If the value is not <strong><c>null</c></strong>, you can cancel the asynchronous operation by passing this reference to the <strong>IMFSourceResolver::CancelObjectCreation</strong> method. The caller must release the interface. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
            <param name = "callbackRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>
            <param name = "unkStateRef"><dd> <p>A oointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:SourceResolverMutuallyExclusiveFlags"/></strong></dt> </dl> </td><td> <p>The <em>dwFlags</em> parameter contains mutually exclusive flags.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedByteStreamType"/></strong></dt> </dl> </td><td> <p>The byte stream is not supported.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ByteStreamNotSeekable"/></strong></dt> </dl> </td><td> <p>The byte stream does not support seeking.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The <em>dwFlags</em> parameter must contain the <strong>MF_RESOLUTION_MEDIASOURCE</strong> flag and should not contain the <strong>MF_RESOLUTION_BYTESTREAM</strong> flag.</p><p>The source resolver attempts to find one or more byte-stream handlers for the byte stream, based on the file name extension of the URL, or the MIME type of the byte stream (or both). The URL is specified in the optional <em>pwszURL</em> parameter, and the MIME type may be specified in the <strong><see cref = "!:ContentType"/></strong> attribute on the byte stream. Byte-stream handlers are registered by file name extension or MIME type, or both, as described in Scheme Handlers and Byte-Stream Handlers. The caller should specify at least one of these values.</p><p>When the operation completes, the source resolver calls the <strong>IMFAsyncCallback::Invoke</strong> method. The <strong>Invoke</strong> method should call <strong>IMFSourceResolver::EndCreateObjectFromByteStream</strong> to get a reference to the media source.</p>
            </remarks>
            <doc-id>ms698915</doc-id>
            <unmanaged>HRESULT IMFSourceResolver::BeginCreateObjectFromByteStream([In] IMFByteStream* pByteStream,[In] const wchar_t* pwszURL,[In] DWORD dwFlags,[In] IPropertyStore* pProps,[Out, Optional] IUnknown** ppIUnknownCancelCookie,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>
            <unmanaged-short>IMFSourceResolver::BeginCreateObjectFromByteStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceResolver.EndCreateObjectFromByteStream(SharpDX.MediaFoundation.AsyncResult,SharpDX.MediaFoundation.ObjectType@,SharpDX.IUnknown@)">
            <summary>
            <p> </p><p>Completes an asynchronous request to create a media source from a byte stream.</p>
            </summary>
            <param name = "resultRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>Invoke</strong> method.</p> </dd></param>
            <param name = "objectTypeRef"><dd> <p>Receives a member of the <strong><see cref = "T:SharpDX.MediaFoundation.ObjectType"/></strong> enumeration, specifying the type of object that was created.</p> </dd></param>
            <param name = "objectOut"><dd> <p>Receives a reference to the media source's <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_ABORT</strong></dt> </dl> </td><td> <p>The application canceled the operation.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this method from inside your application's <strong>IMFAsyncCallback::Invoke</strong> method.</p>
            </remarks>
            <doc-id>ms697199</doc-id>
            <unmanaged>HRESULT IMFSourceResolver::EndCreateObjectFromByteStream([In] IMFAsyncResult* pResult,[Out] MF_OBJECT_TYPE* pObjectType,[Out] IUnknown** ppObject)</unmanaged>
            <unmanaged-short>IMFSourceResolver::EndCreateObjectFromByteStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceResolver.CancelObjectCreation(SharpDX.IUnknown)">
            <summary>
            <p> Cancels an asynchronous request to create an object. </p>
            </summary>
            <param name = "iUnknownCancelCookieRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface that was returned in the <em>ppIUnknownCancelCookie</em> parameter of the <strong>IMFSourceResolver::BeginCreateObjectFromByteStream</strong> or <strong>IMFSourceResolver::BeginCreateObjectFromURL</strong> method. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> You can use this method to cancel a previous call to <strong>BeginCreateObjectFromByteStream</strong> or <strong>BeginCreateObjectFromURL</strong>. Because these methods are asynchronous, however, they might be completed before the operation can be canceled. Therefore, your callback might still be invoked after you call this method. </p><strong>Note</strong>??This method cannot be called remotely.?
            </remarks>
            <doc-id>ms698845</doc-id>
            <unmanaged>HRESULT IMFSourceResolver::CancelObjectCreation([In] IUnknown* pIUnknownCancelCookie)</unmanaged>
            <unmanaged-short>IMFSourceResolver::CancelObjectCreation</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.#ctor(System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.MediaFoundation.Transform"/> class.
            </summary>
            <param name="guid">Guid of the Media Foundation Transform.</param>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.TryGetStreamIDs(System.Int32[],System.Int32[])">
            <summary>
            Gets the stream identifiers for the input and output streams on this Media Foundation transform (MFT).
            </summary>
            <param name="dwInputIDsRef">An array allocated by the caller. The method fills the array with the input stream identifiers. The array size must be at least equal to the number of input streams. To get the number of input streams, call <strong><see cref="M:SharpDX.MediaFoundation.Transform.GetStreamCount(System.Int32@,System.Int32@)" /></strong>.<para>If the caller passes an array that is larger than the number of input streams, the MFT must not write values into the extra array entries.</para></param>
            <param name="dwOutputIDsRef">An array allocated by the caller. The method fills the array with the output stream identifiers. The array size must be at least equal to the number of output streams. To get the number of output streams, call <strong><see cref="M:SharpDX.MediaFoundation.Transform.GetStreamCount(System.Int32@,System.Int32@)" /></strong>.<para>If the caller passes an array that is larger than the number of output streams, the MFT must not write values into the extra array entries.</para></param>
            <returns><c>true</c> if Both streams IDs for input and output are valid, <c>false</c> otherwise</returns>
            <msdn-id>ms693988</msdn-id>
              <unmanaged>HRESULT IMFTransform::GetStreamIDs([In] unsigned int dwInputIDArraySize,[Out, Buffer] unsigned int* pdwInputIDs,[In] unsigned int dwOutputIDArraySize,[Out, Buffer] unsigned int* pdwOutputIDs)</unmanaged>
              <unmanaged-short>IMFTransform::GetStreamIDs</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.TryGetOutputAvailableType(System.Int32,System.Int32,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            Gets an available media type for an output stream on this Media Foundation transform (MFT).
            </summary>
            <param name="dwOutputStreamID">Output stream identifier. To get the list of stream identifiers, call <strong><see cref="M:SharpDX.MediaFoundation.Transform.GetStreamIDs(System.Int32,System.Int32[],System.Int32,System.Int32[])" /></strong>.</param>
            <param name="dwTypeIndex">Index of the media type to retrieve. Media types are indexed from zero and returned in approximate order of preference.</param>
            <param name="typeOut">Receives a pointer to the <strong><see cref="T:SharpDX.MediaFoundation.MediaType" /></strong> interface. The caller must release the interface.</param>
            <returns><c>true</c> if A media type for an output stream is available, <c>false</c> otherwise</returns>
            <msdn-id>ms703812</msdn-id>	
            <unmanaged>HRESULT IMFTransform::GetOutputAvailableType([In] unsigned int dwOutputStreamID,[In] unsigned int dwTypeIndex,[Out] IMFMediaType** ppType)</unmanaged>	
            <unmanaged-short>IMFTransform::GetOutputAvailableType</unmanaged-short>	
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.ProcessOutput(SharpDX.MediaFoundation.TransformProcessOutputFlags,SharpDX.MediaFoundation.TOutputDataBuffer[],SharpDX.MediaFoundation.TransformProcessOutputStatus@)">
            <summary>
            Generates output from the current input data.
            </summary>
            <param name="dwFlags">Bitwise OR of zero or more flags from the <strong><see cref="T:SharpDX.MediaFoundation.TransformProcessOutputFlags" /></strong> enumeration.</param>
            <param name="outputSamplesRef">Pointer to an array of <strong><see cref="T:SharpDX.MediaFoundation.TOutputDataBuffer" /></strong> structures, allocated by the caller. The MFT uses this array to return output data to the caller.</param>
            <param name="dwStatusRef">Receives a bitwise OR of zero or more flags from the <strong><see cref="T:SharpDX.MediaFoundation.TransformProcessOutputStatus" /></strong> enumeration.</param>
            <returns><c>true</c> if the transform cannot produce output data until it receives more input data, <c>false</c> otherwise</returns>
            <msdn-id>ms704014</msdn-id>	
            <unmanaged>HRESULT IMFTransform::ProcessOutput([In] _MFT_PROCESS_OUTPUT_FLAGS dwFlags,[In] unsigned int cOutputBufferCount,[In] MFT_OUTPUT_DATA_BUFFER* pOutputSamples,[Out] _MFT_PROCESS_OUTPUT_STATUS* pdwStatus)</unmanaged>	
            <unmanaged-short>IMFTransform::ProcessOutput</unmanaged-short>	
        </member>
        <member name="P:SharpDX.MediaFoundation.Transform.Attributes">
            <summary>
            <p> Gets the global attribute store for this Media Foundation transform (MFT). </p>
            </summary>
            <remarks>
            <p> Use the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> reference retrieved by this method to get or set attributes that apply to the entire MFT. To get the attribute store for an input stream, call <strong>IMFTransform::GetInputStreamAttributes</strong>. To get the attribute store for an output stream, call <strong>IMFTransform::GetOutputStreamAttributes</strong>. </p><p> Implementation of this method is optional unless the MFT needs to support a particular set of attributes. Exception: Hardware-based MFTs must implement this method. See Hardware MFTs.</p>
            </remarks>
            <doc-id>ms703141</doc-id>
            <unmanaged>GetAttributes</unmanaged>
            <unmanaged-short>GetAttributes</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.Transform.OutputStatus">
            <summary>
            <p> Queries whether the Media Foundation transform (MFT) is ready to produce output data. </p>
            </summary>
            <remarks>
            <p> If the method returns the <strong>MFT_OUTPUT_STATUS_SAMPLE_READY</strong> flag, it means you can generate one or more output samples by calling <strong>IMFTransform::ProcessOutput</strong>. </p><p> MFTs are not required to implement this method. If the method returns <strong>E_NOTIMPL</strong>, you must call <strong>ProcessOutput</strong> to determine whether the transform has output data. </p><p> If the MFT has more than one output stream, but it does not produce samples at the same time for each stream, it can set the <strong>MFT_OUTPUT_STATUS_SAMPLE_READY</strong> flag when just one stream is ready. However, if the MFT normally produces samples at the same time for each output stream, it should not set this flag until all streams are ready. </p><p> After the client has set valid media types on all of the streams, the MFT should always be in one of two states: Able to accept more input, or able to produce more output. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetOutputStatus</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms696269</doc-id>
            <unmanaged>GetOutputStatus</unmanaged>
            <unmanaged-short>GetOutputStatus</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.GetStreamLimits(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            <p> Gets the minimum and maximum number of input and output streams for this Media Foundation transform (MFT). </p>
            </summary>
            <param name = "dwInputMinimumRef"><dd> <p> Receives the minimum number of input streams. </p> </dd></param>
            <param name = "dwInputMaximumRef"><dd> <p> Receives the maximum number of input streams. If there is no maximum, receives the value <strong>MFT_STREAMS_UNLIMITED</strong>. </p> </dd></param>
            <param name = "dwOutputMinimumRef"><dd> <p> Receives the minimum number of output streams. </p> </dd></param>
            <param name = "dwOutputMaximumRef"><dd> <p> Receives the maximum number of output streams. If there is no maximum, receives the value <strong>MFT_STREAMS_UNLIMITED</strong>. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> If the MFT has a fixed number of streams, the minimum and maximum values are the same. </p><p> It is not recommended to create an MFT that supports zero inputs or zero outputs. An MFT with no inputs or no outputs may not be compatible with the rest of the Media Foundation pipeline. You should create a Media Foundation sink or source for this purpose instead. </p><p> When an MFT is first created, it is not guaranteed to have the minimum number of streams. To find the actual number of streams, call <strong>IMFTransform::GetStreamCount</strong>. </p><p> This method should not be called with <strong><c>null</c></strong> parameters, although in practice some implementations may allow <strong><c>null</c></strong> parameters. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetStreamLimits</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms697040</doc-id>
            <unmanaged>HRESULT IMFTransform::GetStreamLimits([Out] DWORD* pdwInputMinimum,[Out] DWORD* pdwInputMaximum,[Out] DWORD* pdwOutputMinimum,[Out] DWORD* pdwOutputMaximum)</unmanaged>
            <unmanaged-short>IMFTransform::GetStreamLimits</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.GetStreamCount(System.Int32@,System.Int32@)">
            <summary>
            <p> Gets the current number of input and output streams on this Media Foundation transform (MFT). </p>
            </summary>
            <param name = "cInputStreamsRef"><dd> <p> Receives the number of input streams. </p> </dd></param>
            <param name = "cOutputStreamsRef"><dd> <p> Receives the number of output streams. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The number of streams includes unselected streams?that is, streams with no media type or a <strong><c>null</c></strong> media type.</p><p> This method should not be called with <strong><c>null</c></strong> parameters, although in practice some implementations may allow <strong><c>null</c></strong> parameters. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetStreamCount</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms697018</doc-id>
            <unmanaged>HRESULT IMFTransform::GetStreamCount([Out] DWORD* pcInputStreams,[Out] DWORD* pcOutputStreams)</unmanaged>
            <unmanaged-short>IMFTransform::GetStreamCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.GetStreamIDs(System.Int32,System.Int32[],System.Int32,System.Int32[])">
            <summary>
            <p> Gets the stream identifiers for the input and output streams on this Media Foundation transform (MFT). </p>
            </summary>
            <param name = "dwInputIDArraySize"><dd> <p> Number of elements in the <em>pdwInputIDs</em> array. </p> </dd></param>
            <param name = "dwInputIDsRef"><dd> <p> Pointer to an array allocated by the caller. The method fills the array with the input stream identifiers. The array size must be at least equal to the number of input streams. To get the number of input streams, call <strong>IMFTransform::GetStreamCount</strong>. </p> <p>If the caller passes an array that is larger than the number of input streams, the MFT must not write values into the extra array entries.</p> </dd></param>
            <param name = "dwOutputIDArraySize"><dd> <p> Number of elements in the <em>pdwOutputIDs</em> array. </p> </dd></param>
            <param name = "dwOutputIDsRef"><dd> <p> Pointer to an array allocated by the caller. The method fills the array with the output stream identifiers. The array size must be at least equal to the number of output streams. To get the number of output streams, call <strong>GetStreamCount</strong>. </p> <p>If the caller passes an array that is larger than the number of output streams, the MFT must not write values into the extra array entries.</p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> Not implemented. See Remarks. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:BufferTooSmall"/></strong></dt> </dl> </td><td> <p> One or both of the arrays is too small. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> Stream identifiers are necessary because some MFTs can add or remove streams, so the index of a stream may not be unique. Therefore, <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> methods that operate on streams take stream identifiers. </p><p>This method can return <strong>E_NOTIMPL</strong> if both of the following conditions are true:</p><ul> <li> The transform has a fixed number of streams. </li> <li> The streams are numbered consecutively from 0 to n ? 1, where n is the number of input streams or output streams. In other words, the first input stream is 0, the second is 1, and so on; and the first output stream is 0, the second is 1, and so on. </li> </ul><p>This method must be implemented if any of the following conditions is true:</p><ul> <li> The MFT can add or remove output streams. </li> <li> The MFT allows the client to add or remove input streams. </li> <li> The stream identifiers are not consecutive. </li> </ul><p> All input stream identifiers must be unique within an MFT, and all output stream identifiers must be unique. However, an input stream and an output stream can share the same identifier. </p><p> If the client adds an input stream, the client assigns the identifier, so the MFT must allow arbitrary identifiers, as long as they are unique. If the MFT creates an output stream, the MFT assigns the identifier. </p><p> By convention, if an MFT has exactly one fixed input stream and one fixed output stream, it should assign the identifier 0 to both streams. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetStreamIDs</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms693988</doc-id>
            <unmanaged>HRESULT IMFTransform::GetStreamIDs([In] DWORD dwInputIDArraySize,[Out, Buffer] DWORD* pdwInputIDs,[In] DWORD dwOutputIDArraySize,[Out, Buffer] DWORD* pdwOutputIDs)</unmanaged>
            <unmanaged-short>IMFTransform::GetStreamIDs</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.GetInputStreamInfo(System.Int32,SharpDX.MediaFoundation.TInputStreamInformation@)">
            <summary>
            <p> Gets the buffer requirements and other information for an input stream on this Media Foundation transform (MFT). </p>
            </summary>
            <param name = "dwInputStreamID"><dd> <p> Input stream identifier. To get the list of stream identifiers, call <strong>IMFTransform::GetStreamIDs</strong>. </p> </dd></param>
            <param name = "streamInfoRef"><dd> <p> Pointer to an <strong><see cref = "T:SharpDX.MediaFoundation.TInputStreamInformation"/></strong> structure. The method fills the structure with information about the input stream. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>It is valid to call this method before setting the media types.</p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetInputStreamInfo</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms703894</doc-id>
            <unmanaged>HRESULT IMFTransform::GetInputStreamInfo([In] DWORD dwInputStreamID,[Out] MFT_INPUT_STREAM_INFO* pStreamInfo)</unmanaged>
            <unmanaged-short>IMFTransform::GetInputStreamInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.GetOutputStreamInfo(System.Int32,SharpDX.MediaFoundation.TOutputStreamInformation@)">
            <summary>
            <p> Gets the buffer requirements and other information for an output stream on this Media Foundation transform (MFT). </p>
            </summary>
            <param name = "dwOutputStreamID"><dd> <p> Output stream identifier. To get the list of stream identifiers, call <strong>IMFTransform::GetStreamIDs</strong>. </p> </dd></param>
            <param name = "streamInfoRef"><dd> <p> Pointer to an <strong><see cref = "T:SharpDX.MediaFoundation.TOutputStreamInformation"/></strong> structure. The method fills the structure with information about the output stream. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream number. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>It is valid to call this method before setting the media types.</p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetOutputStreamInfo</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms693880</doc-id>
            <unmanaged>HRESULT IMFTransform::GetOutputStreamInfo([In] DWORD dwOutputStreamID,[Out] MFT_OUTPUT_STREAM_INFO* pStreamInfo)</unmanaged>
            <unmanaged-short>IMFTransform::GetOutputStreamInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.GetAttributes(SharpDX.MediaFoundation.MediaAttributes@)">
            <summary>
            <p> Gets the global attribute store for this Media Foundation transform (MFT). </p>
            </summary>
            <param name = "attributesRef"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> The MFT does not support attributes. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> Use the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> reference retrieved by this method to get or set attributes that apply to the entire MFT. To get the attribute store for an input stream, call <strong>IMFTransform::GetInputStreamAttributes</strong>. To get the attribute store for an output stream, call <strong>IMFTransform::GetOutputStreamAttributes</strong>. </p><p> Implementation of this method is optional unless the MFT needs to support a particular set of attributes. Exception: Hardware-based MFTs must implement this method. See Hardware MFTs.</p>
            </remarks>
            <doc-id>ms703141</doc-id>
            <unmanaged>HRESULT IMFTransform::GetAttributes([Out] IMFAttributes** pAttributes)</unmanaged>
            <unmanaged-short>IMFTransform::GetAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.GetInputStreamAttributes(System.Int32,SharpDX.MediaFoundation.MediaAttributes@)">
            <summary>
            <p> Gets the attribute store for an input stream on this Media Foundation transform (MFT). </p>
            </summary>
            <param name = "dwInputStreamID"><dd> <p> Input stream identifier. To get the list of stream identifiers, call <strong>IMFTransform::GetStreamIDs</strong>. </p> </dd></param>
            <param name = "attributesRef"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> The MFT does not support input stream attributes. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> Implementation of this method is optional unless the MFT needs to support a particular set of attributes. </p><p> To get the attribute store for the entire MFT, call <strong>IMFTransform::GetAttributes</strong>. </p>
            </remarks>
            <doc-id>ms695366</doc-id>
            <unmanaged>HRESULT IMFTransform::GetInputStreamAttributes([In] DWORD dwInputStreamID,[Out] IMFAttributes** pAttributes)</unmanaged>
            <unmanaged-short>IMFTransform::GetInputStreamAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.GetOutputStreamAttributes(System.Int32,SharpDX.MediaFoundation.MediaAttributes@)">
            <summary>
            <p> Gets the attribute store for an output stream on this Media Foundation transform (MFT). </p>
            </summary>
            <param name = "dwOutputStreamID"><dd> <p> Output stream identifier. To get the list of stream identifiers, call <strong>IMFTransform::GetStreamIDs</strong>. </p> </dd></param>
            <param name = "attributesRef"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> The MFT does not support output stream attributes. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> Implementation of this method is optional unless the MFT needs to support a particular set of attributes. </p><p> To get the attribute store for the entire MFT, call <strong>IMFTransform::GetAttributes</strong>. </p>
            </remarks>
            <doc-id>ms703886</doc-id>
            <unmanaged>HRESULT IMFTransform::GetOutputStreamAttributes([In] DWORD dwOutputStreamID,[Out] IMFAttributes** pAttributes)</unmanaged>
            <unmanaged-short>IMFTransform::GetOutputStreamAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.DeleteInputStream(System.Int32)">
            <summary>
            <p> Removes an input stream from this Media Foundation transform (MFT). </p>
            </summary>
            <param name = "dwStreamID"><dd> <p> Identifier of the input stream to remove. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> The transform has a fixed number of input streams. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p> The stream is not removable, or the transform currently has the minimum number of input streams it can support. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TransformInputRemaining"/></strong></dt> </dl> </td><td> <p> The transform has unprocessed input buffers for the specified stream. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> If the transform has a fixed number of input streams, the method returns <strong>E_NOTIMPL</strong>. </p><p> An MFT might support this method but not allow certain input streams to be removed. If an input stream can be removed, the <strong>IMFTransform::GetInputStreamInfo</strong> method returns the <strong>MFT_INPUT_STREAM_REMOVABLE</strong> flag for that stream. Otherwise, the stream cannot be removed, and the method returns <strong><see cref = "!:InvalidRequest"/></strong>. The method also fails if the MFT currently has the minimum number of input streams that it requires. To find the minimum number of streams, call <strong>IMFTransform::GetStreamLimits</strong>. </p><p> If the transform still has unprocessed input for that stream, the method might succeed or it might return <strong><see cref = "!:TransformInputRemaining"/></strong>. If the method succeeds, the MFT will continue to process the remaining input after the stream is removed. If the method returns <strong><see cref = "!:TransformInputRemaining"/></strong>, you must clear the input buffers before removing the stream. To clear the input buffers, either call <strong>IMFTransform::ProcessOutput</strong> or else call <strong>IMFTransform::ProcessMessage</strong> with the <strong>MFT_MESSAGE_COMMAND_FLUSH</strong> to flush the MFT. Then call the <strong>DeleteInputStream</strong> again. An MFT should never discard input buffers when <strong>DeleteInputStream</strong> is called. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTDeleteInputStream</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms703159</doc-id>
            <unmanaged>HRESULT IMFTransform::DeleteInputStream([In] DWORD dwStreamID)</unmanaged>
            <unmanaged-short>IMFTransform::DeleteInputStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.AddInputStreams(System.Int32,System.Int32)">
            <summary>
            <p> Adds one or more new input streams to this Media Foundation transform (MFT). </p>
            </summary>
            <param name = "cStreams"><dd> <p> Number of streams to add. </p> </dd></param>
            <param name = "adwStreamIDs"><dd> <p> Array of stream identifiers. The new stream identifiers must not match any existing input streams. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> Invalid argument. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> The MFT has a fixed number of input streams. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> If the new streams exceed the maximum number of input streams for this transform, the method returns <strong>E_INVALIDARG.</strong> To find the maximum number of input streams, call <strong>IMFTransform::GetStreamLimits</strong>. </p><p> If any of the new stream identifiers conflicts with an existing input stream, the method returns <strong>E_INVALIDARG</strong>. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTAddInputStreams</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms696211</doc-id>
            <unmanaged>HRESULT IMFTransform::AddInputStreams([In] DWORD cStreams,[In] DWORD* adwStreamIDs)</unmanaged>
            <unmanaged-short>IMFTransform::AddInputStreams</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.GetInputAvailableType(System.Int32,System.Int32,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            <p> Gets an available media type for an input stream on this Media Foundation transform (MFT). </p>
            </summary>
            <param name = "dwInputStreamID"><dd> <p> Input stream identifier. To get the list of stream identifiers, call <strong>IMFTransform::GetStreamIDs</strong>. </p> </dd></param>
            <param name = "dwTypeIndex"><dd> <p> Index of the media type to retrieve. Media types are indexed from zero and returned in approximate order of preference. </p> </dd></param>
            <param name = "typeOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> The MFT does not have a list of available input types. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NoMoreTypes"/></strong></dt> </dl> </td><td> <p> The <em>dwTypeIndex</em> parameter is out of range. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> You must set the output types before setting the input types. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> The MFT defines a list of available media types for each input stream and orders them by preference. This method enumerates the available media types for an input stream. To enumerate the available types, increment <em>dwTypeIndex</em> until the method returns <strong><see cref = "!:NoMoreTypes"/></strong>. </p><p> Setting the media type on one stream might change the available types for another stream, or change the preference order. However, an MFT is not required to update the list of available types dynamically. The only guaranteed way to test whether you can set a particular input type is to call <strong>IMFTransform::SetInputType</strong>. </p><p> In some cases, an MFT cannot return a list of input types until one or more output types are set. If so, the method returns <strong><see cref = "!:TransformTypeNotSet"/></strong>. </p><p> An MFT is not required to implement this method. However, most MFTs should implement this method, unless the supported types are simple and can be discovered through the <strong>MFTGetInfo</strong> function.</p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetInputAvailableType</strong>. See Creating Hybrid DMO/MFT Objects.</p><p>For encoders, after the output type is set, <strong>GetInputAvailableType</strong> must return a list of input types that are compatible with the current output type. This means that all types returned by <strong>GetInputAvailableType</strong> after the output type is set must be valid types for <strong>SetInputType</strong>.</p><p>Encoders should reject input types if the attributes of the input media type and output media type do not match, such as resolution setting with <see cref = "!:FrameSize"/>, nominal range setting with <see cref = "!:VideoNominalRange"/>, or frame rate setting with <see cref = "!:FrameSize"/></p>
            </remarks>
            <doc-id>ms704814</doc-id>
            <unmanaged>HRESULT IMFTransform::GetInputAvailableType([In] DWORD dwInputStreamID,[In] DWORD dwTypeIndex,[Out] IMFMediaType** ppType)</unmanaged>
            <unmanaged-short>IMFTransform::GetInputAvailableType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.GetOutputAvailableType(System.Int32,System.Int32,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            <p> Gets an available media type for an output stream on this Media Foundation transform (MFT). </p>
            </summary>
            <param name = "dwOutputStreamID"><dd> <p> Output stream identifier. To get the list of stream identifiers, call <strong>IMFTransform::GetStreamIDs</strong>. </p> </dd></param>
            <param name = "dwTypeIndex"><dd> <p> Index of the media type to retrieve. Media types are indexed from zero and returned in approximate order of preference. </p> </dd></param>
            <param name = "typeOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> The MFT does not have a list of available output types. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NoMoreTypes"/></strong></dt> </dl> </td><td> <p> The <em>dwTypeIndex</em> parameter is out of range. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> You must set the input types before setting the output types. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> The MFT defines a list of available media types for each output stream and orders them by preference. This method enumerates the available media types for an output stream. To enumerate the available types, increment <em>dwTypeIndex</em> until the method returns MF_<strong>E_NO_MORE_TYPES</strong>. </p><p> Setting the media type on one stream can change the available types for another stream (or change the preference order). However, an MFT is not required to update the list of available types dynamically. The only guaranteed way to test whether you can set a particular input type is to call <strong>IMFTransform::SetOutputType</strong>. </p><p> In some cases, an MFT cannot return a list of output types until one or more input types are set. If so, the method returns <strong><see cref = "!:TransformTypeNotSet"/></strong>. </p><p> An MFT is not required to implement this method. However, most MFTs should implement this method, unless the supported types are simple and can be discovered through the <strong>MFTGetInfo</strong> function. </p><p> This method can return a <em>partial</em> media type. A partial media type contains an incomplete description of a format, and is used to provide a hint to the caller. For example, a partial type might include just the major type and subtype GUIDs. However, after the client sets the input types on the MFT, the MFT should generally return at least one complete output type, which can be used without further modification. For more information, see Complete and Partial Media Types.</p><p>Some MFTs cannot provide an accurate list of output types until the MFT receives the first input sample. For example, the MFT might need to read the first packet header to deduce the format. An MFT should handle this situation as follows:</p><ol> <li> Before the MFT receives any input, it offers a list of one or more output types that it could possibly produce. For example, an MPEG-2 decoder might return a media type that describes the MPEG-2 main profile/main level. </li> <li> The client selects one of these types (generally the first) and sets it on the output stream. </li> <li> The client delivers the first input sample by calling <strong>IMFTransform::ProcessInput</strong>. </li> <li> If the output type does not conform to the input data, the transform signals a format change in the <strong>ProcessOutput</strong> method. For more information about format changes, see <strong>IMFTransform::ProcessOutput</strong>. </li> <li> The calls <strong>GetOutputAvailableType</strong> again. At this point, the method should return an updated list of types that reflects the input data. </li> <li> The client selects a new output type from this list and calls <strong>SetOutputType</strong>. </li> </ol><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetOutputAvailableType</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms703812</doc-id>
            <unmanaged>HRESULT IMFTransform::GetOutputAvailableType([In] DWORD dwOutputStreamID,[In] DWORD dwTypeIndex,[Out] IMFMediaType** ppType)</unmanaged>
            <unmanaged-short>IMFTransform::GetOutputAvailableType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.SetInputType(System.Int32,SharpDX.MediaFoundation.MediaType,System.Int32)">
            <summary>
            <p> Sets, tests, or clears the media type for an input stream on this Media Foundation transform (MFT). </p>
            </summary>
            <param name = "dwInputStreamID"><dd> <p> Input stream identifier. To get the list of stream identifiers, call <strong>IMFTransform::GetStreamIDs</strong>. </p> </dd></param>
            <param name = "typeRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface, or <strong><c>null</c></strong>. </p> </dd></param>
            <param name = "dwFlags"><dd> <p> Zero or more flags from the <strong>_MFT_SET_TYPE_FLAGS</strong> enumeration. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidMediaType"/></strong></dt> </dl> </td><td> <p> The MFT cannot use the proposed media type. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidType"/></strong></dt> </dl> </td><td> <p> The proposed type is not valid. This error code indicates that the media type itself is not configured correctly; for example, it might contain mutually contradictory attributes. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TransformCannotChangeMediaTypeWhileProcessing"/></strong></dt> </dl> </td><td> <p> The MFT cannot switch types while processing data. Try draining or flushing the MFT. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> You must set the output types before setting the input types. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedD3DType"/></strong></dt> </dl> </td><td> <p> The MFT could not find a suitable DirectX Video Acceleration (DXVA) configuration. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method can be used to set, test without setting, or clear the media type:</p><ul> <li> To set the media type, set <em>dwFlags</em> to zero and set <em>pType</em> to a non-<strong><c>null</c></strong> reference that specifies the media type. </li> <li> To test the media type without setting it, set <em>dwFlags</em> to <strong>MFT_SET_TYPE_TEST_ONLY</strong> and set <em>pType</em> to a non-<strong><c>null</c></strong> reference that specifies the media type. If the media type is acceptable, the method return <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns <strong><see cref = "!:InvalidMediaType"/></strong>. Regardless of the return value, the current media type does not change. </li> <li> To clear the media type, set <em>pType</em> to <strong><c>null</c></strong>. </li> </ul><p> Setting the media type on one stream may change the acceptable types on another stream. </p><p> An MFT may require the caller to set one or more output types before setting the input type. If so, the method returns <strong><see cref = "!:TransformTypeNotSet"/></strong>. </p><p> If the MFT supports DirectX Video Acceleration (DXVA) but is unable to find a suitable DXVA configuration (for example, if the graphics driver does not have the right capabilities), the method should return <strong><see cref = "!:UnsupportedD3DType"/></strong>. For more information, see Supporting DXVA 2.0 in Media Foundation. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTSetInputType</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms700113</doc-id>
            <unmanaged>HRESULT IMFTransform::SetInputType([In] DWORD dwInputStreamID,[In, Optional] IMFMediaType* pType,[In] DWORD dwFlags)</unmanaged>
            <unmanaged-short>IMFTransform::SetInputType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.SetOutputType(System.Int32,SharpDX.MediaFoundation.MediaType,System.Int32)">
            <summary>
            <p> Sets, tests, or clears the media type for an output stream on this Media Foundation transform (MFT). </p>
            </summary>
            <param name = "dwOutputStreamID"><dd> <p> Output stream identifier. To get the list of stream identifiers, call <strong>IMFTransform::GetStreamIDs</strong>. </p> </dd></param>
            <param name = "typeRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface, or <strong><c>null</c></strong>. </p> </dd></param>
            <param name = "dwFlags"><dd> <p> Zero or more flags from the <strong>_MFT_SET_TYPE_FLAGS</strong> enumeration. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidMediaType"/></strong></dt> </dl> </td><td> <p> The transform cannot use the proposed media type. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidType"/></strong></dt> </dl> </td><td> <p> The proposed type is not valid. This error code indicates that the media type itself is not configured correctly; for example, it might contain mutually contradictory flags. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TransformCannotChangeMediaTypeWhileProcessing"/></strong></dt> </dl> </td><td> <p> The MFT cannot switch types while processing data. Try draining or flushing the MFT. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> You must set the input types before setting the output types. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedD3DType"/></strong></dt> </dl> </td><td> <p> The MFT could not find a suitable DirectX Video Acceleration (DXVA) configuration. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method can be used to set, test without setting, or clear the media type:</p><ul> <li> To set the media type, set <em>dwFlags</em> to zero and set <em>pType</em> to a non-<strong><c>null</c></strong> reference that specifies the media type. </li> <li> To test the media type without setting it, set <em>dwFlags</em> to <strong>MFT_SET_TYPE_TEST_ONLY</strong> and set <em>pType</em> to a non-<strong><c>null</c></strong> reference that specifies the media type. If the media type is acceptable, the method return <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns <strong><see cref = "!:InvalidMediaType"/></strong>. Regardless of the return value, the current media type does not change. </li> <li> To clear the media type, set <em>pType</em> to <strong><c>null</c></strong>. </li> </ul><p> Setting the media type on one stream may change the acceptable types on another stream. </p><p> An MFT may require the caller to set one or more input types before setting the output type. If so, the method returns <strong><see cref = "!:TransformTypeNotSet"/></strong>. </p><p>If the MFT supports DirectX Video Acceleration (DXVA) but is unable to find a suitable DXVA configuration (for example, if the graphics driver does not have the right capabilities), the method should return <strong><see cref = "!:UnsupportedD3DType"/></strong>. For more information, see Supporting DXVA 2.0 in Media Foundation.</p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTSetOutputType</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms702016</doc-id>
            <unmanaged>HRESULT IMFTransform::SetOutputType([In] DWORD dwOutputStreamID,[In, Optional] IMFMediaType* pType,[In] DWORD dwFlags)</unmanaged>
            <unmanaged-short>IMFTransform::SetOutputType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.GetInputCurrentType(System.Int32,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            <p> Gets the current media type for an input stream on this Media Foundation transform (MFT). </p>
            </summary>
            <param name = "dwInputStreamID"><dd> <p> Input stream identifier. To get the list of stream identifiers, call <strong>IMFTransform::GetStreamIDs</strong>. </p> </dd></param>
            <param name = "typeOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> The input media type has not been set. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> If the specified input stream does not yet have a media type, the method returns <strong><see cref = "!:TransformTypeNotSet"/></strong>. Most MFTs do not set any default media types when first created. Instead, the client must set the media type by calling <strong>IMFTransform::SetInputType</strong>. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetInputCurrentType</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms705607</doc-id>
            <unmanaged>HRESULT IMFTransform::GetInputCurrentType([In] DWORD dwInputStreamID,[Out] IMFMediaType** ppType)</unmanaged>
            <unmanaged-short>IMFTransform::GetInputCurrentType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.GetOutputCurrentType(System.Int32,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            <p> Gets the current media type for an output stream on this Media Foundation transform (MFT). </p>
            </summary>
            <param name = "dwOutputStreamID"><dd> <p> Output stream identifier. To get the list of stream identifiers, call <strong>IMFTransform::GetStreamIDs</strong>. </p> </dd></param>
            <param name = "typeOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> The output media type has not been set. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> If the specified output stream does not yet have a media type, the method returns <strong><see cref = "!:TransformTypeNotSet"/></strong>. Most MFTs do not set any default media types when first created. Instead, the client must set the media type by calling <strong>IMFTransform::SetOutputType</strong>. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetOutputCurrentType</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms696985</doc-id>
            <unmanaged>HRESULT IMFTransform::GetOutputCurrentType([In] DWORD dwOutputStreamID,[Out] IMFMediaType** ppType)</unmanaged>
            <unmanaged-short>IMFTransform::GetOutputCurrentType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.GetInputStatus(System.Int32,System.Int32@)">
            <summary>
            <p> Queries whether an input stream on this Media Foundation transform (MFT) can accept more data. </p>
            </summary>
            <param name = "dwInputStreamID"><dd> <p> Input stream identifier. To get the list of stream identifiers, call <strong>IMFTransform::GetStreamIDs</strong>. </p> </dd></param>
            <param name = "dwFlagsRef"><dd> <p> Receives a member of the <strong>_MFT_INPUT_STATUS_FLAGS</strong> enumeration, or zero. If the value is <strong>MFT_INPUT_STATUS_ACCEPT_DATA</strong>, the stream specified in <em>dwInputStreamID</em> can accept more input data. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> The media type is not set on one or more streams. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> If the method returns the <strong>MFT_INPUT_STATUS_ACCEPT_DATA</strong> flag, you can deliver an input sample to the specified stream by calling <strong>IMFTransform::ProcessInput</strong>. If the method succeeds but does not return any flags in the <em>pdwFlags</em> parameter, it means the input stream already has as much data as it can accept. </p><p> Use this method to test whether the input stream is ready to accept more data, without incurring the overhead of allocating a new sample and calling <strong>ProcessInput</strong>. </p><p> After the client has set valid media types on all of the streams, the MFT should always be in one of two states: Able to accept more input, or able to produce more output (or both). </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetInputStatus</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms697478</doc-id>
            <unmanaged>HRESULT IMFTransform::GetInputStatus([In] DWORD dwInputStreamID,[Out] DWORD* pdwFlags)</unmanaged>
            <unmanaged-short>IMFTransform::GetInputStatus</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.GetOutputStatus(System.Int32@)">
            <summary>
            <p> Queries whether the Media Foundation transform (MFT) is ready to produce output data. </p>
            </summary>
            <param name = "dwFlagsRef"><dd> <p> Receives a member of the <strong>_MFT_OUTPUT_STATUS_FLAGS</strong> enumeration, or zero. If the value is <strong>MFT_OUTPUT_STATUS_SAMPLE_READY</strong>, the MFT can produce an output sample. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> Not implemented. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> The media type is not set on one or more streams. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> If the method returns the <strong>MFT_OUTPUT_STATUS_SAMPLE_READY</strong> flag, it means you can generate one or more output samples by calling <strong>IMFTransform::ProcessOutput</strong>. </p><p> MFTs are not required to implement this method. If the method returns <strong>E_NOTIMPL</strong>, you must call <strong>ProcessOutput</strong> to determine whether the transform has output data. </p><p> If the MFT has more than one output stream, but it does not produce samples at the same time for each stream, it can set the <strong>MFT_OUTPUT_STATUS_SAMPLE_READY</strong> flag when just one stream is ready. However, if the MFT normally produces samples at the same time for each output stream, it should not set this flag until all streams are ready. </p><p> After the client has set valid media types on all of the streams, the MFT should always be in one of two states: Able to accept more input, or able to produce more output. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTGetOutputStatus</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms696269</doc-id>
            <unmanaged>HRESULT IMFTransform::GetOutputStatus([Out] DWORD* pdwFlags)</unmanaged>
            <unmanaged-short>IMFTransform::GetOutputStatus</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.SetOutputBounds(System.Int64,System.Int64)">
            <summary>
            <p> Sets the range of time stamps the client needs for output. </p>
            </summary>
            <param name = "hnsLowerBound"><dd> <p> Specifies the earliest time stamp. The Media Foundation transform (MFT) will accept input until it can produce an output sample that begins at this time; or until it can produce a sample that ends at this time or later. If there is no lower bound, use the value <strong>MFT_OUTPUT_BOUND_LOWER_UNBOUNDED</strong>. </p> </dd></param>
            <param name = "hnsUpperBound"><dd> <p> Specifies the latest time stamp. The MFT will not produce an output sample with time stamps later than this time. If there is no upper bound, use the value <strong>MFT_OUTPUT_BOUND_UPPER_UNBOUNDED</strong>. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> Not implemented. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> The media type is not set on one or more streams. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> This method can be used to optimize preroll, especially in formats that have gaps between time stamps, or formats where the data must start on a sync point, such as MPEG-2. Calling this method is optional, and implementation of this method by an MFT is optional. If the MFT does not implement the method, the return value is <strong>E_NOTIMPL</strong>.</p><p> If an MFT implements this method, it must limit its output data to the range of times specified by <em>hnsLowerBound</em> and <em>hnsUpperBound</em>. The MFT discards any input data that is not needed to produce output within this range. If the sample boundaries do not exactly match the range, the MFT should split the output samples, if possible. Otherwise, the output samples can overlap the range. </p><p> For example, suppose the output range is 100 to 150 milliseconds (ms), and the output format is video with each frame lasting 33 ms. A sample with a time stamp of 67 ms overlaps the range (67 + 33 = 100) and is produced as output. A sample with a time stamp of  66 ms is discarded (66 + 33 = 99). Similarly, a sample with a time stamp of 150 ms is produced as output, but a sample with a time stamp of 151 is discarded.</p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTSetOutputBounds</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms693812</doc-id>
            <unmanaged>HRESULT IMFTransform::SetOutputBounds([In] longlong hnsLowerBound,[In] longlong hnsUpperBound)</unmanaged>
            <unmanaged-short>IMFTransform::SetOutputBounds</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.ProcessEvent(System.Int32,SharpDX.MediaFoundation.MediaEvent)">
            <summary>
            <p> Sends an event to an input stream on this Media Foundation transform (MFT). </p>
            </summary>
            <param name = "dwInputStreamID"><dd> <p> Input stream identifier. To get the list of stream identifiers, call <strong>IMFTransform::GetStreamIDs</strong>. </p> </dd></param>
            <param name = "eventRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEvent"/></strong> interface of an event object. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p> Not implemented. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream number. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> The media type is not set on one or more streams. </p> </td></tr> <tr><td> <dl> <dt><strong>MF_S_TRANSFORM_DO_NOT_PROPAGATE_EVENT</strong></dt> </dl> </td><td> <p> The pipeline should not propagate the event. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> An MFT can handle sending the event downstream, or it can let the pipeline do this, as indicated by the return value: </p><ul> <li><strong>E_NOTIMPL</strong>: The MFT ignores all events, and the pipeline should send all events downstream. After the pipeline receives this return value, it might not call <strong>ProcessEvent</strong> again. </li> <li><strong><see cref = "F:SharpDX.Result.Ok"/></strong>: The MFT has examined this event, but the pipeline should send the event downstream. Internally, the MFT might respond to the event in some way, or it might ignore the event. </li> <li><strong>MF_S_TRANSFORM_DO_NOT_PROPAGATE_EVENT</strong>: The pipeline should not propagate this event downstream. Either the MFT will send the event downstream, or else the MFT will consume the event and not send it downstream. The MFT should only consume the event if the event should stop at this MFT and not travel any further downstream. But in most cases, the event should travel downstream. </li> </ul><p> To send the event downstream, the MFT adds the event to the collection object that is provided by the client in the <strong>pEvents</strong> member of the <strong><see cref = "T:SharpDX.MediaFoundation.TOutputDataBuffer"/></strong> structure, when the client calls <strong>IMFTransform::ProcessOutput</strong>. </p><p> Events must be serialized with the samples that come before and after them. Attach the event to the output sample that follows the event. (The pipeline will process the event first, and then the sample.) If an MFT holds back one or more samples between calls to <strong>IMFTransform::ProcessInput</strong> and <strong>ProcessOutput</strong>, the MFT should handle sending all events downstream, because in this situation the pipeline cannot correlate input samples with output samples. </p><p> If an MFT does not hold back samples and does not need to examine any events, it can return <strong>E_NOTIMPL</strong>. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTProcessEvent</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms695394</doc-id>
            <unmanaged>HRESULT IMFTransform::ProcessEvent([In] DWORD dwInputStreamID,[In, Optional] IMFMediaEvent* pEvent)</unmanaged>
            <unmanaged-short>IMFTransform::ProcessEvent</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.ProcessMessage(SharpDX.MediaFoundation.TMessageType,System.IntPtr)">
            <summary>
            <p> Sends a message to the Media Foundation transform (MFT). </p>
            </summary>
            <param name = "eMessage"><dd> <p> The message to send, specified as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.TMessageType"/></strong> enumeration. </p> </dd></param>
            <param name = "ulParam"><dd> <p> Message parameter. The meaning of this parameter depends on the message type. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream number. Applies to the <strong>MFT_MESSAGE_NOTIFY_END_OF_STREAM</strong> message. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> The media type is not set on one or more streams. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> Before calling this method, set the media types on all input and output streams. </p><p> The MFT might ignore certain message types. If so, the method returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. An error code indicates that the transform handles this message type but was unable to process the message in this instance. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTProcessMessage</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms701863</doc-id>
            <unmanaged>HRESULT IMFTransform::ProcessMessage([In] MFT_MESSAGE_TYPE eMessage,[In] ULONG_PTR ulParam)</unmanaged>
            <unmanaged-short>IMFTransform::ProcessMessage</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.ProcessInput(System.Int32,SharpDX.MediaFoundation.Sample,System.Int32)">
            <summary>
            <p> Delivers data to an input stream on this Media Foundation transform (MFT). </p>
            </summary>
            <param name = "dwInputStreamID"><dd> <p> Input stream identifier. To get the list of stream identifiers, call <strong>IMFTransform::GetStreamIDs</strong>. </p> </dd></param>
            <param name = "sampleRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface of the input sample. The sample must contain at least one media buffer that contains valid input data. </p> </dd></param>
            <param name = "dwFlags"><dd> <p> Reserved. Must be zero. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> Invalid argument. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NoSampleDuration"/></strong></dt> </dl> </td><td> <p>The input sample requires a valid sample duration. To set the duration, call <strong>IMFSample::SetSampleDuration</strong>. </p> <p>Some MFTs require that input samples have valid durations. Some MFTs do not require sample durations.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NoSampleTimestamp"/></strong></dt> </dl> </td><td> <p>The input sample requires a time stamp. To set the time stamp, call <strong>IMFSample::SetSampleTime</strong>. </p> <p>Some MFTs require that input samples have valid time stamps. Some MFTs do not require time stamps.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotAccepting"/></strong></dt> </dl> </td><td> <p> The transform cannot process more input at this time. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> The media type is not set on one or more streams. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedD3DType"/></strong></dt> </dl> </td><td> <p> The media type is not supported for DirectX Video Acceleration (DXVA). A DXVA-enabled decoder might return this error code. </p> </td></tr> </table><p>?</p><strong>Note</strong>??If you are converting a DirectX Media Object (DMO) to an MFT, be aware that <strong>S_FALSE</strong> is not a valid return code for <strong>IMFTransform::ProcessInput</strong>, unlike the <strong>IMediaObject::ProcessInput</strong> method.?</returns>
            <remarks>
            <p> In most cases, if the method succeeds, the MFT stores the sample and holds a reference count on the <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> reference. Do not re-use the sample until the MFT releases the sample. Instead of storing the sample, however, an MFT might copy the sample data into a new buffer. In that case, the MFT should set the <strong>MFT_INPUT_STREAM_DOES_NOT_ADDREF</strong> flag in the <strong>IMFTransform::GetInputStreamInfo</strong> method. </p><p> If the MFT already has enough input data to produce an output sample, it does not accept new input data, and <strong>ProcessInput</strong> returns <strong><see cref = "!:NotAccepting"/></strong>. At that point, the client should clear the pending input data by doing one of the following: </p><ul> <li> Generate new output by calling <strong>IMFTransform::ProcessOutput</strong>. </li> <li> Flush the input data by calling <strong>IMFTransform::ProcessMessage</strong> with the MFT_<strong>MESSAGE_COMMAND_FLUSH</strong> message. </li> </ul><p> An exception to this rule is the <strong>MFT_OUTPUT_STREAM_LAZY_READ</strong> flag. When this flag is present, the transform will discard stored samples if you give it more input. For more information, see <strong>IMFTransform::GetOutputStreamInfo</strong>. A transform should never queue any more input data than is required to produce the correct output. </p><p> An MFT can process the input data in the <strong>ProcessInput</strong> method. However, most MFTs wait until the client calls <strong>ProcessOutput</strong>. </p><p> After the client has set valid media types on all of the streams, the MFT should always be in one of two states: Able to accept more input, or able to produce more output. It should never be in both states or neither state. An MFT should only accept as much input as it needs to generate at least one output sample, at which point <strong>ProcessInput</strong> returns <strong><see cref = "!:NotAccepting"/></strong>. When <strong>ProcessInput</strong> returns <strong><see cref = "!:NotAccepting"/></strong>, the client can assume that the MFT is ready to produce output. </p><p> If an MFT encounters a non-fatal error in the input data, it can simply drop the data and attempt to recover when it gets the more input data. To request more input data, the MFT returns <strong><see cref = "!:TransformNeedMoreInput"/></strong> from the <strong>IMFTransform::ProcessOutput</strong> method. If the MFT drops any data, it should set the <strong><see cref = "!:Discontinuity"/></strong> attribute attribute on the next output sample, to notify the caller that there is a gap in the data stream. </p><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including mftransform.h, this method is renamed <strong>MFTProcessInput</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms703131</doc-id>
            <unmanaged>HRESULT IMFTransform::ProcessInput([In] DWORD dwInputStreamID,[In] IMFSample* pSample,[In] DWORD dwFlags)</unmanaged>
            <unmanaged-short>IMFTransform::ProcessInput</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Transform.ProcessOutput(SharpDX.MediaFoundation.TransformProcessOutputFlags,System.Int32,SharpDX.MediaFoundation.TOutputDataBuffer@,SharpDX.MediaFoundation.TransformProcessOutputStatus@)">
            <summary>
            <p> Generates output from the current input data. </p>
            </summary>
            <param name = "dwFlags"><dd> <p> Bitwise <strong>OR</strong> of zero or more flags from the <strong>_MFT_PROCESS_OUTPUT_FLAGS</strong> enumeration. </p> </dd></param>
            <param name = "cOutputBufferCount"><dd> <p> Number of elements in the <em>pOutputSamples</em> array. The value must be at least 1. </p> </dd></param>
            <param name = "outputSamplesRef"><dd> <p> Pointer to an array of <strong><see cref = "T:SharpDX.MediaFoundation.TOutputDataBuffer"/></strong> structures, allocated by the caller. The MFT uses this array to return output data to the caller. </p> </dd></param>
            <param name = "dwStatusRef"><dd> <p> Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong>_MFT_PROCESS_OUTPUT_STATUS</strong> enumeration. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_UNEXPECTED</strong></dt> </dl> </td><td> <p>The <strong>ProcessOutput</strong> method was called on an asynchronous MFT that was not expecting this method call.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier in the <strong>dwStreamID</strong> member of one or more <strong><see cref = "T:SharpDX.MediaFoundation.TOutputDataBuffer"/></strong> structures. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TransformNeedMoreInput"/></strong></dt> </dl> </td><td> <p> The transform cannot produce output data until it receives more input data. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TransformStreamChange"/></strong></dt> </dl> </td><td> <p> The format has changed on an output stream, or there is a new preferred format, or there is a new output stream. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TransformTypeNotSet"/></strong></dt> </dl> </td><td> <p> You must set the media type on one or more streams of the MFT. </p> </td></tr> </table><p>?</p><strong>Note</strong>??If you are converting a DirectX Media Object (DMO) to an MFT, be aware that <strong>S_FALSE</strong> is not a valid return code for <strong>IMFTransform::ProcessOutput</strong>, unlike the <strong>IMediaObject::ProcessOutput</strong> method.?</returns>
            <remarks>
            <p> The size of the <em>pOutputSamples</em> array must be equal to or greater than the number of <em>selected</em> output streams. The number of selected output streams equals the total number of output streams minus the number of <em>deselected</em> streams. A stream is deselected if it has the <strong>MFT_OUTPUT_STREAM_OPTIONAL</strong> flag and the caller does not set a media type (or sets the media type to <strong><c>null</c></strong>). For more information, see <strong>_MFT_OUTPUT_STREAM_INFO_FLAGS</strong> enumeration. </p><p>This method generates output samples and can also generate events. If the method succeeds, at least one of the following conditions is true:</p><ul> <li> One or more samples in the <em>pOutputSamples</em> array contains output data. </li> <li> One or more members of the <em>pOutputSamples</em> array contains a non-empty collection of events. </li> </ul><p>If <strong>MFT_UNIQUE_METHOD_NAMES</strong> is defined before including Mftransform.h, this method is renamed <strong>MFTProcessOutput</strong>. See Creating Hybrid DMO/MFT Objects.</p>
            </remarks>
            <doc-id>ms704014</doc-id>
            <unmanaged>HRESULT IMFTransform::ProcessOutput([In] DWORD dwFlags,[In] DWORD cOutputBufferCount,[In] MFT_OUTPUT_DATA_BUFFER* pOutputSamples,[Out] DWORD* pdwStatus)</unmanaged>
            <unmanaged-short>IMFTransform::ProcessOutput</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoFormatGuids">
            <summary>
            Functions
            </summary>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoFormatGuids.FromFourCC(SharpDX.Multimedia.FourCC)">
            <summary>
            Returns a standard Media foundation GUID format from a FourCC input
            </summary>
            <param name="fourCC">FourCC input</param>
            <returns>Media foundation unique ID</returns>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormatGuids.Base">
            <summary>Constant Base</summary>
            <unmanaged>MFVideoFormat_Base</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormatGuids.Rgb32">
            <summary>Constant Rgb32</summary>
            <unmanaged>MFVideoFormat_RGB32</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormatGuids.Argb32">
            <summary>Constant Argb32</summary>
            <unmanaged>MFVideoFormat_ARGB32</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormatGuids.Rgb24">
            <summary>Constant Rgb24</summary>
            <unmanaged>MFVideoFormat_RGB24</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormatGuids.Rgb555">
            <summary>Constant Rgb555</summary>
            <unmanaged>MFVideoFormat_RGB555</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormatGuids.Rgb565">
            <summary>Constant Rgb565</summary>
            <unmanaged>MFVideoFormat_RGB565</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormatGuids.Rgb8">
            <summary>Constant Rgb8</summary>
            <unmanaged>MFVideoFormat_RGB8</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormatGuids.L8">
            <summary>Constant L8</summary>
            <unmanaged>MFVideoFormat_L8</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormatGuids.L16">
            <summary>Constant L16</summary>
            <unmanaged>MFVideoFormat_L16</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormatGuids.D16">
            <summary>Constant D16</summary>
            <unmanaged>MFVideoFormat_D16</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormatGuids.A2R10G10B10">
            <summary>Constant A2R10G10B10</summary>
            <unmanaged>MFVideoFormat_A2R10G10B10</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormatGuids.A16B16G16R16F">
            <summary>Constant A16B16G16R16F</summary>
            <unmanaged>MFVideoFormat_A16B16G16R16F</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormatGuids.H264Es">
            <summary>Constant H264Es</summary>
            <unmanaged>MFVideoFormat_H264_ES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormatGuids.Mpeg2">
            <summary>Constant Mpeg2</summary>
            <unmanaged>MFVideoFormat_MPEG2</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormatGuids.H264Hdcp">
            <summary>Constant H264Hdcp</summary>
            <unmanaged>MFVideoFormat_H264_HDCP</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormatGuids.HevcHdcp">
            <summary>Constant HevcHdcp</summary>
            <unmanaged>MFVideoFormat_HEVC_HDCP</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormatGuids.BaseHdcp">
            <summary>Constant BaseHdcp</summary>
            <unmanaged>MFVideoFormat_Base_HDCP</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.WorkQueueId">
            <summary>
            A Work Queue Identifier
            </summary>
            <msdn-id>ms703102</msdn-id>	
            <unmanaged>Work Queue Identifiers</unmanaged>	
            <unmanaged-short>Work Queue Identifiers</unmanaged-short>	
        </member>
        <member name="F:SharpDX.MediaFoundation.WorkQueueId.Standard">
            <summary>
            The default queue associated to the <see cref="F:SharpDX.MediaFoundation.WorkQueueType.Standard"/>.
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.WorkQueueId.Id">
            <summary>
            The identifier.
            </summary>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueId.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.MediaFoundation.WorkQueueId"/> struct.
            </summary>
            <param name="id">The id.</param>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueId.#ctor(SharpDX.MediaFoundation.WorkQueueType)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.MediaFoundation.WorkQueueId"/> struct.
            </summary>
            <param name="id">The id.</param>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueId.op_Implicit(System.Int32)~SharpDX.MediaFoundation.WorkQueueId">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Int32"/> to <see cref="T:SharpDX.MediaFoundation.WorkQueueId"/>.
            </summary>
            <param name="id">The id.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueId.op_Implicit(SharpDX.MediaFoundation.WorkQueueType)~SharpDX.MediaFoundation.WorkQueueId">
            <summary>
            Performs an implicit conversion from <see cref="T:SharpDX.MediaFoundation.WorkQueueType"/> to <see cref="T:SharpDX.MediaFoundation.WorkQueueId"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueId.op_Explicit(SharpDX.MediaFoundation.WorkQueueId)~System.Int32">
            <summary>
            Performs an explicit conversion from <see cref="T:SharpDX.MediaFoundation.WorkQueueId"/> to <see cref="T:System.Int32"/>.
            </summary>
            <param name="workQueueId">The work queue Id.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueId.op_Explicit(SharpDX.MediaFoundation.WorkQueueId)~SharpDX.MediaFoundation.WorkQueueType">
            <summary>
            Performs an explicit conversion from <see cref="T:SharpDX.MediaFoundation.WorkQueueId"/> to <see cref="T:SharpDX.MediaFoundation.WorkQueueType"/>.
            </summary>
            <param name="workQueueId">The work queue Id.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="F:SharpDX.MediaFoundation.ActivateCustomMixerFlags.AllowFail">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_ACTIVATE_CUSTOM_MIXER_ALLOWFAIL</unmanaged>
            <unmanaged-short>MF_ACTIVATE_CUSTOM_MIXER_ALLOWFAIL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ActivateCustomMixerFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ActivateCustomPresenterFlags.AllowFail">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_ACTIVATE_CUSTOM_PRESENTER_ALLOWFAIL</unmanaged>
            <unmanaged-short>MF_ACTIVATE_CUSTOM_PRESENTER_ALLOWFAIL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ActivateCustomPresenterFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfIndexerFlags.WriteNewIndex">
            <summary>
            <dd> <p>The indexer creates a new index object.</p> </dd>
            </summary>
            <doc-id>ms704695</doc-id>
            <unmanaged>MFASF_INDEXER_WRITE_NEW_INDEX</unmanaged>
            <unmanaged-short>MFASF_INDEXER_WRITE_NEW_INDEX</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfIndexerFlags.ReadForReversePlayback">
            <summary>
            <dd> <p>The indexer returns values for reverse playback.</p> </dd>
            </summary>
            <doc-id>ms704695</doc-id>
            <unmanaged>MFASF_INDEXER_READ_FOR_REVERSEPLAYBACK</unmanaged>
            <unmanaged-short>MFASF_INDEXER_READ_FOR_REVERSEPLAYBACK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfIndexerFlags.WriteForLiveread">
            <summary>
            <dd> <p>The indexer creates an index object for a live ASF stream.</p> </dd>
            </summary>
            <doc-id>ms704695</doc-id>
            <unmanaged>MFASF_INDEXER_WRITE_FOR_LIVEREAD</unmanaged>
            <unmanaged-short>MFASF_INDEXER_WRITE_FOR_LIVEREAD</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfIndexerFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfMultiplexerflags.AutoadjustBitRate">
            <summary>
            <dd> <p>The multiplexer automatically adjusts the bit rate of the ASF content in response to the characteristics of the streams being multiplexed.</p> </dd>
            </summary>
            <doc-id>ms698843</doc-id>
            <unmanaged>MFASF_MULTIPLEXER_AUTOADJUST_BITRATE</unmanaged>
            <unmanaged-short>MFASF_MULTIPLEXER_AUTOADJUST_BITRATE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfMultiplexerflags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.AsfSelectionStatus">
            <summary>
            <p> </p><p>Defines the selection options for an ASF stream.</p>
            </summary>
            <doc-id>ms694827</doc-id>
            <unmanaged>ASF_SELECTION_STATUS</unmanaged>
            <unmanaged-short>ASF_SELECTION_STATUS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfSelectionStatus.NotSelected">
            <summary>
            <dd> <p>No samples from the stream are delivered.</p> </dd>
            </summary>
            <doc-id>ms694827</doc-id>
            <unmanaged>ASF_STATUS_NOTSELECTED</unmanaged>
            <unmanaged-short>ASF_STATUS_NOTSELECTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfSelectionStatus.CleanPointsOnly">
            <summary>
            <dd> <p>Only samples from the stream that are clean points are delivered.</p> </dd>
            </summary>
            <doc-id>ms694827</doc-id>
            <unmanaged>ASF_STATUS_CLEANPOINTSONLY</unmanaged>
            <unmanaged-short>ASF_STATUS_CLEANPOINTSONLY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfSelectionStatus.AllDataUnits">
            <summary>
            <dd> <p>All samples from the stream are delivered.</p> </dd>
            </summary>
            <doc-id>ms694827</doc-id>
            <unmanaged>ASF_STATUS_ALLDATAUNITS</unmanaged>
            <unmanaged-short>ASF_STATUS_ALLDATAUNITS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfSplitterflags.Reverse">
            <summary>
            <dd> <p>The splitter delivers samples for the ASF content in reverse order to accommodate reverse playback.</p> </dd>
            </summary>
            <doc-id>ms700211</doc-id>
            <unmanaged>MFASF_SPLITTER_REVERSE</unmanaged>
            <unmanaged-short>MFASF_SPLITTER_REVERSE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfSplitterflags.Wmdrm">
            <summary>
            <dd> <p>The splitter delivers samples for streams that are protected with Windows Media Digital Rights Management.</p> </dd>
            </summary>
            <doc-id>ms700211</doc-id>
            <unmanaged>MFASF_SPLITTER_WMDRM</unmanaged>
            <unmanaged-short>MFASF_SPLITTER_WMDRM</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfSplitterflags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfStatusflags.Incomplete">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms703127</doc-id>
            <unmanaged>ASF_STATUSFLAGS_INCOMPLETE</unmanaged>
            <unmanaged-short>ASF_STATUSFLAGS_INCOMPLETE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfStatusflags.NonfatalError">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms703127</doc-id>
            <unmanaged>ASF_STATUSFLAGS_NONFATAL_ERROR</unmanaged>
            <unmanaged-short>ASF_STATUSFLAGS_NONFATAL_ERROR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfStatusflags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfStreamSelectorFlags.DisableThinning">
            <summary>
            <dd> <p>The stream selector will not set thinning. Thinning is the process of removing samples from a stream to reduce the bit rate.</p> </dd>
            </summary>
            <doc-id>ms696200</doc-id>
            <unmanaged>MFASF_STREAMSELECTOR_DISABLE_THINNING</unmanaged>
            <unmanaged-short>MFASF_STREAMSELECTOR_DISABLE_THINNING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfStreamSelectorFlags.UseAverageBitRate">
            <summary>
            <dd> <p>The stream selector will use the average bit rate of streams when selecting streams.</p> </dd>
            </summary>
            <doc-id>ms696200</doc-id>
            <unmanaged>MFASF_STREAMSELECTOR_USE_AVERAGE_BITRATE</unmanaged>
            <unmanaged-short>MFASF_STREAMSELECTOR_USE_AVERAGE_BITRATE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfStreamSelectorFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsyncCallbackFlags.FastIoProcessing">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFASYNC_FAST_IO_PROCESSING_CALLBACK</unmanaged>
            <unmanaged-short>MFASYNC_FAST_IO_PROCESSING_CALLBACK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsyncCallbackFlags.Signal">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFASYNC_SIGNAL_CALLBACK</unmanaged>
            <unmanaged-short>MFASYNC_SIGNAL_CALLBACK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsyncCallbackFlags.Blocking">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFASYNC_BLOCKING_CALLBACK</unmanaged>
            <unmanaged-short>MFASYNC_BLOCKING_CALLBACK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsyncCallbackFlags.Reply">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFASYNC_REPLY_CALLBACK</unmanaged>
            <unmanaged-short>MFASYNC_REPLY_CALLBACK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsyncCallbackFlags.LocalizeRemote">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFASYNC_LOCALIZE_REMOTE_CALLBACK</unmanaged>
            <unmanaged-short>MFASYNC_LOCALIZE_REMOTE_CALLBACK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsyncCallbackFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.AsyncWorkqueueType">
            <summary>
            <p>Specifies the type of work queue for the <strong>MFAllocateWorkQueueEx</strong> function to create.</p>
            </summary>
            <doc-id>dd388081</doc-id>
            <unmanaged>MFASYNC_WORKQUEUE_TYPE</unmanaged>
            <unmanaged-short>MFASYNC_WORKQUEUE_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsyncWorkqueueType.MfStandardWorkqueue">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388081</doc-id>
            <unmanaged>MF_STANDARD_WORKQUEUE</unmanaged>
            <unmanaged-short>MF_STANDARD_WORKQUEUE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsyncWorkqueueType.MfWindowWorkqueue">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388081</doc-id>
            <unmanaged>MF_WINDOW_WORKQUEUE</unmanaged>
            <unmanaged-short>MF_WINDOW_WORKQUEUE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsyncWorkqueueType.MfMultithreadedWorkqueue">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388081</doc-id>
            <unmanaged>MF_MULTITHREADED_WORKQUEUE</unmanaged>
            <unmanaged-short>MF_MULTITHREADED_WORKQUEUE</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.AttributeSerializeOptions">
            <summary>
            <p> </p><p>Defines flags for serializing and deserializing attribute stores.</p>
            </summary>
            <doc-id>ms704675</doc-id>
            <unmanaged>MF_ATTRIBUTE_SERIALIZE_OPTIONS</unmanaged>
            <unmanaged-short>MF_ATTRIBUTE_SERIALIZE_OPTIONS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AttributeSerializeOptions.UnknownByref">
            <summary>
            <dd> <p>If this flag is set, <strong><see cref = "T:SharpDX.IUnknown"/></strong> references in the attribute store are marshaled to and from the stream. If this flag is absent, <strong><see cref = "T:SharpDX.IUnknown"/></strong> references in the attribute store are not marshaled or serialized.</p> </dd>
            </summary>
            <doc-id>ms704675</doc-id>
            <unmanaged>MF_ATTRIBUTE_SERIALIZE_UNKNOWN_BYREF</unmanaged>
            <unmanaged-short>MF_ATTRIBUTE_SERIALIZE_UNKNOWN_BYREF</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.AttributesMatchType">
            <summary>
            <p> </p><p>Specifies how to compare the attributes on two objects.</p>
            </summary>
            <doc-id>ms703793</doc-id>
            <unmanaged>MF_ATTRIBUTES_MATCH_TYPE</unmanaged>
            <unmanaged-short>MF_ATTRIBUTES_MATCH_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AttributesMatchType.OurItems">
            <summary>
            <dd> <p>Check whether all the attributes in <em>pThis</em> exist in <em>pTheirs</em> and have the same data, where <em>pThis</em> is the object whose <strong>Compare</strong> method is being called and <em>pTheirs</em> is the object given in the <em>pTheirs</em> parameter.</p> </dd>
            </summary>
            <doc-id>ms703793</doc-id>
            <unmanaged>MF_ATTRIBUTES_MATCH_OUR_ITEMS</unmanaged>
            <unmanaged-short>MF_ATTRIBUTES_MATCH_OUR_ITEMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AttributesMatchType.TheirItems">
            <summary>
            <dd> <p>Check whether all the attributes in <em>pTheirs</em> exist in <em>pThis</em> and have the same data, where <em>pThis</em> is the object whose <strong>Compare</strong> method is being called and <em>pTheirs</em> is the object given in the <em>pTheirs</em> parameter.</p> </dd>
            </summary>
            <doc-id>ms703793</doc-id>
            <unmanaged>MF_ATTRIBUTES_MATCH_THEIR_ITEMS</unmanaged>
            <unmanaged-short>MF_ATTRIBUTES_MATCH_THEIR_ITEMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AttributesMatchType.AllItems">
            <summary>
            <dd> <p>Check whether both objects have identical attributes with the same data.</p> </dd>
            </summary>
            <doc-id>ms703793</doc-id>
            <unmanaged>MF_ATTRIBUTES_MATCH_ALL_ITEMS</unmanaged>
            <unmanaged-short>MF_ATTRIBUTES_MATCH_ALL_ITEMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AttributesMatchType.Intersection">
            <summary>
            <dd> <p>Check whether the attributes that exist in both objects have the same data.</p> </dd>
            </summary>
            <doc-id>ms703793</doc-id>
            <unmanaged>MF_ATTRIBUTES_MATCH_INTERSECTION</unmanaged>
            <unmanaged-short>MF_ATTRIBUTES_MATCH_INTERSECTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AttributesMatchType.Smaller">
            <summary>
            <dd> <p>Find the object with the fewest number of attributes, and check if those attributes exist in the other object and have the same data.</p> </dd>
            </summary>
            <doc-id>ms703793</doc-id>
            <unmanaged>MF_ATTRIBUTES_MATCH_SMALLER</unmanaged>
            <unmanaged-short>MF_ATTRIBUTES_MATCH_SMALLER</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.AttributeType">
            <summary>
            <p> </p><p>Defines the data type for a key/value pair.</p>
            </summary>
            <doc-id>ms694854</doc-id>
            <unmanaged>MF_ATTRIBUTE_TYPE</unmanaged>
            <unmanaged-short>MF_ATTRIBUTE_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AttributeType.UInt32">
            <summary>
            <dd> <p>Unsigned 32-bit integer.</p> </dd>
            </summary>
            <doc-id>ms694854</doc-id>
            <unmanaged>MF_ATTRIBUTE_UINT32</unmanaged>
            <unmanaged-short>MF_ATTRIBUTE_UINT32</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AttributeType.UInt64">
            <summary>
            <dd> <p>Unsigned 64-bit integer.</p> </dd>
            </summary>
            <doc-id>ms694854</doc-id>
            <unmanaged>MF_ATTRIBUTE_UINT64</unmanaged>
            <unmanaged-short>MF_ATTRIBUTE_UINT64</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AttributeType.Double">
            <summary>
            <dd> <p>Floating-point number.</p> </dd>
            </summary>
            <doc-id>ms694854</doc-id>
            <unmanaged>MF_ATTRIBUTE_DOUBLE</unmanaged>
            <unmanaged-short>MF_ATTRIBUTE_DOUBLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AttributeType.Guid">
            <summary>
            <dd> <p><strong><see cref = "T:System.Guid"/></strong> value.</p> </dd>
            </summary>
            <doc-id>ms694854</doc-id>
            <unmanaged>MF_ATTRIBUTE_GUID</unmanaged>
            <unmanaged-short>MF_ATTRIBUTE_GUID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AttributeType.String">
            <summary>
            <dd> <p><c>null</c>-terminated wide-character string.</p> </dd>
            </summary>
            <doc-id>ms694854</doc-id>
            <unmanaged>MF_ATTRIBUTE_STRING</unmanaged>
            <unmanaged-short>MF_ATTRIBUTE_STRING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AttributeType.Blob">
            <summary>
            <dd> <p>Byte array.</p> </dd>
            </summary>
            <doc-id>ms694854</doc-id>
            <unmanaged>MF_ATTRIBUTE_BLOB</unmanaged>
            <unmanaged-short>MF_ATTRIBUTE_BLOB</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AttributeType.IUnknown">
            <summary>
            <dd> <p><strong><see cref = "T:SharpDX.IUnknown"/></strong> reference.</p> </dd>
            </summary>
            <doc-id>ms694854</doc-id>
            <unmanaged>MF_ATTRIBUTE_IUNKNOWN</unmanaged>
            <unmanaged-short>MF_ATTRIBUTE_IUNKNOWN</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.AudioConstriction">
            <summary>
            <p>Specifies values for audio constriction.</p>
            </summary>
            <remarks>
            <p>Values defined by the <strong><see cref = "T:SharpDX.MediaFoundation.AudioConstriction"/></strong> enumeration matches the <strong>EAudioConstriction</strong> enumeration defined <strong>audioenginebaseapo.h</strong>.</p>
            </remarks>
            <doc-id>jj128334</doc-id>
            <unmanaged>MFAudioConstriction</unmanaged>
            <unmanaged-short>MFAudioConstriction</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioConstriction.MFaudioConstrictionOff">
            <summary>
            <dd> <p>Audio is not constricted. </p> </dd>
            </summary>
            <doc-id>jj128334</doc-id>
            <unmanaged>MFaudioConstrictionOff</unmanaged>
            <unmanaged-short>MFaudioConstrictionOff</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioConstriction.MFaudioConstriction4816">
            <summary>
            <dd> <p>Audio is down sampled to 48 kHz/16-bit.</p> </dd>
            </summary>
            <doc-id>jj128334</doc-id>
            <unmanaged>MFaudioConstriction48_16</unmanaged>
            <unmanaged-short>MFaudioConstriction48_16</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioConstriction.MFaudioConstriction4416">
            <summary>
            <dd> <p>Audio is down sampled to 44 kHz/16-bit.</p> </dd>
            </summary>
            <doc-id>jj128334</doc-id>
            <unmanaged>MFaudioConstriction44_16</unmanaged>
            <unmanaged-short>MFaudioConstriction44_16</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioConstriction.MFaudioConstriction1414">
            <summary>
            <dd> <p>Audio is down sampled to 14hKz/16-bit.</p> </dd>
            </summary>
            <doc-id>jj128334</doc-id>
            <unmanaged>MFaudioConstriction14_14</unmanaged>
            <unmanaged-short>MFaudioConstriction14_14</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioConstriction.MFaudioConstrictionMute">
            <summary>
            <dd> <p>Audio is muted.</p> </dd>
            </summary>
            <doc-id>jj128334</doc-id>
            <unmanaged>MFaudioConstrictionMute</unmanaged>
            <unmanaged-short>MFaudioConstrictionMute</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.Buffer2DLockFlags">
            <summary>
            <p>Contains flags for the <strong>IMF2DBuffer2::Lock2DSize</strong> method.</p>
            </summary>
            <doc-id>hh162742</doc-id>
            <unmanaged>MF2DBuffer_LockFlags</unmanaged>
            <unmanaged-short>MF2DBuffer_LockFlags</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Buffer2DLockFlags.LockTypeMask">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162742</doc-id>
            <unmanaged>MF2DBuffer_LockFlags_LockTypeMask</unmanaged>
            <unmanaged-short>MF2DBuffer_LockFlags_LockTypeMask</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Buffer2DLockFlags.Read">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162742</doc-id>
            <unmanaged>MF2DBuffer_LockFlags_Read</unmanaged>
            <unmanaged-short>MF2DBuffer_LockFlags_Read</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Buffer2DLockFlags.Write">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162742</doc-id>
            <unmanaged>MF2DBuffer_LockFlags_Write</unmanaged>
            <unmanaged-short>MF2DBuffer_LockFlags_Write</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Buffer2DLockFlags.ReadWrite">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162742</doc-id>
            <unmanaged>MF2DBuffer_LockFlags_ReadWrite</unmanaged>
            <unmanaged-short>MF2DBuffer_LockFlags_ReadWrite</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.ByteStreamSeekOrigin">
            <summary>
            <p> </p><p>Specifies the origin for a seek request.</p>
            </summary>
            <doc-id>ms702091</doc-id>
            <unmanaged>MFBYTESTREAM_SEEK_ORIGIN</unmanaged>
            <unmanaged-short>MFBYTESTREAM_SEEK_ORIGIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ByteStreamSeekOrigin.MsoBegin">
            <summary>
            <dd> <p>The seek position is specified relative to the start of the stream.</p> </dd>
            </summary>
            <doc-id>ms702091</doc-id>
            <unmanaged>msoBegin</unmanaged>
            <unmanaged-short>msoBegin</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ByteStreamSeekOrigin.MsoCurrent">
            <summary>
            <dd> <p>The seek position is specified relative to the current read/write position in the stream.</p> </dd>
            </summary>
            <doc-id>ms702091</doc-id>
            <unmanaged>msoCurrent</unmanaged>
            <unmanaged-short>msoCurrent</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.CaptureEngineDeviceType">
            <summary>
            <p>Specifies a type of capture device.</p>
            </summary>
            <doc-id>hh162811</doc-id>
            <unmanaged>MF_CAPTURE_ENGINE_DEVICE_TYPE</unmanaged>
            <unmanaged-short>MF_CAPTURE_ENGINE_DEVICE_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineDeviceType.Audio">
            <summary>
            <dd> <p>An audio capture device, such as a microphone.</p> </dd>
            </summary>
            <doc-id>hh162811</doc-id>
            <unmanaged>MF_CAPTURE_ENGINE_DEVICE_TYPE_AUDIO</unmanaged>
            <unmanaged-short>MF_CAPTURE_ENGINE_DEVICE_TYPE_AUDIO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineDeviceType.Video">
            <summary>
            <dd> <p>A video capture device, such as a webcam.</p> </dd>
            </summary>
            <doc-id>hh162811</doc-id>
            <unmanaged>MF_CAPTURE_ENGINE_DEVICE_TYPE_VIDEO</unmanaged>
            <unmanaged-short>MF_CAPTURE_ENGINE_DEVICE_TYPE_VIDEO</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.CaptureEngineSinkType">
            <summary>
            <p>Specifies a type of capture sink.</p>
            </summary>
            <doc-id>hh162824</doc-id>
            <unmanaged>MF_CAPTURE_ENGINE_SINK_TYPE</unmanaged>
            <unmanaged-short>MF_CAPTURE_ENGINE_SINK_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineSinkType.Record">
            <summary>
            <dd> <p>A recording sink, for capturing audio and video to a file.</p> </dd>
            </summary>
            <doc-id>hh162824</doc-id>
            <unmanaged>MF_CAPTURE_ENGINE_SINK_TYPE_RECORD</unmanaged>
            <unmanaged-short>MF_CAPTURE_ENGINE_SINK_TYPE_RECORD</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineSinkType.Preview">
            <summary>
            <dd> <p>A preview sink, for previewing live audio or video.</p> </dd>
            </summary>
            <doc-id>hh162824</doc-id>
            <unmanaged>MF_CAPTURE_ENGINE_SINK_TYPE_PREVIEW</unmanaged>
            <unmanaged-short>MF_CAPTURE_ENGINE_SINK_TYPE_PREVIEW</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineSinkType.Photo">
            <summary>
            <dd> <p>A photo sink, for capturing still images.</p> </dd>
            </summary>
            <doc-id>hh162824</doc-id>
            <unmanaged>MF_CAPTURE_ENGINE_SINK_TYPE_PHOTO</unmanaged>
            <unmanaged-short>MF_CAPTURE_ENGINE_SINK_TYPE_PHOTO</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.CaptureEngineStreamCategory">
            <summary>
            <p>Defines the values for the source stream category.</p>
            </summary>
            <doc-id>jj159898</doc-id>
            <unmanaged>MF_CAPTURE_ENGINE_STREAM_CATEGORY</unmanaged>
            <unmanaged-short>MF_CAPTURE_ENGINE_STREAM_CATEGORY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineStreamCategory.VideoPreview">
            <summary>
            <dd> <p>Specifies a video preview stream.</p> </dd>
            </summary>
            <doc-id>jj159898</doc-id>
            <unmanaged>MF_CAPTURE_ENGINE_STREAM_CATEGORY_VIDEO_PREVIEW</unmanaged>
            <unmanaged-short>MF_CAPTURE_ENGINE_STREAM_CATEGORY_VIDEO_PREVIEW</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineStreamCategory.VideoCapture">
            <summary>
            <dd> <p>Specifies a video capture stream.</p> </dd>
            </summary>
            <doc-id>jj159898</doc-id>
            <unmanaged>MF_CAPTURE_ENGINE_STREAM_CATEGORY_VIDEO_CAPTURE</unmanaged>
            <unmanaged-short>MF_CAPTURE_ENGINE_STREAM_CATEGORY_VIDEO_CAPTURE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineStreamCategory.PhotoIndependent">
            <summary>
            <dd> <p>Specifies an independent photo stream.</p> </dd>
            </summary>
            <doc-id>jj159898</doc-id>
            <unmanaged>MF_CAPTURE_ENGINE_STREAM_CATEGORY_PHOTO_INDEPENDENT</unmanaged>
            <unmanaged-short>MF_CAPTURE_ENGINE_STREAM_CATEGORY_PHOTO_INDEPENDENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineStreamCategory.PhotoDependent">
            <summary>
            <dd> <p>Specifies a dependent photo stream.</p> </dd>
            </summary>
            <doc-id>jj159898</doc-id>
            <unmanaged>MF_CAPTURE_ENGINE_STREAM_CATEGORY_PHOTO_DEPENDENT</unmanaged>
            <unmanaged-short>MF_CAPTURE_ENGINE_STREAM_CATEGORY_PHOTO_DEPENDENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineStreamCategory.Audio">
            <summary>
            <dd> <p>Specifies an audio stream.</p> </dd>
            </summary>
            <doc-id>jj159898</doc-id>
            <unmanaged>MF_CAPTURE_ENGINE_STREAM_CATEGORY_AUDIO</unmanaged>
            <unmanaged-short>MF_CAPTURE_ENGINE_STREAM_CATEGORY_AUDIO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineStreamCategory.Unsupported">
            <summary>
            <dd> <p>Specifies an unsupported stream.</p> </dd>
            </summary>
            <doc-id>jj159898</doc-id>
            <unmanaged>MF_CAPTURE_ENGINE_STREAM_CATEGORY_UNSUPPORTED</unmanaged>
            <unmanaged-short>MF_CAPTURE_ENGINE_STREAM_CATEGORY_UNSUPPORTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ClockCharacteristicsFlags.Frequency10mhz">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms699872</doc-id>
            <unmanaged>MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ</unmanaged>
            <unmanaged-short>MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ClockCharacteristicsFlags.AlwaysRunning">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms699872</doc-id>
            <unmanaged>MFCLOCK_CHARACTERISTICS_FLAG_ALWAYS_RUNNING</unmanaged>
            <unmanaged-short>MFCLOCK_CHARACTERISTICS_FLAG_ALWAYS_RUNNING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ClockCharacteristicsFlags.IsSystemClock">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms699872</doc-id>
            <unmanaged>MFCLOCK_CHARACTERISTICS_FLAG_IS_SYSTEM_CLOCK</unmanaged>
            <unmanaged-short>MFCLOCK_CHARACTERISTICS_FLAG_IS_SYSTEM_CLOCK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ClockCharacteristicsFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ClockRelationalFlags.JitterNeverAhead">
            <summary>
            <dd> <p>Jitter values are always negative. In other words, the time returned by <strong>IMFClock::GetCorrelatedTime</strong> might jitter behind the actual clock time, but will never jitter ahead of the actual time. If this flag is not present, the clock might jitter in either direction.</p> </dd>
            </summary>
            <doc-id>ms703927</doc-id>
            <unmanaged>MFCLOCK_RELATIONAL_FLAG_JITTER_NEVER_AHEAD</unmanaged>
            <unmanaged-short>MFCLOCK_RELATIONAL_FLAG_JITTER_NEVER_AHEAD</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ClockRelationalFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.ClockState">
            <summary>
            <p> </p><p>Defines the state of a clock.</p>
            </summary>
            <doc-id>ms700794</doc-id>
            <unmanaged>MFCLOCK_STATE</unmanaged>
            <unmanaged-short>MFCLOCK_STATE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ClockState.Invalid">
            <summary>
            <dd> <p>The clock is invalid. A clock might be invalid for several reasons. Some clocks return this state before the first start. This state can also occur if the underlying device is lost.</p> </dd>
            </summary>
            <doc-id>ms700794</doc-id>
            <unmanaged>MFCLOCK_STATE_INVALID</unmanaged>
            <unmanaged-short>MFCLOCK_STATE_INVALID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ClockState.Running">
            <summary>
            <dd> <p>The clock is running. While the clock is running, the time advances at the clock's frequency and current rate.</p> </dd>
            </summary>
            <doc-id>ms700794</doc-id>
            <unmanaged>MFCLOCK_STATE_RUNNING</unmanaged>
            <unmanaged-short>MFCLOCK_STATE_RUNNING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ClockState.Stopped">
            <summary>
            <dd> <p>The clock is stopped. While stopped, the clock reports a time of 0.</p> </dd>
            </summary>
            <doc-id>ms700794</doc-id>
            <unmanaged>MFCLOCK_STATE_STOPPED</unmanaged>
            <unmanaged-short>MFCLOCK_STATE_STOPPED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ClockState.Paused">
            <summary>
            <dd> <p>The clock is paused. While paused, the clock reports the time it was paused.</p> </dd>
            </summary>
            <doc-id>ms700794</doc-id>
            <unmanaged>MFCLOCK_STATE_PAUSED</unmanaged>
            <unmanaged-short>MFCLOCK_STATE_PAUSED</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.ConnectMethod">
            <summary>
            <p>Specifies how the topology loader connects a topology node. This enumeration is used with the <strong><see cref = "T:SharpDX.MediaFoundation.ConnectMethod"/></strong> attribute. </p>
            </summary>
            <doc-id>ms700178</doc-id>
            <unmanaged>MF_CONNECT_METHOD</unmanaged>
            <unmanaged-short>MF_CONNECT_METHOD</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ConnectMethod.Direct">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms700178</doc-id>
            <unmanaged>MF_CONNECT_DIRECT</unmanaged>
            <unmanaged-short>MF_CONNECT_DIRECT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ConnectMethod.AllowConverter">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms700178</doc-id>
            <unmanaged>MF_CONNECT_ALLOW_CONVERTER</unmanaged>
            <unmanaged-short>MF_CONNECT_ALLOW_CONVERTER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ConnectMethod.AllowDecoder">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms700178</doc-id>
            <unmanaged>MF_CONNECT_ALLOW_DECODER</unmanaged>
            <unmanaged-short>MF_CONNECT_ALLOW_DECODER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ConnectMethod.ResolveIndependentOutputTypes">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms700178</doc-id>
            <unmanaged>MF_CONNECT_RESOLVE_INDEPENDENT_OUTPUTTYPES</unmanaged>
            <unmanaged-short>MF_CONNECT_RESOLVE_INDEPENDENT_OUTPUTTYPES</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ConnectMethod.AsOptional">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms700178</doc-id>
            <unmanaged>MF_CONNECT_AS_OPTIONAL</unmanaged>
            <unmanaged-short>MF_CONNECT_AS_OPTIONAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ConnectMethod.AsOptionalBranch">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms700178</doc-id>
            <unmanaged>MF_CONNECT_AS_OPTIONAL_BRANCH</unmanaged>
            <unmanaged-short>MF_CONNECT_AS_OPTIONAL_BRANCH</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.CrossOriginPolicy">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_CROSS_ORIGIN_POLICY</unmanaged>
            <unmanaged-short>MF_CROSS_ORIGIN_POLICY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CrossOriginPolicy.None">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_CROSS_ORIGIN_POLICY_NONE</unmanaged>
            <unmanaged-short>MF_CROSS_ORIGIN_POLICY_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CrossOriginPolicy.Anonymous">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_CROSS_ORIGIN_POLICY_ANONYMOUS</unmanaged>
            <unmanaged-short>MF_CROSS_ORIGIN_POLICY_ANONYMOUS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CrossOriginPolicy.UseCredentials">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_CROSS_ORIGIN_POLICY_USE_CREDENTIALS</unmanaged>
            <unmanaged-short>MF_CROSS_ORIGIN_POLICY_USE_CREDENTIALS</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.CustomDecodeUnitType">
            <summary>
            <p>Specifies the type of unit contained in an <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> in a MFSampleExtension_ForwardedDecodeUnits collection.</p>
            </summary>
            <doc-id>mt493447</doc-id>
            <unmanaged>MF_CUSTOM_DECODE_UNIT_TYPE</unmanaged>
            <unmanaged-short>MF_CUSTOM_DECODE_UNIT_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CustomDecodeUnitType.MfDecodeUnitNal">
            <summary>
            No documentation.
            </summary>
            <doc-id>mt493447</doc-id>
            <unmanaged>MF_DECODE_UNIT_NAL</unmanaged>
            <unmanaged-short>MF_DECODE_UNIT_NAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CustomDecodeUnitType.MfDecodeUnitSei">
            <summary>
            No documentation.
            </summary>
            <doc-id>mt493447</doc-id>
            <unmanaged>MF_DECODE_UNIT_SEI</unmanaged>
            <unmanaged-short>MF_DECODE_UNIT_SEI</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.DepthMeasurement">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFDepthMeasurement</unmanaged>
            <unmanaged-short>MFDepthMeasurement</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DepthMeasurement.DistanceToFocalPlane">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DistanceToFocalPlane</unmanaged>
            <unmanaged-short>DistanceToFocalPlane</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DepthMeasurement.DistanceToOpticalCenter">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DistanceToOpticalCenter</unmanaged>
            <unmanaged-short>DistanceToOpticalCenter</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.DeviceStreamState">
            <summary>
            <p>The <strong>SetOutputStreamState</strong> method sets the Device MFT output stream state and media type.</p>
            </summary>
            <remarks>
            <p>This interface method helps to transition the output stream to a specified state with specified media type set on the output stream. This will be used by the DTM when the Device Source requests a specific output stream?s state and media type to be changed. Device MFT should change the specified output stream?s media type and state to the requested media type.</p><p>If the incoming media type and stream state are same as the current media type and stream state the method return <strong><see cref = "F:SharpDX.Result.Ok"/></strong>.</p><p>If the incoming media type and current media type of the stream are the same, Device MFT must change the stream?s state to the requested value and return the appropriate <strong><see cref = "T:SharpDX.Result"/></strong>.</p><p>When a change in the output stream?s media type requires a corresponding change in the input then Device MFT must post the METransformInputStreamStateChanged event  to DTM to change the relevant input stream. The call must return only after changing the input stream?s media type and the appropriate <strong><see cref = "T:SharpDX.Result"/></strong>.</p><p>As an  example, consider a Device MFT that has two input streams and three output streams. Let  Output 1 and Output 2 source from Input 1 and  stream at 720p. Now, let us say Output 2?s media type changes to 1080p. To satisfy this request, Device MFT must  change the Input 1 media type to 1080p, by posting METransformInputStreamStateChanged event to the DTM. DTM would call <strong>SetInputStreamState</strong> to change the input stream? media type and state. After this call, the <strong>SetOutputStreamState</strong> must return.</p>
            </remarks>
            <doc-id>mt797684</doc-id>
            <unmanaged>DeviceStreamState</unmanaged>
            <unmanaged-short>DeviceStreamState</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DeviceStreamState.Stop">
            <summary>
            <dd> <p>Stream ID of the input stream where the state and media type needs to be changed.</p> </dd>
            </summary>
            <doc-id>mt797684</doc-id>
            <unmanaged>DeviceStreamState_Stop</unmanaged>
            <unmanaged-short>DeviceStreamState_Stop</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DeviceStreamState.Pause">
            <summary>
            <dd> <p>Preferred media type for the input stream is passed in through this parameter. Device MFT should change the media type only if the incoming media type is different from the current media type.</p> </dd>
            </summary>
            <doc-id>mt797684</doc-id>
            <unmanaged>DeviceStreamState_Pause</unmanaged>
            <unmanaged-short>DeviceStreamState_Pause</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DeviceStreamState.Run">
            <summary>
            <dd> <p>Specifies the  <strong>DeviceStreamState</strong> which the input stream should transition to.</p> </dd>
            </summary>
            <doc-id>mt797684</doc-id>
            <unmanaged>DeviceStreamState_Run</unmanaged>
            <unmanaged-short>DeviceStreamState_Run</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DeviceStreamState.Disabled">
            <summary>
            <dd> <p>Must be zero.</p> </dd>
            </summary>
            <doc-id>mt797684</doc-id>
            <unmanaged>DeviceStreamState_Disabled</unmanaged>
            <unmanaged-short>DeviceStreamState_Disabled</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoInplaceProcessFlags.DmoInplaceNormal">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DMO_INPLACE_NORMAL</unmanaged>
            <unmanaged-short>DMO_INPLACE_NORMAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoInplaceProcessFlags.DmoInplaceZero">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DMO_INPLACE_ZERO</unmanaged>
            <unmanaged-short>DMO_INPLACE_ZERO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoInplaceProcessFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoInputDataBufferFlags.DmoInputDataBufferFSyncpoint">
            <summary>
            <dd> <p>The beginning of the data is a synchronization point.</p> </dd>
            </summary>
            <doc-id>dd375501</doc-id>
            <unmanaged>DMO_INPUT_DATA_BUFFERF_SYNCPOINT</unmanaged>
            <unmanaged-short>DMO_INPUT_DATA_BUFFERF_SYNCPOINT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoInputDataBufferFlags.DmoInputDataBufferFTime">
            <summary>
            <dd> <p>The buffer's time stamp is valid.</p> <p>The buffer's indicated time length is valid.</p> </dd>
            </summary>
            <doc-id>dd375501</doc-id>
            <unmanaged>DMO_INPUT_DATA_BUFFERF_TIME</unmanaged>
            <unmanaged-short>DMO_INPUT_DATA_BUFFERF_TIME</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoInputDataBufferFlags.DmoInputDataBufferFTimelength">
            <summary>
            <dd> <p>The buffer's indicated time length is valid.</p> </dd>
            </summary>
            <doc-id>dd375501</doc-id>
            <unmanaged>DMO_INPUT_DATA_BUFFERF_TIMELENGTH</unmanaged>
            <unmanaged-short>DMO_INPUT_DATA_BUFFERF_TIMELENGTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoInputDataBufferFlags.DmoInputDataBufferFDiscontinuity">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375501</doc-id>
            <unmanaged>DMO_INPUT_DATA_BUFFERF_DISCONTINUITY</unmanaged>
            <unmanaged-short>DMO_INPUT_DATA_BUFFERF_DISCONTINUITY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoInputDataBufferFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoInputStatusFlags.DmoInputStatusfAcceptData">
            <summary>
            No documentation.
            </summary>
            <doc-id>bb250374</doc-id>
            <unmanaged>DMO_INPUT_STATUSF_ACCEPT_DATA</unmanaged>
            <unmanaged-short>DMO_INPUT_STATUSF_ACCEPT_DATA</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoInputStatusFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoInputStreamInformationFlags.DmoInputStreamFWholeSamples">
            <summary>
            <dd> <p>The stream requires whole samples. Samples must not span multiple buffers, and buffers must not contain partial samples.</p> </dd>
            </summary>
            <doc-id>dd375502</doc-id>
            <unmanaged>DMO_INPUT_STREAMF_WHOLE_SAMPLES</unmanaged>
            <unmanaged-short>DMO_INPUT_STREAMF_WHOLE_SAMPLES</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoInputStreamInformationFlags.DmoInputStreamFSingleSamplePerBuffer">
            <summary>
            <dd> <p>Each buffer must contain exactly one sample.</p> </dd>
            </summary>
            <doc-id>dd375502</doc-id>
            <unmanaged>DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER</unmanaged>
            <unmanaged-short>DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoInputStreamInformationFlags.DmoInputStreamFFixedSampleSize">
            <summary>
            <dd> <p>All the samples in this stream must be the same size.</p> </dd>
            </summary>
            <doc-id>dd375502</doc-id>
            <unmanaged>DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE</unmanaged>
            <unmanaged-short>DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoInputStreamInformationFlags.DmoInputStreamFHoldsBuffers">
            <summary>
            <dd> <p>The DMO performs lookahead on the incoming data, and may hold multiple input buffers for this stream.</p> </dd>
            </summary>
            <doc-id>dd375502</doc-id>
            <unmanaged>DMO_INPUT_STREAMF_HOLDS_BUFFERS</unmanaged>
            <unmanaged-short>DMO_INPUT_STREAMF_HOLDS_BUFFERS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoInputStreamInformationFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoOutputDataBufferFlags.DmoOutputDataBufferFSyncpoint">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT</unmanaged>
            <unmanaged-short>DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoOutputDataBufferFlags.DmoOutputDataBufferFTime">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DMO_OUTPUT_DATA_BUFFERF_TIME</unmanaged>
            <unmanaged-short>DMO_OUTPUT_DATA_BUFFERF_TIME</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoOutputDataBufferFlags.DmoOutputDataBufferFTimelength">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH</unmanaged>
            <unmanaged-short>DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoOutputDataBufferFlags.DmoOutputDataBufferFDiscontinuity">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DMO_OUTPUT_DATA_BUFFERF_DISCONTINUITY</unmanaged>
            <unmanaged-short>DMO_OUTPUT_DATA_BUFFERF_DISCONTINUITY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoOutputDataBufferFlags.DmoOutputDataBufferFIncomplete">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE</unmanaged>
            <unmanaged-short>DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoOutputDataBufferFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoOutputStreamInformationFlags.DmoOutputStreamFWholeSamples">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DMO_OUTPUT_STREAMF_WHOLE_SAMPLES</unmanaged>
            <unmanaged-short>DMO_OUTPUT_STREAMF_WHOLE_SAMPLES</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoOutputStreamInformationFlags.DmoOutputStreamFSingleSamplePerBuffer">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER</unmanaged>
            <unmanaged-short>DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoOutputStreamInformationFlags.DmoOutputStreamFFixedSampleSize">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE</unmanaged>
            <unmanaged-short>DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoOutputStreamInformationFlags.DmoOutputStreamFDiscardable">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DMO_OUTPUT_STREAMF_DISCARDABLE</unmanaged>
            <unmanaged-short>DMO_OUTPUT_STREAMF_DISCARDABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoOutputStreamInformationFlags.DmoOutputStreamFOptional">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DMO_OUTPUT_STREAMF_OPTIONAL</unmanaged>
            <unmanaged-short>DMO_OUTPUT_STREAMF_OPTIONAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoOutputStreamInformationFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoProcessOutputFlags.DmoProcessOutputDiscardWhenNoBuffer">
            <summary>
            <dd> <p>Discard the output when the reference to the output buffer is <strong><c>null</c></strong>.</p> </dd>
            </summary>
            <doc-id>dd375511</doc-id>
            <unmanaged>DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER</unmanaged>
            <unmanaged-short>DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoProcessOutputFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoQualityStatusFlags.DmoQualityStatusEnabled">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DMO_QUALITY_STATUS_ENABLED</unmanaged>
            <unmanaged-short>DMO_QUALITY_STATUS_ENABLED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoQualityStatusFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoSetTypeFlags.DmoSetTypefTestOnly">
            <summary>
            <dd> <p>Test the media type but do not set it.</p> </dd>
            </summary>
            <doc-id>dd375514</doc-id>
            <unmanaged>DMO_SET_TYPEF_TEST_ONLY</unmanaged>
            <unmanaged-short>DMO_SET_TYPEF_TEST_ONLY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoSetTypeFlags.DmoSetTypefClear">
            <summary>
            <dd> <p>Clear the media type that was set for the stream.</p> </dd>
            </summary>
            <doc-id>dd375514</doc-id>
            <unmanaged>DMO_SET_TYPEF_CLEAR</unmanaged>
            <unmanaged-short>DMO_SET_TYPEF_CLEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoSetTypeFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoVideoOutputStreamFlags.DmoVosfNeedsPreviousSample">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DMO_VOSF_NEEDS_PREVIOUS_SAMPLE</unmanaged>
            <unmanaged-short>DMO_VOSF_NEEDS_PREVIOUS_SAMPLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoVideoOutputStreamFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.EAllocationType">
            <summary>
            No documentation.
            </summary>
            <unmanaged>EAllocationType</unmanaged>
            <unmanaged-short>EAllocationType</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.EAllocationType.EAllocationTypeDynamic">
            <summary>
            No documentation.
            </summary>
            <unmanaged>eAllocationTypeDynamic</unmanaged>
            <unmanaged-short>eAllocationTypeDynamic</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.EAllocationType.EAllocationTypeRT">
            <summary>
            No documentation.
            </summary>
            <unmanaged>eAllocationTypeRT</unmanaged>
            <unmanaged-short>eAllocationTypeRT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.EAllocationType.EAllocationTypePageable">
            <summary>
            No documentation.
            </summary>
            <unmanaged>eAllocationTypePageable</unmanaged>
            <unmanaged-short>eAllocationTypePageable</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.EAllocationType.EAllocationTypeIgnore">
            <summary>
            No documentation.
            </summary>
            <unmanaged>eAllocationTypeIgnore</unmanaged>
            <unmanaged-short>eAllocationTypeIgnore</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.EVRFilterConfigPrefs">
            <summary>
            <p>Contains flags that are used to configure the Microsoft DirectShow enhanced video renderer (EVR) filter.</p>
            </summary>
            <doc-id>dd318789</doc-id>
            <unmanaged>EVRFilterConfigPrefs</unmanaged>
            <unmanaged-short>EVRFilterConfigPrefs</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRFilterConfigPrefs.EnableQoS">
            <summary>
            <dd> <p>Enables dynamic adjustments to video quality during playback.</p> </dd>
            </summary>
            <doc-id>dd318789</doc-id>
            <unmanaged>EVRFilterConfigPrefs_EnableQoS</unmanaged>
            <unmanaged-short>EVRFilterConfigPrefs_EnableQoS</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.FileAccessMode">
            <summary>
            <p> </p><p>Specifies the requested access mode for opening a file.</p>
            </summary>
            <doc-id>ms696239</doc-id>
            <unmanaged>MF_FILE_ACCESSMODE</unmanaged>
            <unmanaged-short>MF_FILE_ACCESSMODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FileAccessMode.MfAccessModeRead">
            <summary>
            <dd> <p>Read mode.</p> </dd>
            </summary>
            <doc-id>ms696239</doc-id>
            <unmanaged>MF_ACCESSMODE_READ</unmanaged>
            <unmanaged-short>MF_ACCESSMODE_READ</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FileAccessMode.MfAccessModeWrite">
            <summary>
            <dd> <p>Write mode.</p> </dd>
            </summary>
            <doc-id>ms696239</doc-id>
            <unmanaged>MF_ACCESSMODE_WRITE</unmanaged>
            <unmanaged-short>MF_ACCESSMODE_WRITE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FileAccessMode.MfAccessModeReadwrite">
            <summary>
            <dd> <p>Read and write mode.</p> </dd>
            </summary>
            <doc-id>ms696239</doc-id>
            <unmanaged>MF_ACCESSMODE_READWRITE</unmanaged>
            <unmanaged-short>MF_ACCESSMODE_READWRITE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FileFlags.FlagsNone">
            <summary>
            <dd> <p> Use the default behavior. </p> </dd>
            </summary>
            <doc-id>ms694926</doc-id>
            <unmanaged>MF_FILEFLAGS_NONE</unmanaged>
            <unmanaged-short>MF_FILEFLAGS_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FileFlags.FlagsNobuffering">
            <summary>
            <dd> <p> Open the file with no system caching. </p> </dd>
            </summary>
            <doc-id>ms694926</doc-id>
            <unmanaged>MF_FILEFLAGS_NOBUFFERING</unmanaged>
            <unmanaged-short>MF_FILEFLAGS_NOBUFFERING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FileFlags.FlagsAllowWriteSharing">
            <summary>
            <dd> <p>Subsequent open operations can have write access to the file. </p> <strong>Note</strong>??Requires Windows?7 or later. ? </dd>
            </summary>
            <doc-id>ms694926</doc-id>
            <unmanaged>MF_FILEFLAGS_ALLOW_WRITE_SHARING</unmanaged>
            <unmanaged-short>MF_FILEFLAGS_ALLOW_WRITE_SHARING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FileFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.FileOpenMode">
            <summary>
            <p> </p><p>Specifies how to open or create a file.</p>
            </summary>
            <doc-id>ms694164</doc-id>
            <unmanaged>MF_FILE_OPENMODE</unmanaged>
            <unmanaged-short>MF_FILE_OPENMODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FileOpenMode.MfOpenModeFailIfNotExist">
            <summary>
            <dd> <p>Open an existing file. Fail if the file does not exist.</p> </dd>
            </summary>
            <doc-id>ms694164</doc-id>
            <unmanaged>MF_OPENMODE_FAIL_IF_NOT_EXIST</unmanaged>
            <unmanaged-short>MF_OPENMODE_FAIL_IF_NOT_EXIST</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FileOpenMode.MfOpenModeFailIfExist">
            <summary>
            <dd> <p>Create a new file. Fail if the file already exists.</p> </dd>
            </summary>
            <doc-id>ms694164</doc-id>
            <unmanaged>MF_OPENMODE_FAIL_IF_EXIST</unmanaged>
            <unmanaged-short>MF_OPENMODE_FAIL_IF_EXIST</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FileOpenMode.MfOpenModeResetIfExist">
            <summary>
            <dd> <p>Open an existing file and truncate it, so that the size is zero bytes. Fail if the file does not already exist.</p> </dd>
            </summary>
            <doc-id>ms694164</doc-id>
            <unmanaged>MF_OPENMODE_RESET_IF_EXIST</unmanaged>
            <unmanaged-short>MF_OPENMODE_RESET_IF_EXIST</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FileOpenMode.MfOpenModeAppendIfExist">
            <summary>
            <dd> <p>If the file does not exist, create a new file. If the file exists, open it.</p> </dd>
            </summary>
            <doc-id>ms694164</doc-id>
            <unmanaged>MF_OPENMODE_APPEND_IF_EXIST</unmanaged>
            <unmanaged-short>MF_OPENMODE_APPEND_IF_EXIST</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FileOpenMode.MfOpenModeDeleteIfExist">
            <summary>
            <dd> <p>Create a new file. If the file exists, overwrite the file.</p> </dd>
            </summary>
            <doc-id>ms694164</doc-id>
            <unmanaged>MF_OPENMODE_DELETE_IF_EXIST</unmanaged>
            <unmanaged-short>MF_OPENMODE_DELETE_IF_EXIST</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.FrameSourceTypes">
            <summary>
            <p>Describes the type of data provided by a frame source.</p>
            </summary>
            <remarks>
            <p>The values of this enumeration are used with the MF_DEVICESTREAM_ATTRIBUTE_FRAMESOURCE_TYPES attribute.</p>
            </remarks>
            <doc-id>mt764279</doc-id>
            <unmanaged>MFFrameSourceTypes</unmanaged>
            <unmanaged-short>MFFrameSourceTypes</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FrameSourceTypes.Color">
            <summary>
            <dd> <p>The frame source provides color data.</p> </dd>
            </summary>
            <doc-id>mt764279</doc-id>
            <unmanaged>MFFrameSourceTypes_Color</unmanaged>
            <unmanaged-short>MFFrameSourceTypes_Color</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FrameSourceTypes.Infrared">
            <summary>
            <dd> <p>The frame source provides infrared data.</p> </dd>
            </summary>
            <doc-id>mt764279</doc-id>
            <unmanaged>MFFrameSourceTypes_Infrared</unmanaged>
            <unmanaged-short>MFFrameSourceTypes_Infrared</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FrameSourceTypes.Depth">
            <summary>
            <dd> <p>The frame source provides depth data.</p> </dd>
            </summary>
            <doc-id>mt764279</doc-id>
            <unmanaged>MFFrameSourceTypes_Depth</unmanaged>
            <unmanaged-short>MFFrameSourceTypes_Depth</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FrameSourceTypes.Custom">
            <summary>
            <dd> <p>The frame source provides custom data.</p> </dd>
            </summary>
            <doc-id>mt764279</doc-id>
            <unmanaged>MFFrameSourceTypes_Custom</unmanaged>
            <unmanaged-short>MFFrameSourceTypes_Custom</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.HdcpStatus">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_HDCP_STATUS</unmanaged>
            <unmanaged-short>MF_HDCP_STATUS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.HdcpStatus.On">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_HDCP_STATUS_ON</unmanaged>
            <unmanaged-short>MF_HDCP_STATUS_ON</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.HdcpStatus.Off">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_HDCP_STATUS_OFF</unmanaged>
            <unmanaged-short>MF_HDCP_STATUS_OFF</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.HdcpStatus.OnWithTypeEnforcement">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_HDCP_STATUS_ON_WITH_TYPE_ENFORCEMENT</unmanaged>
            <unmanaged-short>MF_HDCP_STATUS_ON_WITH_TYPE_ENFORCEMENT</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaEngineCanPlay">
            <summary>
            <p>Specifies the likelihood that the Media Engine can play a specified type of media resource.</p>
            </summary>
            <doc-id>hh162836</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_CANPLAY</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_CANPLAY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineCanPlay.NotSupported">
            <summary>
            <dd> <p>The Media Engine cannot play the resource.</p> </dd>
            </summary>
            <doc-id>hh162836</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_CANPLAY_NOT_SUPPORTED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_CANPLAY_NOT_SUPPORTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineCanPlay.Maybe">
            <summary>
            <dd> <p>The Media Engine might be able to play the resource.</p> </dd>
            </summary>
            <doc-id>hh162836</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_CANPLAY_MAYBE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_CANPLAY_MAYBE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineCanPlay.Probably">
            <summary>
            <dd> <p>The Media Engine can probably play the resource.</p> </dd>
            </summary>
            <doc-id>hh162836</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_CANPLAY_PROBABLY</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_CANPLAY_PROBABLY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineCreateFlags.AudioOnly">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162839</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_AUDIOONLY</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_AUDIOONLY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineCreateFlags.WaitForStableState">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162839</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_WAITFORSTABLE_STATE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_WAITFORSTABLE_STATE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineCreateFlags.ForceMute">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162839</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_FORCEMUTE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_FORCEMUTE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineCreateFlags.RealTimeMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162839</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_REAL_TIME_MODE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_REAL_TIME_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineCreateFlags.DisableLocalPlugins">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162839</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_DISABLE_LOCAL_PLUGINS</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_DISABLE_LOCAL_PLUGINS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineCreateFlags.CreateFlagsMask">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162839</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_CREATEFLAGS_MASK</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_CREATEFLAGS_MASK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineCreateFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaEngineErr">
            <summary>
            <p>Defines error status codes for the Media Engine.</p>
            </summary>
            <remarks>
            <p>The values greater than zero correspond to error codes defined for the <strong>MediaError</strong> object  in HTML5.</p>
            </remarks>
            <doc-id>hh162841</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_ERR</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_ERR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineErr.Noerror">
            <summary>
            <dd> <p>No error.</p> </dd>
            </summary>
            <doc-id>hh162841</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_ERR_NOERROR</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_ERR_NOERROR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineErr.Aborted">
            <summary>
            <dd> <p>The process of fetching the media resource was stopped at the user's request. </p> </dd>
            </summary>
            <doc-id>hh162841</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_ERR_ABORTED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_ERR_ABORTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineErr.Network">
            <summary>
            <dd> <p>A network error occurred while fetching the media resource. </p> </dd>
            </summary>
            <doc-id>hh162841</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_ERR_NETWORK</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_ERR_NETWORK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineErr.Decode">
            <summary>
            <dd> <p>An error occurred while decoding the media resource. </p> </dd>
            </summary>
            <doc-id>hh162841</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_ERR_DECODE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_ERR_DECODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineErr.SourceNotSupported">
            <summary>
            <dd> <p>The media resource is not supported. </p> </dd>
            </summary>
            <doc-id>hh162841</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_ERR_SRC_NOT_SUPPORTED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_ERR_SRC_NOT_SUPPORTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineErr.Encrypted">
            <summary>
            <dd> <p>An error occurred while encrypting the media resource.</p> <p>Supported in Windows?8.1 and later.</p> </dd>
            </summary>
            <doc-id>hh162841</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_ERR_ENCRYPTED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_ERR_ENCRYPTED</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaEngineEvent">
            <summary>
            <p>Defines event codes for the Media Engine. </p>
            </summary>
            <remarks>
            <p>The application receives Media Engine events through the <strong>IMFMediaEngineNotify::EventNotify</strong> method. The <strong>EventNotify</strong> method includes two event parameters, <em>param1</em> and <em>param2</em>. The meaning of the parameters depends on the event code. If the event description does not list any parameters, ignore the values of <em>param1</em> and <em>param2</em>.</p><p>Values below 1000 correspond to events defined in HTML 5 for media elements.</p>
            </remarks>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.LoadStart">
            <summary>
            <dd> <p>The Media Engine has started to load the source. See <strong>IMFMediaEngine::Load</strong>.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_LOADSTART</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_LOADSTART</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.Progress">
            <summary>
            <dd> <p>The Media Engine is loading the source.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_PROGRESS</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_PROGRESS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.Suspend">
            <summary>
            <dd> <p>The Media Engine has suspended a load operation.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_SUSPEND</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_SUSPEND</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.Abort">
            <summary>
            <dd> <p>The Media Engine cancelled a load operation that was in progress. </p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_ABORT</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_ABORT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.Error">
            <summary>
            <dd> <p>An error occurred.</p> <table> <tr><th>Event Parameter</th><th>Description</th></tr> <tr><td><em>param1</em></td><td>A member of the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineErr"/></strong> enumeration.</td></tr> <tr><td><em>param2</em></td><td>An <strong><see cref = "T:SharpDX.Result"/></strong> error code, or zero.</td></tr> </table> <p>?</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_ERROR</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_ERROR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.Emptied">
            <summary>
            <dd> <p>The Media Engine has switched to the <strong>MF_MEDIA_ENGINE_NETWORK_EMPTY</strong> state. This can occur when the <strong>IMFMediaEngine::Load</strong> method is called, or if an error occurs during the <strong>Load</strong> method. See <strong>IMFMediaEngine::GetNetworkState</strong>.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_EMPTIED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_EMPTIED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.Stalled">
            <summary>
            <dd> <p>The <strong>Load</strong> algorithm is stalled, waiting for data.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_STALLED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_STALLED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.Play">
            <summary>
            <dd> <p>The Media Engine is switching to the playing state. See <strong>IMFMediaEngine::Play</strong>.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_PLAY</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_PLAY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.Pause">
            <summary>
            <dd> <p>The media engine has paused. See <strong>IMFMediaEngine::Pause</strong>.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_PAUSE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_PAUSE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.LoadedMetadata">
            <summary>
            <dd> <p>The Media Engine has loaded enough source data to determine the duration and dimensions  of the source.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_LOADEDMETADATA</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_LOADEDMETADATA</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.LoadedData">
            <summary>
            <dd> <p>The Media Engine has loaded enough data to render some content (for example, a video frame).</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_LOADEDDATA</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_LOADEDDATA</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.Waiting">
            <summary>
            <dd> <p>Playback has stopped because the next frame is not available.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_WAITING</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_WAITING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.Playing">
            <summary>
            <dd> <p>Playback has started. See <strong>IMFMediaEngine::Play</strong>.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_PLAYING</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_PLAYING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.CanPlay">
            <summary>
            <dd> <p>Playback can start, but the Media Engine might need to stop to buffer more data.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_CANPLAY</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_CANPLAY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.CanPlayThrough">
            <summary>
            <dd> <p>The Media Engine can probably play through to the end of the resource, without stopping to buffer data.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_CANPLAYTHROUGH</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_CANPLAYTHROUGH</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.Seeking">
            <summary>
            <dd> <p>The Media Engine has started seeking to a new playback position. See <strong>IMFMediaEngine::SetCurrentTime</strong>.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_SEEKING</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_SEEKING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.Seeked">
            <summary>
            <dd> <p>The Media Engine has seeked to a new playback position. See <strong>IMFMediaEngine::SetCurrentTime</strong>.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_SEEKED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_SEEKED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.TimeUpdate">
            <summary>
            <dd> <p>The playback position has changed. See <strong>IMFMediaEngine::GetCurrentTime</strong>.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_TIMEUPDATE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_TIMEUPDATE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.Ended">
            <summary>
            <dd> <p>Playback has reached the end of the source. This event is not sent if the <strong>GetLoop</strong>is <strong>TRUE</strong>.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_ENDED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_ENDED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.RateChange">
            <summary>
            <dd> <p>The playback rate has changed. See <strong>IMFMediaEngine::SetPlaybackRate</strong>.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_RATECHANGE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_RATECHANGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.DurationChange">
            <summary>
            <dd> <p>The duration of the media source has changed. See <strong>IMFMediaEngine::GetDuration</strong>.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_DURATIONCHANGE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_DURATIONCHANGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.VolumeChange">
            <summary>
            <dd> <p>The audio volume changed. See <strong>IMFMediaEngine::SetVolume</strong>.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_VOLUMECHANGE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_VOLUMECHANGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.FormatChange">
            <summary>
            <dd> <p>The output format of the media source has changed.</p> <table> <tr><th>Event Parameter</th><th>Description</th></tr> <tr><td><em>param1</em></td><td>Zero if the video format changed, 1 if the audio format changed.</td></tr> <tr><td><em>param2</em></td><td>Zero.</td></tr> </table> <p>?</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_FORMATCHANGE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_FORMATCHANGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.PurgeQueuedEvents">
            <summary>
            <dd> <p>The Media Engine flushed any pending events from its 	queue.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.TimelineMarker">
            <summary>
            <dd> <p>The playback position reached a timeline marker. See <strong>IMFMediaEngineEx::SetTimelineMarkerTimer</strong>.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_TIMELINE_MARKER</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_TIMELINE_MARKER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.BalanceChange">
            <summary>
            <dd> <p>The audio balance changed. See <strong>IMFMediaEngineEx::SetBalance</strong>.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_BALANCECHANGE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_BALANCECHANGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.DownloadComplete">
            <summary>
            <dd> <p>The Media Engine has finished downloading the source data.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_DOWNLOADCOMPLETE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_DOWNLOADCOMPLETE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.BufferingStarted">
            <summary>
            <dd> <p>The media source has started to buffer data.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_BUFFERINGSTARTED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_BUFFERINGSTARTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.BufferingEnded">
            <summary>
            <dd> <p>The media source has stopped buffering data.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_BUFFERINGENDED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_BUFFERINGENDED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.FrameStepCompleted">
            <summary>
            <dd> <p>The <strong>IMFMediaEngineEx::FrameStep</strong> method completed.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_FRAMESTEPCOMPLETED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_FRAMESTEPCOMPLETED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.NotifyStableState">
            <summary>
            <dd> <p>The Media Engine's <strong>Load</strong> algorithm is waiting to start.</p> <table> <tr><th>Event Parameter</th><th>Description</th></tr> <tr><td><em>param1</em></td><td>A handle to a waitable event, of type <strong>HANDLE</strong>.</td></tr> <tr><td><em>param2</em></td><td>Zero.</td></tr> </table> <p>?</p> <p>If Media Engine is created with the <strong>MF_MEDIA_ENGINE_WAITFORSTABLE_STATE</strong> flag, the Media Engine sends the <strong>MF_MEDIA_ENGINE_EVENT_NOTIFYSTABLESTATE</strong> event at the start of the <strong>Load</strong> algorithm. The <em>param1</em> parameter is a handle to a waitable event. The <strong>Load</strong> thread waits for the application to signal the event by calling <strong>SetEvent</strong>.</p> <p>If the Media Engine is not created with the <strong>MF_MEDIA_ENGINE_WAITFORSTABLE_STATE</strong>, it does not send this event, and the <strong>Load</strong> thread does not wait to be signalled.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_NOTIFYSTABLESTATE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_NOTIFYSTABLESTATE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.FirstFrameReady">
            <summary>
            <dd> <p>The first frame of the media source is ready to render.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_FIRSTFRAMEREADY</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_FIRSTFRAMEREADY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.Trackschange">
            <summary>
            <dd> <p>Raised when a new track is added or removed.</p> <p>Supported in Windows?8.1 and later.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_TRACKSCHANGE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_TRACKSCHANGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.OpmInformation">
            <summary>
            <dd> <p>Raised when there is new information about the Output Protection Manager (OPM). </p> <p>This event will be raised when an OPM failure occurs, but ITA allows fallback without the OPM. In this case, constriction can be applied. </p> <p>This event will not be raised when there is an OPM failure and the fallback also fails. For example, if ITA blocks playback entirely when OPM cannot be established.</p> <p>Supported in Windows?8.1 and later.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_OPMINFO</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_OPMINFO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.ResourceLost">
            <summary>
            <dd> <p>Raised when one of the component streams of a media stream fails. This event is only raised if the media stream contains other component streams that did not fail.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_RESOURCELOST</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_RESOURCELOST</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.DelayloadeventChanged">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_DELAYLOADEVENT_CHANGED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_DELAYLOADEVENT_CHANGED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.StreamRenderingerror">
            <summary>
            <dd> <p>Raised when one of the component streams of a media stream fails. This event is only raised if the media stream contains other component streams that did not fail.</p> </dd>
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_STREAMRENDERINGERROR</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_STREAMRENDERINGERROR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineEvent.SupportedRateSChanged">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162842</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EVENT_SUPPORTEDRATES_CHANGED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EVENT_SUPPORTEDRATES_CHANGED</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaEngineExtensionType">
            <summary>
            <p>Specifies media engine extension types.</p>
            </summary>
            <doc-id>hh162844</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EXTENSION_TYPE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EXTENSION_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineExtensionType.MediaSource">
            <summary>
            <dd></dd>
            </summary>
            <doc-id>hh162844</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EXTENSION_TYPE_MEDIASOURCE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EXTENSION_TYPE_MEDIASOURCE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineExtensionType.ByteStream">
            <summary>
            <dd></dd>
            </summary>
            <doc-id>hh162844</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_EXTENSION_TYPE_BYTESTREAM</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_EXTENSION_TYPE_BYTESTREAM</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineFrameProtectionFlags.Protected">
            <summary>
            <dd> <p>The video frame should be protected.</p> </dd>
            </summary>
            <doc-id>hh162845</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_PROTECTED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_PROTECTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineFrameProtectionFlags.RequiresSurfaceProtection">
            <summary>
            <dd> <p>Direct3D surface protection must be applied to any surface that contains the frame.</p> </dd>
            </summary>
            <doc-id>hh162845</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_SURFACE_PROTECTION</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_SURFACE_PROTECTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineFrameProtectionFlags.RequiresAntiScreenScrapeProtection">
            <summary>
            <dd> <p>Direct3D anti-screen-scrape protection must be applied to any surface that contains the frame.</p> </dd>
            </summary>
            <doc-id>hh162845</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_ANTI_SCREEN_SCRAPE_PROTECTION</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_ANTI_SCREEN_SCRAPE_PROTECTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineFrameProtectionFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaEngineKeyerr">
            <summary>
            <p>Defines media key error codes for the media engine.</p>
            </summary>
            <remarks>
            <p><strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineKeyerr"/></strong> is used with the <em>code</em> parameter of  <strong>IMFMediaKeySessionNotify::KeyError</strong> and the <em>code</em> value returned from <strong>IMFMediaKeySession::GetError</strong>.</p>
            </remarks>
            <doc-id>dn302188</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_KEYERR</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_KEYERR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineKeyerr.EngineKeyerrUnknown">
            <summary>
            <dd> <p>Unknown error occurred.</p> </dd>
            </summary>
            <doc-id>dn302188</doc-id>
            <unmanaged>MF_MEDIAENGINE_KEYERR_UNKNOWN</unmanaged>
            <unmanaged-short>MF_MEDIAENGINE_KEYERR_UNKNOWN</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineKeyerr.EngineKeyerrClient">
            <summary>
            <dd> <p>An error with the client occurred.</p> </dd>
            </summary>
            <doc-id>dn302188</doc-id>
            <unmanaged>MF_MEDIAENGINE_KEYERR_CLIENT</unmanaged>
            <unmanaged-short>MF_MEDIAENGINE_KEYERR_CLIENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineKeyerr.EngineKeyerrService">
            <summary>
            <dd> <p>An error with the service occurred.</p> </dd>
            </summary>
            <doc-id>dn302188</doc-id>
            <unmanaged>MF_MEDIAENGINE_KEYERR_SERVICE</unmanaged>
            <unmanaged-short>MF_MEDIAENGINE_KEYERR_SERVICE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineKeyerr.EngineKeyerrOutput">
            <summary>
            <dd> <p>An error with the output occurred.</p> </dd>
            </summary>
            <doc-id>dn302188</doc-id>
            <unmanaged>MF_MEDIAENGINE_KEYERR_OUTPUT</unmanaged>
            <unmanaged-short>MF_MEDIAENGINE_KEYERR_OUTPUT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineKeyerr.EngineKeyerrHardwarechange">
            <summary>
            <dd> <p>An error occurred related to a hardware change.</p> </dd>
            </summary>
            <doc-id>dn302188</doc-id>
            <unmanaged>MF_MEDIAENGINE_KEYERR_HARDWARECHANGE</unmanaged>
            <unmanaged-short>MF_MEDIAENGINE_KEYERR_HARDWARECHANGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineKeyerr.EngineKeyerrDomain">
            <summary>
            <dd> <p>An error with the domain occurred.</p> </dd>
            </summary>
            <doc-id>dn302188</doc-id>
            <unmanaged>MF_MEDIAENGINE_KEYERR_DOMAIN</unmanaged>
            <unmanaged-short>MF_MEDIAENGINE_KEYERR_DOMAIN</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaEngineNetwork">
            <summary>
            <p>Defines network status codes for the Media Engine.</p>
            </summary>
            <doc-id>hh162846</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_NETWORK</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_NETWORK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineNetwork.Empty">
            <summary>
            <dd> <p>The initial state.</p> </dd>
            </summary>
            <doc-id>hh162846</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_NETWORK_EMPTY</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_NETWORK_EMPTY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineNetwork.Idle">
            <summary>
            <dd> <p>The Media Engine has started the resource selection algorithm, and has selected a media resource, but is not using the network.</p> </dd>
            </summary>
            <doc-id>hh162846</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_NETWORK_IDLE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_NETWORK_IDLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineNetwork.Loading">
            <summary>
            <dd> <p>The Media Engine is loading a media resource.</p> </dd>
            </summary>
            <doc-id>hh162846</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_NETWORK_LOADING</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_NETWORK_LOADING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineNetwork.NoSource">
            <summary>
            <dd> <p>The Media Engine has started the resource selection algorithm, but has not selected a media resource.</p> </dd>
            </summary>
            <doc-id>hh162846</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_NETWORK_NO_SOURCE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_NETWORK_NO_SOURCE</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaEngineOpmStatus">
            <summary>
            <p>Defines the status of the Output Protection Manager (OPM).</p>
            </summary>
            <doc-id>dn302190</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_OPM_STATUS</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_OPM_STATUS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineOpmStatus.NotRequested">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302190</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_OPM_NOT_REQUESTED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_OPM_NOT_REQUESTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineOpmStatus.Established">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302190</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_OPM_ESTABLISHED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_OPM_ESTABLISHED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineOpmStatus.FailedVm">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302190</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_OPM_FAILED_VM</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_OPM_FAILED_VM</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineOpmStatus.FailedBda">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302190</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_OPM_FAILED_BDA</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_OPM_FAILED_BDA</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineOpmStatus.FailedUnsignedDriver">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302190</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_OPM_FAILED_UNSIGNED_DRIVER</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_OPM_FAILED_UNSIGNED_DRIVER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineOpmStatus.Failed">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302190</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_OPM_FAILED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_OPM_FAILED</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaEnginePreload">
            <summary>
            <p>Defines preload hints for the Media Engine. These values correspond to the <strong>preload</strong> attribute of the <strong>HTMLMediaElement</strong> interface in HTML5.</p>
            </summary>
            <doc-id>hh162851</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_PRELOAD</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_PRELOAD</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEnginePreload.Missing">
            <summary>
            <dd> <p>The <strong>preload</strong> attribute is missing. </p> </dd>
            </summary>
            <doc-id>hh162851</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_PRELOAD_MISSING</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_PRELOAD_MISSING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEnginePreload.Empty">
            <summary>
            <dd> <p>The <strong>preload</strong> attribute is an empty string. This value is equivalent to <strong>MF_MEDIA_ENGINE_PRELOAD_AUTOMATIC</strong>.</p> </dd>
            </summary>
            <doc-id>hh162851</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_PRELOAD_EMPTY</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_PRELOAD_EMPTY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEnginePreload.None">
            <summary>
            <dd> <p>The <strong>preload</strong> attribute is "none". This value is a hint to the user agent not to preload the resource.</p> </dd>
            </summary>
            <doc-id>hh162851</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_PRELOAD_NONE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_PRELOAD_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEnginePreload.Metadata">
            <summary>
            <dd> <p>The <strong>preload</strong> attribute is "metadata". This value is a hint to the user agent to fetch the resource metadata.</p> </dd>
            </summary>
            <doc-id>hh162851</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_PRELOAD_METADATA</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_PRELOAD_METADATA</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEnginePreload.Automatic">
            <summary>
            <dd> <p>The <strong>preload</strong> attribute is "auto". This value is a hint to the user agent to preload the entire resource.</p> </dd>
            </summary>
            <doc-id>hh162851</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_PRELOAD_AUTOMATIC</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_PRELOAD_AUTOMATIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineProtectionFlags.EnableProtectedContent">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162852</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_ENABLE_PROTECTED_CONTENT</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_ENABLE_PROTECTED_CONTENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineProtectionFlags.UsePmpForAllContent">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162852</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_USE_PMP_FOR_ALL_CONTENT</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_USE_PMP_FOR_ALL_CONTENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineProtectionFlags.UseUnprotectedPmp">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162852</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_USE_UNPROTECTED_PMP</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_USE_UNPROTECTED_PMP</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineProtectionFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaEngineReady">
            <summary>
            <p>Defines ready-state values for the Media Engine.</p>
            </summary>
            <remarks>
            <p>These values correspond to constants defined for the  <strong>HTMLMediaElement.readyState</strong> attribute  in HTML5.</p>
            </remarks>
            <doc-id>hh162853</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_READY</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_READY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineReady.HaveNothing">
            <summary>
            <dd> <p>No data is available.</p> </dd>
            </summary>
            <doc-id>hh162853</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_READY_HAVE_NOTHING</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_READY_HAVE_NOTHING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineReady.HaveMetadata">
            <summary>
            <dd> <p>Some metadata is available, including the duration and, for video files, the video dimensions. No media data is available.</p> </dd>
            </summary>
            <doc-id>hh162853</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_READY_HAVE_METADATA</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_READY_HAVE_METADATA</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineReady.HaveCurrentData">
            <summary>
            <dd> <p>There is media data  for the current playback position, but not enough data for playback or seeking.</p> </dd>
            </summary>
            <doc-id>hh162853</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_READY_HAVE_CURRENT_DATA</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_READY_HAVE_CURRENT_DATA</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineReady.HaveFutureData">
            <summary>
            <dd> <p>There is enough media data to enable some playback or seeking. The amount of data might be a little as the next video frame.</p> </dd>
            </summary>
            <doc-id>hh162853</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_READY_HAVE_FUTURE_DATA</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_READY_HAVE_FUTURE_DATA</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineReady.HaveEnoughData">
            <summary>
            <dd> <p>There is enough data to play the resource, based on the current rate at which the resource is being fetched. </p> </dd>
            </summary>
            <doc-id>hh162853</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_READY_HAVE_ENOUGH_DATA</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_READY_HAVE_ENOUGH_DATA</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaEngineS3DPackingMode">
            <summary>
            <p>Specifies the layout for a packed 3D video frame.</p>
            </summary>
            <doc-id>hh162854</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_S3D_PACKING_MODE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_S3D_PACKING_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineS3DPackingMode.None">
            <summary>
            <dd> <p>None.</p> </dd>
            </summary>
            <doc-id>hh162854</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_S3D_PACKING_MODE_NONE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_S3D_PACKING_MODE_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineS3DPackingMode.SideBySide">
            <summary>
            <dd> <p>The views are packed side-by-side in a single frame.</p> </dd>
            </summary>
            <doc-id>hh162854</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_S3D_PACKING_MODE_SIDE_BY_SIDE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_S3D_PACKING_MODE_SIDE_BY_SIDE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineS3DPackingMode.TopBottom">
            <summary>
            <dd> <p>The views are packed top-to-bottom in a single frame.</p> </dd>
            </summary>
            <doc-id>hh162854</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_S3D_PACKING_MODE_TOP_BOTTOM</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_S3D_PACKING_MODE_TOP_BOTTOM</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaEngineSeekMode">
            <summary>
            <p>Defines values for the media engine seek mode.</p>
            </summary>
            <remarks>
            <p>This enumeration is used with the <strong>MediaEngineEx::SetCurrentTimeEx</strong>.</p>
            </remarks>
            <doc-id>jj128345</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_SEEK_MODE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_SEEK_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineSeekMode.Normal">
            <summary>
            <dd> <p>Specifies normal seek.</p> </dd>
            </summary>
            <doc-id>jj128345</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_SEEK_MODE_NORMAL</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_SEEK_MODE_NORMAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineSeekMode.Approximate">
            <summary>
            <dd> <p>Specifies an approximate seek. </p> </dd>
            </summary>
            <doc-id>jj128345</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_SEEK_MODE_APPROXIMATE</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_SEEK_MODE_APPROXIMATE</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaEngineStatistic">
            <summary>
            <p>Identifies statistics that the Media Engine tracks during playback. To get a playback statistic from the Media Engine, call <strong>IMFMediaEngineEx::GetStatistics</strong>.</p><p>In the descriptions that follow, the data type and value-type tag for the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> are listed in parentheses.</p>
            </summary>
            <doc-id>hh162855</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_STATISTIC</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_STATISTIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineStatistic.FramesRendered">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162855</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_STATISTIC_FRAMES_RENDERED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_STATISTIC_FRAMES_RENDERED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineStatistic.FramesDropped">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162855</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_STATISTIC_FRAMES_DROPPED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_STATISTIC_FRAMES_DROPPED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineStatistic.BytesDownloaded">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162855</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_STATISTIC_BYTES_DOWNLOADED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_STATISTIC_BYTES_DOWNLOADED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineStatistic.BufferProgress">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162855</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_STATISTIC_BUFFER_PROGRESS</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_STATISTIC_BUFFER_PROGRESS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineStatistic.FramesPerSecond">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162855</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_STATISTIC_FRAMES_PER_SECOND</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_STATISTIC_FRAMES_PER_SECOND</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineStatistic.PlaybackJitter">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162855</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_STATISTIC_PLAYBACK_JITTER</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_STATISTIC_PLAYBACK_JITTER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineStatistic.FramesCorrupted">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162855</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_STATISTIC_FRAMES_CORRUPTED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_STATISTIC_FRAMES_CORRUPTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineStatistic.TotalFrameDelay">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162855</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_STATISTIC_TOTAL_FRAME_DELAY</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_STATISTIC_TOTAL_FRAME_DELAY</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaEngineStreamTypeFailed">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Identifies the kind of media stream that failed.</p>
            </summary>
            <doc-id>dn879054</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_STREAMTYPE_FAILED</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_STREAMTYPE_FAILED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineStreamTypeFailed.Unknown">
            <summary>
            <dd> <p>The stream type is unknown.</p> </dd>
            </summary>
            <doc-id>dn879054</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_STREAMTYPE_FAILED_UNKNOWN</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_STREAMTYPE_FAILED_UNKNOWN</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineStreamTypeFailed.Audio">
            <summary>
            <dd> <p>The stream is an audio stream.</p> </dd>
            </summary>
            <doc-id>dn879054</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_STREAMTYPE_FAILED_AUDIO</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_STREAMTYPE_FAILED_AUDIO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineStreamTypeFailed.Video">
            <summary>
            <dd> <p>The stream is a video stream.</p> </dd>
            </summary>
            <doc-id>dn879054</doc-id>
            <unmanaged>MF_MEDIA_ENGINE_STREAMTYPE_FAILED_VIDEO</unmanaged>
            <unmanaged-short>MF_MEDIA_ENGINE_STREAMTYPE_FAILED_VIDEO</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaEventTypes">
            <summary>
            No documentation.
            </summary>
            <unmanaged>__MIDL___MIDL_itf_mfobjects_0000_0012_0001</unmanaged>
            <unmanaged-short>__MIDL___MIDL_itf_mfobjects_0000_0012_0001</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.Unknown">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEUnknown</unmanaged>
            <unmanaged-short>MEUnknown</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.Error">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEError</unmanaged>
            <unmanaged-short>MEError</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.ExtendedType">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEExtendedType</unmanaged>
            <unmanaged-short>MEExtendedType</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.NonFatalError">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MENonFatalError</unmanaged>
            <unmanaged-short>MENonFatalError</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.GenericV1Anchor">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEGenericV1Anchor</unmanaged>
            <unmanaged-short>MEGenericV1Anchor</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SessionUnknown">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESessionUnknown</unmanaged>
            <unmanaged-short>MESessionUnknown</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SessionTopologySet">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESessionTopologySet</unmanaged>
            <unmanaged-short>MESessionTopologySet</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SessionTopologiesCleared">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESessionTopologiesCleared</unmanaged>
            <unmanaged-short>MESessionTopologiesCleared</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SessionStarted">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESessionStarted</unmanaged>
            <unmanaged-short>MESessionStarted</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SessionPaused">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESessionPaused</unmanaged>
            <unmanaged-short>MESessionPaused</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SessionStopped">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESessionStopped</unmanaged>
            <unmanaged-short>MESessionStopped</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SessionClosed">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESessionClosed</unmanaged>
            <unmanaged-short>MESessionClosed</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SessionEnded">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESessionEnded</unmanaged>
            <unmanaged-short>MESessionEnded</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SessionRateChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESessionRateChanged</unmanaged>
            <unmanaged-short>MESessionRateChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SessionScrubSampleComplete">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESessionScrubSampleComplete</unmanaged>
            <unmanaged-short>MESessionScrubSampleComplete</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SessionCapabilitiesChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESessionCapabilitiesChanged</unmanaged>
            <unmanaged-short>MESessionCapabilitiesChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SessionTopologyStatus">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESessionTopologyStatus</unmanaged>
            <unmanaged-short>MESessionTopologyStatus</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SessionNotifyPresentationTime">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESessionNotifyPresentationTime</unmanaged>
            <unmanaged-short>MESessionNotifyPresentationTime</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.NewPresentation">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MENewPresentation</unmanaged>
            <unmanaged-short>MENewPresentation</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.LicenseAcquisitionStart">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MELicenseAcquisitionStart</unmanaged>
            <unmanaged-short>MELicenseAcquisitionStart</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.LicenseAcquisitionCompleted">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MELicenseAcquisitionCompleted</unmanaged>
            <unmanaged-short>MELicenseAcquisitionCompleted</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.IndividualizationStart">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEIndividualizationStart</unmanaged>
            <unmanaged-short>MEIndividualizationStart</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.IndividualizationCompleted">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEIndividualizationCompleted</unmanaged>
            <unmanaged-short>MEIndividualizationCompleted</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.EnablerProgress">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEEnablerProgress</unmanaged>
            <unmanaged-short>MEEnablerProgress</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.EnablerCompleted">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEEnablerCompleted</unmanaged>
            <unmanaged-short>MEEnablerCompleted</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.PolicyError">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEPolicyError</unmanaged>
            <unmanaged-short>MEPolicyError</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.PolicyReport">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEPolicyReport</unmanaged>
            <unmanaged-short>MEPolicyReport</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.BufferingStarted">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEBufferingStarted</unmanaged>
            <unmanaged-short>MEBufferingStarted</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.BufferingStopped">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEBufferingStopped</unmanaged>
            <unmanaged-short>MEBufferingStopped</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.ConnectStart">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEConnectStart</unmanaged>
            <unmanaged-short>MEConnectStart</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.ConnectEnd">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEConnectEnd</unmanaged>
            <unmanaged-short>MEConnectEnd</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.ReconnectStart">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEReconnectStart</unmanaged>
            <unmanaged-short>MEReconnectStart</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.ReconnectEnd">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEReconnectEnd</unmanaged>
            <unmanaged-short>MEReconnectEnd</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.RendererEvent">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MERendererEvent</unmanaged>
            <unmanaged-short>MERendererEvent</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SessionStreamSinkFormatChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESessionStreamSinkFormatChanged</unmanaged>
            <unmanaged-short>MESessionStreamSinkFormatChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SessionV1Anchor">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESessionV1Anchor</unmanaged>
            <unmanaged-short>MESessionV1Anchor</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SourceUnknown">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESourceUnknown</unmanaged>
            <unmanaged-short>MESourceUnknown</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SourceStarted">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESourceStarted</unmanaged>
            <unmanaged-short>MESourceStarted</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.StreamStarted">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEStreamStarted</unmanaged>
            <unmanaged-short>MEStreamStarted</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SourceSeeked">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESourceSeeked</unmanaged>
            <unmanaged-short>MESourceSeeked</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.StreamSeeked">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEStreamSeeked</unmanaged>
            <unmanaged-short>MEStreamSeeked</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.NewStream">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MENewStream</unmanaged>
            <unmanaged-short>MENewStream</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.UpdatedStream">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEUpdatedStream</unmanaged>
            <unmanaged-short>MEUpdatedStream</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SourceStopped">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESourceStopped</unmanaged>
            <unmanaged-short>MESourceStopped</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.StreamStopped">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEStreamStopped</unmanaged>
            <unmanaged-short>MEStreamStopped</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SourcePaused">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESourcePaused</unmanaged>
            <unmanaged-short>MESourcePaused</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.StreamPaused">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEStreamPaused</unmanaged>
            <unmanaged-short>MEStreamPaused</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.EndOfPresentation">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEEndOfPresentation</unmanaged>
            <unmanaged-short>MEEndOfPresentation</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.EndOfStream">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEEndOfStream</unmanaged>
            <unmanaged-short>MEEndOfStream</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.MediaSample">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEMediaSample</unmanaged>
            <unmanaged-short>MEMediaSample</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.StreamTick">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEStreamTick</unmanaged>
            <unmanaged-short>MEStreamTick</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.StreamThinMode">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEStreamThinMode</unmanaged>
            <unmanaged-short>MEStreamThinMode</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.StreamFormatChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEStreamFormatChanged</unmanaged>
            <unmanaged-short>MEStreamFormatChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SourceRateChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESourceRateChanged</unmanaged>
            <unmanaged-short>MESourceRateChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.EndOfPresentationSegment">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEEndOfPresentationSegment</unmanaged>
            <unmanaged-short>MEEndOfPresentationSegment</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SourceCharacteristicsChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESourceCharacteristicsChanged</unmanaged>
            <unmanaged-short>MESourceCharacteristicsChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SourceRateChangeRequested">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESourceRateChangeRequested</unmanaged>
            <unmanaged-short>MESourceRateChangeRequested</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SourceMetadataChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESourceMetadataChanged</unmanaged>
            <unmanaged-short>MESourceMetadataChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SequencerSourceTopologyUpdated">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESequencerSourceTopologyUpdated</unmanaged>
            <unmanaged-short>MESequencerSourceTopologyUpdated</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SourceV1Anchor">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESourceV1Anchor</unmanaged>
            <unmanaged-short>MESourceV1Anchor</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SinkUnknown">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESinkUnknown</unmanaged>
            <unmanaged-short>MESinkUnknown</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.StreamSinkStarted">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEStreamSinkStarted</unmanaged>
            <unmanaged-short>MEStreamSinkStarted</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.StreamSinkStopped">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEStreamSinkStopped</unmanaged>
            <unmanaged-short>MEStreamSinkStopped</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.StreamSinkPaused">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEStreamSinkPaused</unmanaged>
            <unmanaged-short>MEStreamSinkPaused</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.StreamSinkRateChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEStreamSinkRateChanged</unmanaged>
            <unmanaged-short>MEStreamSinkRateChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.StreamSinkRequestSample">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEStreamSinkRequestSample</unmanaged>
            <unmanaged-short>MEStreamSinkRequestSample</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.StreamSinkMarker">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEStreamSinkMarker</unmanaged>
            <unmanaged-short>MEStreamSinkMarker</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.StreamSinkPrerolled">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEStreamSinkPrerolled</unmanaged>
            <unmanaged-short>MEStreamSinkPrerolled</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.StreamSinkScrubSampleComplete">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEStreamSinkScrubSampleComplete</unmanaged>
            <unmanaged-short>MEStreamSinkScrubSampleComplete</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.StreamSinkFormatChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEStreamSinkFormatChanged</unmanaged>
            <unmanaged-short>MEStreamSinkFormatChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.StreamSinkDeviceChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEStreamSinkDeviceChanged</unmanaged>
            <unmanaged-short>MEStreamSinkDeviceChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.QualityNotify">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEQualityNotify</unmanaged>
            <unmanaged-short>MEQualityNotify</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SinkInvalidated">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESinkInvalidated</unmanaged>
            <unmanaged-short>MESinkInvalidated</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.AudioSessionNameChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEAudioSessionNameChanged</unmanaged>
            <unmanaged-short>MEAudioSessionNameChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.AudioSessionVolumeChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEAudioSessionVolumeChanged</unmanaged>
            <unmanaged-short>MEAudioSessionVolumeChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.AudioSessionDeviceRemoved">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEAudioSessionDeviceRemoved</unmanaged>
            <unmanaged-short>MEAudioSessionDeviceRemoved</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.AudioSessionServerShutdown">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEAudioSessionServerShutdown</unmanaged>
            <unmanaged-short>MEAudioSessionServerShutdown</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.AudioSessionGroupingParamChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEAudioSessionGroupingParamChanged</unmanaged>
            <unmanaged-short>MEAudioSessionGroupingParamChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.AudioSessionIconChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEAudioSessionIconChanged</unmanaged>
            <unmanaged-short>MEAudioSessionIconChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.AudioSessionFormatChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEAudioSessionFormatChanged</unmanaged>
            <unmanaged-short>MEAudioSessionFormatChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.AudioSessionDisconnected">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEAudioSessionDisconnected</unmanaged>
            <unmanaged-short>MEAudioSessionDisconnected</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.AudioSessionExclusiveModeOverride">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEAudioSessionExclusiveModeOverride</unmanaged>
            <unmanaged-short>MEAudioSessionExclusiveModeOverride</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SinkV1Anchor">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESinkV1Anchor</unmanaged>
            <unmanaged-short>MESinkV1Anchor</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.CaptureAudioSessionVolumeChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MECaptureAudioSessionVolumeChanged</unmanaged>
            <unmanaged-short>MECaptureAudioSessionVolumeChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.CaptureAudioSessionDeviceRemoved">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MECaptureAudioSessionDeviceRemoved</unmanaged>
            <unmanaged-short>MECaptureAudioSessionDeviceRemoved</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.CaptureAudioSessionFormatChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MECaptureAudioSessionFormatChanged</unmanaged>
            <unmanaged-short>MECaptureAudioSessionFormatChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.CaptureAudioSessionDisconnected">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MECaptureAudioSessionDisconnected</unmanaged>
            <unmanaged-short>MECaptureAudioSessionDisconnected</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.CaptureAudioSessionExclusiveModeOverride">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MECaptureAudioSessionExclusiveModeOverride</unmanaged>
            <unmanaged-short>MECaptureAudioSessionExclusiveModeOverride</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.CaptureAudioSessionServerShutdown">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MECaptureAudioSessionServerShutdown</unmanaged>
            <unmanaged-short>MECaptureAudioSessionServerShutdown</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.SinkV2Anchor">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MESinkV2Anchor</unmanaged>
            <unmanaged-short>MESinkV2Anchor</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.TrustUnknown">
            <summary>
            No documentation.
            </summary>
            <unmanaged>METrustUnknown</unmanaged>
            <unmanaged-short>METrustUnknown</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.PolicyChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEPolicyChanged</unmanaged>
            <unmanaged-short>MEPolicyChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.ContentProtectionMessage">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEContentProtectionMessage</unmanaged>
            <unmanaged-short>MEContentProtectionMessage</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.PolicySet">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEPolicySet</unmanaged>
            <unmanaged-short>MEPolicySet</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.TrustV1Anchor">
            <summary>
            No documentation.
            </summary>
            <unmanaged>METrustV1Anchor</unmanaged>
            <unmanaged-short>METrustV1Anchor</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.WindowsMediaDRMLicenseBackupCompleted">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEWMDRMLicenseBackupCompleted</unmanaged>
            <unmanaged-short>MEWMDRMLicenseBackupCompleted</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.WindowsMediaDRMLicenseBackupProgress">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEWMDRMLicenseBackupProgress</unmanaged>
            <unmanaged-short>MEWMDRMLicenseBackupProgress</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.WindowsMediaDRMLicenseRestoreCompleted">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEWMDRMLicenseRestoreCompleted</unmanaged>
            <unmanaged-short>MEWMDRMLicenseRestoreCompleted</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.WindowsMediaDRMLicenseRestoreProgress">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEWMDRMLicenseRestoreProgress</unmanaged>
            <unmanaged-short>MEWMDRMLicenseRestoreProgress</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.WindowsMediaDRMLicenseAcquisitionCompleted">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEWMDRMLicenseAcquisitionCompleted</unmanaged>
            <unmanaged-short>MEWMDRMLicenseAcquisitionCompleted</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.WindowsMediaDRMIndividualizationCompleted">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEWMDRMIndividualizationCompleted</unmanaged>
            <unmanaged-short>MEWMDRMIndividualizationCompleted</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.WindowsMediaDRMIndividualizationProgress">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEWMDRMIndividualizationProgress</unmanaged>
            <unmanaged-short>MEWMDRMIndividualizationProgress</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.WindowsMediaDRMProximityCompleted">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEWMDRMProximityCompleted</unmanaged>
            <unmanaged-short>MEWMDRMProximityCompleted</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.WindowsMediaDRMLicenseStoreCleaned">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEWMDRMLicenseStoreCleaned</unmanaged>
            <unmanaged-short>MEWMDRMLicenseStoreCleaned</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.WindowsMediaDRMRevocationDownloadCompleted">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEWMDRMRevocationDownloadCompleted</unmanaged>
            <unmanaged-short>MEWMDRMRevocationDownloadCompleted</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.WindowsMediaDRMV1Anchor">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEWMDRMV1Anchor</unmanaged>
            <unmanaged-short>MEWMDRMV1Anchor</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.TransformUnknown">
            <summary>
            No documentation.
            </summary>
            <unmanaged>METransformUnknown</unmanaged>
            <unmanaged-short>METransformUnknown</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.TransformNeedInput">
            <summary>
            No documentation.
            </summary>
            <unmanaged>METransformNeedInput</unmanaged>
            <unmanaged-short>METransformNeedInput</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.TransformHaveOutput">
            <summary>
            No documentation.
            </summary>
            <unmanaged>METransformHaveOutput</unmanaged>
            <unmanaged-short>METransformHaveOutput</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.TransformDrainComplete">
            <summary>
            No documentation.
            </summary>
            <unmanaged>METransformDrainComplete</unmanaged>
            <unmanaged-short>METransformDrainComplete</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.TransformMarker">
            <summary>
            No documentation.
            </summary>
            <unmanaged>METransformMarker</unmanaged>
            <unmanaged-short>METransformMarker</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.TransformInputStreamStateChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>METransformInputStreamStateChanged</unmanaged>
            <unmanaged-short>METransformInputStreamStateChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.ByteStreamCharacteristicsChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEByteStreamCharacteristicsChanged</unmanaged>
            <unmanaged-short>MEByteStreamCharacteristicsChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.VideoCaptureDeviceRemoved">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEVideoCaptureDeviceRemoved</unmanaged>
            <unmanaged-short>MEVideoCaptureDeviceRemoved</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.VideoCaptureDevicePreempted">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEVideoCaptureDevicePreempted</unmanaged>
            <unmanaged-short>MEVideoCaptureDevicePreempted</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.StreamSinkFormatInvalidated">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEStreamSinkFormatInvalidated</unmanaged>
            <unmanaged-short>MEStreamSinkFormatInvalidated</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.EncodingParameters">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEEncodingParameters</unmanaged>
            <unmanaged-short>MEEncodingParameters</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.ContentProtectionMetadata">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEContentProtectionMetadata</unmanaged>
            <unmanaged-short>MEContentProtectionMetadata</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.DeviceThermalStateChanged">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEDeviceThermalStateChanged</unmanaged>
            <unmanaged-short>MEDeviceThermalStateChanged</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEventTypes.ReservedMax">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MEReservedMax</unmanaged>
            <unmanaged-short>MEReservedMax</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaKeysessionMessagetype">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEYSESSION_MESSAGETYPE</unmanaged>
            <unmanaged-short>MF_MEDIAKEYSESSION_MESSAGETYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeysessionMessagetype.LicenseRequest">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_REQUEST</unmanaged>
            <unmanaged-short>MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_REQUEST</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeysessionMessagetype.LicenseRenewal">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RENEWAL</unmanaged>
            <unmanaged-short>MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RENEWAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeysessionMessagetype.LicenseRelease">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RELEASE</unmanaged>
            <unmanaged-short>MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RELEASE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeysessionMessagetype.IndividualizationRequest">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEYSESSION_MESSAGETYPE_INDIVIDUALIZATION_REQUEST</unmanaged>
            <unmanaged-short>MF_MEDIAKEYSESSION_MESSAGETYPE_INDIVIDUALIZATION_REQUEST</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaKeysessionType">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEYSESSION_TYPE</unmanaged>
            <unmanaged-short>MF_MEDIAKEYSESSION_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeysessionType.Temporary">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEYSESSION_TYPE_TEMPORARY</unmanaged>
            <unmanaged-short>MF_MEDIAKEYSESSION_TYPE_TEMPORARY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeysessionType.PersistentLicense">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEYSESSION_TYPE_PERSISTENT_LICENSE</unmanaged>
            <unmanaged-short>MF_MEDIAKEYSESSION_TYPE_PERSISTENT_LICENSE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeysessionType.PersistentReleaseMessage">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEYSESSION_TYPE_PERSISTENT_RELEASE_MESSAGE</unmanaged>
            <unmanaged-short>MF_MEDIAKEYSESSION_TYPE_PERSISTENT_RELEASE_MESSAGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeysessionType.PersistentUsageRecord">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEYSESSION_TYPE_PERSISTENT_USAGE_RECORD</unmanaged>
            <unmanaged-short>MF_MEDIAKEYSESSION_TYPE_PERSISTENT_USAGE_RECORD</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaKeysRequirement">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEYS_REQUIREMENT</unmanaged>
            <unmanaged-short>MF_MEDIAKEYS_REQUIREMENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeysRequirement.Required">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEYS_REQUIREMENT_REQUIRED</unmanaged>
            <unmanaged-short>MF_MEDIAKEYS_REQUIREMENT_REQUIRED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeysRequirement.Optional">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEYS_REQUIREMENT_OPTIONAL</unmanaged>
            <unmanaged-short>MF_MEDIAKEYS_REQUIREMENT_OPTIONAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeysRequirement.NotAllowEd">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEYS_REQUIREMENT_NOT_ALLOWED</unmanaged>
            <unmanaged-short>MF_MEDIAKEYS_REQUIREMENT_NOT_ALLOWED</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaKeyStatusState">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEY_STATUS</unmanaged>
            <unmanaged-short>MF_MEDIAKEY_STATUS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeyStatusState.Usable">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEY_STATUS_USABLE</unmanaged>
            <unmanaged-short>MF_MEDIAKEY_STATUS_USABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeyStatusState.Expired">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEY_STATUS_EXPIRED</unmanaged>
            <unmanaged-short>MF_MEDIAKEY_STATUS_EXPIRED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeyStatusState.OutputDownscaled">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEY_STATUS_OUTPUT_DOWNSCALED</unmanaged>
            <unmanaged-short>MF_MEDIAKEY_STATUS_OUTPUT_DOWNSCALED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeyStatusState.OutputNotAllowEd">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEY_STATUS_OUTPUT_NOT_ALLOWED</unmanaged>
            <unmanaged-short>MF_MEDIAKEY_STATUS_OUTPUT_NOT_ALLOWED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeyStatusState.StatusPending">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEY_STATUS_STATUS_PENDING</unmanaged>
            <unmanaged-short>MF_MEDIAKEY_STATUS_STATUS_PENDING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeyStatusState.InternalError">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEY_STATUS_INTERNAL_ERROR</unmanaged>
            <unmanaged-short>MF_MEDIAKEY_STATUS_INTERNAL_ERROR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeyStatusState.Released">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEY_STATUS_RELEASED</unmanaged>
            <unmanaged-short>MF_MEDIAKEY_STATUS_RELEASED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeyStatusState.OutputRestricted">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIAKEY_STATUS_OUTPUT_RESTRICTED</unmanaged>
            <unmanaged-short>MF_MEDIAKEY_STATUS_OUTPUT_RESTRICTED</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaSourceCharacteristics">
            <summary>
            <p>Defines the characteristics of a media source. These flags are retrieved by the <strong>IMFMediaSource::GetCharacteristics</strong> method.</p>
            </summary>
            <remarks>
            <p>To skip forward or backward in a playlist, call <strong>IMFMediaSource::Start</strong> or <strong>IMFMediaSession::Start</strong> with the <strong>MF_TIME_FORMAT_ENTRY_RELATIVE</strong> time-format <see cref = "T:System.Guid"/>. This capability applies only when the <strong>MFMEDIASOURCE_HAS_MULTIPLE_PRESENTATIONS</strong> flag is present.</p>
            </remarks>
            <doc-id>ms694277</doc-id>
            <unmanaged>MFMEDIASOURCE_CHARACTERISTICS</unmanaged>
            <unmanaged-short>MFMEDIASOURCE_CHARACTERISTICS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaSourceCharacteristics.IsLive">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms694277</doc-id>
            <unmanaged>MFMEDIASOURCE_IS_LIVE</unmanaged>
            <unmanaged-short>MFMEDIASOURCE_IS_LIVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaSourceCharacteristics.CanSeek">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms694277</doc-id>
            <unmanaged>MFMEDIASOURCE_CAN_SEEK</unmanaged>
            <unmanaged-short>MFMEDIASOURCE_CAN_SEEK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaSourceCharacteristics.CanPause">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms694277</doc-id>
            <unmanaged>MFMEDIASOURCE_CAN_PAUSE</unmanaged>
            <unmanaged-short>MFMEDIASOURCE_CAN_PAUSE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaSourceCharacteristics.HasSlowSeek">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms694277</doc-id>
            <unmanaged>MFMEDIASOURCE_HAS_SLOW_SEEK</unmanaged>
            <unmanaged-short>MFMEDIASOURCE_HAS_SLOW_SEEK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaSourceCharacteristics.HasMultiplePresentations">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms694277</doc-id>
            <unmanaged>MFMEDIASOURCE_HAS_MULTIPLE_PRESENTATIONS</unmanaged>
            <unmanaged-short>MFMEDIASOURCE_HAS_MULTIPLE_PRESENTATIONS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaSourceCharacteristics.CanSkipforward">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms694277</doc-id>
            <unmanaged>MFMEDIASOURCE_CAN_SKIPFORWARD</unmanaged>
            <unmanaged-short>MFMEDIASOURCE_CAN_SKIPFORWARD</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaSourceCharacteristics.CanSkipbackward">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms694277</doc-id>
            <unmanaged>MFMEDIASOURCE_CAN_SKIPBACKWARD</unmanaged>
            <unmanaged-short>MFMEDIASOURCE_CAN_SKIPBACKWARD</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaSourceCharacteristics.DoesNotUseNetwork">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms694277</doc-id>
            <unmanaged>MFMEDIASOURCE_DOES_NOT_USE_NETWORK</unmanaged>
            <unmanaged-short>MFMEDIASOURCE_DOES_NOT_USE_NETWORK</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaSourceStatusInformation">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIASOURCE_STATUS_INFO</unmanaged>
            <unmanaged-short>MF_MEDIASOURCE_STATUS_INFO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaSourceStatusInformation.FullySupported">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIASOURCE_STATUS_INFO_FULLYSUPPORTED</unmanaged>
            <unmanaged-short>MF_MEDIASOURCE_STATUS_INFO_FULLYSUPPORTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaSourceStatusInformation.Unknown">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MEDIASOURCE_STATUS_INFO_UNKNOWN</unmanaged>
            <unmanaged-short>MF_MEDIASOURCE_STATUS_INFO_UNKNOWN</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MfpCreationOptions">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Specifies options for the <strong>MFPCreateMediaPlayer</strong> function.</p>
            </summary>
            <remarks>
            <p>The following <strong>typedef</strong> is defined for combining flags from this enumeration.</p><code>typedef UINT32 MFP_CREATION_OPTIONS;</code>
            </remarks>
            <doc-id>dd757934</doc-id>
            <unmanaged>_MFP_CREATION_OPTIONS</unmanaged>
            <unmanaged-short>_MFP_CREATION_OPTIONS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MfpCreationOptions.MfpOptionNone">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd757934</doc-id>
            <unmanaged>MFP_OPTION_NONE</unmanaged>
            <unmanaged-short>MFP_OPTION_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MfpCreationOptions.MfpOptionFreeThreadedCallback">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd757934</doc-id>
            <unmanaged>MFP_OPTION_FREE_THREADED_CALLBACK</unmanaged>
            <unmanaged-short>MFP_OPTION_FREE_THREADED_CALLBACK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MfpCreationOptions.MfpOptionNoMmcss">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd757934</doc-id>
            <unmanaged>MFP_OPTION_NO_MMCSS</unmanaged>
            <unmanaged-short>MFP_OPTION_NO_MMCSS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MfpCreationOptions.MfpOptionNoRemoteDesktopOptimization">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd757934</doc-id>
            <unmanaged>MFP_OPTION_NO_REMOTE_DESKTOP_OPTIMIZATION</unmanaged>
            <unmanaged-short>MFP_OPTION_NO_REMOTE_DESKTOP_OPTIMIZATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MfpCredentialFlags.MfpCredentialPrompt">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd757935</doc-id>
            <unmanaged>MFP_CREDENTIAL_PROMPT</unmanaged>
            <unmanaged-short>MFP_CREDENTIAL_PROMPT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MfpCredentialFlags.MfpCredentialSave">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd757935</doc-id>
            <unmanaged>MFP_CREDENTIAL_SAVE</unmanaged>
            <unmanaged-short>MFP_CREDENTIAL_SAVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MfpCredentialFlags.MfpCredentialDoNotCache">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd757935</doc-id>
            <unmanaged>MFP_CREDENTIAL_DO_NOT_CACHE</unmanaged>
            <unmanaged-short>MFP_CREDENTIAL_DO_NOT_CACHE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MfpCredentialFlags.MfpCredentialClearText">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd757935</doc-id>
            <unmanaged>MFP_CREDENTIAL_CLEAR_TEXT</unmanaged>
            <unmanaged-short>MFP_CREDENTIAL_CLEAR_TEXT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MfpCredentialFlags.MfpCredentialProxy">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd757935</doc-id>
            <unmanaged>MFP_CREDENTIAL_PROXY</unmanaged>
            <unmanaged-short>MFP_CREDENTIAL_PROXY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MfpCredentialFlags.MfpCredentialLoggedOnUser">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd757935</doc-id>
            <unmanaged>MFP_CREDENTIAL_LOGGED_ON_USER</unmanaged>
            <unmanaged-short>MFP_CREDENTIAL_LOGGED_ON_USER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MfpCredentialFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MfpMediaItemCharacteristics">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Contains flags that describe a media item.</p>
            </summary>
            <remarks>
            <p>The following <strong>typedef</strong> is defined for combining flags from this enumeration.</p><code>typedef UINT32 MFP_MEDIAITEM_CHARACTERISTICS;</code>
            </remarks>
            <doc-id>dd757936</doc-id>
            <unmanaged>_MFP_MEDIAITEM_CHARACTERISTICS</unmanaged>
            <unmanaged-short>_MFP_MEDIAITEM_CHARACTERISTICS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MfpMediaItemCharacteristics.MfpMediaItemIsLive">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd757936</doc-id>
            <unmanaged>MFP_MEDIAITEM_IS_LIVE</unmanaged>
            <unmanaged-short>MFP_MEDIAITEM_IS_LIVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MfpMediaItemCharacteristics.MfpMediaItemCanSeek">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd757936</doc-id>
            <unmanaged>MFP_MEDIAITEM_CAN_SEEK</unmanaged>
            <unmanaged-short>MFP_MEDIAITEM_CAN_SEEK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MfpMediaItemCharacteristics.MfpMediaItemCanPause">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd757936</doc-id>
            <unmanaged>MFP_MEDIAITEM_CAN_PAUSE</unmanaged>
            <unmanaged-short>MFP_MEDIAITEM_CAN_PAUSE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MfpMediaItemCharacteristics.MfpMediaItemHasSlowSeek">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd757936</doc-id>
            <unmanaged>MFP_MEDIAITEM_HAS_SLOW_SEEK</unmanaged>
            <unmanaged-short>MFP_MEDIAITEM_HAS_SLOW_SEEK</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MftDrainType">
            <summary>
            <p> </p><p>Not supported.</p><strong>Note</strong>??Earlier versions of this documentation described the <strong>_MFT_DRAIN_TYPE</strong> enumeration incorrectly. The enumeration is not supported. For more information, see <strong><see cref = "T:SharpDX.MediaFoundation.TMessageType"/></strong>.?
            </summary>
            <doc-id>ms700116</doc-id>
            <unmanaged>_MFT_DRAIN_TYPE</unmanaged>
            <unmanaged-short>_MFT_DRAIN_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftDrainType.MftDrainProduceTails">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms700116</doc-id>
            <unmanaged>MFT_DRAIN_PRODUCE_TAILS</unmanaged>
            <unmanaged-short>MFT_DRAIN_PRODUCE_TAILS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftDrainType.MftDrainNoTails">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms700116</doc-id>
            <unmanaged>MFT_DRAIN_NO_TAILS</unmanaged>
            <unmanaged-short>MFT_DRAIN_NO_TAILS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftInputDataBufferFlags.MftInputDataBufferPlaceholder">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms694836</doc-id>
            <unmanaged>MFT_INPUT_DATA_BUFFER_PLACEHOLDER</unmanaged>
            <unmanaged-short>MFT_INPUT_DATA_BUFFER_PLACEHOLDER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftInputDataBufferFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftInputStatusFlags.MftInputStatusAcceptData">
            <summary>
            <dd> <p>The input stream can receive more data at this time. To deliver more input data, call <strong>IMFTransform::ProcessInput</strong>.</p> </dd>
            </summary>
            <doc-id>ms703084</doc-id>
            <unmanaged>MFT_INPUT_STATUS_ACCEPT_DATA</unmanaged>
            <unmanaged-short>MFT_INPUT_STATUS_ACCEPT_DATA</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftInputStatusFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftInputStreamInformationFlags.MftInputStreamWholeSamples">
            <summary>
            <dd> <p>Each media sample (<strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface) of input data must contain complete, unbroken units of data. The definition of a <em>unit of data</em> depends on the media type: For uncompressed video, a video frame; for compressed data, a compressed packet; for uncompressed audio, a single audio frame.</p> <p>For uncompressed audio formats, this flag is always implied. (It is valid to set the flag, but not required.) An uncompressed audio frame should never span more than one media sample.</p> </dd>
            </summary>
            <doc-id>ms703975</doc-id>
            <unmanaged>MFT_INPUT_STREAM_WHOLE_SAMPLES</unmanaged>
            <unmanaged-short>MFT_INPUT_STREAM_WHOLE_SAMPLES</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftInputStreamInformationFlags.MftInputStreamSingleSamplePerBuffer">
            <summary>
            <dd> <p>Each media sample that the client provides as input must contain exactly one unit of data, as defined for the MFT_INPUT_STREAM_WHOLE_SAMPLES flag.</p> <p>If this flag is present, the MFT_INPUT_STREAM_WHOLE_SAMPLES flag must also be present.</p> <p>An MFT that processes uncompressed audio should not set this flag. The MFT should accept buffers that contain more than a single audio frame, for efficiency.</p> </dd>
            </summary>
            <doc-id>ms703975</doc-id>
            <unmanaged>MFT_INPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER</unmanaged>
            <unmanaged-short>MFT_INPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftInputStreamInformationFlags.MftInputStreamFixedSampleSize">
            <summary>
            <dd> <p> All input samples must be the same size. The size is given in the <strong>cbSize</strong> member of the <strong><see cref = "T:SharpDX.MediaFoundation.TInputStreamInformation"/></strong> structure. The MFT must provide this value. During processing, the MFT should verify the size of input samples, and may drop samples with incorrect size.</p> </dd>
            </summary>
            <doc-id>ms703975</doc-id>
            <unmanaged>MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE</unmanaged>
            <unmanaged-short>MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftInputStreamInformationFlags.MftInputStreamHoldsBuffers">
            <summary>
            <dd> <p>The MFT might hold one or more input samples after <strong>IMFTransform::ProcessOutput</strong> is called. If this flag is present, the <strong>hnsMaxLatency</strong> member of the <strong><see cref = "T:SharpDX.MediaFoundation.TInputStreamInformation"/></strong> structure gives the maximum latency, and the <strong>cbMaxLookahead</strong> member gives the maximum number of bytes of lookahead.</p> </dd>
            </summary>
            <doc-id>ms703975</doc-id>
            <unmanaged>MFT_INPUT_STREAM_HOLDS_BUFFERS</unmanaged>
            <unmanaged-short>MFT_INPUT_STREAM_HOLDS_BUFFERS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftInputStreamInformationFlags.MftInputStreamDoesNotAddref">
            <summary>
            <dd> <p>The MFT does not hold input samples after the <strong>IMFTransform::ProcessInput</strong> method returns. It releases the sample before the <strong>ProcessInput</strong> method returns.</p> <p>If this flag is absent, the MFT might hold a reference count on the samples that are passed to the <strong>ProcessInput</strong> method. The client must not re-use or delete the buffer memory until the MFT releases the sample's <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> reference.</p> <p>If this flag is absent, it does not guarantee that the MFT holds a reference count on the input samples. It is valid for an MFT to release input samples in <strong>ProcessInput</strong> even if the MFT does not set this flag. However, setting this flag might enable to client to optimize how it re-uses buffers.</p> <p>An MFT should not set this flag if it ever holds onto an input sample after returning from <strong>ProcessInput</strong>.</p> </dd>
            </summary>
            <doc-id>ms703975</doc-id>
            <unmanaged>MFT_INPUT_STREAM_DOES_NOT_ADDREF</unmanaged>
            <unmanaged-short>MFT_INPUT_STREAM_DOES_NOT_ADDREF</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftInputStreamInformationFlags.MftInputStreamRemovable">
            <summary>
            <dd> <p>This input stream can be removed by calling <strong>IMFTransform::DeleteInputStream</strong>.</p> </dd>
            </summary>
            <doc-id>ms703975</doc-id>
            <unmanaged>MFT_INPUT_STREAM_REMOVABLE</unmanaged>
            <unmanaged-short>MFT_INPUT_STREAM_REMOVABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftInputStreamInformationFlags.MftInputStreamOptional">
            <summary>
            <dd> <p>This input stream is optional. The transform can produce output without receiving input from this stream. The caller can deselect the stream by not setting a media type or by setting a <strong><c>null</c></strong> media type. It is possible for every input stream on a transform to be optional, but at least one input must be selected in order to produce output.</p> </dd>
            </summary>
            <doc-id>ms703975</doc-id>
            <unmanaged>MFT_INPUT_STREAM_OPTIONAL</unmanaged>
            <unmanaged-short>MFT_INPUT_STREAM_OPTIONAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftInputStreamInformationFlags.MftInputStreamProcessesInPlace">
            <summary>
            <dd> <p>The MFT can perform in-place processing. In this mode, the MFT directly modifies the input buffer. When the client calls <strong>ProcessOutput</strong>, the same sample that was delivered to this stream is returned in the output stream that has a matching stream identifier. This flag implies that the MFT holds onto the input buffer, so this flag cannot combined with the MFT_INPUT_STREAM_DOES_NOT_ADDREF flag.</p> <p>If this flag is present, the MFT must set the MFT_OUTPUT_STREAM_PROVIDES_SAMPLES or MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES flag for the output stream that corresponds to this input stream. (See <strong>IMFTransform::GetOutputStreamInfo</strong>).</p> </dd>
            </summary>
            <doc-id>ms703975</doc-id>
            <unmanaged>MFT_INPUT_STREAM_PROCESSES_IN_PLACE</unmanaged>
            <unmanaged-short>MFT_INPUT_STREAM_PROCESSES_IN_PLACE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftInputStreamInformationFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftOutputDataBufferFlags.MftOutputDataBufferIncomplete">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms702281</doc-id>
            <unmanaged>MFT_OUTPUT_DATA_BUFFER_INCOMPLETE</unmanaged>
            <unmanaged-short>MFT_OUTPUT_DATA_BUFFER_INCOMPLETE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftOutputDataBufferFlags.MftOutputDataBufferFormatChange">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms702281</doc-id>
            <unmanaged>MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE</unmanaged>
            <unmanaged-short>MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftOutputDataBufferFlags.MftOutputDataBufferStreamEnd">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms702281</doc-id>
            <unmanaged>MFT_OUTPUT_DATA_BUFFER_STREAM_END</unmanaged>
            <unmanaged-short>MFT_OUTPUT_DATA_BUFFER_STREAM_END</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftOutputDataBufferFlags.MftOutputDataBufferNoSample">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms702281</doc-id>
            <unmanaged>MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE</unmanaged>
            <unmanaged-short>MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftOutputDataBufferFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftOutputStatusFlags.MftOutputStatusSampleReady">
            <summary>
            <dd> <p>There is a sample available for at least one output stream. To retrieve the available output samples, call <strong>IMFTransform::ProcessOutput</strong>.</p> </dd>
            </summary>
            <doc-id>ms701553</doc-id>
            <unmanaged>MFT_OUTPUT_STATUS_SAMPLE_READY</unmanaged>
            <unmanaged-short>MFT_OUTPUT_STATUS_SAMPLE_READY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftOutputStatusFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftOutputStreamInformationFlags.MftOutputStreamWholeSamples">
            <summary>
            <dd> <p>Each media sample (<strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface) of output data from the MFT contains complete, unbroken units of data. The definition of a <em>unit of data</em> depends on the media type: For uncompressed video, a video frame; for compressed data, a compressed packet; for uncompressed audio, a single audio frame.</p> <p>For uncompressed audio formats, this flag is always implied. (It is valid to set the flag, but not required.) An uncompressed audio frame should never span more than one media sample.</p> </dd>
            </summary>
            <doc-id>ms705618</doc-id>
            <unmanaged>MFT_OUTPUT_STREAM_WHOLE_SAMPLES</unmanaged>
            <unmanaged-short>MFT_OUTPUT_STREAM_WHOLE_SAMPLES</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftOutputStreamInformationFlags.MftOutputStreamSingleSamplePerBuffer">
            <summary>
            <dd> <p>Each output sample contains exactly one unit of data, as defined for the MFT_OUTPUT_STREAM_WHOLE_SAMPLES flag.</p> <p>If this flag is present, the MFT_OUTPUT_STREAM_WHOLE_SAMPLES flag must also be present.</p> <p>An MFT that outputs uncompressed audio should not set this flag. For efficiency, it should output more than one audio frame at a time.</p> </dd>
            </summary>
            <doc-id>ms705618</doc-id>
            <unmanaged>MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER</unmanaged>
            <unmanaged-short>MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftOutputStreamInformationFlags.MftOutputStreamFixedSampleSize">
            <summary>
            <dd> <p>All output samples are the same size.</p> </dd>
            </summary>
            <doc-id>ms705618</doc-id>
            <unmanaged>MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE</unmanaged>
            <unmanaged-short>MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftOutputStreamInformationFlags.MftOutputStreamDiscardable">
            <summary>
            <dd> <p>The MFT can discard the output data from this output stream, if requested by the client. To discard the output, set the MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER flag in the <strong>IMFTransform::ProcessOutput</strong> method.</p> </dd>
            </summary>
            <doc-id>ms705618</doc-id>
            <unmanaged>MFT_OUTPUT_STREAM_DISCARDABLE</unmanaged>
            <unmanaged-short>MFT_OUTPUT_STREAM_DISCARDABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftOutputStreamInformationFlags.MftOutputStreamOptional">
            <summary>
            <dd> <p>This output stream is optional. The client can deselect the stream by not setting a media type or by setting a <strong><c>null</c></strong> media type. When an optional stream is deselected, it does not produce any output data.</p> </dd>
            </summary>
            <doc-id>ms705618</doc-id>
            <unmanaged>MFT_OUTPUT_STREAM_OPTIONAL</unmanaged>
            <unmanaged-short>MFT_OUTPUT_STREAM_OPTIONAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftOutputStreamInformationFlags.MftOutputStreamProvidesSamples">
            <summary>
            <dd> <p>The MFT provides the output samples for this stream, either by allocating them internally or by operating directly on the input samples. The MFT cannot use output samples provided by the client for this stream.</p> <p>If this flag is not set, the MFT must set <strong>cbSize</strong> to a nonzero value in the <strong><see cref = "T:SharpDX.MediaFoundation.TOutputStreamInformation"/></strong> structure, so that the client can allocate the correct buffer size. For more information, see <strong>IMFTransform::GetOutputStreamInfo</strong>. This flag cannot be combined with the MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES flag.</p> </dd>
            </summary>
            <doc-id>ms705618</doc-id>
            <unmanaged>MFT_OUTPUT_STREAM_PROVIDES_SAMPLES</unmanaged>
            <unmanaged-short>MFT_OUTPUT_STREAM_PROVIDES_SAMPLES</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftOutputStreamInformationFlags.MftOutputStreamCanProvideSamples">
            <summary>
            <dd> <p>The MFT can either provide output samples for this stream or it can use samples that the client allocates. This flag cannot be combined with the MFT_OUTPUT_STREAM_PROVIDES_SAMPLES flag.</p> <p>If the MFT does not set this flag or the MFT_OUTPUT_STREAM_PROVIDES_SAMPLES flag, the client must allocate the samples for this output stream. The MFT will not provide its own samples.</p> </dd>
            </summary>
            <doc-id>ms705618</doc-id>
            <unmanaged>MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES</unmanaged>
            <unmanaged-short>MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftOutputStreamInformationFlags.MftOutputStreamLazyRead">
            <summary>
            <dd> <p>The MFT does not require the client to process the output for this stream. If the client continues to send input data without getting the output from this stream, the MFT simply discards the previous input.</p> </dd>
            </summary>
            <doc-id>ms705618</doc-id>
            <unmanaged>MFT_OUTPUT_STREAM_LAZY_READ</unmanaged>
            <unmanaged-short>MFT_OUTPUT_STREAM_LAZY_READ</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftOutputStreamInformationFlags.MftOutputStreamRemovable">
            <summary>
            <dd> <p>The MFT might remove this output stream during streaming. This flag typically applies to demultiplexers, where the input data contains multiple streams that can start and stop during streaming. For more information, see <strong>IMFTransform::ProcessOutput</strong>.</p> </dd>
            </summary>
            <doc-id>ms705618</doc-id>
            <unmanaged>MFT_OUTPUT_STREAM_REMOVABLE</unmanaged>
            <unmanaged-short>MFT_OUTPUT_STREAM_REMOVABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftOutputStreamInformationFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftSetTypeFlags.MftSetTypeTestOnly">
            <summary>
            <dd> <p>Test the proposed media type, but do not set it.</p> </dd>
            </summary>
            <doc-id>ms704051</doc-id>
            <unmanaged>MFT_SET_TYPE_TEST_ONLY</unmanaged>
            <unmanaged-short>MFT_SET_TYPE_TEST_ONLY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MftSetTypeFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MidlMidlItfMfreadwrite000000010002">
            <summary>
            No documentation.
            </summary>
            <unmanaged>__MIDL___MIDL_itf_mfreadwrite_0000_0001_0002</unmanaged>
            <unmanaged-short>__MIDL___MIDL_itf_mfreadwrite_0000_0001_0002</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MidlMidlItfMfreadwrite000000010002.CurrentTypeIndex">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_SOURCE_READER_CURRENT_TYPE_INDEX</unmanaged>
            <unmanaged-short>MF_SOURCE_READER_CURRENT_TYPE_INDEX</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MultisampledEAppendMode">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MSE_APPEND_MODE</unmanaged>
            <unmanaged-short>MF_MSE_APPEND_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MultisampledEAppendMode.Segments">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MSE_APPEND_MODE_SEGMENTS</unmanaged>
            <unmanaged-short>MF_MSE_APPEND_MODE_SEGMENTS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MultisampledEAppendMode.Sequence">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MSE_APPEND_MODE_SEQUENCE</unmanaged>
            <unmanaged-short>MF_MSE_APPEND_MODE_SEQUENCE</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MultisampledEError">
            <summary>
            <p>Defines the different error states of the Media Source Extension.</p>
            </summary>
            <doc-id>dn302195</doc-id>
            <unmanaged>MF_MSE_ERROR</unmanaged>
            <unmanaged-short>MF_MSE_ERROR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MultisampledEError.Noerror">
            <summary>
            <dd> <p>Specifies no error.</p> </dd>
            </summary>
            <doc-id>dn302195</doc-id>
            <unmanaged>MF_MSE_ERROR_NOERROR</unmanaged>
            <unmanaged-short>MF_MSE_ERROR_NOERROR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MultisampledEError.Network">
            <summary>
            <dd> <p>Specifies an error with the network.</p> </dd>
            </summary>
            <doc-id>dn302195</doc-id>
            <unmanaged>MF_MSE_ERROR_NETWORK</unmanaged>
            <unmanaged-short>MF_MSE_ERROR_NETWORK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MultisampledEError.Decode">
            <summary>
            <dd> <p>Specifies an error with decoding.</p> </dd>
            </summary>
            <doc-id>dn302195</doc-id>
            <unmanaged>MF_MSE_ERROR_DECODE</unmanaged>
            <unmanaged-short>MF_MSE_ERROR_DECODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MultisampledEError.UnknownError">
            <summary>
            <dd> <p>Specifies an unknown error.</p> </dd>
            </summary>
            <doc-id>dn302195</doc-id>
            <unmanaged>MF_MSE_ERROR_UNKNOWN_ERROR</unmanaged>
            <unmanaged-short>MF_MSE_ERROR_UNKNOWN_ERROR</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MultisampledEOperationUsSupportType">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MSE_OPUS_SUPPORT_TYPE</unmanaged>
            <unmanaged-short>MF_MSE_OPUS_SUPPORT_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MultisampledEOperationUsSupportType.On">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MSE_OPUS_SUPPORT_ON</unmanaged>
            <unmanaged-short>MF_MSE_OPUS_SUPPORT_ON</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MultisampledEOperationUsSupportType.Off">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MSE_OPUS_SUPPORT_OFF</unmanaged>
            <unmanaged-short>MF_MSE_OPUS_SUPPORT_OFF</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MultisampledEReady">
            <summary>
            <p>Defines the different ready states of the Media Source Extension.</p>
            </summary>
            <doc-id>dn302196</doc-id>
            <unmanaged>MF_MSE_READY</unmanaged>
            <unmanaged-short>MF_MSE_READY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MultisampledEReady.Closed">
            <summary>
            <dd> <p>The media source is closed.</p> </dd>
            </summary>
            <doc-id>dn302196</doc-id>
            <unmanaged>MF_MSE_READY_CLOSED</unmanaged>
            <unmanaged-short>MF_MSE_READY_CLOSED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MultisampledEReady.Open">
            <summary>
            <dd> <p>The media source is open.</p> </dd>
            </summary>
            <doc-id>dn302196</doc-id>
            <unmanaged>MF_MSE_READY_OPEN</unmanaged>
            <unmanaged-short>MF_MSE_READY_OPEN</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MultisampledEReady.Ended">
            <summary>
            <dd> <p>The media source is ended.</p> </dd>
            </summary>
            <doc-id>dn302196</doc-id>
            <unmanaged>MF_MSE_READY_ENDED</unmanaged>
            <unmanaged-short>MF_MSE_READY_ENDED</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MultisampledEVp9SupportType">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MSE_VP9_SUPPORT_TYPE</unmanaged>
            <unmanaged-short>MF_MSE_VP9_SUPPORT_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MultisampledEVp9SupportType.Default">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MSE_VP9_SUPPORT_DEFAULT</unmanaged>
            <unmanaged-short>MF_MSE_VP9_SUPPORT_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MultisampledEVp9SupportType.On">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MSE_VP9_SUPPORT_ON</unmanaged>
            <unmanaged-short>MF_MSE_VP9_SUPPORT_ON</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MultisampledEVp9SupportType.Off">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_MSE_VP9_SUPPORT_OFF</unmanaged>
            <unmanaged-short>MF_MSE_VP9_SUPPORT_OFF</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.NetAuthenticationFlags">
            <summary>
            <p> </p><p>Specifies how the user's credentials will be used.</p>
            </summary>
            <doc-id>ms697023</doc-id>
            <unmanaged>MFNetAuthenticationFlags</unmanaged>
            <unmanaged-short>MFNetAuthenticationFlags</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetAuthenticationFlags.MfnetAuthenticationProxy">
            <summary>
            <dd> <p>The credentials will be used to authenticate with a proxy.</p> </dd>
            </summary>
            <doc-id>ms697023</doc-id>
            <unmanaged>MFNET_AUTHENTICATION_PROXY</unmanaged>
            <unmanaged-short>MFNET_AUTHENTICATION_PROXY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetAuthenticationFlags.MfnetAuthenticationClearText">
            <summary>
            <dd> <p>The credentials will be sent over the network unencrypted.</p> </dd>
            </summary>
            <doc-id>ms697023</doc-id>
            <unmanaged>MFNET_AUTHENTICATION_CLEAR_TEXT</unmanaged>
            <unmanaged-short>MFNET_AUTHENTICATION_CLEAR_TEXT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetAuthenticationFlags.MfnetAuthenticationLoggedOnUser">
            <summary>
            <dd> <p>The credentials must be from a user who is currently logged on.</p> </dd>
            </summary>
            <doc-id>ms697023</doc-id>
            <unmanaged>MFNET_AUTHENTICATION_LOGGED_ON_USER</unmanaged>
            <unmanaged-short>MFNET_AUTHENTICATION_LOGGED_ON_USER</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.NetCredentialOptions">
            <summary>
            <p> </p><p>Describes options for the caching network credentials.</p>
            </summary>
            <doc-id>ms697386</doc-id>
            <unmanaged>MFNetCredentialOptions</unmanaged>
            <unmanaged-short>MFNetCredentialOptions</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetCredentialOptions.MfnetCredentialSave">
            <summary>
            <dd> <p>Allow the credential cache object to save  credentials in persistant storage.</p> </dd>
            </summary>
            <doc-id>ms697386</doc-id>
            <unmanaged>MFNET_CREDENTIAL_SAVE</unmanaged>
            <unmanaged-short>MFNET_CREDENTIAL_SAVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetCredentialOptions.MfnetCredentialDontCache">
            <summary>
            <dd> <p>Do not allow the credential cache object to cache the credentials in memory. This flag cannot be combined with the MFNET_CREDENTIAL_SAVE flag.</p> </dd>
            </summary>
            <doc-id>ms697386</doc-id>
            <unmanaged>MFNET_CREDENTIAL_DONT_CACHE</unmanaged>
            <unmanaged-short>MFNET_CREDENTIAL_DONT_CACHE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetCredentialOptions.MfnetCredentialAllowClearText">
            <summary>
            <dd> <p>The user allows credentials to be sent over the network in clear text.</p> <p> By default, <strong>IMFNetCredentialCache::GetCredential</strong> always returns the REQUIRE_PROMPT flag when the authentication flags include MFNET_AUTHENTICATION_CLEAR_TEXT, even if cached credentials are available. If you set the MFNET_CREDENTIAL_ALLOW_CLEAR_TEXT option, the <strong>GetCredential</strong> method will not return  REQUIRE_PROMPT for clear text, if cached credentials are available.</p> <p>Do not set this flag without notifying the user that credentials might be sent in clear text.</p> </dd>
            </summary>
            <doc-id>ms697386</doc-id>
            <unmanaged>MFNET_CREDENTIAL_ALLOW_CLEAR_TEXT</unmanaged>
            <unmanaged-short>MFNET_CREDENTIAL_ALLOW_CLEAR_TEXT</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.NetCredentialRequirements">
            <summary>
            <p> Specifies how the credential manager should obtain user credentials. </p>
            </summary>
            <remarks>
            <p>The application implements the credential manager, which must expose the <strong><see cref = "T:SharpDX.MediaFoundation.NetCredentialManager"/></strong> interface. If the <strong>REQUIRE_PROMPT</strong> flag is set, the credential manager should prompt the user for his or her name and password.</p><p>The credential cache object sets the <strong>REQUIRE_PROMPT</strong> flag if the cache does not yet contain valid credentials. It also sets this flag if the credentials will be sent as plain text, unless the credential manager previously set the <strong>MFNET_CREDENTIAL_ALLOW_CLEAR_TEXT</strong> option. (See <strong>IMFNetCredentialCache::SetUserOptions</strong>.)</p>
            </remarks>
            <doc-id>ms700813</doc-id>
            <unmanaged>MFNetCredentialRequirements</unmanaged>
            <unmanaged-short>MFNetCredentialRequirements</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetCredentialRequirements.RequirePrompt">
            <summary>
            <dd> <p> The credential manager should prompt the user to provide the credentials. </p> </dd>
            </summary>
            <doc-id>ms700813</doc-id>
            <unmanaged>REQUIRE_PROMPT</unmanaged>
            <unmanaged-short>REQUIRE_PROMPT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetCredentialRequirements.RequireSaveSelected">
            <summary>
            <dd> <p> </p><strong>Note</strong>??Requires Windows?7 or later. ? <p>The credentials are saved to persistent storage. This flag acts as a hint for the application's UI. If the application prompts the user for credentials, the UI can indicate that the credentials have already been saved.</p> </dd>
            </summary>
            <doc-id>ms700813</doc-id>
            <unmanaged>REQUIRE_SAVE_SELECTED</unmanaged>
            <unmanaged-short>REQUIRE_SAVE_SELECTED</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.NetProxysettings">
            <summary>
            <p>Specifies how the default proxy locator will specify the connection settings to a proxy server. The application must set these values in the <strong>MFNETSOURCE_PROXYSETTINGS</strong> property.</p>
            </summary>
            <doc-id>aa372538</doc-id>
            <unmanaged>MFNET_PROXYSETTINGS</unmanaged>
            <unmanaged-short>MFNET_PROXYSETTINGS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetProxysettings.None">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa372538</doc-id>
            <unmanaged>MFNET_PROXYSETTING_NONE</unmanaged>
            <unmanaged-short>MFNET_PROXYSETTING_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetProxysettings.Manual">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa372538</doc-id>
            <unmanaged>MFNET_PROXYSETTING_MANUAL</unmanaged>
            <unmanaged-short>MFNET_PROXYSETTING_MANUAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetProxysettings.Auto">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa372538</doc-id>
            <unmanaged>MFNET_PROXYSETTING_AUTO</unmanaged>
            <unmanaged-short>MFNET_PROXYSETTING_AUTO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetProxysettings.Browser">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa372538</doc-id>
            <unmanaged>MFNET_PROXYSETTING_BROWSER</unmanaged>
            <unmanaged-short>MFNET_PROXYSETTING_BROWSER</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.NetsourceCacheState">
            <summary>
            <p> </p><p>Defines the status of the cache for a media file or entry.</p>
            </summary>
            <doc-id>ms705647</doc-id>
            <unmanaged>MFNETSOURCE_CACHE_STATE</unmanaged>
            <unmanaged-short>MFNETSOURCE_CACHE_STATE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceCacheState.Unavailable">
            <summary>
            <dd> <p>The cache for a file or entry does not exist.</p> </dd>
            </summary>
            <doc-id>ms705647</doc-id>
            <unmanaged>MFNETSOURCE_CACHE_UNAVAILABLE</unmanaged>
            <unmanaged-short>MFNETSOURCE_CACHE_UNAVAILABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceCacheState.ActiveWriting">
            <summary>
            <dd> <p>The cache for a file or entry is growing.</p> </dd>
            </summary>
            <doc-id>ms705647</doc-id>
            <unmanaged>MFNETSOURCE_CACHE_ACTIVE_WRITING</unmanaged>
            <unmanaged-short>MFNETSOURCE_CACHE_ACTIVE_WRITING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceCacheState.ActiveComplete">
            <summary>
            <dd> <p>The cache for a file or entry is completed.</p> </dd>
            </summary>
            <doc-id>ms705647</doc-id>
            <unmanaged>MFNETSOURCE_CACHE_ACTIVE_COMPLETE</unmanaged>
            <unmanaged-short>MFNETSOURCE_CACHE_ACTIVE_COMPLETE</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.NetsourceProtocolType">
            <summary>
            <p> Indicates the type of control protocol that is used in streaming or downloading. </p>
            </summary>
            <doc-id>ms704031</doc-id>
            <unmanaged>MFNETSOURCE_PROTOCOL_TYPE</unmanaged>
            <unmanaged-short>MFNETSOURCE_PROTOCOL_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceProtocolType.Undefined">
            <summary>
            <dd> <p> The protocol type has not yet been determined. </p> </dd>
            </summary>
            <doc-id>ms704031</doc-id>
            <unmanaged>MFNETSOURCE_UNDEFINED</unmanaged>
            <unmanaged-short>MFNETSOURCE_UNDEFINED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceProtocolType.Http">
            <summary>
            <dd> <p> The protocol type is HTTP. This includes HTTPv9, WMSP, and HTTP download. </p> </dd>
            </summary>
            <doc-id>ms704031</doc-id>
            <unmanaged>MFNETSOURCE_HTTP</unmanaged>
            <unmanaged-short>MFNETSOURCE_HTTP</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceProtocolType.Rtsp">
            <summary>
            <dd> <p> The protocol type is Real Time Streaming Protocol (RTSP). </p> </dd>
            </summary>
            <doc-id>ms704031</doc-id>
            <unmanaged>MFNETSOURCE_RTSP</unmanaged>
            <unmanaged-short>MFNETSOURCE_RTSP</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceProtocolType.File">
            <summary>
            <dd> <p> The content is read from a file. The file might be local or on a remote share. </p> </dd>
            </summary>
            <doc-id>ms704031</doc-id>
            <unmanaged>MFNETSOURCE_FILE</unmanaged>
            <unmanaged-short>MFNETSOURCE_FILE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceProtocolType.Multicast">
            <summary>
            <dd> <p>The protocol type is multicast.</p> <strong>Note</strong>??Requires Windows?7 or later. ? </dd>
            </summary>
            <doc-id>ms704031</doc-id>
            <unmanaged>MFNETSOURCE_MULTICAST</unmanaged>
            <unmanaged-short>MFNETSOURCE_MULTICAST</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.NetsourceStatisticsIds">
            <summary>
            <p>Defines statistics collected by the network source. The values in this enumeration define property identifiers (PIDs) for the <strong>MFNETSOURCE_STATISTICS</strong> property.</p><p>To retrieve statistics from the network source, call <strong>IMFGetService::GetService</strong> with the service identifier <strong><see cref = "!:NetworkSourceStatistics"/></strong> and the interface identifier IID_IPropertyStore. The retrieved reference is an <strong><see cref = "T:SharpDX.ComObject"/></strong> reference. To get the value of a network statistic, construct a <strong>PROPERTYKEY</strong> with <strong>fmtid</strong> equal to <strong>MFNETSOURCE_STATISTICS</strong> and <strong>pid</strong> equal to a value from this enumeration. Then call <strong>IPropertyStore::GetValue</strong> with the property key to retrieve the value of the statistic as a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong>. </p><p>In the descriptions that follow, the data type and value-type tag for the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> are listed in parentheses.</p>
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_STATISTICS_IDS</unmanaged>
            <unmanaged-short>MFNETSOURCE_STATISTICS_IDS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.RecvpacketsId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_RECVPACKETS_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_RECVPACKETS_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.LostpacketsId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_LOSTPACKETS_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_LOSTPACKETS_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.ResendsrequestedId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_RESENDSREQUESTED_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_RESENDSREQUESTED_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.ResendsreceivedId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_RESENDSRECEIVED_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_RESENDSRECEIVED_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.RecoveredbyeccpacketsId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_RECOVEREDBYECCPACKETS_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_RECOVEREDBYECCPACKETS_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.RecoveredbyrtxpacketsId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_RECOVEREDBYRTXPACKETS_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_RECOVEREDBYRTXPACKETS_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.OutpacketsId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_OUTPACKETS_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_OUTPACKETS_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.RecvrateId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_RECVRATE_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_RECVRATE_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.AvgbandwidthbpsId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_AVGBANDWIDTHBPS_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_AVGBANDWIDTHBPS_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.BytesReceivedId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_BYTESRECEIVED_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_BYTESRECEIVED_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.ProtocolId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_PROTOCOL_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_PROTOCOL_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.TransportId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_TRANSPORT_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_TRANSPORT_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.CacheStateId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_CACHE_STATE_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_CACHE_STATE_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.LinkbandwidthId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_LINKBANDWIDTH_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_LINKBANDWIDTH_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.ContentbitrateId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_CONTENTBITRATE_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_CONTENTBITRATE_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.SpeedfactorId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_SPEEDFACTOR_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_SPEEDFACTOR_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.BufferSizeId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_BUFFERSIZE_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_BUFFERSIZE_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.BufferProgressId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_BUFFERPROGRESS_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_BUFFERPROGRESS_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.LastBwswitchtsId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_LASTBWSWITCHTS_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_LASTBWSWITCHTS_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.SeekrangestartId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_SEEKRANGESTART_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_SEEKRANGESTART_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.SeekrangeendId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_SEEKRANGEEND_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_SEEKRANGEEND_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.BufferingCountId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_BUFFERINGCOUNT_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_BUFFERINGCOUNT_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.IncorrectlysignedpacketsId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_INCORRECTLYSIGNEDPACKETS_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_INCORRECTLYSIGNEDPACKETS_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.SignedsessionId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_SIGNEDSESSION_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_SIGNEDSESSION_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.MaximumBitRateId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_MAXBITRATE_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_MAXBITRATE_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.ReceptionQualityId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_RECEPTION_QUALITY_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_RECEPTION_QUALITY_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.RecoveredpacketsId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_RECOVEREDPACKETS_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_RECOVEREDPACKETS_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.VariableBitRateId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_VBR_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_VBR_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.DownloadProgressId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_DOWNLOADPROGRESS_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_DOWNLOADPROGRESS_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceStatisticsIds.UnpredefinedprotocolnameId">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697019</doc-id>
            <unmanaged>MFNETSOURCE_UNPREDEFINEDPROTOCOLNAME_ID</unmanaged>
            <unmanaged-short>MFNETSOURCE_UNPREDEFINEDPROTOCOLNAME_ID</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.NetsourceTransportType">
            <summary>
            <p> </p><p>Describes the type of transport used in streaming or downloading data (TCP or UDP).</p>
            </summary>
            <doc-id>ms702233</doc-id>
            <unmanaged>MFNETSOURCE_TRANSPORT_TYPE</unmanaged>
            <unmanaged-short>MFNETSOURCE_TRANSPORT_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceTransportType.Udp">
            <summary>
            <dd> <p>The data transport type is UDP.</p> </dd>
            </summary>
            <doc-id>ms702233</doc-id>
            <unmanaged>MFNETSOURCE_UDP</unmanaged>
            <unmanaged-short>MFNETSOURCE_UDP</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetsourceTransportType.Tcp">
            <summary>
            <dd> <p>The data transport type is TCP.</p> </dd>
            </summary>
            <doc-id>ms702233</doc-id>
            <unmanaged>MFNETSOURCE_TCP</unmanaged>
            <unmanaged-short>MFNETSOURCE_TCP</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.NominalRange">
            <summary>
            <p>Specifies whether color data includes headroom and toeroom. Headroom allows for values beyond 1.0 white ("whiter than white"), and toeroom allows for values below reference 0.0 black ("blacker than black"). </p>
            </summary>
            <remarks>
            <p> This enumeration is used with the <strong><see cref = "!:VideoNominalRange"/></strong> attribute. </p><p> For more information about these values, see the remarks for the <strong>DXVA2_NominalRange</strong> enumeration, which is the DirectX Video Acceleration (DXVA) equivalent of this enumeration. </p>
            </remarks>
            <doc-id>ms705659</doc-id>
            <unmanaged>MFNominalRange</unmanaged>
            <unmanaged-short>MFNominalRange</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NominalRange.Unknown">
            <summary>
            <dd> <p> Unknown nominal range. </p> </dd>
            </summary>
            <doc-id>ms705659</doc-id>
            <unmanaged>MFNominalRange_Unknown</unmanaged>
            <unmanaged-short>MFNominalRange_Unknown</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NominalRange.Normal">
            <summary>
            <dd> <p> Equivalent to MFNominalRange_0_255. </p> </dd>
            </summary>
            <doc-id>ms705659</doc-id>
            <unmanaged>MFNominalRange_Normal</unmanaged>
            <unmanaged-short>MFNominalRange_Normal</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NominalRange.Wide">
            <summary>
            <dd> <p> Equivalent to MFNominalRange_16_235. </p> </dd>
            </summary>
            <doc-id>ms705659</doc-id>
            <unmanaged>MFNominalRange_Wide</unmanaged>
            <unmanaged-short>MFNominalRange_Wide</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NominalRange.Range0_255">
            <summary>
            <dd> <p> The normalized range [0...1] maps to [0...255] for 8-bit samples or [0...1023] for 10-bit samples. </p> </dd>
            </summary>
            <doc-id>ms705659</doc-id>
            <unmanaged>MFNominalRange_0_255</unmanaged>
            <unmanaged-short>MFNominalRange_0_255</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NominalRange.Range16_235">
            <summary>
            <dd> <p> The normalized range [0...1] maps to [16...235] for 8-bit samples or [64...940] for 10-bit samples. </p> </dd>
            </summary>
            <doc-id>ms705659</doc-id>
            <unmanaged>MFNominalRange_16_235</unmanaged>
            <unmanaged-short>MFNominalRange_16_235</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NominalRange.Range48_208">
            <summary>
            <dd> <p> The normalized range [0..1] maps to [48...208] for 8-bit samples or [64...940] for 10-bit samples. </p> </dd>
            </summary>
            <doc-id>ms705659</doc-id>
            <unmanaged>MFNominalRange_48_208</unmanaged>
            <unmanaged-short>MFNominalRange_48_208</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NominalRange.Range64_127">
            <summary>
            <dd> <p>The normalized range [0..1] maps to [64...127] for 8-bit samples or [256...508] for 10-bit samples. This range is used in the xRGB color space.</p> <strong>Note</strong>??Requires Windows?7 or later. ? </dd>
            </summary>
            <doc-id>ms705659</doc-id>
            <unmanaged>MFNominalRange_64_127</unmanaged>
            <unmanaged-short>MFNominalRange_64_127</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NominalRange.Last">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms705659</doc-id>
            <unmanaged>MFNominalRange_Last</unmanaged>
            <unmanaged-short>MFNominalRange_Last</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NominalRange.ForceDWORD">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms705659</doc-id>
            <unmanaged>MFNominalRange_ForceDWORD</unmanaged>
            <unmanaged-short>MFNominalRange_ForceDWORD</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.ObjectType">
            <summary>
            <p> </p><p>Defines the object types that are created by the source resolver.</p>
            </summary>
            <doc-id>ms704771</doc-id>
            <unmanaged>MF_OBJECT_TYPE</unmanaged>
            <unmanaged-short>MF_OBJECT_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ObjectType.MediaSource">
            <summary>
            <dd> <p>Media source. You can query the object for the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSource"/></strong> interface.</p> </dd>
            </summary>
            <doc-id>ms704771</doc-id>
            <unmanaged>MF_OBJECT_MEDIASOURCE</unmanaged>
            <unmanaged-short>MF_OBJECT_MEDIASOURCE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ObjectType.ByteStream">
            <summary>
            <dd> <p>Byte stream. You can query the object for the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface.</p> </dd>
            </summary>
            <doc-id>ms704771</doc-id>
            <unmanaged>MF_OBJECT_BYTESTREAM</unmanaged>
            <unmanaged-short>MF_OBJECT_BYTESTREAM</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ObjectType.Invalid">
            <summary>
            <dd> <p>Invalid type.</p> </dd>
            </summary>
            <doc-id>ms704771</doc-id>
            <unmanaged>MF_OBJECT_INVALID</unmanaged>
            <unmanaged-short>MF_OBJECT_INVALID</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.OpmAcpProtectionLevel">
            <summary>
            <p>Defines protection levels for <strong>MFPROTECTION_ACP</strong>.</p>
            </summary>
            <doc-id>jj128346</doc-id>
            <unmanaged>MF_OPM_ACP_PROTECTION_LEVEL</unmanaged>
            <unmanaged-short>MF_OPM_ACP_PROTECTION_LEVEL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.OpmAcpProtectionLevel.Off">
            <summary>
            <dd> <p>Specifies ACP is disabled.</p> </dd>
            </summary>
            <doc-id>jj128346</doc-id>
            <unmanaged>MF_OPM_ACP_OFF</unmanaged>
            <unmanaged-short>MF_OPM_ACP_OFF</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.OpmAcpProtectionLevel.LevelOne">
            <summary>
            <dd> <p>Specifies ACP is level one.</p> </dd>
            </summary>
            <doc-id>jj128346</doc-id>
            <unmanaged>MF_OPM_ACP_LEVEL_ONE</unmanaged>
            <unmanaged-short>MF_OPM_ACP_LEVEL_ONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.OpmAcpProtectionLevel.LevelTwo">
            <summary>
            <dd> <p>Specifies ACP is level two.</p> </dd>
            </summary>
            <doc-id>jj128346</doc-id>
            <unmanaged>MF_OPM_ACP_LEVEL_TWO</unmanaged>
            <unmanaged-short>MF_OPM_ACP_LEVEL_TWO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.OpmAcpProtectionLevel.LevelThree">
            <summary>
            <dd> <p>Specifies ACP is level three.</p> </dd>
            </summary>
            <doc-id>jj128346</doc-id>
            <unmanaged>MF_OPM_ACP_LEVEL_THREE</unmanaged>
            <unmanaged-short>MF_OPM_ACP_LEVEL_THREE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.OpmAcpProtectionLevel.ForceUlong">
            <summary>
            <dd> <p>Reserved.</p> </dd>
            </summary>
            <doc-id>jj128346</doc-id>
            <unmanaged>MF_OPM_ACP_FORCE_ULONG</unmanaged>
            <unmanaged-short>MF_OPM_ACP_FORCE_ULONG</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.OpmCgmsaProtectionLevel">
            <summary>
            <p>Defines protection levels for <strong>MFPROTECTION_CGMSA</strong>.</p>
            </summary>
            <remarks>
            <p>These flags are equivalent to the OPM_CGMSA_Protection_Level enumeration constants used in the Output Protection Protocol (OPM). </p>
            </remarks>
            <doc-id>jj128347</doc-id>
            <unmanaged>MF_OPM_CGMSA_PROTECTION_LEVEL</unmanaged>
            <unmanaged-short>MF_OPM_CGMSA_PROTECTION_LEVEL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.OpmCgmsaProtectionLevel.Off">
            <summary>
            <dd> <p>CGMS-A is disabled.</p> </dd>
            </summary>
            <doc-id>jj128347</doc-id>
            <unmanaged>MF_OPM_CGMSA_OFF</unmanaged>
            <unmanaged-short>MF_OPM_CGMSA_OFF</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.OpmCgmsaProtectionLevel.CopyFreely">
            <summary>
            <dd> <p>The protection level is Copy Freely.</p> </dd>
            </summary>
            <doc-id>jj128347</doc-id>
            <unmanaged>MF_OPM_CGMSA_COPY_FREELY</unmanaged>
            <unmanaged-short>MF_OPM_CGMSA_COPY_FREELY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.OpmCgmsaProtectionLevel.CopyNoMore">
            <summary>
            <dd> <p>The protection level is Copy No More.</p> </dd>
            </summary>
            <doc-id>jj128347</doc-id>
            <unmanaged>MF_OPM_CGMSA_COPY_NO_MORE</unmanaged>
            <unmanaged-short>MF_OPM_CGMSA_COPY_NO_MORE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.OpmCgmsaProtectionLevel.CopyOneGeneration">
            <summary>
            <dd> <p>The protection level is Copy One Generation.</p> </dd>
            </summary>
            <doc-id>jj128347</doc-id>
            <unmanaged>MF_OPM_CGMSA_COPY_ONE_GENERATION</unmanaged>
            <unmanaged-short>MF_OPM_CGMSA_COPY_ONE_GENERATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.OpmCgmsaProtectionLevel.CopyNever">
            <summary>
            <dd> <p>The protection level is Copy Never.</p> </dd>
            </summary>
            <doc-id>jj128347</doc-id>
            <unmanaged>MF_OPM_CGMSA_COPY_NEVER</unmanaged>
            <unmanaged-short>MF_OPM_CGMSA_COPY_NEVER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.OpmCgmsaProtectionLevel.RedistributionControlRequired">
            <summary>
            <dd> <p>Redistribution control (also called the broadcast flag) is required. This flag can be combined with the other flags.</p> </dd>
            </summary>
            <doc-id>jj128347</doc-id>
            <unmanaged>MF_OPM_CGMSA_REDISTRIBUTION_CONTROL_REQUIRED</unmanaged>
            <unmanaged-short>MF_OPM_CGMSA_REDISTRIBUTION_CONTROL_REQUIRED</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PEventType">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Defines event types for the <strong><see cref = "T:SharpDX.MediaFoundation.PMediaPlayerCallback"/></strong> interface.</p>
            </summary>
            <remarks>
            <p>For each event type, the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> callback receives a reference to a data structure. The first part of the data structure is always an <strong><see cref = "T:SharpDX.MediaFoundation.PEventHeader"/></strong> structure. The following table lists the data structure for each event type.</p><p>In your implementation of <strong>OnMediaPlayerEvent</strong>, you must cast the <em>pEventHeader</em> parameter to the correct structure type. A set of macros is defined for this purpose. These macros check the value of the event type and return <strong><c>null</c></strong> if there is a mismatch; otherwise they return a reference to the correct structure type.</p><table> <tr><td><strong>Event type</strong></td><td> <p><strong>Event structure</strong></p> <p><strong>Pointer cast macro</strong></p> </td></tr> <tr><td>MFP_EVENT_TYPE_PLAY</td><td> <p> <strong><see cref = "T:SharpDX.MediaFoundation.PPlayEvent"/></strong> </p> <p> <strong>MFP_GET_PLAY_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_PAUSE</td><td> <p> <strong><see cref = "T:SharpDX.MediaFoundation.PPauseEvent"/></strong> </p> <p> <strong>MFP_GET_PAUSE_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_STOP</td><td> <p> <strong><see cref = "T:SharpDX.MediaFoundation.PStopEvent"/></strong> </p> <p> <strong>MFP_GET_STOP_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_POSITION_SET</td><td> <p> <strong><see cref = "T:SharpDX.MediaFoundation.PPositionSetEvent"/></strong> </p> <p> <strong>MFP_GET_POSITION_SET_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_RATE_SET</td><td> <p> <strong><see cref = "T:SharpDX.MediaFoundation.PRateSetEvent"/></strong> </p> <p> <strong>MFP_GET_RATE_SET_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_MEDIAITEM_CREATED</td><td> <p> <strong><see cref = "T:SharpDX.MediaFoundation.PMediaItemCreateDEvent"/></strong> </p> <p> <strong>MFP_GET_MEDIAITEM_CREATED_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_MEDIAITEM_SET</td><td> <p> <strong><see cref = "T:SharpDX.MediaFoundation.PMediaItemSetEvent"/></strong> </p> <p> <strong>MFP_GET_MEDIAITEM_SET_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_FRAME_STEP</td><td> <p> <strong><see cref = "T:SharpDX.MediaFoundation.PFrameStepEvent"/></strong> </p> <p> <strong>MFP_GET_FRAME_STEP_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_MEDIAITEM_CLEARED</td><td> <p> <strong><see cref = "T:SharpDX.MediaFoundation.PMediaItemClearedEvent"/></strong> </p> <p> <strong>MFP_GET_MEDIAITEM_CLEARED_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_MF</td><td> <p> <strong><see cref = "T:SharpDX.MediaFoundation.PMfEvent"/></strong> </p> <p> <strong>MFP_GET_MF_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_ERROR</td><td> <p> <strong><see cref = "T:SharpDX.MediaFoundation.PErrorEvent"/></strong> </p> <p> <strong>MFP_GET_ERROR_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_PLAYBACK_ENDED</td><td> <p> <strong><see cref = "T:SharpDX.MediaFoundation.PPlaybackEndedEvent"/></strong> </p> <p> <strong>MFP_GET_PLAYBACK_ENDED_EVENT</strong> </p> </td></tr> <tr><td>MFP_EVENT_TYPE_ACQUIRE_USER_CREDENTIAL</td><td> <p> <strong><see cref = "T:SharpDX.MediaFoundation.PAcquireUserCredentialEvent"/></strong> </p> <p> <strong>MFP_GET_ACQUIRE_USER_CREDENTIAL_EVENT</strong> </p> </td></tr> </table><p>?</p>
            </remarks>
            <doc-id>dd375532</doc-id>
            <unmanaged>MFP_EVENT_TYPE</unmanaged>
            <unmanaged-short>MFP_EVENT_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PEventType.Play">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375532</doc-id>
            <unmanaged>MFP_EVENT_TYPE_PLAY</unmanaged>
            <unmanaged-short>MFP_EVENT_TYPE_PLAY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PEventType.Pause">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375532</doc-id>
            <unmanaged>MFP_EVENT_TYPE_PAUSE</unmanaged>
            <unmanaged-short>MFP_EVENT_TYPE_PAUSE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PEventType.Stop">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375532</doc-id>
            <unmanaged>MFP_EVENT_TYPE_STOP</unmanaged>
            <unmanaged-short>MFP_EVENT_TYPE_STOP</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PEventType.PositionSet">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375532</doc-id>
            <unmanaged>MFP_EVENT_TYPE_POSITION_SET</unmanaged>
            <unmanaged-short>MFP_EVENT_TYPE_POSITION_SET</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PEventType.RateSet">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375532</doc-id>
            <unmanaged>MFP_EVENT_TYPE_RATE_SET</unmanaged>
            <unmanaged-short>MFP_EVENT_TYPE_RATE_SET</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PEventType.MediaItemCreateD">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375532</doc-id>
            <unmanaged>MFP_EVENT_TYPE_MEDIAITEM_CREATED</unmanaged>
            <unmanaged-short>MFP_EVENT_TYPE_MEDIAITEM_CREATED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PEventType.MediaItemSet">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375532</doc-id>
            <unmanaged>MFP_EVENT_TYPE_MEDIAITEM_SET</unmanaged>
            <unmanaged-short>MFP_EVENT_TYPE_MEDIAITEM_SET</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PEventType.FrameStep">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375532</doc-id>
            <unmanaged>MFP_EVENT_TYPE_FRAME_STEP</unmanaged>
            <unmanaged-short>MFP_EVENT_TYPE_FRAME_STEP</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PEventType.MediaItemCleared">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375532</doc-id>
            <unmanaged>MFP_EVENT_TYPE_MEDIAITEM_CLEARED</unmanaged>
            <unmanaged-short>MFP_EVENT_TYPE_MEDIAITEM_CLEARED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PEventType.Mf">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375532</doc-id>
            <unmanaged>MFP_EVENT_TYPE_MF</unmanaged>
            <unmanaged-short>MFP_EVENT_TYPE_MF</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PEventType.Error">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375532</doc-id>
            <unmanaged>MFP_EVENT_TYPE_ERROR</unmanaged>
            <unmanaged-short>MFP_EVENT_TYPE_ERROR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PEventType.PlaybackEnded">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375532</doc-id>
            <unmanaged>MFP_EVENT_TYPE_PLAYBACK_ENDED</unmanaged>
            <unmanaged-short>MFP_EVENT_TYPE_PLAYBACK_ENDED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PEventType.AcquireUserCredential">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375532</doc-id>
            <unmanaged>MFP_EVENT_TYPE_ACQUIRE_USER_CREDENTIAL</unmanaged>
            <unmanaged-short>MFP_EVENT_TYPE_ACQUIRE_USER_CREDENTIAL</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PluginControlPolicy">
            <summary>
            <p>Defines policy settings for the <strong>IMFPluginControl2::SetPolicy</strong> method.</p>
            </summary>
            <doc-id>hh162881</doc-id>
            <unmanaged>MF_PLUGIN_CONTROL_POLICY</unmanaged>
            <unmanaged-short>MF_PLUGIN_CONTROL_POLICY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PluginControlPolicy.UseAllPlugins">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162881</doc-id>
            <unmanaged>MF_PLUGIN_CONTROL_POLICY_USE_ALL_PLUGINS</unmanaged>
            <unmanaged-short>MF_PLUGIN_CONTROL_POLICY_USE_ALL_PLUGINS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PluginControlPolicy.UseApprovedPlugins">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162881</doc-id>
            <unmanaged>MF_PLUGIN_CONTROL_POLICY_USE_APPROVED_PLUGINS</unmanaged>
            <unmanaged-short>MF_PLUGIN_CONTROL_POLICY_USE_APPROVED_PLUGINS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PluginControlPolicy.UseWebPlugins">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162881</doc-id>
            <unmanaged>MF_PLUGIN_CONTROL_POLICY_USE_WEB_PLUGINS</unmanaged>
            <unmanaged-short>MF_PLUGIN_CONTROL_POLICY_USE_WEB_PLUGINS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PluginControlPolicy.UseWebPluginsEdgemode">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh162881</doc-id>
            <unmanaged>MF_PLUGIN_CONTROL_POLICY_USE_WEB_PLUGINS_EDGEMODE</unmanaged>
            <unmanaged-short>MF_PLUGIN_CONTROL_POLICY_USE_WEB_PLUGINS_EDGEMODE</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PluginType">
            <summary>
            <p>Specifies the object type for the <strong><see cref = "T:SharpDX.MediaFoundation.PluginControl"/></strong> interface.</p>
            </summary>
            <doc-id>dd375763</doc-id>
            <unmanaged>MF_Plugin_Type</unmanaged>
            <unmanaged-short>MF_Plugin_Type</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PluginType.Mft">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375763</doc-id>
            <unmanaged>MF_Plugin_Type_MFT</unmanaged>
            <unmanaged-short>MF_Plugin_Type_MFT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PluginType.MediaSource">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375763</doc-id>
            <unmanaged>MF_Plugin_Type_MediaSource</unmanaged>
            <unmanaged-short>MF_Plugin_Type_MediaSource</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PluginType.MftMatchOutputType">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375763</doc-id>
            <unmanaged>MF_Plugin_Type_MFT_MatchOutputType</unmanaged>
            <unmanaged-short>MF_Plugin_Type_MFT_MatchOutputType</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PluginType.Other">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375763</doc-id>
            <unmanaged>MF_Plugin_Type_Other</unmanaged>
            <unmanaged-short>MF_Plugin_Type_Other</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PMediaPlayerState">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Specifies the current playback state.</p>
            </summary>
            <doc-id>dd375562</doc-id>
            <unmanaged>MFP_MEDIAPLAYER_STATE</unmanaged>
            <unmanaged-short>MFP_MEDIAPLAYER_STATE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PMediaPlayerState.Empty">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375562</doc-id>
            <unmanaged>MFP_MEDIAPLAYER_STATE_EMPTY</unmanaged>
            <unmanaged-short>MFP_MEDIAPLAYER_STATE_EMPTY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PMediaPlayerState.Stopped">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375562</doc-id>
            <unmanaged>MFP_MEDIAPLAYER_STATE_STOPPED</unmanaged>
            <unmanaged-short>MFP_MEDIAPLAYER_STATE_STOPPED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PMediaPlayerState.Playing">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375562</doc-id>
            <unmanaged>MFP_MEDIAPLAYER_STATE_PLAYING</unmanaged>
            <unmanaged-short>MFP_MEDIAPLAYER_STATE_PLAYING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PMediaPlayerState.Paused">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375562</doc-id>
            <unmanaged>MFP_MEDIAPLAYER_STATE_PAUSED</unmanaged>
            <unmanaged-short>MFP_MEDIAPLAYER_STATE_PAUSED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PMediaPlayerState.Shutdown">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375562</doc-id>
            <unmanaged>MFP_MEDIAPLAYER_STATE_SHUTDOWN</unmanaged>
            <unmanaged-short>MFP_MEDIAPLAYER_STATE_SHUTDOWN</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PmpsessionCreationFlags.UnprotectedProcess">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697495</doc-id>
            <unmanaged>MFPMPSESSION_UNPROTECTED_PROCESS</unmanaged>
            <unmanaged-short>MFPMPSESSION_UNPROTECTED_PROCESS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PmpsessionCreationFlags.InProcess">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697495</doc-id>
            <unmanaged>MFPMPSESSION_IN_PROCESS</unmanaged>
            <unmanaged-short>MFPMPSESSION_IN_PROCESS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PmpsessionCreationFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PolicymanagerAction">
            <summary>
            <p> </p><p>Defines actions that can be performed on a stream.</p>
            </summary>
            <doc-id>ms698977</doc-id>
            <unmanaged>MFPOLICYMANAGER_ACTION</unmanaged>
            <unmanaged-short>MFPOLICYMANAGER_ACTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PolicymanagerAction.PeactionNo">
            <summary>
            <dd> <p>No action.</p> </dd>
            </summary>
            <doc-id>ms698977</doc-id>
            <unmanaged>PEACTION_NO</unmanaged>
            <unmanaged-short>PEACTION_NO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PolicymanagerAction.PeactionPlay">
            <summary>
            <dd> <p>Play the stream.</p> </dd>
            </summary>
            <doc-id>ms698977</doc-id>
            <unmanaged>PEACTION_PLAY</unmanaged>
            <unmanaged-short>PEACTION_PLAY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PolicymanagerAction.PeactionCopy">
            <summary>
            <dd> <p>Copy the stream.</p> </dd>
            </summary>
            <doc-id>ms698977</doc-id>
            <unmanaged>PEACTION_COPY</unmanaged>
            <unmanaged-short>PEACTION_COPY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PolicymanagerAction.PeactionExport">
            <summary>
            <dd> <p>Export the stream to another format.</p> </dd>
            </summary>
            <doc-id>ms698977</doc-id>
            <unmanaged>PEACTION_EXPORT</unmanaged>
            <unmanaged-short>PEACTION_EXPORT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PolicymanagerAction.PeactionExtract">
            <summary>
            <dd> <p>Extract the data from the stream and pass it to the application. For example, acoustic echo cancellation requires this action.</p> </dd>
            </summary>
            <doc-id>ms698977</doc-id>
            <unmanaged>PEACTION_EXTRACT</unmanaged>
            <unmanaged-short>PEACTION_EXTRACT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PolicymanagerAction.PeactionReserved1">
            <summary>
            <dd> <p>Reserved.</p> </dd>
            </summary>
            <doc-id>ms698977</doc-id>
            <unmanaged>PEACTION_RESERVED1</unmanaged>
            <unmanaged-short>PEACTION_RESERVED1</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PolicymanagerAction.PeactionReserved2">
            <summary>
            <dd> <p>Reserved.</p> </dd>
            </summary>
            <doc-id>ms698977</doc-id>
            <unmanaged>PEACTION_RESERVED2</unmanaged>
            <unmanaged-short>PEACTION_RESERVED2</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PolicymanagerAction.PeactionReserved3">
            <summary>
            <dd> <p>Reserved.</p> </dd>
            </summary>
            <doc-id>ms698977</doc-id>
            <unmanaged>PEACTION_RESERVED3</unmanaged>
            <unmanaged-short>PEACTION_RESERVED3</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PolicymanagerAction.PeactionLast">
            <summary>
            <dd> <p>Last member of the enumeration.</p> </dd>
            </summary>
            <doc-id>ms698977</doc-id>
            <unmanaged>PEACTION_LAST</unmanaged>
            <unmanaged-short>PEACTION_LAST</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PreferredMediaStream">
            <summary>
            No documentation.
            </summary>
            <unmanaged>__MIDL___MIDL_itf_mfcaptureengine_0000_0000_0001</unmanaged>
            <unmanaged-short>__MIDL___MIDL_itf_mfcaptureengine_0000_0000_0001</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PreferredMediaStream.VIDEO_PREVIEW">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_PREVIEW</unmanaged>
            <unmanaged-short>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_PREVIEW</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PreferredMediaStream.VIDEO_RECORD">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_RECORD</unmanaged>
            <unmanaged-short>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_RECORD</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PreferredMediaStream.PHOTO">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_PHOTO</unmanaged>
            <unmanaged-short>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_PHOTO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PreferredMediaStream.AUDIO">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_AUDIO</unmanaged>
            <unmanaged-short>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_AUDIO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PreferredMediaStream.MfCaptureEngineMediaSource">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_CAPTURE_ENGINE_MEDIASOURCE</unmanaged>
            <unmanaged-short>MF_CAPTURE_ENGINE_MEDIASOURCE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.QualityAdviseFlags.CannotKeepUp">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd743824</doc-id>
            <unmanaged>MF_QUALITY_CANNOT_KEEP_UP</unmanaged>
            <unmanaged-short>MF_QUALITY_CANNOT_KEEP_UP</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.QualityAdviseFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.QualityDropMode">
            <summary>
            <p> </p><p>Specifies how aggressively a pipeline component should drop samples.</p>
            </summary>
            <remarks>
            <p>In drop mode, a component drops samples, more or less aggressively depending on the level of the drop mode. The specific algorithm used depends on the component. Mode 1 is the least aggressive mode, and mode 5 is the most aggressive. A component is not required to implement all five levels.</p><p>For example, suppose an encoded video stream has three B-frames between each pair of P-frames. A decoder might implement the following drop modes:</p><ul> <li> <p>Mode 1: Drop one out of every three B frames.</p> </li> <li> <p>Mode 2: Drop one out of every two B frames.</p> </li> <li> <p>Mode 3: Drop all delta frames.</p> </li> <li> <p>Modes 4 and 5: Unsupported.</p> </li> </ul><p>The enhanced video renderer (EVR) can drop video frames before sending them to the EVR mixer.</p>
            </remarks>
            <doc-id>ms704659</doc-id>
            <unmanaged>MF_QUALITY_DROP_MODE</unmanaged>
            <unmanaged-short>MF_QUALITY_DROP_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.QualityDropMode.MfDropModeNone">
            <summary>
            <dd> <p>Normal processing of samples. Drop mode is disabled.</p> </dd>
            </summary>
            <doc-id>ms704659</doc-id>
            <unmanaged>MF_DROP_MODE_NONE</unmanaged>
            <unmanaged-short>MF_DROP_MODE_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.QualityDropMode.MfDropMode1">
            <summary>
            <dd> <p>First drop mode (least aggressive).</p> </dd>
            </summary>
            <doc-id>ms704659</doc-id>
            <unmanaged>MF_DROP_MODE_1</unmanaged>
            <unmanaged-short>MF_DROP_MODE_1</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.QualityDropMode.MfDropMode2">
            <summary>
            <dd> <p>Second drop mode.</p> </dd>
            </summary>
            <doc-id>ms704659</doc-id>
            <unmanaged>MF_DROP_MODE_2</unmanaged>
            <unmanaged-short>MF_DROP_MODE_2</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.QualityDropMode.MfDropMode3">
            <summary>
            <dd> <p>Third drop mode.</p> </dd>
            </summary>
            <doc-id>ms704659</doc-id>
            <unmanaged>MF_DROP_MODE_3</unmanaged>
            <unmanaged-short>MF_DROP_MODE_3</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.QualityDropMode.MfDropMode4">
            <summary>
            <dd> <p>Fourth drop mode.</p> </dd>
            </summary>
            <doc-id>ms704659</doc-id>
            <unmanaged>MF_DROP_MODE_4</unmanaged>
            <unmanaged-short>MF_DROP_MODE_4</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.QualityDropMode.MfDropMode5">
            <summary>
            <dd> <p>Fifth drop mode (most aggressive, if it is supported; see Remarks).</p> </dd>
            </summary>
            <doc-id>ms704659</doc-id>
            <unmanaged>MF_DROP_MODE_5</unmanaged>
            <unmanaged-short>MF_DROP_MODE_5</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.QualityDropMode.MfNumDropModes">
            <summary>
            <dd> <p>Maximum number of drop modes. This value is not a valid flag.</p> </dd>
            </summary>
            <doc-id>ms704659</doc-id>
            <unmanaged>MF_NUM_DROP_MODES</unmanaged>
            <unmanaged-short>MF_NUM_DROP_MODES</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.QualityLevel">
            <summary>
            <p>Specifies the quality level for a pipeline component. The quality level determines how the component consumes or produces samples.</p>
            </summary>
            <remarks>
            <p> Each successive quality level decreases the amount of processing that is needed, while also reducing the resulting quality of the audio or video. The specific algorithm used to reduce quality depends on the component. Mode 1 is the least aggressive mode, and mode 5 is the most aggressive. A component is not required to implement all five levels. Also, the same quality level might not be comparable between two different components. </p><p> Video decoders can often reduce quality by leaving out certain post-processing steps. The enhanced video renderer (EVR) can sometimes reduce quality by switching to a different deinterlacing mode. </p>
            </remarks>
            <doc-id>ms698949</doc-id>
            <unmanaged>MF_QUALITY_LEVEL</unmanaged>
            <unmanaged-short>MF_QUALITY_LEVEL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.QualityLevel.MfQualityNormal">
            <summary>
            <dd> <p> Normal quality. </p> </dd>
            </summary>
            <doc-id>ms698949</doc-id>
            <unmanaged>MF_QUALITY_NORMAL</unmanaged>
            <unmanaged-short>MF_QUALITY_NORMAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.QualityLevel.MfQualityNormalMinus1">
            <summary>
            <dd> <p> One level below normal quality. </p> </dd>
            </summary>
            <doc-id>ms698949</doc-id>
            <unmanaged>MF_QUALITY_NORMAL_MINUS_1</unmanaged>
            <unmanaged-short>MF_QUALITY_NORMAL_MINUS_1</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.QualityLevel.MfQualityNormalMinus2">
            <summary>
            <dd> <p> Two levels below normal quality. </p> </dd>
            </summary>
            <doc-id>ms698949</doc-id>
            <unmanaged>MF_QUALITY_NORMAL_MINUS_2</unmanaged>
            <unmanaged-short>MF_QUALITY_NORMAL_MINUS_2</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.QualityLevel.MfQualityNormalMinus3">
            <summary>
            <dd> <p> Three levels below normal quality. </p> </dd>
            </summary>
            <doc-id>ms698949</doc-id>
            <unmanaged>MF_QUALITY_NORMAL_MINUS_3</unmanaged>
            <unmanaged-short>MF_QUALITY_NORMAL_MINUS_3</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.QualityLevel.MfQualityNormalMinus4">
            <summary>
            <dd> <p> Four levels below normal quality. </p> </dd>
            </summary>
            <doc-id>ms698949</doc-id>
            <unmanaged>MF_QUALITY_NORMAL_MINUS_4</unmanaged>
            <unmanaged-short>MF_QUALITY_NORMAL_MINUS_4</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.QualityLevel.MfQualityNormalMinus5">
            <summary>
            <dd> <p> Five levels below normal quality. </p> </dd>
            </summary>
            <doc-id>ms698949</doc-id>
            <unmanaged>MF_QUALITY_NORMAL_MINUS_5</unmanaged>
            <unmanaged-short>MF_QUALITY_NORMAL_MINUS_5</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.QualityLevel.MfNumQualityLevels">
            <summary>
            <dd> <p> Maximum number of quality levels. This value is not a valid flag. </p> </dd>
            </summary>
            <doc-id>ms698949</doc-id>
            <unmanaged>MF_NUM_QUALITY_LEVELS</unmanaged>
            <unmanaged-short>MF_NUM_QUALITY_LEVELS</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.RateDirection">
            <summary>
            <p> </p><p>Specifies the direction of playback (forward or reverse).</p>
            </summary>
            <doc-id>ms696225</doc-id>
            <unmanaged>MFRATE_DIRECTION</unmanaged>
            <unmanaged-short>MFRATE_DIRECTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.RateDirection.Forward">
            <summary>
            <dd> <p>Forward playback.</p> </dd>
            </summary>
            <doc-id>ms696225</doc-id>
            <unmanaged>MFRATE_FORWARD</unmanaged>
            <unmanaged-short>MFRATE_FORWARD</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.RateDirection.Reverse">
            <summary>
            <dd> <p>Reverse playback.</p> </dd>
            </summary>
            <doc-id>ms696225</doc-id>
            <unmanaged>MFRATE_REVERSE</unmanaged>
            <unmanaged-short>MFRATE_REVERSE</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.SampleEncryptionProtectionScheme">
            <summary>
            <p>Specifies the supported protection schemes for encrypted samples.</p>
            </summary>
            <remarks>
            <p>The encryption scheme for a sample is specified using the MFSampleExtension_Encryption_ProtectionScheme attribute.</p>
            </remarks>
            <doc-id>mt804350</doc-id>
            <unmanaged>MFSampleEncryptionProtectionScheme</unmanaged>
            <unmanaged-short>MFSampleEncryptionProtectionScheme</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleEncryptionProtectionScheme.MfSampleEncryptionProtectionSchemeNone">
            <summary>
            <dd> <p>No encryption scheme.</p> </dd>
            </summary>
            <doc-id>mt804350</doc-id>
            <unmanaged>MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_NONE</unmanaged>
            <unmanaged-short>MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleEncryptionProtectionScheme.MfSampleEncryptionProtectionSchemeAesCtr">
            <summary>
            <dd> <p>The encryption scheme is AES counter mode (CTR).</p> </dd>
            </summary>
            <doc-id>mt804350</doc-id>
            <unmanaged>MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CTR</unmanaged>
            <unmanaged-short>MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CTR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleEncryptionProtectionScheme.MfSampleEncryptionProtectionSchemeAesCbc">
            <summary>
            <dd> <p>The encryption scheme is Cipher Block Chaining (CBC).</p> </dd>
            </summary>
            <doc-id>mt804350</doc-id>
            <unmanaged>MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CBC</unmanaged>
            <unmanaged-short>MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CBC</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.SampleProtectionVersion">
            <summary>
            <p> </p><p>Defines the version number for sample protection.</p>
            </summary>
            <doc-id>ms697061</doc-id>
            <unmanaged>SAMPLE_PROTECTION_VERSION</unmanaged>
            <unmanaged-short>SAMPLE_PROTECTION_VERSION</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleProtectionVersion.No">
            <summary>
            <dd> <p>No sample protection.</p> </dd>
            </summary>
            <doc-id>ms697061</doc-id>
            <unmanaged>SAMPLE_PROTECTION_VERSION_NO</unmanaged>
            <unmanaged-short>SAMPLE_PROTECTION_VERSION_NO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleProtectionVersion.BasicLoki">
            <summary>
            <dd> <p>Version 1.</p> </dd>
            </summary>
            <doc-id>ms697061</doc-id>
            <unmanaged>SAMPLE_PROTECTION_VERSION_BASIC_LOKI</unmanaged>
            <unmanaged-short>SAMPLE_PROTECTION_VERSION_BASIC_LOKI</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleProtectionVersion.Scatter">
            <summary>
            <dd> <p>Version 2.</p> </dd>
            </summary>
            <doc-id>ms697061</doc-id>
            <unmanaged>SAMPLE_PROTECTION_VERSION_SCATTER</unmanaged>
            <unmanaged-short>SAMPLE_PROTECTION_VERSION_SCATTER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleProtectionVersion.Rc4">
            <summary>
            <dd> <p>Version 3.</p> </dd>
            </summary>
            <doc-id>ms697061</doc-id>
            <unmanaged>SAMPLE_PROTECTION_VERSION_RC4</unmanaged>
            <unmanaged-short>SAMPLE_PROTECTION_VERSION_RC4</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleProtectionVersion.Aes128ctr">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697061</doc-id>
            <unmanaged>SAMPLE_PROTECTION_VERSION_AES128CTR</unmanaged>
            <unmanaged-short>SAMPLE_PROTECTION_VERSION_AES128CTR</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.SensorDeviceMode">
            <summary>
            <p>Specifies how a video stream is interlaced.</p><p>In the descriptions that follow, upper field refers to the field that contains the leading half scan line. Lower field refers to the field that contains the first full scan line.</p>
            </summary>
            <remarks>
            <p>Scan lines in the lower field are 0.5 scan line lower than those in the upper field. In NTSC television, a frame consists of a lower field followed by an upper field. In PAL television, a frame consists of an upper field followed by a lower field.</p><p>The upper field is also called the even field, the top field, or field 2. The lower field is also called the odd field, the bottom field, or field 1.</p><p>If the interlace mode is MFVideoInterlace_FieldSingleUpper or MFVideoInterlace_FieldSingleLower, each sample contains a single field, so each buffer contains only half the number of field lines given in the media type.</p>
            </remarks>
            <doc-id>ms694269</doc-id>
            <unmanaged>MFSensorDeviceMode</unmanaged>
            <unmanaged-short>MFSensorDeviceMode</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SensorDeviceMode.Controller">
            <summary>
            <dd> <p> The type of interlacing is not known. </p> </dd>
            </summary>
            <doc-id>ms694269</doc-id>
            <unmanaged>MFSensorDeviceMode_Controller</unmanaged>
            <unmanaged-short>MFSensorDeviceMode_Controller</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SensorDeviceMode.Shared">
            <summary>
            <dd> <p> Progressive frames. </p> </dd>
            </summary>
            <doc-id>ms694269</doc-id>
            <unmanaged>MFSensorDeviceMode_Shared</unmanaged>
            <unmanaged-short>MFSensorDeviceMode_Shared</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.SensorDeviceType">
            <summary>
            <p> </p><p>Specifies how to open or create a file.</p>
            </summary>
            <doc-id>ms694164</doc-id>
            <unmanaged>MFSensorDeviceType</unmanaged>
            <unmanaged-short>MFSensorDeviceType</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SensorDeviceType.Unknown">
            <summary>
            <dd> <p>Open an existing file. Fail if the file does not exist.</p> </dd>
            </summary>
            <doc-id>ms694164</doc-id>
            <unmanaged>MFSensorDeviceType_Unknown</unmanaged>
            <unmanaged-short>MFSensorDeviceType_Unknown</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SensorDeviceType.Device">
            <summary>
            <dd> <p>Create a new file. Fail if the file already exists.</p> </dd>
            </summary>
            <doc-id>ms694164</doc-id>
            <unmanaged>MFSensorDeviceType_Device</unmanaged>
            <unmanaged-short>MFSensorDeviceType_Device</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SensorDeviceType.MediaSource">
            <summary>
            <dd> <p>Open an existing file and truncate it, so that the size is zero bytes. Fail if the file does not already exist.</p> </dd>
            </summary>
            <doc-id>ms694164</doc-id>
            <unmanaged>MFSensorDeviceType_MediaSource</unmanaged>
            <unmanaged-short>MFSensorDeviceType_MediaSource</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SensorDeviceType.FrameProvider">
            <summary>
            <dd> <p>If the file does not exist, create a new file. If the file exists, open it.</p> </dd>
            </summary>
            <doc-id>ms694164</doc-id>
            <unmanaged>MFSensorDeviceType_FrameProvider</unmanaged>
            <unmanaged-short>MFSensorDeviceType_FrameProvider</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SensorDeviceType.SensorTransform">
            <summary>
            <dd> <p>Create a new file. If the file exists, overwrite the file.</p> </dd>
            </summary>
            <doc-id>ms694164</doc-id>
            <unmanaged>MFSensorDeviceType_SensorTransform</unmanaged>
            <unmanaged-short>MFSensorDeviceType_SensorTransform</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.SensorStreamType">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies whether a stream associated with an <strong><see cref = "T:SharpDX.MediaFoundation.SensorDevice"/></strong> is an input or an output stream.</p>
            </summary>
            <doc-id>mt797984</doc-id>
            <unmanaged>MFSensorStreamType</unmanaged>
            <unmanaged-short>MFSensorStreamType</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SensorStreamType.Unknown">
            <summary>
            No documentation.
            </summary>
            <doc-id>mt797984</doc-id>
            <unmanaged>MFSensorStreamType_Unknown</unmanaged>
            <unmanaged-short>MFSensorStreamType_Unknown</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SensorStreamType.Input">
            <summary>
            No documentation.
            </summary>
            <doc-id>mt797984</doc-id>
            <unmanaged>MFSensorStreamType_Input</unmanaged>
            <unmanaged-short>MFSensorStreamType_Input</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SensorStreamType.Output">
            <summary>
            No documentation.
            </summary>
            <doc-id>mt797984</doc-id>
            <unmanaged>MFSensorStreamType_Output</unmanaged>
            <unmanaged-short>MFSensorStreamType_Output</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.SequencerTopologyFlags">
            <summary>
            <p> </p><p>Contains flags for adding a topology to the sequencer source, or updating a topology already in the queue.</p>
            </summary>
            <doc-id>ms703884</doc-id>
            <unmanaged>MFSequencerTopologyFlags</unmanaged>
            <unmanaged-short>MFSequencerTopologyFlags</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SequencerTopologyFlags.SequencerTopologyFlagsLast">
            <summary>
            <dd> <p>This topology is the last topology in the sequence.</p> </dd>
            </summary>
            <doc-id>ms703884</doc-id>
            <unmanaged>SequencerTopologyFlags_Last</unmanaged>
            <unmanaged-short>SequencerTopologyFlags_Last</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.ServiceLookupType">
            <summary>
            <p> </p><p>Retrieves an interface from the enhanced video renderer (EVR), or from the video mixer or video presenter.</p>
            </summary>
            <remarks>
            <p>This method can be called only from inside the <strong>IMFTopologyServiceLookupClient::InitServicePointers</strong> method. At any other time, the method returns <see cref = "!:NotAccepting"/>.</p><p>The presenter can use this method to query the EVR and the mixer. The mixer can use it to query the EVR and the presenter. Which objects are queried depends on the caller and the service <see cref = "T:System.Guid"/>, as shown in the following table.</p><table> <tr><th>Caller</th><th>Service <see cref = "T:System.Guid"/></th><th>Objects queried</th></tr> <tr><td>Presenter</td><td>MR_VIDEO_RENDER_SERVICE</td><td>EVR</td></tr> <tr><td>Presenter</td><td>MR_VIDEO_MIXER_SERVICE</td><td>Mixer</td></tr> <tr><td>Mixer</td><td>MR_VIDEO_RENDER_SERVICE</td><td>Presenter and EVR</td></tr> </table><p>?</p><p>The following interfaces are available from the EVR:</p><ul> <li> <p><strong>IMediaEventSink</strong>. This interface is documented in the DirectShow SDK documentation.</p> </li> <li> <p> <strong><see cref = "T:SharpDX.MediaFoundation.Clock"/></strong> interface. This interface is available if the EVR has access to a clock (reference clock in DirectShow or presentation clock in Media Foundation). This interface might not be available. Presenter and mixers must be able to process data without a clock. If the <strong><see cref = "T:SharpDX.MediaFoundation.Clock"/></strong> interface is available, you can also get these related interfaces:</p> <ul> <li> <p> <strong><see cref = "T:SharpDX.MediaFoundation.Timer"/></strong> </p> </li> <li> <p> <strong><see cref = "T:SharpDX.MediaFoundation.PresentationClock"/></strong> (Media Foundation EVR only)</p> </li> </ul> </li> </ul><p>The following interfaces are available from the mixer:</p><ul> <li> <p> <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> </p> </li> <li> <p> <strong><see cref = "T:SharpDX.MediaFoundation.VideoDeviceID"/></strong> </p> </li> </ul>
            </remarks>
            <doc-id>bb970504</doc-id>
            <unmanaged>MF_SERVICE_LOOKUP_TYPE</unmanaged>
            <unmanaged-short>MF_SERVICE_LOOKUP_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ServiceLookupType.Upstream">
            <summary>
            <dd> <p>Specifies the scope of the search. Currently this parameter is ignored. Use the value MF_SERVICE_LOOKUP_GLOBAL.</p> </dd>
            </summary>
            <doc-id>bb970504</doc-id>
            <unmanaged>MF_SERVICE_LOOKUP_UPSTREAM</unmanaged>
            <unmanaged-short>MF_SERVICE_LOOKUP_UPSTREAM</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ServiceLookupType.UpstreamDirect">
            <summary>
            <dd> <p>Reserved, must be zero.</p> </dd>
            </summary>
            <doc-id>bb970504</doc-id>
            <unmanaged>MF_SERVICE_LOOKUP_UPSTREAM_DIRECT</unmanaged>
            <unmanaged-short>MF_SERVICE_LOOKUP_UPSTREAM_DIRECT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ServiceLookupType.Downstream">
            <summary>
            <dd> <p>Service <see cref = "T:System.Guid"/> of the requested interface.</p> </dd>
            </summary>
            <doc-id>bb970504</doc-id>
            <unmanaged>MF_SERVICE_LOOKUP_DOWNSTREAM</unmanaged>
            <unmanaged-short>MF_SERVICE_LOOKUP_DOWNSTREAM</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ServiceLookupType.DownstreamDirect">
            <summary>
            <dd> <p>Interface identifier of the requested interface.</p> </dd>
            </summary>
            <doc-id>bb970504</doc-id>
            <unmanaged>MF_SERVICE_LOOKUP_DOWNSTREAM_DIRECT</unmanaged>
            <unmanaged-short>MF_SERVICE_LOOKUP_DOWNSTREAM_DIRECT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ServiceLookupType.All">
            <summary>
            <dd> <p>Array of interface references. If the method succeeds, each member of the array contains either a valid interface reference or <strong><c>null</c></strong>. The caller must release the interface references when the EVR calls <strong>IMFTopologyServiceLookupClient::ReleaseServicePointers</strong> (or earlier). If the method fails, every member of the array is <strong><c>null</c></strong>.</p> </dd>
            </summary>
            <doc-id>bb970504</doc-id>
            <unmanaged>MF_SERVICE_LOOKUP_ALL</unmanaged>
            <unmanaged-short>MF_SERVICE_LOOKUP_ALL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ServiceLookupType.Global">
            <summary>
            <dd> <p>Pointer to a value that specifies the size of the <em>ppvObjects</em> array. The value must be at least 1. In the current implementation, there is no reason to specify an array size larger than one element. The value is not changed on output.</p> </dd>
            </summary>
            <doc-id>bb970504</doc-id>
            <unmanaged>MF_SERVICE_LOOKUP_GLOBAL</unmanaged>
            <unmanaged-short>MF_SERVICE_LOOKUP_GLOBAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SessionGetFullTopologyFlags.Current">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms701845</doc-id>
            <unmanaged>MFSESSION_GETFULLTOPOLOGY_CURRENT</unmanaged>
            <unmanaged-short>MFSESSION_GETFULLTOPOLOGY_CURRENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SessionGetFullTopologyFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SessionSetTopologyFlags.Immediate">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms696169</doc-id>
            <unmanaged>MFSESSION_SETTOPOLOGY_IMMEDIATE</unmanaged>
            <unmanaged-short>MFSESSION_SETTOPOLOGY_IMMEDIATE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SessionSetTopologyFlags.Noresolution">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms696169</doc-id>
            <unmanaged>MFSESSION_SETTOPOLOGY_NORESOLUTION</unmanaged>
            <unmanaged-short>MFSESSION_SETTOPOLOGY_NORESOLUTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SessionSetTopologyFlags.ClearCurrent">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms696169</doc-id>
            <unmanaged>MFSESSION_SETTOPOLOGY_CLEAR_CURRENT</unmanaged>
            <unmanaged-short>MFSESSION_SETTOPOLOGY_CLEAR_CURRENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SessionSetTopologyFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.ShutdownStatus">
            <summary>
            <p> Describes the current status of a call to the <strong>IMFShutdown::Shutdown</strong> method.</p>
            </summary>
            <doc-id>ms701630</doc-id>
            <unmanaged>MFSHUTDOWN_STATUS</unmanaged>
            <unmanaged-short>MFSHUTDOWN_STATUS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ShutdownStatus.Initiated">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms701630</doc-id>
            <unmanaged>MFSHUTDOWN_INITIATED</unmanaged>
            <unmanaged-short>MFSHUTDOWN_INITIATED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ShutdownStatus.Completed">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms701630</doc-id>
            <unmanaged>MFSHUTDOWN_COMPLETED</unmanaged>
            <unmanaged-short>MFSHUTDOWN_COMPLETED</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.SinkWmdrmaction">
            <summary>
            <p> </p><p>Specifies how the ASF file sink should apply Windows Media DRM.</p>
            </summary>
            <doc-id>ms703949</doc-id>
            <unmanaged>MFSINK_WMDRMACTION</unmanaged>
            <unmanaged-short>MFSINK_WMDRMACTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWmdrmaction.Undefined">
            <summary>
            <dd> <p>Undefined action.</p> </dd>
            </summary>
            <doc-id>ms703949</doc-id>
            <unmanaged>MFSINK_WMDRMACTION_UNDEFINED</unmanaged>
            <unmanaged-short>MFSINK_WMDRMACTION_UNDEFINED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWmdrmaction.Encode">
            <summary>
            <dd> <p>Encode the content using Windows Media DRM. Use this flag if the source content does not have DRM protection.</p> </dd>
            </summary>
            <doc-id>ms703949</doc-id>
            <unmanaged>MFSINK_WMDRMACTION_ENCODE</unmanaged>
            <unmanaged-short>MFSINK_WMDRMACTION_ENCODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWmdrmaction.Transcode">
            <summary>
            <dd> <p>Transcode the content using Windows Media DRM. Use this flag if the source content has Windows Media DRM protection and you want to change the encoding parameters but not the DRM protection.</p> </dd>
            </summary>
            <doc-id>ms703949</doc-id>
            <unmanaged>MFSINK_WMDRMACTION_TRANSCODE</unmanaged>
            <unmanaged-short>MFSINK_WMDRMACTION_TRANSCODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWmdrmaction.Transcrypt">
            <summary>
            <dd> <p>Transcrypt the content. Use this flag if the source content has DRM protection and you want to change the DRM protection; for example, if you want to convert from Windows Media DRM version 1 to Windows Media DRM version 7 or later.</p> </dd>
            </summary>
            <doc-id>ms703949</doc-id>
            <unmanaged>MFSINK_WMDRMACTION_TRANSCRYPT</unmanaged>
            <unmanaged-short>MFSINK_WMDRMACTION_TRANSCRYPT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWmdrmaction.Last">
            <summary>
            <dd> <p>Reserved. Do not use.</p> </dd>
            </summary>
            <doc-id>ms703949</doc-id>
            <unmanaged>MFSINK_WMDRMACTION_LAST</unmanaged>
            <unmanaged-short>MFSINK_WMDRMACTION_LAST</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.SinkWriterIndex">
            <summary>
            No documentation.
            </summary>
            <unmanaged>__MIDL___MIDL_itf_mfreadwrite_0000_0005_0001</unmanaged>
            <unmanaged-short>__MIDL___MIDL_itf_mfreadwrite_0000_0005_0001</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterIndex.InvalidStreamIndex">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_SINK_WRITER_INVALID_STREAM_INDEX</unmanaged>
            <unmanaged-short>MF_SINK_WRITER_INVALID_STREAM_INDEX</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterIndex.AllStreams">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_SINK_WRITER_ALL_STREAMS</unmanaged>
            <unmanaged-short>MF_SINK_WRITER_ALL_STREAMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterIndex.MediaSink">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_SINK_WRITER_MEDIASINK</unmanaged>
            <unmanaged-short>MF_SINK_WRITER_MEDIASINK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderControlFlags.ControlfDrain">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375771</doc-id>
            <unmanaged>MF_SOURCE_READER_CONTROLF_DRAIN</unmanaged>
            <unmanaged-short>MF_SOURCE_READER_CONTROLF_DRAIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderControlFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderFlags.Error">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375773</doc-id>
            <unmanaged>MF_SOURCE_READERF_ERROR</unmanaged>
            <unmanaged-short>MF_SOURCE_READERF_ERROR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderFlags.Endofstream">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375773</doc-id>
            <unmanaged>MF_SOURCE_READERF_ENDOFSTREAM</unmanaged>
            <unmanaged-short>MF_SOURCE_READERF_ENDOFSTREAM</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderFlags.Newstream">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375773</doc-id>
            <unmanaged>MF_SOURCE_READERF_NEWSTREAM</unmanaged>
            <unmanaged-short>MF_SOURCE_READERF_NEWSTREAM</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderFlags.Nativemediatypechanged">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375773</doc-id>
            <unmanaged>MF_SOURCE_READERF_NATIVEMEDIATYPECHANGED</unmanaged>
            <unmanaged-short>MF_SOURCE_READERF_NATIVEMEDIATYPECHANGED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderFlags.Currentmediatypechanged">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375773</doc-id>
            <unmanaged>MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED</unmanaged>
            <unmanaged-short>MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderFlags.StreamTick">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375773</doc-id>
            <unmanaged>MF_SOURCE_READERF_STREAMTICK</unmanaged>
            <unmanaged-short>MF_SOURCE_READERF_STREAMTICK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderFlags.AllEffectsremoved">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375773</doc-id>
            <unmanaged>MF_SOURCE_READERF_ALLEFFECTSREMOVED</unmanaged>
            <unmanaged-short>MF_SOURCE_READERF_ALLEFFECTSREMOVED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.SourceReaderIndex">
            <summary>
            No documentation.
            </summary>
            <unmanaged>__MIDL___MIDL_itf_mfreadwrite_0000_0001_0001</unmanaged>
            <unmanaged-short>__MIDL___MIDL_itf_mfreadwrite_0000_0001_0001</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderIndex.InvalidStreamIndex">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_SOURCE_READER_INVALID_STREAM_INDEX</unmanaged>
            <unmanaged-short>MF_SOURCE_READER_INVALID_STREAM_INDEX</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderIndex.AllStreams">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_SOURCE_READER_ALL_STREAMS</unmanaged>
            <unmanaged-short>MF_SOURCE_READER_ALL_STREAMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderIndex.AnyStream">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_SOURCE_READER_ANY_STREAM</unmanaged>
            <unmanaged-short>MF_SOURCE_READER_ANY_STREAM</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderIndex.FirstAudioStream">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_SOURCE_READER_FIRST_AUDIO_STREAM</unmanaged>
            <unmanaged-short>MF_SOURCE_READER_FIRST_AUDIO_STREAM</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderIndex.FirstVideoStream">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_SOURCE_READER_FIRST_VIDEO_STREAM</unmanaged>
            <unmanaged-short>MF_SOURCE_READER_FIRST_VIDEO_STREAM</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderIndex.MediaSource">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_SOURCE_READER_MEDIASOURCE</unmanaged>
            <unmanaged-short>MF_SOURCE_READER_MEDIASOURCE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceResolverFlags.MediaSource">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_RESOLUTION_MEDIASOURCE</unmanaged>
            <unmanaged-short>MF_RESOLUTION_MEDIASOURCE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceResolverFlags.ByteStream">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_RESOLUTION_BYTESTREAM</unmanaged>
            <unmanaged-short>MF_RESOLUTION_BYTESTREAM</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceResolverFlags.ContentDoesNotHaveToMatchExtensionOrMimeType">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_RESOLUTION_CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE</unmanaged>
            <unmanaged-short>MF_RESOLUTION_CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceResolverFlags.KeepByteStreamAliveOnFail">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_RESOLUTION_KEEP_BYTE_STREAM_ALIVE_ON_FAIL</unmanaged>
            <unmanaged-short>MF_RESOLUTION_KEEP_BYTE_STREAM_ALIVE_ON_FAIL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceResolverFlags.DisableLocalPlugins">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_RESOLUTION_DISABLE_LOCAL_PLUGINS</unmanaged>
            <unmanaged-short>MF_RESOLUTION_DISABLE_LOCAL_PLUGINS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceResolverFlags.PluginControlPolicyApprovedOnly">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_RESOLUTION_PLUGIN_CONTROL_POLICY_APPROVED_ONLY</unmanaged>
            <unmanaged-short>MF_RESOLUTION_PLUGIN_CONTROL_POLICY_APPROVED_ONLY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceResolverFlags.PluginControlPolicyWebOnly">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY</unmanaged>
            <unmanaged-short>MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceResolverFlags.PluginControlPolicyWebOnlyEdgemode">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY_EDGEMODE</unmanaged>
            <unmanaged-short>MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY_EDGEMODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceResolverFlags.EnableStorePlugins">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_RESOLUTION_ENABLE_STORE_PLUGINS</unmanaged>
            <unmanaged-short>MF_RESOLUTION_ENABLE_STORE_PLUGINS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceResolverFlags.Read">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_RESOLUTION_READ</unmanaged>
            <unmanaged-short>MF_RESOLUTION_READ</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceResolverFlags.Write">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_RESOLUTION_WRITE</unmanaged>
            <unmanaged-short>MF_RESOLUTION_WRITE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceResolverFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.StandardVideoFormat">
            <summary>
            <p> </p><p>Contains values that specify common video formats.</p>
            </summary>
            <doc-id>aa473799</doc-id>
            <unmanaged>MFStandardVideoFormat</unmanaged>
            <unmanaged-short>MFStandardVideoFormat</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.StandardVideoFormat.DVideoFormatReserved">
            <summary>
            <dd> <p>Reserved; do not use.</p> </dd>
            </summary>
            <doc-id>aa473799</doc-id>
            <unmanaged>MFStdVideoFormat_reserved</unmanaged>
            <unmanaged-short>MFStdVideoFormat_reserved</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.StandardVideoFormat.DVideoFormatNtsc">
            <summary>
            <dd> <p>NTSC television (720 x 480i).</p> </dd>
            </summary>
            <doc-id>aa473799</doc-id>
            <unmanaged>MFStdVideoFormat_NTSC</unmanaged>
            <unmanaged-short>MFStdVideoFormat_NTSC</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.StandardVideoFormat.DVideoFormatPal">
            <summary>
            <dd> <p>PAL television (720 x 576i).</p> </dd>
            </summary>
            <doc-id>aa473799</doc-id>
            <unmanaged>MFStdVideoFormat_PAL</unmanaged>
            <unmanaged-short>MFStdVideoFormat_PAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.StandardVideoFormat.DVideoFormatDvdNtsc">
            <summary>
            <dd> <p>DVD, NTSC standard (720 x 480).</p> </dd>
            </summary>
            <doc-id>aa473799</doc-id>
            <unmanaged>MFStdVideoFormat_DVD_NTSC</unmanaged>
            <unmanaged-short>MFStdVideoFormat_DVD_NTSC</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.StandardVideoFormat.DVideoFormatDvdPal">
            <summary>
            <dd> <p>DVD, PAL standard (720 x 576).</p> </dd>
            </summary>
            <doc-id>aa473799</doc-id>
            <unmanaged>MFStdVideoFormat_DVD_PAL</unmanaged>
            <unmanaged-short>MFStdVideoFormat_DVD_PAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.StandardVideoFormat.DVideoFormatDvPal">
            <summary>
            <dd> <p>DV video, PAL standard.</p> </dd>
            </summary>
            <doc-id>aa473799</doc-id>
            <unmanaged>MFStdVideoFormat_DV_PAL</unmanaged>
            <unmanaged-short>MFStdVideoFormat_DV_PAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.StandardVideoFormat.DVideoFormatDvNtsc">
            <summary>
            <dd> <p>DV video, NTSC standard.</p> </dd>
            </summary>
            <doc-id>aa473799</doc-id>
            <unmanaged>MFStdVideoFormat_DV_NTSC</unmanaged>
            <unmanaged-short>MFStdVideoFormat_DV_NTSC</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.StandardVideoFormat.DVideoFormatAtscSD480i">
            <summary>
            <dd> <p>ATSC digital television, SD (480i).</p> </dd>
            </summary>
            <doc-id>aa473799</doc-id>
            <unmanaged>MFStdVideoFormat_ATSC_SD480i</unmanaged>
            <unmanaged-short>MFStdVideoFormat_ATSC_SD480i</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.StandardVideoFormat.DVideoFormatAtscHD1080i">
            <summary>
            <dd> <p>ATSC digital television, HD interlaced (1080i)</p> </dd>
            </summary>
            <doc-id>aa473799</doc-id>
            <unmanaged>MFStdVideoFormat_ATSC_HD1080i</unmanaged>
            <unmanaged-short>MFStdVideoFormat_ATSC_HD1080i</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.StandardVideoFormat.DVideoFormatAtscHD720p">
            <summary>
            <dd> <p>ATSC digital television, HD progressive (720p)</p> </dd>
            </summary>
            <doc-id>aa473799</doc-id>
            <unmanaged>MFStdVideoFormat_ATSC_HD720p</unmanaged>
            <unmanaged-short>MFStdVideoFormat_ATSC_HD720p</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.StreamsInkMarkerType">
            <summary>
            <p>Defines stream marker information for the <strong>IMFStreamSink::PlaceMarker</strong> method. The <strong>PlaceMarker</strong> method places a marker on the stream between samples. The <strong><see cref = "T:SharpDX.MediaFoundation.StreamsInkMarkerType"/></strong> enumeration defines the marker type and the type of information associated with the marker.</p>
            </summary>
            <remarks>
            <p>If the Streaming Audio Renderer receives an <strong>MFSTREAMSINK_MARKER_TICK</strong> marker, it inserts silence to cover the gap in the data. </p>
            </remarks>
            <doc-id>ms703837</doc-id>
            <unmanaged>MFSTREAMSINK_MARKER_TYPE</unmanaged>
            <unmanaged-short>MFSTREAMSINK_MARKER_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamsInkMarkerType.Default">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms703837</doc-id>
            <unmanaged>MFSTREAMSINK_MARKER_DEFAULT</unmanaged>
            <unmanaged-short>MFSTREAMSINK_MARKER_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamsInkMarkerType.Endofsegment">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms703837</doc-id>
            <unmanaged>MFSTREAMSINK_MARKER_ENDOFSEGMENT</unmanaged>
            <unmanaged-short>MFSTREAMSINK_MARKER_ENDOFSEGMENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamsInkMarkerType.Tick">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms703837</doc-id>
            <unmanaged>MFSTREAMSINK_MARKER_TICK</unmanaged>
            <unmanaged-short>MFSTREAMSINK_MARKER_TICK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamsInkMarkerType.Event">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms703837</doc-id>
            <unmanaged>MFSTREAMSINK_MARKER_EVENT</unmanaged>
            <unmanaged-short>MFSTREAMSINK_MARKER_EVENT</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.StreamState">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_STREAM_STATE</unmanaged>
            <unmanaged-short>MF_STREAM_STATE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamState.Stopped">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_STREAM_STATE_STOPPED</unmanaged>
            <unmanaged-short>MF_STREAM_STATE_STOPPED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamState.Paused">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_STREAM_STATE_PAUSED</unmanaged>
            <unmanaged-short>MF_STREAM_STATE_PAUSED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamState.Running">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_STREAM_STATE_RUNNING</unmanaged>
            <unmanaged-short>MF_STREAM_STATE_RUNNING</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TAudioDecoderDegradationReason">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFT_AUDIO_DECODER_DEGRADATION_REASON</unmanaged>
            <unmanaged-short>MFT_AUDIO_DECODER_DEGRADATION_REASON</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TAudioDecoderDegradationReason.None">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFT_AUDIO_DECODER_DEGRADATION_REASON_NONE</unmanaged>
            <unmanaged-short>MFT_AUDIO_DECODER_DEGRADATION_REASON_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TAudioDecoderDegradationReason.LicensingRequirement">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFT_AUDIO_DECODER_DEGRADATION_REASON_LICENSING_REQUIREMENT</unmanaged>
            <unmanaged-short>MFT_AUDIO_DECODER_DEGRADATION_REASON_LICENSING_REQUIREMENT</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TAudioDecoderDegradationType">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFT_AUDIO_DECODER_DEGRADATION_TYPE</unmanaged>
            <unmanaged-short>MFT_AUDIO_DECODER_DEGRADATION_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TAudioDecoderDegradationType.None">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFT_AUDIO_DECODER_DEGRADATION_TYPE_NONE</unmanaged>
            <unmanaged-short>MFT_AUDIO_DECODER_DEGRADATION_TYPE_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TAudioDecoderDegradationType.Downmix2channel">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX2CHANNEL</unmanaged>
            <unmanaged-short>MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX2CHANNEL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TAudioDecoderDegradationType.Downmix6channel">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX6CHANNEL</unmanaged>
            <unmanaged-short>MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX6CHANNEL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TAudioDecoderDegradationType.Downmix8channel">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX8CHANNEL</unmanaged>
            <unmanaged-short>MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX8CHANNEL</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TimedTextAlignment">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies how text is aligned in its parent block element. </p>
            </summary>
            <doc-id>dn782325</doc-id>
            <unmanaged>MF_TIMED_TEXT_ALIGNMENT</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_ALIGNMENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextAlignment.Start">
            <summary>
            <dd> <p>Text is aligned at the start of its parent block element.</p> </dd>
            </summary>
            <doc-id>dn782325</doc-id>
            <unmanaged>MF_TIMED_TEXT_ALIGNMENT_START</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_ALIGNMENT_START</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextAlignment.End">
            <summary>
            <dd> <p>Text is aligned at the end of its parent block element.</p> </dd>
            </summary>
            <doc-id>dn782325</doc-id>
            <unmanaged>MF_TIMED_TEXT_ALIGNMENT_END</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_ALIGNMENT_END</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextAlignment.Center">
            <summary>
            <dd> <p>Text is aligned in the center of its parent block element.</p> </dd>
            </summary>
            <doc-id>dn782325</doc-id>
            <unmanaged>MF_TIMED_TEXT_ALIGNMENT_CENTER</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_ALIGNMENT_CENTER</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TimedTextCueEvent">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies the type of  a timed text cue event.</p>
            </summary>
            <doc-id>dn904197</doc-id>
            <unmanaged>MF_TIMED_TEXT_CUE_EVENT</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_CUE_EVENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextCueEvent.Active">
            <summary>
            <dd> <p>The cue has become active.</p> </dd>
            </summary>
            <doc-id>dn904197</doc-id>
            <unmanaged>MF_TIMED_TEXT_CUE_EVENT_ACTIVE</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_CUE_EVENT_ACTIVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextCueEvent.Inactive">
            <summary>
            <dd> <p>The cue has become inactive.</p> </dd>
            </summary>
            <doc-id>dn904197</doc-id>
            <unmanaged>MF_TIMED_TEXT_CUE_EVENT_INACTIVE</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_CUE_EVENT_INACTIVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextCueEvent.Clear">
            <summary>
            <dd> <p>All cues have been deactivated.</p> </dd>
            </summary>
            <doc-id>dn904197</doc-id>
            <unmanaged>MF_TIMED_TEXT_CUE_EVENT_CLEAR</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_CUE_EVENT_CLEAR</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TimedTextDecoration">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies how text is decorated (underlined and so on). </p>
            </summary>
            <doc-id>dn782326</doc-id>
            <unmanaged>MF_TIMED_TEXT_DECORATION</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_DECORATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextDecoration.None">
            <summary>
            <dd> <p>Text isn't decorated.</p> </dd>
            </summary>
            <doc-id>dn782326</doc-id>
            <unmanaged>MF_TIMED_TEXT_DECORATION_NONE</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_DECORATION_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextDecoration.Underline">
            <summary>
            <dd> <p>Text is underlined.</p> </dd>
            </summary>
            <doc-id>dn782326</doc-id>
            <unmanaged>MF_TIMED_TEXT_DECORATION_UNDERLINE</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_DECORATION_UNDERLINE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextDecoration.LineThrough">
            <summary>
            <dd> <p>Text has a line through it.</p> </dd>
            </summary>
            <doc-id>dn782326</doc-id>
            <unmanaged>MF_TIMED_TEXT_DECORATION_LINE_THROUGH</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_DECORATION_LINE_THROUGH</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextDecoration.Overline">
            <summary>
            <dd> <p>Text has a line over it.</p> </dd>
            </summary>
            <doc-id>dn782326</doc-id>
            <unmanaged>MF_TIMED_TEXT_DECORATION_OVERLINE</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_DECORATION_OVERLINE</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TimedTextDisplayAlignment">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies how text is aligned with the display. </p>
            </summary>
            <doc-id>dn782327</doc-id>
            <unmanaged>MF_TIMED_TEXT_DISPLAY_ALIGNMENT</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_DISPLAY_ALIGNMENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextDisplayAlignment.Before">
            <summary>
            <dd> <p>Text is aligned before an element.</p> </dd>
            </summary>
            <doc-id>dn782327</doc-id>
            <unmanaged>MF_TIMED_TEXT_DISPLAY_ALIGNMENT_BEFORE</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_DISPLAY_ALIGNMENT_BEFORE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextDisplayAlignment.After">
            <summary>
            <dd> <p>Text is aligned after an element.</p> </dd>
            </summary>
            <doc-id>dn782327</doc-id>
            <unmanaged>MF_TIMED_TEXT_DISPLAY_ALIGNMENT_AFTER</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_DISPLAY_ALIGNMENT_AFTER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextDisplayAlignment.Center">
            <summary>
            <dd> <p>Text is aligned in the center between elements.</p> </dd>
            </summary>
            <doc-id>dn782327</doc-id>
            <unmanaged>MF_TIMED_TEXT_DISPLAY_ALIGNMENT_CENTER</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_DISPLAY_ALIGNMENT_CENTER</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TimedTextErrorCode">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies the kind error that occurred with a timed text track.</p>
            </summary>
            <remarks>
            <p>This enumeration is used to return error information  from the <strong>IMFTimedTextTrack::GetErrorCode</strong> method.</p>
            </remarks>
            <doc-id>dn859186</doc-id>
            <unmanaged>MF_TIMED_TEXT_ERROR_CODE</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_ERROR_CODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextErrorCode.Noerror">
            <summary>
            <dd> <p>No error occurred.</p> </dd>
            </summary>
            <doc-id>dn859186</doc-id>
            <unmanaged>MF_TIMED_TEXT_ERROR_CODE_NOERROR</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_ERROR_CODE_NOERROR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextErrorCode.Fatal">
            <summary>
            <dd> <p>A fatal error occurred.</p> </dd>
            </summary>
            <doc-id>dn859186</doc-id>
            <unmanaged>MF_TIMED_TEXT_ERROR_CODE_FATAL</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_ERROR_CODE_FATAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextErrorCode.DataFormat">
            <summary>
            <dd> <p>An error occurred with the data format of the timed text track.</p> </dd>
            </summary>
            <doc-id>dn859186</doc-id>
            <unmanaged>MF_TIMED_TEXT_ERROR_CODE_DATA_FORMAT</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_ERROR_CODE_DATA_FORMAT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextErrorCode.Network">
            <summary>
            <dd> <p>A network error occurred when trying to load the timed text track.</p> </dd>
            </summary>
            <doc-id>dn859186</doc-id>
            <unmanaged>MF_TIMED_TEXT_ERROR_CODE_NETWORK</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_ERROR_CODE_NETWORK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextErrorCode.Internal">
            <summary>
            <dd> <p>An internal error occurred.</p> </dd>
            </summary>
            <doc-id>dn859186</doc-id>
            <unmanaged>MF_TIMED_TEXT_ERROR_CODE_INTERNAL</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_ERROR_CODE_INTERNAL</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TimedTextFontStyle">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies the font style of the timed text.</p>
            </summary>
            <doc-id>dn782328</doc-id>
            <unmanaged>MF_TIMED_TEXT_FONT_STYLE</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_FONT_STYLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextFontStyle.Normal">
            <summary>
            <dd> <p>The font style is normal, sometimes referred to as roman.</p> </dd>
            </summary>
            <doc-id>dn782328</doc-id>
            <unmanaged>MF_TIMED_TEXT_FONT_STYLE_NORMAL</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_FONT_STYLE_NORMAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextFontStyle.Oblique">
            <summary>
            <dd> <p>The font style is oblique.</p> </dd>
            </summary>
            <doc-id>dn782328</doc-id>
            <unmanaged>MF_TIMED_TEXT_FONT_STYLE_OBLIQUE</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_FONT_STYLE_OBLIQUE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextFontStyle.Italic">
            <summary>
            <dd> <p>The font style is italic.</p> </dd>
            </summary>
            <doc-id>dn782328</doc-id>
            <unmanaged>MF_TIMED_TEXT_FONT_STYLE_ITALIC</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_FONT_STYLE_ITALIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TimedTextScrollMode">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies how text appears when the parent element is scrolled.</p>
            </summary>
            <doc-id>dn782329</doc-id>
            <unmanaged>MF_TIMED_TEXT_SCROLL_MODE</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_SCROLL_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextScrollMode.PopOn">
            <summary>
            <dd> <p>Text pops on when the parent element is scrolled.</p> </dd>
            </summary>
            <doc-id>dn782329</doc-id>
            <unmanaged>MF_TIMED_TEXT_SCROLL_MODE_POP_ON</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_SCROLL_MODE_POP_ON</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextScrollMode.RollUp">
            <summary>
            <dd> <p>Text rolls up when the parent element is scrolled.</p> </dd>
            </summary>
            <doc-id>dn782329</doc-id>
            <unmanaged>MF_TIMED_TEXT_SCROLL_MODE_ROLL_UP</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_SCROLL_MODE_ROLL_UP</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TimedTextTrackKind">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies the kind of timed text track.</p>
            </summary>
            <doc-id>dn782330</doc-id>
            <unmanaged>MF_TIMED_TEXT_TRACK_KIND</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_TRACK_KIND</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextTrackKind.Unknown">
            <summary>
            <dd> <p>The kind of timed text track is unknown.</p> </dd>
            </summary>
            <doc-id>dn782330</doc-id>
            <unmanaged>MF_TIMED_TEXT_TRACK_KIND_UNKNOWN</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_TRACK_KIND_UNKNOWN</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextTrackKind.SubTitles">
            <summary>
            <dd> <p>The kind of timed text track is subtitles.</p> </dd>
            </summary>
            <doc-id>dn782330</doc-id>
            <unmanaged>MF_TIMED_TEXT_TRACK_KIND_SUBTITLES</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_TRACK_KIND_SUBTITLES</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextTrackKind.Captions">
            <summary>
            <dd> <p>The kind of timed text track is closed captions.</p> </dd>
            </summary>
            <doc-id>dn782330</doc-id>
            <unmanaged>MF_TIMED_TEXT_TRACK_KIND_CAPTIONS</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_TRACK_KIND_CAPTIONS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextTrackKind.Metadata">
            <summary>
            <dd> <p>The kind of timed text track is metadata.</p> </dd>
            </summary>
            <doc-id>dn782330</doc-id>
            <unmanaged>MF_TIMED_TEXT_TRACK_KIND_METADATA</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_TRACK_KIND_METADATA</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TimedTextTrackReadyState">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_TIMED_TEXT_TRACK_READY_STATE</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_TRACK_READY_STATE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextTrackReadyState.None">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_TIMED_TEXT_TRACK_READY_STATE_NONE</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_TRACK_READY_STATE_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextTrackReadyState.Loading">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_TIMED_TEXT_TRACK_READY_STATE_LOADING</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_TRACK_READY_STATE_LOADING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextTrackReadyState.Loaded">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_TIMED_TEXT_TRACK_READY_STATE_LOADED</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_TRACK_READY_STATE_LOADED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextTrackReadyState.Error">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_TIMED_TEXT_TRACK_READY_STATE_ERROR</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_TRACK_READY_STATE_ERROR</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TimedTextUnitType">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies the units in which the timed text is measured.</p>
            </summary>
            <doc-id>dn782331</doc-id>
            <unmanaged>MF_TIMED_TEXT_UNIT_TYPE</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_UNIT_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextUnitType.Pixels">
            <summary>
            <dd> <p>The timed text is measured in pixels.</p> </dd>
            </summary>
            <doc-id>dn782331</doc-id>
            <unmanaged>MF_TIMED_TEXT_UNIT_TYPE_PIXELS</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_UNIT_TYPE_PIXELS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextUnitType.Percentage">
            <summary>
            <dd> <p>The timed text is measured as a percentage.</p> </dd>
            </summary>
            <doc-id>dn782331</doc-id>
            <unmanaged>MF_TIMED_TEXT_UNIT_TYPE_PERCENTAGE</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_UNIT_TYPE_PERCENTAGE</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TimedTextWritingMode">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Specifies the sequence in which text is written on its parent element.</p>
            </summary>
            <doc-id>dn782332</doc-id>
            <unmanaged>MF_TIMED_TEXT_WRITING_MODE</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_WRITING_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextWritingMode.Lrtb">
            <summary>
            <dd> <p>Text is written from left to right and top to bottom.</p> </dd>
            </summary>
            <doc-id>dn782332</doc-id>
            <unmanaged>MF_TIMED_TEXT_WRITING_MODE_LRTB</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_WRITING_MODE_LRTB</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextWritingMode.Rltb">
            <summary>
            <dd> <p>Text is written from right to left and top to bottom.</p> </dd>
            </summary>
            <doc-id>dn782332</doc-id>
            <unmanaged>MF_TIMED_TEXT_WRITING_MODE_RLTB</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_WRITING_MODE_RLTB</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextWritingMode.Tbrl">
            <summary>
            <dd> <p>Text is written from top to bottom and right to left.</p> </dd>
            </summary>
            <doc-id>dn782332</doc-id>
            <unmanaged>MF_TIMED_TEXT_WRITING_MODE_TBRL</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_WRITING_MODE_TBRL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextWritingMode.Tblr">
            <summary>
            <dd> <p>Text is written from top to bottom and left to right.</p> </dd>
            </summary>
            <doc-id>dn782332</doc-id>
            <unmanaged>MF_TIMED_TEXT_WRITING_MODE_TBLR</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_WRITING_MODE_TBLR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextWritingMode.Lr">
            <summary>
            <dd> <p>Text is written from left to right.</p> </dd>
            </summary>
            <doc-id>dn782332</doc-id>
            <unmanaged>MF_TIMED_TEXT_WRITING_MODE_LR</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_WRITING_MODE_LR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextWritingMode.Rl">
            <summary>
            <dd> <p>Text is written from right to left.</p> </dd>
            </summary>
            <doc-id>dn782332</doc-id>
            <unmanaged>MF_TIMED_TEXT_WRITING_MODE_RL</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_WRITING_MODE_RL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimedTextWritingMode.Tb">
            <summary>
            <dd> <p>Text is written from top to bottom.</p> </dd>
            </summary>
            <doc-id>dn782332</doc-id>
            <unmanaged>MF_TIMED_TEXT_WRITING_MODE_TB</unmanaged>
            <unmanaged-short>MF_TIMED_TEXT_WRITING_MODE_TB</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimerFlags.Relative">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms703005</doc-id>
            <unmanaged>MFTIMER_RELATIVE</unmanaged>
            <unmanaged-short>MFTIMER_RELATIVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TimerFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TMessageType">
            <summary>
            <p>Defines messages for a Media Foundation transform (MFT). To send a message to an MFT, call <strong>IMFTransform::ProcessMessage</strong>.</p>
            </summary>
            <remarks>
            <p>Some messages require specific actions from the MFT. These events have "MESSAGE" in the message name. Other messages are informational; they notify the MFT of some action by the client, and do not require any particular response from the MFT. These messages have "NOTIFY" in the messages name. Except where noted, an MFT should not rely on the client sending notification messages.</p>
            </remarks>
            <doc-id>ms697223</doc-id>
            <unmanaged>MFT_MESSAGE_TYPE</unmanaged>
            <unmanaged-short>MFT_MESSAGE_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TMessageType.CommandFlush">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697223</doc-id>
            <unmanaged>MFT_MESSAGE_COMMAND_FLUSH</unmanaged>
            <unmanaged-short>MFT_MESSAGE_COMMAND_FLUSH</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TMessageType.CommandDrain">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697223</doc-id>
            <unmanaged>MFT_MESSAGE_COMMAND_DRAIN</unmanaged>
            <unmanaged-short>MFT_MESSAGE_COMMAND_DRAIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TMessageType.SetD3DManager">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697223</doc-id>
            <unmanaged>MFT_MESSAGE_SET_D3D_MANAGER</unmanaged>
            <unmanaged-short>MFT_MESSAGE_SET_D3D_MANAGER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TMessageType.DropSamples">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697223</doc-id>
            <unmanaged>MFT_MESSAGE_DROP_SAMPLES</unmanaged>
            <unmanaged-short>MFT_MESSAGE_DROP_SAMPLES</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TMessageType.CommandTick">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697223</doc-id>
            <unmanaged>MFT_MESSAGE_COMMAND_TICK</unmanaged>
            <unmanaged-short>MFT_MESSAGE_COMMAND_TICK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TMessageType.NotifyBeginStreaming">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697223</doc-id>
            <unmanaged>MFT_MESSAGE_NOTIFY_BEGIN_STREAMING</unmanaged>
            <unmanaged-short>MFT_MESSAGE_NOTIFY_BEGIN_STREAMING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TMessageType.NotifyEndStreaming">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697223</doc-id>
            <unmanaged>MFT_MESSAGE_NOTIFY_END_STREAMING</unmanaged>
            <unmanaged-short>MFT_MESSAGE_NOTIFY_END_STREAMING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TMessageType.NotifyEndOfStream">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697223</doc-id>
            <unmanaged>MFT_MESSAGE_NOTIFY_END_OF_STREAM</unmanaged>
            <unmanaged-short>MFT_MESSAGE_NOTIFY_END_OF_STREAM</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TMessageType.NotifyStartOfStream">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697223</doc-id>
            <unmanaged>MFT_MESSAGE_NOTIFY_START_OF_STREAM</unmanaged>
            <unmanaged-short>MFT_MESSAGE_NOTIFY_START_OF_STREAM</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TMessageType.NotifyReleaseResources">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697223</doc-id>
            <unmanaged>MFT_MESSAGE_NOTIFY_RELEASE_RESOURCES</unmanaged>
            <unmanaged-short>MFT_MESSAGE_NOTIFY_RELEASE_RESOURCES</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TMessageType.NotifyReacquireResources">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697223</doc-id>
            <unmanaged>MFT_MESSAGE_NOTIFY_REACQUIRE_RESOURCES</unmanaged>
            <unmanaged-short>MFT_MESSAGE_NOTIFY_REACQUIRE_RESOURCES</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TMessageType.NotifyEvent">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697223</doc-id>
            <unmanaged>MFT_MESSAGE_NOTIFY_EVENT</unmanaged>
            <unmanaged-short>MFT_MESSAGE_NOTIFY_EVENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TMessageType.CommandSetOutputStreamState">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697223</doc-id>
            <unmanaged>MFT_MESSAGE_COMMAND_SET_OUTPUT_STREAM_STATE</unmanaged>
            <unmanaged-short>MFT_MESSAGE_COMMAND_SET_OUTPUT_STREAM_STATE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TMessageType.CommandFlushOutputStream">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697223</doc-id>
            <unmanaged>MFT_MESSAGE_COMMAND_FLUSH_OUTPUT_STREAM</unmanaged>
            <unmanaged-short>MFT_MESSAGE_COMMAND_FLUSH_OUTPUT_STREAM</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TMessageType.CommandMarker">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697223</doc-id>
            <unmanaged>MFT_MESSAGE_COMMAND_MARKER</unmanaged>
            <unmanaged-short>MFT_MESSAGE_COMMAND_MARKER</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TopologyDxvaMode">
            <summary>
            <p>Specifies whether the topology loader enables Microsoft DirectX Video Acceleration (DXVA) in the topology.</p>
            </summary>
            <remarks>
            <p>This enumeration is used with the <see cref = "!:DXVAMode"/> topology attribute.</p><p>If an MFT supports DXVA, the MFT must return <strong>TRUE</strong> for the <strong><see cref = "!:D3DAware"/></strong> attribute. To enable DXVA, the topology loader calls <strong>IMFTransform::ProcessMessage</strong> on the MFT, passing the MFT a reference to the <strong>IDirect3DDeviceManager9</strong> interface. The topology loader gets the <strong>IDirect3DDeviceManager9</strong> reference from the media sink for the video stream. Typically the enhanced video renderer (EVR) is the media sink.</p><p>Previous versions of Microsoft Media Foundation supported DXVA only for decoders.</p>
            </remarks>
            <doc-id>dd388653</doc-id>
            <unmanaged>MFTOPOLOGY_DXVA_MODE</unmanaged>
            <unmanaged-short>MFTOPOLOGY_DXVA_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyDxvaMode.Default">
            <summary>
            <dd> <p>The topology loader enables DXVA
            on the decoder if possible, and drops optional Media Foundation transforms (MFTs) that do not support DXVA.</p> </dd>
            </summary>
            <doc-id>dd388653</doc-id>
            <unmanaged>MFTOPOLOGY_DXVA_DEFAULT</unmanaged>
            <unmanaged-short>MFTOPOLOGY_DXVA_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyDxvaMode.None">
            <summary>
            <dd> <p>The topology loader disables all video acceleration. This setting forces software processing, even when the decoder supports DXVA.</p> </dd>
            </summary>
            <doc-id>dd388653</doc-id>
            <unmanaged>MFTOPOLOGY_DXVA_NONE</unmanaged>
            <unmanaged-short>MFTOPOLOGY_DXVA_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyDxvaMode.Full">
            <summary>
            <dd> <p>The topology loader enables DXVA on every MFT that supports it.</p> </dd>
            </summary>
            <doc-id>dd388653</doc-id>
            <unmanaged>MFTOPOLOGY_DXVA_FULL</unmanaged>
            <unmanaged-short>MFTOPOLOGY_DXVA_FULL</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TopologyHardwareMode">
            <summary>
            <p>Specifies whether the topology loader will insert hardware-based Media Foundation transforms (MFTs) into the topology.</p>
            </summary>
            <remarks>
            <p> This enumeration is used with the <see cref = "!:HardwareMode"/> topology attribute. </p>
            </remarks>
            <doc-id>dd388654</doc-id>
            <unmanaged>MFTOPOLOGY_HARDWARE_MODE</unmanaged>
            <unmanaged-short>MFTOPOLOGY_HARDWARE_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyHardwareMode.WmodeSoftwareOnly">
            <summary>
            <dd> <p>Use only software  MFTs. Do not use hardware-based MFTs. This mode is the default, for backward compatibility with existing applications.</p> </dd>
            </summary>
            <doc-id>dd388654</doc-id>
            <unmanaged>MFTOPOLOGY_HWMODE_SOFTWARE_ONLY</unmanaged>
            <unmanaged-short>MFTOPOLOGY_HWMODE_SOFTWARE_ONLY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyHardwareMode.WmodeUseHardware">
            <summary>
            <dd> <p>Use hardware-based MFTs when possible, and software MFTs otherwise. This mode is the recommended one.</p> </dd>
            </summary>
            <doc-id>dd388654</doc-id>
            <unmanaged>MFTOPOLOGY_HWMODE_USE_HARDWARE</unmanaged>
            <unmanaged-short>MFTOPOLOGY_HWMODE_USE_HARDWARE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyHardwareMode.WmodeUseOnlyHardware">
            <summary>
            <dd> <p>If hardware-based MFTs are available, the topoloader will insert them.  If not, the connection will fail.</p> <p>Supported in Windows?8.1 and later.</p> </dd>
            </summary>
            <doc-id>dd388654</doc-id>
            <unmanaged>MFTOPOLOGY_HWMODE_USE_ONLY_HARDWARE</unmanaged>
            <unmanaged-short>MFTOPOLOGY_HWMODE_USE_ONLY_HARDWARE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyResolutionStatusFlags.MfTopologyResolutionSucceeded">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms704637</doc-id>
            <unmanaged>MF_TOPOLOGY_RESOLUTION_SUCCEEDED</unmanaged>
            <unmanaged-short>MF_TOPOLOGY_RESOLUTION_SUCCEEDED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyResolutionStatusFlags.MfOptionalNodeRejectedMediaType">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms704637</doc-id>
            <unmanaged>MF_OPTIONAL_NODE_REJECTED_MEDIA_TYPE</unmanaged>
            <unmanaged-short>MF_OPTIONAL_NODE_REJECTED_MEDIA_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyResolutionStatusFlags.MfOptionalNodeRejectedProtectedProcess">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms704637</doc-id>
            <unmanaged>MF_OPTIONAL_NODE_REJECTED_PROTECTED_PROCESS</unmanaged>
            <unmanaged-short>MF_OPTIONAL_NODE_REJECTED_PROTECTED_PROCESS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyResolutionStatusFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TopologyStatus">
            <summary>
            <p> Specifies the status of a topology during playback. </p>
            </summary>
            <remarks>
            <p> This enumeration is used with the MESessionTopologyStatus event. The MESessionTopologyStatus event always has an <strong><see cref = "T:SharpDX.MediaFoundation.TopologyStatus"/></strong> attribute whose value is a member of this enumeration. </p><p> For a single topology, the Media Session sends these status flags in numerical order, starting with <strong>MF_TOPOSTATUS_READY</strong>. However, there is no guarantee about the ordering of the events across two different topologies. For example, you might get <strong>MF_TOPOSTATUS_READY</strong> for a topology before you get <strong>MF_TOPOSTATUS_ENDED</strong> for the previous topology. </p>
            </remarks>
            <doc-id>aa370812</doc-id>
            <unmanaged>MF_TOPOSTATUS</unmanaged>
            <unmanaged-short>MF_TOPOSTATUS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyStatus.Invalid">
            <summary>
            <dd> <p> This value is not used. </p> </dd>
            </summary>
            <doc-id>aa370812</doc-id>
            <unmanaged>MF_TOPOSTATUS_INVALID</unmanaged>
            <unmanaged-short>MF_TOPOSTATUS_INVALID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyStatus.Ready">
            <summary>
            <dd> <p> The topology is ready to start. After this status flag is received, you can use the Media Session's <strong>IMFGetService::GetService</strong> method to query the topology for services, such as rate control. </p> </dd>
            </summary>
            <doc-id>aa370812</doc-id>
            <unmanaged>MF_TOPOSTATUS_READY</unmanaged>
            <unmanaged-short>MF_TOPOSTATUS_READY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyStatus.StartedSource">
            <summary>
            <dd> <p> The Media Session has started to read data from the media sources in the topology. </p> </dd>
            </summary>
            <doc-id>aa370812</doc-id>
            <unmanaged>MF_TOPOSTATUS_STARTED_SOURCE</unmanaged>
            <unmanaged-short>MF_TOPOSTATUS_STARTED_SOURCE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyStatus.DynamicChanged">
            <summary>
            <dd> <p>The Media Session modified the topology, because the format of a stream changed.</p> </dd>
            </summary>
            <doc-id>aa370812</doc-id>
            <unmanaged>MF_TOPOSTATUS_DYNAMIC_CHANGED</unmanaged>
            <unmanaged-short>MF_TOPOSTATUS_DYNAMIC_CHANGED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyStatus.SinkSwitched">
            <summary>
            <dd> <p> The media sinks have switched from the previous topology to this topology. This status value is not sent for the first topology that is played. For the first topology, the MESessionStarted event indicates that the media sinks have started receiving data. </p> </dd>
            </summary>
            <doc-id>aa370812</doc-id>
            <unmanaged>MF_TOPOSTATUS_SINK_SWITCHED</unmanaged>
            <unmanaged-short>MF_TOPOSTATUS_SINK_SWITCHED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyStatus.Ended">
            <summary>
            <dd> <p> Playback of this topology is complete. The Media Session might still use the topology internally. The Media Session does not completely release the topology until it sends the next <strong>MF_TOPOSTATUS_STARTED_SOURCE</strong> status event or the MESessionEnded event. </p> </dd>
            </summary>
            <doc-id>aa370812</doc-id>
            <unmanaged>MF_TOPOSTATUS_ENDED</unmanaged>
            <unmanaged-short>MF_TOPOSTATUS_ENDED</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TopologyType">
            <summary>
            <p> </p><p>Defines the type of a topology node.</p>
            </summary>
            <doc-id>ms698973</doc-id>
            <unmanaged>MF_TOPOLOGY_TYPE</unmanaged>
            <unmanaged-short>MF_TOPOLOGY_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyType.OutputNode">
            <summary>
            <dd> <p>Output node. Represents a media sink in the topology.</p> </dd>
            </summary>
            <doc-id>ms698973</doc-id>
            <unmanaged>MF_TOPOLOGY_OUTPUT_NODE</unmanaged>
            <unmanaged-short>MF_TOPOLOGY_OUTPUT_NODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyType.SourceStreamNode">
            <summary>
            <dd> <p>Source node. Represents a media stream in the topology.</p> </dd>
            </summary>
            <doc-id>ms698973</doc-id>
            <unmanaged>MF_TOPOLOGY_SOURCESTREAM_NODE</unmanaged>
            <unmanaged-short>MF_TOPOLOGY_SOURCESTREAM_NODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyType.TransformNode">
            <summary>
            <dd> <p>Transform node. Represents a Media Foundation Transform (MFT) in the topology.</p> </dd>
            </summary>
            <doc-id>ms698973</doc-id>
            <unmanaged>MF_TOPOLOGY_TRANSFORM_NODE</unmanaged>
            <unmanaged-short>MF_TOPOLOGY_TRANSFORM_NODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyType.TeeNode">
            <summary>
            <dd> <p>Tee node. A tee node does not hold a reference to an object. Instead, it represents a fork in the stream. A tee node has one input and multiple outputs, and samples from the upstream node are delivered to all of the downstream nodes.</p> </dd>
            </summary>
            <doc-id>ms698973</doc-id>
            <unmanaged>MF_TOPOLOGY_TEE_NODE</unmanaged>
            <unmanaged-short>MF_TOPOLOGY_TEE_NODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyType.Maximum">
            <summary>
            <dd> <p>Reserved.</p> </dd>
            </summary>
            <doc-id>ms698973</doc-id>
            <unmanaged>MF_TOPOLOGY_MAX</unmanaged>
            <unmanaged-short>MF_TOPOLOGY_MAX</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.ToponodeDrainMode">
            <summary>
            <p> </p><p>Defines at what times a transform in a topology is drained.</p>
            </summary>
            <doc-id>aa370822</doc-id>
            <unmanaged>MF_TOPONODE_DRAIN_MODE</unmanaged>
            <unmanaged-short>MF_TOPONODE_DRAIN_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ToponodeDrainMode.Default">
            <summary>
            <dd> <p>The transform is drained when the end of a stream is reached. It is not drained when markout is reached at the end of a segment.</p> </dd>
            </summary>
            <doc-id>aa370822</doc-id>
            <unmanaged>MF_TOPONODE_DRAIN_DEFAULT</unmanaged>
            <unmanaged-short>MF_TOPONODE_DRAIN_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ToponodeDrainMode.Always">
            <summary>
            <dd> <p>The transform is drained whenever a topology ends.</p> </dd>
            </summary>
            <doc-id>aa370822</doc-id>
            <unmanaged>MF_TOPONODE_DRAIN_ALWAYS</unmanaged>
            <unmanaged-short>MF_TOPONODE_DRAIN_ALWAYS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ToponodeDrainMode.Never">
            <summary>
            <dd> <p>The transform is never drained.</p> </dd>
            </summary>
            <doc-id>aa370822</doc-id>
            <unmanaged>MF_TOPONODE_DRAIN_NEVER</unmanaged>
            <unmanaged-short>MF_TOPONODE_DRAIN_NEVER</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.ToponodeFlushMode">
            <summary>
            <p> </p><p>Defines when a transform in a topology is flushed.</p>
            </summary>
            <doc-id>ms704760</doc-id>
            <unmanaged>MF_TOPONODE_FLUSH_MODE</unmanaged>
            <unmanaged-short>MF_TOPONODE_FLUSH_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ToponodeFlushMode.Always">
            <summary>
            <dd> <p>The transform is flushed whenever the stream changes, including seeks and new segments.</p> </dd>
            </summary>
            <doc-id>ms704760</doc-id>
            <unmanaged>MF_TOPONODE_FLUSH_ALWAYS</unmanaged>
            <unmanaged-short>MF_TOPONODE_FLUSH_ALWAYS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ToponodeFlushMode.Seek">
            <summary>
            <dd> <p>The transform is flushed when seeking is performed on the stream.</p> </dd>
            </summary>
            <doc-id>ms704760</doc-id>
            <unmanaged>MF_TOPONODE_FLUSH_SEEK</unmanaged>
            <unmanaged-short>MF_TOPONODE_FLUSH_SEEK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ToponodeFlushMode.Never">
            <summary>
            <dd> <p>The transform is never flushed during streaming. It is flushed only when the object is released.</p> </dd>
            </summary>
            <doc-id>ms704760</doc-id>
            <unmanaged>MF_TOPONODE_FLUSH_NEVER</unmanaged>
            <unmanaged-short>MF_TOPONODE_FLUSH_NEVER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeAdjustProfileFlags.Default">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388918</doc-id>
            <unmanaged>MF_TRANSCODE_ADJUST_PROFILE_DEFAULT</unmanaged>
            <unmanaged-short>MF_TRANSCODE_ADJUST_PROFILE_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeAdjustProfileFlags.UseSourceAttributes">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388918</doc-id>
            <unmanaged>MF_TRANSCODE_ADJUST_PROFILE_USE_SOURCE_ATTRIBUTES</unmanaged>
            <unmanaged-short>MF_TRANSCODE_ADJUST_PROFILE_USE_SOURCE_ATTRIBUTES</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeAdjustProfileFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeTopologymodeFlags.SoftwareOnly">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388926</doc-id>
            <unmanaged>MF_TRANSCODE_TOPOLOGYMODE_SOFTWARE_ONLY</unmanaged>
            <unmanaged-short>MF_TRANSCODE_TOPOLOGYMODE_SOFTWARE_ONLY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeTopologymodeFlags.HardwareAllowEd">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388926</doc-id>
            <unmanaged>MF_TRANSCODE_TOPOLOGYMODE_HARDWARE_ALLOWED</unmanaged>
            <unmanaged-short>MF_TRANSCODE_TOPOLOGYMODE_HARDWARE_ALLOWED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeTopologymodeFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransferVideoFrameFlags.Default">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_TRANSFER_VIDEO_FRAME_DEFAULT</unmanaged>
            <unmanaged-short>MF_TRANSFER_VIDEO_FRAME_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransferVideoFrameFlags.Stretch">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_TRANSFER_VIDEO_FRAME_STRETCH</unmanaged>
            <unmanaged-short>MF_TRANSFER_VIDEO_FRAME_STRETCH</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransferVideoFrameFlags.IgnorePar">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_TRANSFER_VIDEO_FRAME_IGNORE_PAR</unmanaged>
            <unmanaged-short>MF_TRANSFER_VIDEO_FRAME_IGNORE_PAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransferVideoFrameFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformEnumFlag.Syncmft">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd389302</doc-id>
            <unmanaged>MFT_ENUM_FLAG_SYNCMFT</unmanaged>
            <unmanaged-short>MFT_ENUM_FLAG_SYNCMFT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformEnumFlag.Asyncmft">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd389302</doc-id>
            <unmanaged>MFT_ENUM_FLAG_ASYNCMFT</unmanaged>
            <unmanaged-short>MFT_ENUM_FLAG_ASYNCMFT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformEnumFlag.Hardware">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd389302</doc-id>
            <unmanaged>MFT_ENUM_FLAG_HARDWARE</unmanaged>
            <unmanaged-short>MFT_ENUM_FLAG_HARDWARE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformEnumFlag.Fieldofuse">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd389302</doc-id>
            <unmanaged>MFT_ENUM_FLAG_FIELDOFUSE</unmanaged>
            <unmanaged-short>MFT_ENUM_FLAG_FIELDOFUSE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformEnumFlag.Localmft">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd389302</doc-id>
            <unmanaged>MFT_ENUM_FLAG_LOCALMFT</unmanaged>
            <unmanaged-short>MFT_ENUM_FLAG_LOCALMFT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformEnumFlag.TranscodeOnly">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd389302</doc-id>
            <unmanaged>MFT_ENUM_FLAG_TRANSCODE_ONLY</unmanaged>
            <unmanaged-short>MFT_ENUM_FLAG_TRANSCODE_ONLY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformEnumFlag.SortAndFilter">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd389302</doc-id>
            <unmanaged>MFT_ENUM_FLAG_SORTANDFILTER</unmanaged>
            <unmanaged-short>MFT_ENUM_FLAG_SORTANDFILTER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformEnumFlag.SortAndFilterApprovedOnly">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd389302</doc-id>
            <unmanaged>MFT_ENUM_FLAG_SORTANDFILTER_APPROVED_ONLY</unmanaged>
            <unmanaged-short>MFT_ENUM_FLAG_SORTANDFILTER_APPROVED_ONLY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformEnumFlag.SortAndFilterWebOnly">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd389302</doc-id>
            <unmanaged>MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY</unmanaged>
            <unmanaged-short>MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformEnumFlag.SortAndFilterWebOnlyEdgemode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd389302</doc-id>
            <unmanaged>MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY_EDGEMODE</unmanaged>
            <unmanaged-short>MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY_EDGEMODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformEnumFlag.UntrustedStoremft">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd389302</doc-id>
            <unmanaged>MFT_ENUM_FLAG_UNTRUSTED_STOREMFT</unmanaged>
            <unmanaged-short>MFT_ENUM_FLAG_UNTRUSTED_STOREMFT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformEnumFlag.All">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd389302</doc-id>
            <unmanaged>MFT_ENUM_FLAG_ALL</unmanaged>
            <unmanaged-short>MFT_ENUM_FLAG_ALL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformEnumFlag.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformProcessOutputFlags.MftProcessOutputDiscardWhenNoBuffer">
            <summary>
            <dd> <p>Do not produce output for streams in which the <strong>pSample</strong> member of the <strong><see cref = "T:SharpDX.MediaFoundation.TOutputDataBuffer"/></strong> structure is <strong><c>null</c></strong>. This flag is not valid unless the MFT has marked the output stream with the MFT_OUTPUT_STREAM_DISCARDABLE or MFT_OUTPUT_STREAM_LAZY_READ flag. For more information, see <strong>IMFTransform::GetOutputStreamInfo</strong>.</p> </dd>
            </summary>
            <doc-id>ms700163</doc-id>
            <unmanaged>MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER</unmanaged>
            <unmanaged-short>MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformProcessOutputFlags.MftProcessOutputRegenerateLastOutput">
            <summary>
            <dd> <p>Regenerates the last output sample.</p> <p><strong>Note</strong> Requires Windows?8.</p> </dd>
            </summary>
            <doc-id>ms700163</doc-id>
            <unmanaged>MFT_PROCESS_OUTPUT_REGENERATE_LAST_OUTPUT</unmanaged>
            <unmanaged-short>MFT_PROCESS_OUTPUT_REGENERATE_LAST_OUTPUT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformProcessOutputFlags.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TransformProcessOutputStatus">
            <summary>
            <p> </p><p>Indicates the status of a call to <strong>IMFTransform::ProcessOutput</strong>.</p>
            </summary>
            <remarks>
            <p>If the MFT sets this flag, the <strong>ProcessOutput</strong> method returns <see cref = "!:TransformStreamChange"/> and no output data is produced. The client should respond as follows:</p><ol> <li> <p>Call <strong>IMFTransform::GetStreamCount</strong> to get the new number of streams.</p> </li> <li> <p>Call <strong>IMFTransform::GetStreamIDs</strong> to get the new stream identifiers.</p> </li> <li> <p>Call <strong>IMFTransform::GetOutputAvailableType</strong> and <strong>IMFTransform::SetOutputType</strong> to set the media types on the new streams.</p> </li> </ol><p>Until these steps are completed, all further calls to <strong>ProcessOutput</strong> return <see cref = "!:TransformStreamChange"/>.</p>
            </remarks>
            <doc-id>ms699875</doc-id>
            <unmanaged>_MFT_PROCESS_OUTPUT_STATUS</unmanaged>
            <unmanaged-short>_MFT_PROCESS_OUTPUT_STATUS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformProcessOutputStatus.MftProcessOutputStatusNewStreams">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms699875</doc-id>
            <unmanaged>MFT_PROCESS_OUTPUT_STATUS_NEW_STREAMS</unmanaged>
            <unmanaged-short>MFT_PROCESS_OUTPUT_STATUS_NEW_STREAMS</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.UrlTrustStatus">
            <summary>
            <p> </p><p>Indicates whether the URL is from a trusted source.</p>
            </summary>
            <doc-id>ms705652</doc-id>
            <unmanaged>MF_URL_TRUST_STATUS</unmanaged>
            <unmanaged-short>MF_URL_TRUST_STATUS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.UrlTrustStatus.MfLicenseUrlUntrusted">
            <summary>
            <dd> <p>The validity of the URL cannot be guaranteed because it is not signed. The application should warn the user.</p> </dd>
            </summary>
            <doc-id>ms705652</doc-id>
            <unmanaged>MF_LICENSE_URL_UNTRUSTED</unmanaged>
            <unmanaged-short>MF_LICENSE_URL_UNTRUSTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.UrlTrustStatus.MfLicenseUrlTrusted">
            <summary>
            <dd> <p>The URL is the original one provided with the content.</p> </dd>
            </summary>
            <doc-id>ms705652</doc-id>
            <unmanaged>MF_LICENSE_URL_TRUSTED</unmanaged>
            <unmanaged-short>MF_LICENSE_URL_TRUSTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.UrlTrustStatus.MfLicenseUrlTampered">
            <summary>
            <dd> <p>The URL was originally signed and has been tampered with. The file should be considered corrupted, and the application should not navigate to the URL without issuing a strong warning the user.</p> </dd>
            </summary>
            <doc-id>ms705652</doc-id>
            <unmanaged>MF_LICENSE_URL_TAMPERED</unmanaged>
            <unmanaged-short>MF_LICENSE_URL_TAMPERED</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.Video3DFormat">
            <summary>
            <p>Specifies how 3D video frames are stored in memory.</p>
            </summary>
            <remarks>
            <p>This enumeration is used with the <see cref = "!:Video3dFormat"/> attribute.</p>
            </remarks>
            <doc-id>hh162802</doc-id>
            <unmanaged>MFVideo3DFormat</unmanaged>
            <unmanaged-short>MFVideo3DFormat</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Video3DFormat.SampleFormatBaseView">
            <summary>
            <dd> <p>The base view is stored in a single buffer. The other view is discarded.</p> </dd>
            </summary>
            <doc-id>hh162802</doc-id>
            <unmanaged>MFVideo3DSampleFormat_BaseView</unmanaged>
            <unmanaged-short>MFVideo3DSampleFormat_BaseView</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Video3DFormat.SampleFormatMultiView">
            <summary>
            <dd> <p>Each media sample contains multiple buffers, one for each view.</p> </dd>
            </summary>
            <doc-id>hh162802</doc-id>
            <unmanaged>MFVideo3DSampleFormat_MultiView</unmanaged>
            <unmanaged-short>MFVideo3DSampleFormat_MultiView</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Video3DFormat.SampleFormatPackedLeftRight">
            <summary>
            <dd> <p>Each media sample contains one buffer, with both views packed side-by-side into a single frame. </p> </dd>
            </summary>
            <doc-id>hh162802</doc-id>
            <unmanaged>MFVideo3DSampleFormat_Packed_LeftRight</unmanaged>
            <unmanaged-short>MFVideo3DSampleFormat_Packed_LeftRight</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Video3DFormat.SampleFormatPackedTopBottom">
            <summary>
            <dd> <p>Each media sample contains one buffer, with both views packed top-and-bottom into a single frame. </p> </dd>
            </summary>
            <doc-id>hh162802</doc-id>
            <unmanaged>MFVideo3DSampleFormat_Packed_TopBottom</unmanaged>
            <unmanaged-short>MFVideo3DSampleFormat_Packed_TopBottom</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.Video3DOutputType">
            <summary>
            <p>Specifies how to  output a 3D stereoscopic video stream.</p>
            </summary>
            <remarks>
            <p>This enumeration is used with the <see cref = "!:Enable3dvideoOutput"/> attribute.</p>
            </remarks>
            <doc-id>hh162743</doc-id>
            <unmanaged>MF3DVideoOutputType</unmanaged>
            <unmanaged-short>MF3DVideoOutputType</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Video3DOutputType.BaseView">
            <summary>
            <dd> <p>Output the base view only. Discard the other view.</p> </dd>
            </summary>
            <doc-id>hh162743</doc-id>
            <unmanaged>MF3DVideoOutputType_BaseView</unmanaged>
            <unmanaged-short>MF3DVideoOutputType_BaseView</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Video3DOutputType.Stereo">
            <summary>
            <dd> <p>Output a stereo view (two buffers).</p> </dd>
            </summary>
            <doc-id>hh162743</doc-id>
            <unmanaged>MF3DVideoOutputType_Stereo</unmanaged>
            <unmanaged-short>MF3DVideoOutputType_Stereo</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.Video3DSampleFormat">
            <summary>
            <p>Specifies how a 3D video frame is stored in a media sample.</p>
            </summary>
            <remarks>
            <p>This enumeration is used with the <see cref = "T:SharpDX.MediaFoundation.Video3DSampleFormat"/> attribute.</p><p>The exact layout of the views in memory is specified by the following media type attributes:</p><ul> <li> <see cref = "!:Video3dFormat"/> </li> <li> <see cref = "!:Video3dFirstIsLeft"/> </li> <li> <see cref = "!:Video3dLeftIsBase"/> </li> <li> <see cref = "!:Video3dNumViews"/> </li> </ul>
            </remarks>
            <doc-id>hh162803</doc-id>
            <unmanaged>MFVideo3DSampleFormat</unmanaged>
            <unmanaged-short>MFVideo3DSampleFormat</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Video3DSampleFormat.MFSampleExtension3DVideoMultiView">
            <summary>
            <dd> <p>Each view is stored in a separate buffer. The sample contains one buffer per view.</p> </dd>
            </summary>
            <doc-id>hh162803</doc-id>
            <unmanaged>MFSampleExtension_3DVideo_MultiView</unmanaged>
            <unmanaged-short>MFSampleExtension_3DVideo_MultiView</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Video3DSampleFormat.MFSampleExtension3DVideoPacked">
            <summary>
            <dd> <p>All of the views are stored in the same buffer. The sample contains a single buffer. </p> </dd>
            </summary>
            <doc-id>hh162803</doc-id>
            <unmanaged>MFSampleExtension_3DVideo_Packed</unmanaged>
            <unmanaged-short>MFSampleExtension_3DVideo_Packed</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoAspectRatioMode">
            <summary>
            <p> </p><p>Specifies the aspect-ratio mode.</p>
            </summary>
            <doc-id>ms703040</doc-id>
            <unmanaged>MFVideoAspectRatioMode</unmanaged>
            <unmanaged-short>MFVideoAspectRatioMode</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoAspectRatioMode.RModeNone">
            <summary>
            <dd> <p>Do not maintain the aspect ratio of the video. Stretch the video to fit the output rectangle.</p> </dd>
            </summary>
            <doc-id>ms703040</doc-id>
            <unmanaged>MFVideoARMode_None</unmanaged>
            <unmanaged-short>MFVideoARMode_None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoAspectRatioMode.RModePreservePicture">
            <summary>
            <dd> <p>Preserve the aspect ratio of the video by letterboxing or within the output rectangle.</p> </dd>
            </summary>
            <doc-id>ms703040</doc-id>
            <unmanaged>MFVideoARMode_PreservePicture</unmanaged>
            <unmanaged-short>MFVideoARMode_PreservePicture</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoAspectRatioMode.RModePreservePixel">
            <summary>
            <dd> <strong>Note</strong>??Currently the EVR ignores this flag. ? <p>Correct the aspect ratio if the physical size of the display device does not match the display resolution. For example, if the native resolution of the monitor is 1600 by 1200 (4:3) but the display resolution is 1280 by 1024 (5:4), the monitor will display non-square pixels.</p> <p>If this flag is set, you must also set the <strong>MFVideoARMode_PreservePicture</strong> flag.</p> </dd>
            </summary>
            <doc-id>ms703040</doc-id>
            <unmanaged>MFVideoARMode_PreservePixel</unmanaged>
            <unmanaged-short>MFVideoARMode_PreservePixel</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoAspectRatioMode.RModeNonLinearStretch">
            <summary>
            <dd> <p>Apply a non-linear horizontal stretch if the aspect ratio of the destination rectangle does not match the aspect ratio of the source rectangle.</p> <p>The non-linear stretch algorithm preserves the aspect ratio in the middle of the picture and stretches (or shrinks) the image progressively more toward the left and right. This mode is useful when viewing 4:3 content full-screen on a 16:9 display, instead of pillar-boxing. Non-linear vertical stretch is not supported, because the visual results are generally poor.</p> <p>This mode may cause performance degradation.</p> <p>If this flag is set, you must also set the <strong>MFVideoARMode_PreservePixel</strong> and <strong>MFVideoARMode_PreservePicture</strong> flags.</p> </dd>
            </summary>
            <doc-id>ms703040</doc-id>
            <unmanaged>MFVideoARMode_NonLinearStretch</unmanaged>
            <unmanaged-short>MFVideoARMode_NonLinearStretch</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoChromaSubsampling">
            <summary>
            <p> </p><p>Contains flags that define the chroma encoding scheme for Y'Cb'Cr' data.</p>
            </summary>
            <remarks>
            <p>These flags are used with the <strong><see cref = "!:VideoChromaSiting"/></strong> attribute.</p><p>For more information about these values, see the remarks for the <strong>DXVA2_VideoChromaSubSampling</strong> enumeration, which is the DirectX Video Acceleration (DXVA) equivalent of this enumeration.</p>
            </remarks>
            <doc-id>ms698989</doc-id>
            <unmanaged>MFVideoChromaSubsampling</unmanaged>
            <unmanaged-short>MFVideoChromaSubsampling</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoChromaSubsampling.Unknown">
            <summary>
            <dd> <p>Unknown encoding scheme.</p> </dd>
            </summary>
            <doc-id>ms698989</doc-id>
            <unmanaged>MFVideoChromaSubsampling_Unknown</unmanaged>
            <unmanaged-short>MFVideoChromaSubsampling_Unknown</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoChromaSubsampling.ProgressiveChroma">
            <summary>
            <dd> <p>Chroma should be reconstructed as if the underlying video was progressive content, rather than skipping fields or applying chroma filtering to minimize artifacts from reconstructing 4:2:0 interlaced chroma.</p> </dd>
            </summary>
            <doc-id>ms698989</doc-id>
            <unmanaged>MFVideoChromaSubsampling_ProgressiveChroma</unmanaged>
            <unmanaged-short>MFVideoChromaSubsampling_ProgressiveChroma</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoChromaSubsampling.HorizontallyCosited">
            <summary>
            <dd> <p>Chroma samples are aligned horizontally with the luma samples, or with multiples of the luma samples. If this flag is not set, chroma samples are located 1/2 pixel to the right of the corresponding luma sample.</p> </dd>
            </summary>
            <doc-id>ms698989</doc-id>
            <unmanaged>MFVideoChromaSubsampling_Horizontally_Cosited</unmanaged>
            <unmanaged-short>MFVideoChromaSubsampling_Horizontally_Cosited</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoChromaSubsampling.VerticallyCosited">
            <summary>
            <dd> <p>Chroma samples are aligned vertically with the luma samples, or with multiples of the luma samples. If this flag is not set, chroma samples are located 1/2 pixel down from the corresponding luma sample.</p> </dd>
            </summary>
            <doc-id>ms698989</doc-id>
            <unmanaged>MFVideoChromaSubsampling_Vertically_Cosited</unmanaged>
            <unmanaged-short>MFVideoChromaSubsampling_Vertically_Cosited</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoChromaSubsampling.VerticallyAlignedChromaPlanes">
            <summary>
            <dd> <p>The U and V planes are aligned vertically. If this flag is not set, the chroma planes are assumed to be out of phase by 1/2 chroma sample, alternating between a line of U followed by a line of V.</p> </dd>
            </summary>
            <doc-id>ms698989</doc-id>
            <unmanaged>MFVideoChromaSubsampling_Vertically_AlignedChromaPlanes</unmanaged>
            <unmanaged-short>MFVideoChromaSubsampling_Vertically_AlignedChromaPlanes</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoChromaSubsampling.Mpeg2">
            <summary>
            <dd> <p>Specifies the chroma encoding scheme for MPEG-2 video. Chroma samples are aligned horizontally with the luma samples, but are not aligned vertically. The U and V planes are aligned vertically.</p> </dd>
            </summary>
            <doc-id>ms698989</doc-id>
            <unmanaged>MFVideoChromaSubsampling_MPEG2</unmanaged>
            <unmanaged-short>MFVideoChromaSubsampling_MPEG2</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoChromaSubsampling.Mpeg1">
            <summary>
            <dd> <p>Specifies the chroma encoding scheme for MPEG-1 video.</p> </dd>
            </summary>
            <doc-id>ms698989</doc-id>
            <unmanaged>MFVideoChromaSubsampling_MPEG1</unmanaged>
            <unmanaged-short>MFVideoChromaSubsampling_MPEG1</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoChromaSubsampling.DvPal">
            <summary>
            <dd> <p>Specifies the chroma encoding scheme for PAL DV video.</p> </dd>
            </summary>
            <doc-id>ms698989</doc-id>
            <unmanaged>MFVideoChromaSubsampling_DV_PAL</unmanaged>
            <unmanaged-short>MFVideoChromaSubsampling_DV_PAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoChromaSubsampling.Cosited">
            <summary>
            <dd> <p>Chroma samples are aligned vertically and horizontally with the luma samples. YUV formats such as 4:4:4, 4:2:2, and 4:1:1 are always cosited in both directions and should use this flag.</p> </dd>
            </summary>
            <doc-id>ms698989</doc-id>
            <unmanaged>MFVideoChromaSubsampling_Cosited</unmanaged>
            <unmanaged-short>MFVideoChromaSubsampling_Cosited</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoChromaSubsampling.Last">
            <summary>
            <dd> <p>Reserved.</p> </dd>
            </summary>
            <doc-id>ms698989</doc-id>
            <unmanaged>MFVideoChromaSubsampling_Last</unmanaged>
            <unmanaged-short>MFVideoChromaSubsampling_Last</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoChromaSubsampling.ForceDWORD">
            <summary>
            <dd> <p>Reserved. This member forces the enumeration type to compile as a <strong><see cref = "T:System.Int32"/></strong> value.</p> </dd>
            </summary>
            <doc-id>ms698989</doc-id>
            <unmanaged>MFVideoChromaSubsampling_ForceDWORD</unmanaged>
            <unmanaged-short>MFVideoChromaSubsampling_ForceDWORD</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoDRMFlags">
            <summary>
            <p>Specifies the type of copy protection required for a video stream. </p>
            </summary>
            <remarks>
            <p>Use these flags with the <strong><see cref = "!:DrmFlags"/></strong> attribute.</p>
            </remarks>
            <doc-id>ms698900</doc-id>
            <unmanaged>MFVideoDRMFlags</unmanaged>
            <unmanaged-short>MFVideoDRMFlags</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoDRMFlags.None">
            <summary>
            <dd> <p>No copy protection is required. </p> </dd>
            </summary>
            <doc-id>ms698900</doc-id>
            <unmanaged>MFVideoDRMFlag_None</unmanaged>
            <unmanaged-short>MFVideoDRMFlag_None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoDRMFlags.AnalogProtected">
            <summary>
            <dd> <p>Analog copy protection should be applied. </p> </dd>
            </summary>
            <doc-id>ms698900</doc-id>
            <unmanaged>MFVideoDRMFlag_AnalogProtected</unmanaged>
            <unmanaged-short>MFVideoDRMFlag_AnalogProtected</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoDRMFlags.DigitallyProtected">
            <summary>
            <dd> <p>Digital copy protection should be applied. </p> </dd>
            </summary>
            <doc-id>ms698900</doc-id>
            <unmanaged>MFVideoDRMFlag_DigitallyProtected</unmanaged>
            <unmanaged-short>MFVideoDRMFlag_DigitallyProtected</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoFlags">
            <summary>
            <p>Contains flags that describe a video stream.</p><p>These flags are used in the <strong><see cref = "T:SharpDX.MediaFoundation.VideoInfo"/></strong> structure, which is part of the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure.</p>
            </summary>
            <remarks>
            <p>Developers are encouraged to use media type attributes instead of using the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure. The following table lists the attributes that correspond to the flags defined in this enumeration.</p><table> <tr><th>Flags</th><th>Media Type Attribute</th></tr> <tr><td> <p>MFVideoFlag_PAD_TO_None</p> <p>MFVideoFlag_PAD_TO_4x3</p> <p>MFVideoFlag_PAD_TO_16x9</p> </td><td> <strong><see cref = "!:PadControlFlags"/></strong> </td></tr> <tr><td> <p>MFVideoFlag_SrcContentHint16x9</p> <p>MFVideoFlag_SrcContentHint16x9</p> <p>MFVideoFlag_SrcContentHint235_1</p> </td><td> <strong><see cref = "!:SourceContentHint"/></strong> </td></tr> <tr><td> <p>MFVideoFlag_AnalogProtected</p> <p>MFVideoFlag_DigitallyProtected</p> </td><td> <strong><see cref = "!:DrmFlags"/></strong> </td></tr> <tr><td>MFVideoFlag_PanScanEnabled</td><td> <strong><see cref = "F:SharpDX.MediaFoundation.VideoFlags.PanScanEnabled"/></strong> </td></tr> <tr><td>MFVideoFlag_BottomUpLinearRep</td><td>Use the <strong><see cref = "!:DefaultStride"/></strong> attribute to specify a negative stride.</td></tr> </table><p>?</p><p>The following flags were defined to describe per-sample interlacing information, but are obsolete:</p><ul> <li> MFVideoFlag_ProgressiveContent </li> <li> MFVideoFlag_FieldRepeatCountMask </li> <li> MFVideoFlag_FieldRepeatCountShift </li> <li> MFVideoFlag_ProgressiveSeqReset </li> <li> MFVideoFlag_LowerFieldFirst </li> </ul><p>Instead, components should use sample attributes to describe per-sample interlacing information, as described in the topic Video Interlacing.</p>
            </remarks>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlags</unmanaged>
            <unmanaged-short>MFVideoFlags</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFlags.PadToNone">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlag_PAD_TO_None</unmanaged>
            <unmanaged-short>MFVideoFlag_PAD_TO_None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFlags.PadTo4x3">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlag_PAD_TO_4x3</unmanaged>
            <unmanaged-short>MFVideoFlag_PAD_TO_4x3</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFlags.PadTo16x9">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlag_PAD_TO_16x9</unmanaged>
            <unmanaged-short>MFVideoFlag_PAD_TO_16x9</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFlags.SrcContentHintMask">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlag_SrcContentHintMask</unmanaged>
            <unmanaged-short>MFVideoFlag_SrcContentHintMask</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFlags.SrcContentHintNone">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlag_SrcContentHintNone</unmanaged>
            <unmanaged-short>MFVideoFlag_SrcContentHintNone</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFlags.SrcContentHint16x9">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlag_SrcContentHint16x9</unmanaged>
            <unmanaged-short>MFVideoFlag_SrcContentHint16x9</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFlags.SrcContentHint2351">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlag_SrcContentHint235_1</unmanaged>
            <unmanaged-short>MFVideoFlag_SrcContentHint235_1</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFlags.AnalogProtected">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlag_AnalogProtected</unmanaged>
            <unmanaged-short>MFVideoFlag_AnalogProtected</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFlags.DigitallyProtected">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlag_DigitallyProtected</unmanaged>
            <unmanaged-short>MFVideoFlag_DigitallyProtected</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFlags.ProgressiveContent">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlag_ProgressiveContent</unmanaged>
            <unmanaged-short>MFVideoFlag_ProgressiveContent</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFlags.FieldRepeatCountMask">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlag_FieldRepeatCountMask</unmanaged>
            <unmanaged-short>MFVideoFlag_FieldRepeatCountMask</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFlags.FieldRepeatCountShift">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlag_FieldRepeatCountShift</unmanaged>
            <unmanaged-short>MFVideoFlag_FieldRepeatCountShift</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFlags.ProgressiveSeqReset">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlag_ProgressiveSeqReset</unmanaged>
            <unmanaged-short>MFVideoFlag_ProgressiveSeqReset</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFlags.PanScanEnabled">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlag_PanScanEnabled</unmanaged>
            <unmanaged-short>MFVideoFlag_PanScanEnabled</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFlags.LowerFieldFirst">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlag_LowerFieldFirst</unmanaged>
            <unmanaged-short>MFVideoFlag_LowerFieldFirst</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFlags.BottomUpLinearRep">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlag_BottomUpLinearRep</unmanaged>
            <unmanaged-short>MFVideoFlag_BottomUpLinearRep</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFlags.SDXVASurface">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlags_DXVASurface</unmanaged>
            <unmanaged-short>MFVideoFlags_DXVASurface</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFlags.SRenderTargetSurface">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlags_RenderTargetSurface</unmanaged>
            <unmanaged-short>MFVideoFlags_RenderTargetSurface</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFlags.SForceQWORD">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473786</doc-id>
            <unmanaged>MFVideoFlags_ForceQWORD</unmanaged>
            <unmanaged-short>MFVideoFlags_ForceQWORD</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoInterlaceMode">
            <summary>
            <p>Specifies how a video stream is interlaced.</p><p>In the descriptions that follow, upper field refers to the field that contains the leading half scan line. Lower field refers to the field that contains the first full scan line.</p>
            </summary>
            <remarks>
            <p>Scan lines in the lower field are 0.5 scan line lower than those in the upper field. In NTSC television, a frame consists of a lower field followed by an upper field. In PAL television, a frame consists of an upper field followed by a lower field.</p><p>The upper field is also called the even field, the top field, or field 2. The lower field is also called the odd field, the bottom field, or field 1.</p><p>If the interlace mode is MFVideoInterlace_FieldSingleUpper or MFVideoInterlace_FieldSingleLower, each sample contains a single field, so each buffer contains only half the number of field lines given in the media type.</p>
            </remarks>
            <doc-id>ms694269</doc-id>
            <unmanaged>MFVideoInterlaceMode</unmanaged>
            <unmanaged-short>MFVideoInterlaceMode</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInterlaceMode.Unknown">
            <summary>
            <dd> <p> The type of interlacing is not known. </p> </dd>
            </summary>
            <doc-id>ms694269</doc-id>
            <unmanaged>MFVideoInterlace_Unknown</unmanaged>
            <unmanaged-short>MFVideoInterlace_Unknown</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInterlaceMode.Progressive">
            <summary>
            <dd> <p> Progressive frames. </p> </dd>
            </summary>
            <doc-id>ms694269</doc-id>
            <unmanaged>MFVideoInterlace_Progressive</unmanaged>
            <unmanaged-short>MFVideoInterlace_Progressive</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInterlaceMode.FieldInterleavedUpperFirst">
            <summary>
            <dd> <p> Interlaced frames. Each frame contains two fields. The field lines are interleaved, with the upper field appearing on the first line. </p> </dd>
            </summary>
            <doc-id>ms694269</doc-id>
            <unmanaged>MFVideoInterlace_FieldInterleavedUpperFirst</unmanaged>
            <unmanaged-short>MFVideoInterlace_FieldInterleavedUpperFirst</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInterlaceMode.FieldInterleavedLowerFirst">
            <summary>
            <dd> <p> Interlaced frames. Each frame contains two fields. The field lines are interleaved, with the lower field appearing on the first line. </p> </dd>
            </summary>
            <doc-id>ms694269</doc-id>
            <unmanaged>MFVideoInterlace_FieldInterleavedLowerFirst</unmanaged>
            <unmanaged-short>MFVideoInterlace_FieldInterleavedLowerFirst</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInterlaceMode.FieldSingleUpper">
            <summary>
            <dd> <p> Interlaced frames. Each frame contains one field, with the upper field appearing first. </p> </dd>
            </summary>
            <doc-id>ms694269</doc-id>
            <unmanaged>MFVideoInterlace_FieldSingleUpper</unmanaged>
            <unmanaged-short>MFVideoInterlace_FieldSingleUpper</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInterlaceMode.FieldSingleLower">
            <summary>
            <dd> <p> Interlaced frames. Each frame contains one field, with the lower field appearing first. </p> </dd>
            </summary>
            <doc-id>ms694269</doc-id>
            <unmanaged>MFVideoInterlace_FieldSingleLower</unmanaged>
            <unmanaged-short>MFVideoInterlace_FieldSingleLower</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInterlaceMode.MixedInterlaceOrProgressive">
            <summary>
            <dd> <p> The stream contains a mix of interlaced and progressive modes. </p> </dd>
            </summary>
            <doc-id>ms694269</doc-id>
            <unmanaged>MFVideoInterlace_MixedInterlaceOrProgressive</unmanaged>
            <unmanaged-short>MFVideoInterlace_MixedInterlaceOrProgressive</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInterlaceMode.Last">
            <summary>
            <dd> <p> Reserved. </p> </dd>
            </summary>
            <doc-id>ms694269</doc-id>
            <unmanaged>MFVideoInterlace_Last</unmanaged>
            <unmanaged-short>MFVideoInterlace_Last</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInterlaceMode.ForceDWORD">
            <summary>
            <dd> <p> Reserved. This member forces the enumeration type to compile as a <strong><see cref = "T:System.Int32"/></strong> value. </p> </dd>
            </summary>
            <doc-id>ms694269</doc-id>
            <unmanaged>MFVideoInterlace_ForceDWORD</unmanaged>
            <unmanaged-short>MFVideoInterlace_ForceDWORD</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoLighting">
            <summary>
            <p> </p><p>Describes the optimal lighting for viewing a particular set of video content.</p>
            </summary>
            <remarks>
            <p>This enumeration is used with the <strong><see cref = "T:SharpDX.MediaFoundation.VideoLighting"/></strong> attribute.</p>
            </remarks>
            <doc-id>ms696202</doc-id>
            <unmanaged>MFVideoLighting</unmanaged>
            <unmanaged-short>MFVideoLighting</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoLighting.Unknown">
            <summary>
            <dd> <p>The optimal lighting is unknown.</p> </dd>
            </summary>
            <doc-id>ms696202</doc-id>
            <unmanaged>MFVideoLighting_Unknown</unmanaged>
            <unmanaged-short>MFVideoLighting_Unknown</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoLighting.Bright">
            <summary>
            <dd> <p>Bright lighting; for example, outdoors.</p> </dd>
            </summary>
            <doc-id>ms696202</doc-id>
            <unmanaged>MFVideoLighting_bright</unmanaged>
            <unmanaged-short>MFVideoLighting_bright</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoLighting.Office">
            <summary>
            <dd> <p>Medium brightness; for example, normal office lighting.</p> </dd>
            </summary>
            <doc-id>ms696202</doc-id>
            <unmanaged>MFVideoLighting_office</unmanaged>
            <unmanaged-short>MFVideoLighting_office</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoLighting.Dim">
            <summary>
            <dd> <p>Dim; for example, a living room with a television and additional low lighting.</p> </dd>
            </summary>
            <doc-id>ms696202</doc-id>
            <unmanaged>MFVideoLighting_dim</unmanaged>
            <unmanaged-short>MFVideoLighting_dim</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoLighting.Dark">
            <summary>
            <dd> <p>Dark; for example, a movie theater.</p> </dd>
            </summary>
            <doc-id>ms696202</doc-id>
            <unmanaged>MFVideoLighting_dark</unmanaged>
            <unmanaged-short>MFVideoLighting_dark</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoLighting.Last">
            <summary>
            <dd> <p>Reserved.</p> </dd>
            </summary>
            <doc-id>ms696202</doc-id>
            <unmanaged>MFVideoLighting_Last</unmanaged>
            <unmanaged-short>MFVideoLighting_Last</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoLighting.ForceDWORD">
            <summary>
            <dd> <p>Reserved. This member forces the enumeration type to compile as a <strong><see cref = "T:System.Int32"/></strong> value.</p> </dd>
            </summary>
            <doc-id>ms696202</doc-id>
            <unmanaged>MFVideoLighting_ForceDWORD</unmanaged>
            <unmanaged-short>MFVideoLighting_ForceDWORD</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoMixPrefs">
            <summary>
            <p>Contains flags that are used to configure how the enhanced video renderer (EVR) performs  deinterlacing.</p>
            </summary>
            <remarks>
            <p>To set these flags, call the <strong>IMFVideoMixerControl2::SetMixingPrefs</strong> method.</p><p>These flags control some trade-offs between video quality and rendering speed. The constants named "MFVideoMixPrefs_Allow..." enable lower-quality settings, but only when the quality manager requests a drop in quality.  The constants named "MFVideoMixPrefs_Force..." force the EVR to use lower-quality settings regardless of  what the quality manager requests. (For more information about the quality manager, see <strong><see cref = "T:SharpDX.MediaFoundation.QualityAdvise"/></strong>.)</p><p>Currently two lower-quality modes are supported, as described in the following table. Either is preferable to dropping an entire frame.</p><p></p><table> <tr><th>Mode</th><th>Description</th></tr> <tr><td> <p>Half interface</p> </td><td> <p>The EVR's video mixer skips the second field (relative to temporal order) of each interlaced frame. The video mixer still deinterlaces the first field, and this operation typically interpolates data from the second field. The overall frame rate is unaffected.</p> </td></tr> <tr><td> <p>Bob deinterlacing</p> </td><td> <p>The video mixer uses bob deinterlacing, even if the driver supports  a higher-quality deinterlacing algorithm.</p> </td></tr> </table><p>?</p>
            </remarks>
            <doc-id>dd388675</doc-id>
            <unmanaged>MFVideoMixPrefs</unmanaged>
            <unmanaged-short>MFVideoMixPrefs</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoMixPrefs.ForceHalfInterlace">
            <summary>
            <dd> <p>Force the EVR  to skip the second field (in temporal order) of every interlaced frame. </p> </dd>
            </summary>
            <doc-id>dd388675</doc-id>
            <unmanaged>MFVideoMixPrefs_ForceHalfInterlace</unmanaged>
            <unmanaged-short>MFVideoMixPrefs_ForceHalfInterlace</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoMixPrefs.AllowDropToHalfInterlace">
            <summary>
            <dd> <p>If the EVR is falling behind, allow it to skip the second field (in temporal order) of every interlaced frame.</p> </dd>
            </summary>
            <doc-id>dd388675</doc-id>
            <unmanaged>MFVideoMixPrefs_AllowDropToHalfInterlace</unmanaged>
            <unmanaged-short>MFVideoMixPrefs_AllowDropToHalfInterlace</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoMixPrefs.AllowDropToBob">
            <summary>
            <dd> <p>If the EVR is falling behind, allow it to use bob deinterlacing, even if the driver supports a higher-quality deinterlacing mode.</p> </dd>
            </summary>
            <doc-id>dd388675</doc-id>
            <unmanaged>MFVideoMixPrefs_AllowDropToBob</unmanaged>
            <unmanaged-short>MFVideoMixPrefs_AllowDropToBob</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoMixPrefs.ForceBob">
            <summary>
            <dd> <p>Force the EVR to use bob deinterlacing, even if the driver supports a higher-quality mode.</p> </dd>
            </summary>
            <doc-id>dd388675</doc-id>
            <unmanaged>MFVideoMixPrefs_ForceBob</unmanaged>
            <unmanaged-short>MFVideoMixPrefs_ForceBob</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoMixPrefs.EnableRotation">
            <summary>
            <dd> <p>The bitmask of valid flag values. This constant is not itself a valid flag.
            </p> </dd>
            </summary>
            <doc-id>dd388675</doc-id>
            <unmanaged>MFVideoMixPrefs_EnableRotation</unmanaged>
            <unmanaged-short>MFVideoMixPrefs_EnableRotation</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoPadFlags">
            <summary>
            <p> </p><p>Specifies whether to pad a video image so that it fits within a specified aspect ratio.</p>
            </summary>
            <remarks>
            <p>Use these flags with the <strong><see cref = "!:PadControlFlags"/></strong> attribute.</p>
            </remarks>
            <doc-id>ms703091</doc-id>
            <unmanaged>MFVideoPadFlags</unmanaged>
            <unmanaged-short>MFVideoPadFlags</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoPadFlags.PadToNone">
            <summary>
            <dd> <p>Do not pad the image.</p> </dd>
            </summary>
            <doc-id>ms703091</doc-id>
            <unmanaged>MFVideoPadFlag_PAD_TO_None</unmanaged>
            <unmanaged-short>MFVideoPadFlag_PAD_TO_None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoPadFlags.PadTo4x3">
            <summary>
            <dd> <p>Pad the image so that it can be displayed in a 4?3 area.</p> </dd>
            </summary>
            <doc-id>ms703091</doc-id>
            <unmanaged>MFVideoPadFlag_PAD_TO_4x3</unmanaged>
            <unmanaged-short>MFVideoPadFlag_PAD_TO_4x3</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoPadFlags.PadTo16x9">
            <summary>
            <dd> <p>Pad the image so that it can be displayed in a 16?9 area.</p> </dd>
            </summary>
            <doc-id>ms703091</doc-id>
            <unmanaged>MFVideoPadFlag_PAD_TO_16x9</unmanaged>
            <unmanaged-short>MFVideoPadFlag_PAD_TO_16x9</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoPrimaries">
            <summary>
            <p>Specifies the color primaries of a video source. The color primaries define how to convert colors from RGB color space to CIE XYZ color space.</p>
            </summary>
            <remarks>
            <p>This enumeration is used with the <strong><see cref = "T:SharpDX.MediaFoundation.VideoPrimaries"/></strong> attribute.</p><p>For more information about these values, see the remarks for the <strong>DXVA2_VideoPrimaries</strong> enumeration, which is the DirectX Video Acceleration (DXVA) equivalent of this enumeration.</p>
            </remarks>
            <doc-id>ms701628</doc-id>
            <unmanaged>MFVideoPrimaries</unmanaged>
            <unmanaged-short>MFVideoPrimaries</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoPrimaries.Unknown">
            <summary>
            <dd> <p> The color primaries are unknown. </p> </dd>
            </summary>
            <doc-id>ms701628</doc-id>
            <unmanaged>MFVideoPrimaries_Unknown</unmanaged>
            <unmanaged-short>MFVideoPrimaries_Unknown</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoPrimaries.Reserved">
            <summary>
            <dd> <p> Reserved. </p> </dd>
            </summary>
            <doc-id>ms701628</doc-id>
            <unmanaged>MFVideoPrimaries_reserved</unmanaged>
            <unmanaged-short>MFVideoPrimaries_reserved</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoPrimaries.Bt709">
            <summary>
            <dd> <p> ITU-R BT.709. Also used for sRGB and scRGB. </p> </dd>
            </summary>
            <doc-id>ms701628</doc-id>
            <unmanaged>MFVideoPrimaries_BT709</unmanaged>
            <unmanaged-short>MFVideoPrimaries_BT709</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoPrimaries.Bt4702SysM">
            <summary>
            <dd> <p> ITU-R BT.470-4 System M (NTSC). </p> </dd>
            </summary>
            <doc-id>ms701628</doc-id>
            <unmanaged>MFVideoPrimaries_BT470_2_SysM</unmanaged>
            <unmanaged-short>MFVideoPrimaries_BT470_2_SysM</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoPrimaries.Bt4702SysBG">
            <summary>
            <dd> <p> ITU-R BT.470-4 System B,G (NTSC). </p> </dd>
            </summary>
            <doc-id>ms701628</doc-id>
            <unmanaged>MFVideoPrimaries_BT470_2_SysBG</unmanaged>
            <unmanaged-short>MFVideoPrimaries_BT470_2_SysBG</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoPrimaries.Smpte170m">
            <summary>
            <dd> <p> SMPTE 170M. </p> </dd>
            </summary>
            <doc-id>ms701628</doc-id>
            <unmanaged>MFVideoPrimaries_SMPTE170M</unmanaged>
            <unmanaged-short>MFVideoPrimaries_SMPTE170M</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoPrimaries.Smpte240m">
            <summary>
            <dd> <p> SMPTE 240M. </p> </dd>
            </summary>
            <doc-id>ms701628</doc-id>
            <unmanaged>MFVideoPrimaries_SMPTE240M</unmanaged>
            <unmanaged-short>MFVideoPrimaries_SMPTE240M</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoPrimaries.Ebu3213">
            <summary>
            <dd> <p> EBU 3213. </p> </dd>
            </summary>
            <doc-id>ms701628</doc-id>
            <unmanaged>MFVideoPrimaries_EBU3213</unmanaged>
            <unmanaged-short>MFVideoPrimaries_EBU3213</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoPrimaries.SmpteC">
            <summary>
            <dd> <p> SMPTE C (SMPTE RP 145). </p> </dd>
            </summary>
            <doc-id>ms701628</doc-id>
            <unmanaged>MFVideoPrimaries_SMPTE_C</unmanaged>
            <unmanaged-short>MFVideoPrimaries_SMPTE_C</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoPrimaries.Bt2020">
            <summary>
            <dd> <p> Reserved. </p> </dd>
            </summary>
            <doc-id>ms701628</doc-id>
            <unmanaged>MFVideoPrimaries_BT2020</unmanaged>
            <unmanaged-short>MFVideoPrimaries_BT2020</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoPrimaries.Xyz">
            <summary>
            <dd> <p> Reserved. This member forces the enumeration type to compile as a <strong><see cref = "T:System.Int32"/></strong> value. </p> </dd>
            </summary>
            <doc-id>ms701628</doc-id>
            <unmanaged>MFVideoPrimaries_XYZ</unmanaged>
            <unmanaged-short>MFVideoPrimaries_XYZ</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoPrimaries.DeviceContextIP3">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms701628</doc-id>
            <unmanaged>MFVideoPrimaries_DCI_P3</unmanaged>
            <unmanaged-short>MFVideoPrimaries_DCI_P3</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoPrimaries.Aces">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms701628</doc-id>
            <unmanaged>MFVideoPrimaries_ACES</unmanaged>
            <unmanaged-short>MFVideoPrimaries_ACES</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoPrimaries.Last">
            <summary>
            <dd> <p> Reserved. </p> </dd>
            </summary>
            <doc-id>ms701628</doc-id>
            <unmanaged>MFVideoPrimaries_Last</unmanaged>
            <unmanaged-short>MFVideoPrimaries_Last</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoPrimaries.ForceDWORD">
            <summary>
            <dd> <p> Reserved. This member forces the enumeration type to compile as a <strong><see cref = "T:System.Int32"/></strong> value. </p> </dd>
            </summary>
            <doc-id>ms701628</doc-id>
            <unmanaged>MFVideoPrimaries_ForceDWORD</unmanaged>
            <unmanaged-short>MFVideoPrimaries_ForceDWORD</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoProcessorAlgorithmType">
            <summary>
            <p>Defines algorithms for the video processor which is use by MF_VIDEO_PROCESSOR_ALGORITHM.</p>
            </summary>
            <doc-id>dn302208</doc-id>
            <unmanaged>MF_VIDEO_PROCESSOR_ALGORITHM_TYPE</unmanaged>
            <unmanaged-short>MF_VIDEO_PROCESSOR_ALGORITHM_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoProcessorAlgorithmType.Default">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302208</doc-id>
            <unmanaged>MF_VIDEO_PROCESSOR_ALGORITHM_DEFAULT</unmanaged>
            <unmanaged-short>MF_VIDEO_PROCESSOR_ALGORITHM_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoProcessorAlgorithmType.MrfCrf444">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302208</doc-id>
            <unmanaged>MF_VIDEO_PROCESSOR_ALGORITHM_MRF_CRF_444</unmanaged>
            <unmanaged-short>MF_VIDEO_PROCESSOR_ALGORITHM_MRF_CRF_444</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoProcessorMirror">
            <summary>
            <p>Specifies how to flip a video image.</p>
            </summary>
            <doc-id>hh162904</doc-id>
            <unmanaged>MF_VIDEO_PROCESSOR_MIRROR</unmanaged>
            <unmanaged-short>MF_VIDEO_PROCESSOR_MIRROR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoProcessorMirror.MirrorNone">
            <summary>
            <dd> <p>Do not flip the image.</p> </dd>
            </summary>
            <doc-id>hh162904</doc-id>
            <unmanaged>MIRROR_NONE</unmanaged>
            <unmanaged-short>MIRROR_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoProcessorMirror.MirrorHorizontal">
            <summary>
            <dd> <p>Flip the image horizontally.</p> </dd>
            </summary>
            <doc-id>hh162904</doc-id>
            <unmanaged>MIRROR_HORIZONTAL</unmanaged>
            <unmanaged-short>MIRROR_HORIZONTAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoProcessorMirror.MirrorVertical">
            <summary>
            <dd> <p>Flip the image vertically.</p> </dd>
            </summary>
            <doc-id>hh162904</doc-id>
            <unmanaged>MIRROR_VERTICAL</unmanaged>
            <unmanaged-short>MIRROR_VERTICAL</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoProcessorRotation">
            <summary>
            <p>Specifies how to rotate a video image.</p>
            </summary>
            <doc-id>hh162905</doc-id>
            <unmanaged>MF_VIDEO_PROCESSOR_ROTATION</unmanaged>
            <unmanaged-short>MF_VIDEO_PROCESSOR_ROTATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoProcessorRotation.RotationNone">
            <summary>
            <dd> <p>Do not rotate the image.</p> </dd>
            </summary>
            <doc-id>hh162905</doc-id>
            <unmanaged>ROTATION_NONE</unmanaged>
            <unmanaged-short>ROTATION_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoProcessorRotation.RotationNormal">
            <summary>
            <dd> <p>Rotate the image to the correct viewing orientation.</p> </dd>
            </summary>
            <doc-id>hh162905</doc-id>
            <unmanaged>ROTATION_NORMAL</unmanaged>
            <unmanaged-short>ROTATION_NORMAL</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoRenderPrefs">
            <summary>
            <p> </p><p>Contains flags that define how the enhanced video renderer (EVR) displays the video.</p>
            </summary>
            <remarks>
            <p>To set these flags, call <strong>IMFVideoDisplayControl::SetRenderingPrefs</strong>.</p><p>The flags named "MFVideoRenderPrefs_Allow..." cause the EVR to use lower-quality settings only when requested by the quality manager. (For more information, see <strong><see cref = "T:SharpDX.MediaFoundation.QualityAdvise"/></strong>.) The flags named "MFVideoRenderPrefs_Force..." cause the video mixer to use lower-quality settings regardless of the quality manager. </p>
            </remarks>
            <doc-id>ms701834</doc-id>
            <unmanaged>MFVideoRenderPrefs</unmanaged>
            <unmanaged-short>MFVideoRenderPrefs</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoRenderPrefs.DoNotRenderBorder">
            <summary>
            <dd> <p> If this flag is set, the EVR does not draw the border color. By default, the EVR draws a border on areas of the destination rectangle that have no video. See <strong>IMFVideoDisplayControl::SetBorderColor</strong>. </p> </dd>
            </summary>
            <doc-id>ms701834</doc-id>
            <unmanaged>MFVideoRenderPrefs_DoNotRenderBorder</unmanaged>
            <unmanaged-short>MFVideoRenderPrefs_DoNotRenderBorder</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoRenderPrefs.DoNotClipToDevice">
            <summary>
            <dd> <p> If this flag is set, the EVR does not clip the video when the video window straddles two monitors. By default, if the video window straddles two monitors, the EVR clips the video to the monitor that contains the largest area of video. </p> </dd>
            </summary>
            <doc-id>ms701834</doc-id>
            <unmanaged>MFVideoRenderPrefs_DoNotClipToDevice</unmanaged>
            <unmanaged-short>MFVideoRenderPrefs_DoNotClipToDevice</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoRenderPrefs.AllowOutputThrottling">
            <summary>
            <dd> <p> </p><strong>Note</strong>??Requires Windows?7 or later. ? <p>Allow the EVR to limit its output to match GPU bandwidth.</p> </dd>
            </summary>
            <doc-id>ms701834</doc-id>
            <unmanaged>MFVideoRenderPrefs_AllowOutputThrottling</unmanaged>
            <unmanaged-short>MFVideoRenderPrefs_AllowOutputThrottling</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoRenderPrefs.ForceOutputThrottling">
            <summary>
            <dd> <p> </p><strong>Note</strong>??Requires Windows?7 or later. ? <p>Force the EVR to limit its output to match GPU bandwidth.</p> </dd>
            </summary>
            <doc-id>ms701834</doc-id>
            <unmanaged>MFVideoRenderPrefs_ForceOutputThrottling</unmanaged>
            <unmanaged-short>MFVideoRenderPrefs_ForceOutputThrottling</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoRenderPrefs.ForceBatching">
            <summary>
            <dd> <p> </p><strong>Note</strong>??Requires Windows?7 or later. ? <p>Force the EVR to batch Direct3D <strong>Present</strong> calls. This optimization enables the system to enter to idle states more frequently, which can reduce power consumption. </p> </dd>
            </summary>
            <doc-id>ms701834</doc-id>
            <unmanaged>MFVideoRenderPrefs_ForceBatching</unmanaged>
            <unmanaged-short>MFVideoRenderPrefs_ForceBatching</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoRenderPrefs.AllowBatching">
            <summary>
            <dd> <p> </p><strong>Note</strong>??Requires Windows?7 or later. ? <p>Allow the EVR to batch Direct3D <strong>Present</strong> calls.</p> </dd>
            </summary>
            <doc-id>ms701834</doc-id>
            <unmanaged>MFVideoRenderPrefs_AllowBatching</unmanaged>
            <unmanaged-short>MFVideoRenderPrefs_AllowBatching</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoRenderPrefs.ForceScaling">
            <summary>
            <dd> <p> </p><strong>Note</strong>??Requires Windows?7 or later. ? <p>Force the EVR to mix the video inside a rectangle that is smaller than the output rectangle. The EVR will then scale the result to the correct output size. The effective resolution will be lower if this setting is applied.</p> </dd>
            </summary>
            <doc-id>ms701834</doc-id>
            <unmanaged>MFVideoRenderPrefs_ForceScaling</unmanaged>
            <unmanaged-short>MFVideoRenderPrefs_ForceScaling</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoRenderPrefs.AllowScaling">
            <summary>
            <dd> <p> </p><strong>Note</strong>??Requires Windows?7 or later. ? <p>Allow the EVR to mix the video inside a rectangle that is smaller than the output rectangle. </p> </dd>
            </summary>
            <doc-id>ms701834</doc-id>
            <unmanaged>MFVideoRenderPrefs_AllowScaling</unmanaged>
            <unmanaged-short>MFVideoRenderPrefs_AllowScaling</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoRenderPrefs.DoNotRepaintOnStop">
            <summary>
            <dd> <p> </p><strong>Note</strong>??Requires Windows?7 or later. ? <p>Prevent the EVR from repainting the video window after a stop command. By default, the EVR repaints the video window black after a stop command.</p> </dd>
            </summary>
            <doc-id>ms701834</doc-id>
            <unmanaged>MFVideoRenderPrefs_DoNotRepaintOnStop</unmanaged>
            <unmanaged-short>MFVideoRenderPrefs_DoNotRepaintOnStop</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoRotationFormat">
            <summary>
            <p>Describes the rotation of the video image in the counter-clockwise direction.</p>
            </summary>
            <remarks>
            <p>This enumeration is used with the <see cref = "!:VideoRotation"/> attribute.</p>
            </remarks>
            <doc-id>hh162805</doc-id>
            <unmanaged>MFVideoRotationFormat</unmanaged>
            <unmanaged-short>MFVideoRotationFormat</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoRotationFormat.Angle0">
            <summary>
            <dd> <p>The image is not rotated.</p> </dd>
            </summary>
            <doc-id>hh162805</doc-id>
            <unmanaged>MFVideoRotationFormat_0</unmanaged>
            <unmanaged-short>MFVideoRotationFormat_0</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoRotationFormat.Angle90">
            <summary>
            <dd> <p>The image is rotated 90 degrees counter-clockwise.</p> </dd>
            </summary>
            <doc-id>hh162805</doc-id>
            <unmanaged>MFVideoRotationFormat_90</unmanaged>
            <unmanaged-short>MFVideoRotationFormat_90</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoRotationFormat.Angle180">
            <summary>
            <dd> <p>The image is rotated 180 degrees.</p> </dd>
            </summary>
            <doc-id>hh162805</doc-id>
            <unmanaged>MFVideoRotationFormat_180</unmanaged>
            <unmanaged-short>MFVideoRotationFormat_180</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoRotationFormat.Angle270">
            <summary>
            <dd> <p>The image is rotated 270 degrees counter-clockwise.</p> </dd>
            </summary>
            <doc-id>hh162805</doc-id>
            <unmanaged>MFVideoRotationFormat_270</unmanaged>
            <unmanaged-short>MFVideoRotationFormat_270</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoSphericalFormat">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFVideoSphericalFormat</unmanaged>
            <unmanaged-short>MFVideoSphericalFormat</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoSphericalFormat.Unsupported">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFVideoSphericalFormat_Unsupported</unmanaged>
            <unmanaged-short>MFVideoSphericalFormat_Unsupported</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoSphericalFormat.Equirectangular">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFVideoSphericalFormat_Equirectangular</unmanaged>
            <unmanaged-short>MFVideoSphericalFormat_Equirectangular</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoSrcContentHintFlags">
            <summary>
            <p> </p><p>Describes the intended aspect ratio for a video stream.</p>
            </summary>
            <remarks>
            <p>Use these flags with the <strong><see cref = "!:SourceContentHint"/></strong> attribute.</p>
            </remarks>
            <doc-id>ms697451</doc-id>
            <unmanaged>MFVideoSrcContentHintFlags</unmanaged>
            <unmanaged-short>MFVideoSrcContentHintFlags</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoSrcContentHintFlags.None">
            <summary>
            <dd> <p>The aspect ratio is unknown.</p> </dd>
            </summary>
            <doc-id>ms697451</doc-id>
            <unmanaged>MFVideoSrcContentHintFlag_None</unmanaged>
            <unmanaged-short>MFVideoSrcContentHintFlag_None</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoSrcContentHintFlags.Hint16x9">
            <summary>
            <dd> <p>The source is 16?9 content encoded within a 4?3 area.</p> </dd>
            </summary>
            <doc-id>ms697451</doc-id>
            <unmanaged>MFVideoSrcContentHintFlag_16x9</unmanaged>
            <unmanaged-short>MFVideoSrcContentHintFlag_16x9</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoSrcContentHintFlags.Hint235_1">
            <summary>
            <dd> <p>The source is 2.35:1 content encoded within a 16?9 or 4?3 area.</p> </dd>
            </summary>
            <doc-id>ms697451</doc-id>
            <unmanaged>MFVideoSrcContentHintFlag_235_1</unmanaged>
            <unmanaged-short>MFVideoSrcContentHintFlag_235_1</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoTransferFunction">
            <summary>
            <p> Specifies the conversion function from linear RGB to non-linear RGB (R'G'B'). </p>
            </summary>
            <remarks>
            <p> These flags are used with the <strong><see cref = "!:TransferFunction"/></strong> attribute. </p><p> For more information about these values, see the remarks for the <strong>DXVA2_VideoTransferFunction</strong> enumeration, which is the DirectX Video Acceleration (DXVA) equivalent of this enumeration. </p>
            </remarks>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransferFunction</unmanaged>
            <unmanaged-short>MFVideoTransferFunction</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferFunction.FuncUnknown">
            <summary>
            <dd> <p> Unknown. Treat as MFVideoTransFunc_709. </p> </dd>
            </summary>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransFunc_Unknown</unmanaged>
            <unmanaged-short>MFVideoTransFunc_Unknown</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferFunction.Func10">
            <summary>
            <dd> <p> Linear RGB (gamma = 1.0). </p> </dd>
            </summary>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransFunc_10</unmanaged>
            <unmanaged-short>MFVideoTransFunc_10</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferFunction.Func18">
            <summary>
            <dd> <p> True 1.8 gamma, L' = L^1/1.8. </p> </dd>
            </summary>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransFunc_18</unmanaged>
            <unmanaged-short>MFVideoTransFunc_18</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferFunction.Func20">
            <summary>
            <dd> <p> True 2.0 gamma, L' = L^1/2.0. </p> </dd>
            </summary>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransFunc_20</unmanaged>
            <unmanaged-short>MFVideoTransFunc_20</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferFunction.Func22">
            <summary>
            <dd> <p> True 2.2 gamma, L' = L^1/2.2. This transfer function is used in ITU-R BT.470-2 System M (NTSC). </p> </dd>
            </summary>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransFunc_22</unmanaged>
            <unmanaged-short>MFVideoTransFunc_22</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferFunction.Func709">
            <summary>
            <dd> <p> ITU-R BT.709 transfer function. Gamma 2.2 curve with a linear segment in the lower range. This transfer function is used in BT.709, BT.601, SMPTE 296M, SMPTE 170M, BT.470, and SPMTE 274M. In addition BT-1361 uses this function within the range [0...1]. </p> </dd>
            </summary>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransFunc_709</unmanaged>
            <unmanaged-short>MFVideoTransFunc_709</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferFunction.Func240m">
            <summary>
            <dd> <p> SPMTE 240M transfer function. Gamma 2.2 curve with a linear segment in the lower range. </p> </dd>
            </summary>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransFunc_240M</unmanaged>
            <unmanaged-short>MFVideoTransFunc_240M</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferFunction.FuncSRGB">
            <summary>
            <dd> <p> sRGB transfer function. Gamma 2.4 curve with a linear segment in the lower range. </p> </dd>
            </summary>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransFunc_sRGB</unmanaged>
            <unmanaged-short>MFVideoTransFunc_sRGB</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferFunction.Func28">
            <summary>
            <dd> <p> True 2.8 gamma. L' = L^1/2.8. This transfer function is used in ITU-R BT.470-2 System B, G (PAL). </p> </dd>
            </summary>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransFunc_28</unmanaged>
            <unmanaged-short>MFVideoTransFunc_28</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferFunction.FuncLog100">
            <summary>
            <dd> <p>Logarithmic transfer (100:1 range); for example, as used in H.264 video.</p> <strong>Note</strong>??Requires Windows?7 or later. ? </dd>
            </summary>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransFunc_Log_100</unmanaged>
            <unmanaged-short>MFVideoTransFunc_Log_100</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferFunction.FuncLog316">
            <summary>
            <dd> <p>Logarithmic transfer (316.22777:1 range); for example, as used in H.264 video.</p> <strong>Note</strong>??Requires Windows?7 or later. ? </dd>
            </summary>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransFunc_Log_316</unmanaged>
            <unmanaged-short>MFVideoTransFunc_Log_316</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferFunction.Func709Sym">
            <summary>
            <dd> <p>Symmetric ITU-R BT.709.</p> <strong>Note</strong>??Requires Windows?7 or later. ? </dd>
            </summary>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransFunc_709_sym</unmanaged>
            <unmanaged-short>MFVideoTransFunc_709_sym</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferFunction.Func2020Const">
            <summary>
            <dd> <p> Reserved. </p> </dd>
            </summary>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransFunc_2020_const</unmanaged>
            <unmanaged-short>MFVideoTransFunc_2020_const</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferFunction.Func2020">
            <summary>
            <dd> <p> Reserved. This member forces the enumeration type to compile as a <strong><see cref = "T:System.Int32"/></strong> value. </p> </dd>
            </summary>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransFunc_2020</unmanaged>
            <unmanaged-short>MFVideoTransFunc_2020</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferFunction.Func26">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransFunc_26</unmanaged>
            <unmanaged-short>MFVideoTransFunc_26</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferFunction.Func2084">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransFunc_2084</unmanaged>
            <unmanaged-short>MFVideoTransFunc_2084</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferFunction.FuncHlg">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransFunc_HLG</unmanaged>
            <unmanaged-short>MFVideoTransFunc_HLG</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferFunction.FuncLast">
            <summary>
            <dd> <p> Reserved. </p> </dd>
            </summary>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransFunc_Last</unmanaged>
            <unmanaged-short>MFVideoTransFunc_Last</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferFunction.FuncForceDWORD">
            <summary>
            <dd> <p> Reserved. This member forces the enumeration type to compile as a <strong><see cref = "T:System.Int32"/></strong> value. </p> </dd>
            </summary>
            <doc-id>ms705629</doc-id>
            <unmanaged>MFVideoTransFunc_ForceDWORD</unmanaged>
            <unmanaged-short>MFVideoTransFunc_ForceDWORD</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoTransferMatrix">
            <summary>
            <p> </p><p>Describes the conversion matrices between Y'PbPr (component video) and studio R'G'B'.</p>
            </summary>
            <remarks>
            <p>This enumeration is used with the <strong><see cref = "!:YuvMatrix"/></strong> attribute.</p><p>For more information about these values, see the remarks for the <strong>DXVA2_VideoTransferMatrix</strong> enumeration, which is the DirectX Video Acceleration (DXVA) equivalent of this enumeration.</p>
            </remarks>
            <doc-id>ms694036</doc-id>
            <unmanaged>MFVideoTransferMatrix</unmanaged>
            <unmanaged-short>MFVideoTransferMatrix</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferMatrix.Unknown">
            <summary>
            <dd> <p>Unknown transfer matrix. Treat as MFVideoTransferMatrix_BT709.</p> </dd>
            </summary>
            <doc-id>ms694036</doc-id>
            <unmanaged>MFVideoTransferMatrix_Unknown</unmanaged>
            <unmanaged-short>MFVideoTransferMatrix_Unknown</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferMatrix.Bt709">
            <summary>
            <dd> <p>ITU-R BT.709 transfer matrix.</p> </dd>
            </summary>
            <doc-id>ms694036</doc-id>
            <unmanaged>MFVideoTransferMatrix_BT709</unmanaged>
            <unmanaged-short>MFVideoTransferMatrix_BT709</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferMatrix.Bt601">
            <summary>
            <dd> <p>ITU-R BT.601 transfer matrix. Also used for SMPTE 170 and ITU-R BT.470-2 System B,G.</p> </dd>
            </summary>
            <doc-id>ms694036</doc-id>
            <unmanaged>MFVideoTransferMatrix_BT601</unmanaged>
            <unmanaged-short>MFVideoTransferMatrix_BT601</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferMatrix.Smpte240m">
            <summary>
            <dd> <p>SMPTE 240M transfer matrix.</p> </dd>
            </summary>
            <doc-id>ms694036</doc-id>
            <unmanaged>MFVideoTransferMatrix_SMPTE240M</unmanaged>
            <unmanaged-short>MFVideoTransferMatrix_SMPTE240M</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferMatrix.Bt202010">
            <summary>
            <dd> <p>Reserved.</p> </dd>
            </summary>
            <doc-id>ms694036</doc-id>
            <unmanaged>MFVideoTransferMatrix_BT2020_10</unmanaged>
            <unmanaged-short>MFVideoTransferMatrix_BT2020_10</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferMatrix.Bt202012">
            <summary>
            <dd> <p>Reserved. This member forces the enumeration type to compile as a <strong><see cref = "T:System.Int32"/></strong> value.</p> </dd>
            </summary>
            <doc-id>ms694036</doc-id>
            <unmanaged>MFVideoTransferMatrix_BT2020_12</unmanaged>
            <unmanaged-short>MFVideoTransferMatrix_BT2020_12</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferMatrix.Last">
            <summary>
            <dd> <p>Reserved.</p> </dd>
            </summary>
            <doc-id>ms694036</doc-id>
            <unmanaged>MFVideoTransferMatrix_Last</unmanaged>
            <unmanaged-short>MFVideoTransferMatrix_Last</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoTransferMatrix.ForceDWORD">
            <summary>
            <dd> <p>Reserved. This member forces the enumeration type to compile as a <strong><see cref = "T:System.Int32"/></strong> value.</p> </dd>
            </summary>
            <doc-id>ms694036</doc-id>
            <unmanaged>MFVideoTransferMatrix_ForceDWORD</unmanaged>
            <unmanaged-short>MFVideoTransferMatrix_ForceDWORD</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VpMessageType">
            <summary>
            <p>Defines messages for an enhanced video renderer (EVR) presenter. This enumeration is used with the <strong>IMFVideoPresenter::ProcessMessage</strong> method.</p>
            </summary>
            <doc-id>ms698964</doc-id>
            <unmanaged>MFVP_MESSAGE_TYPE</unmanaged>
            <unmanaged-short>MFVP_MESSAGE_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VpMessageType.Flush">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms698964</doc-id>
            <unmanaged>MFVP_MESSAGE_FLUSH</unmanaged>
            <unmanaged-short>MFVP_MESSAGE_FLUSH</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VpMessageType.InvalidateMediaType">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms698964</doc-id>
            <unmanaged>MFVP_MESSAGE_INVALIDATEMEDIATYPE</unmanaged>
            <unmanaged-short>MFVP_MESSAGE_INVALIDATEMEDIATYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VpMessageType.Processinputnotify">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms698964</doc-id>
            <unmanaged>MFVP_MESSAGE_PROCESSINPUTNOTIFY</unmanaged>
            <unmanaged-short>MFVP_MESSAGE_PROCESSINPUTNOTIFY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VpMessageType.Beginstreaming">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms698964</doc-id>
            <unmanaged>MFVP_MESSAGE_BEGINSTREAMING</unmanaged>
            <unmanaged-short>MFVP_MESSAGE_BEGINSTREAMING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VpMessageType.Endstreaming">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms698964</doc-id>
            <unmanaged>MFVP_MESSAGE_ENDSTREAMING</unmanaged>
            <unmanaged-short>MFVP_MESSAGE_ENDSTREAMING</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VpMessageType.Endofstream">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms698964</doc-id>
            <unmanaged>MFVP_MESSAGE_ENDOFSTREAM</unmanaged>
            <unmanaged-short>MFVP_MESSAGE_ENDOFSTREAM</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VpMessageType.Step">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms698964</doc-id>
            <unmanaged>MFVP_MESSAGE_STEP</unmanaged>
            <unmanaged-short>MFVP_MESSAGE_STEP</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VpMessageType.Cancelstep">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms698964</doc-id>
            <unmanaged>MFVP_MESSAGE_CANCELSTEP</unmanaged>
            <unmanaged-short>MFVP_MESSAGE_CANCELSTEP</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.WaveFormatExConvertFlags">
            <summary>
            <p> </p><p>Contains flags that specify how to convert an audio media type.</p>
            </summary>
            <doc-id>ms703181</doc-id>
            <unmanaged>MFWaveFormatExConvertFlags</unmanaged>
            <unmanaged-short>MFWaveFormatExConvertFlags</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.WaveFormatExConvertFlags.Normal">
            <summary>
            <dd> <p>Convert the media type to a <strong><see cref = "T:SharpDX.Multimedia.WaveFormat"/></strong> structure if possible, or a <strong><see cref = "T:SharpDX.Multimedia.WaveFormatExtensible"/></strong> structure otherwise.</p> </dd>
            </summary>
            <doc-id>ms703181</doc-id>
            <unmanaged>MFWaveFormatExConvertFlag_Normal</unmanaged>
            <unmanaged-short>MFWaveFormatExConvertFlag_Normal</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.WaveFormatExConvertFlags.ForceExtensible">
            <summary>
            <dd> <p>Convert the media type to a <strong><see cref = "T:SharpDX.Multimedia.WaveFormatExtensible"/></strong> structure.</p> </dd>
            </summary>
            <doc-id>ms703181</doc-id>
            <unmanaged>MFWaveFormatExConvertFlag_ForceExtensible</unmanaged>
            <unmanaged-short>MFWaveFormatExConvertFlag_ForceExtensible</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.WorkQueueType">
            <summary>
            <p> </p><p>Provides configuration information to the dispatching thread for a callback.</p>
            </summary>
            <remarks>
            <p> The <strong>GetParameters</strong> method returns information about the callback so that the dispatching thread can optimize the process that it uses to invoke the callback. </p><p> If the method returns a value other than zero in the <em>pdwFlags</em> parameter, your <strong>Invoke</strong> method must meet the requirements described here. Otherwise, the callback might delay the pipeline.</p><p> If you want default values for both parameters, return <strong>E_NOTIMPL</strong>. The default values are given in the parameter descriptions on this page.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970381</doc-id>
            <unmanaged>MFASYNC_CALLBACK_QUEUE</unmanaged>
            <unmanaged-short>MFASYNC_CALLBACK_QUEUE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.WorkQueueType.Undefined">
            <summary>
            <dd> <p>Receives a flag indicating the behavior of the callback object's <strong>IMFAsyncCallback::Invoke</strong> method. The following values are defined. The default value is zero.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>Zero</strong></dt> </dl> </td><td> <p>The callback does not take a long time to complete, but has no specific restrictions on what system calls it makes. The callback generally takes less than 30 milliseconds to complete.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MFASYNC_FAST_IO_PROCESSING_CALLBACK</strong></strong></dt> </dl> </td><td> <p>The callback does very minimal processing. It takes less than 1 millisecond to complete.</p> <p>The callback must be invoked from one of the following work queues:</p> <ul> <li><strong>MFASYNC_CALLBACK_QUEUE_IO</strong></li> <li><strong>MFASYNC_CALLBACK_QUEUE_TIMER</strong></li> </ul> </td></tr> <tr><td><dl> <dt><strong><strong>MFASYNC_SIGNAL_CALLBACK</strong></strong></dt> </dl> </td><td> <p>Implies <strong>MFASYNC_FAST_IO_PROCESSING_CALLBACK</strong>, with the additional restriction that the callback does no processing (less than 50 microseconds), and the only system call it makes is <strong>SetEvent</strong>.</p> <p>The callback must be invoked from one of the following work queues:</p> <ul> <li><strong>MFASYNC_CALLBACK_QUEUE_IO</strong></li> <li><strong>MFASYNC_CALLBACK_QUEUE_TIMER</strong></li> </ul> </td></tr> <tr><td><dl> <dt><strong><strong>MFASYNC_BLOCKING_CALLBACK</strong></strong></dt> </dl> </td><td> <p>Blocking callback.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MFASYNC_REPLY_CALLBACK</strong></strong></dt> </dl> </td><td> <p>Reply callback.</p> </td></tr> </table> <p>?</p> </dd>
            </summary>
            <doc-id>bb970381</doc-id>
            <unmanaged>MFASYNC_CALLBACK_QUEUE_UNDEFINED</unmanaged>
            <unmanaged-short>MFASYNC_CALLBACK_QUEUE_UNDEFINED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.WorkQueueType.Standard">
            <summary>
            <dd> <p> Receives the identifier of the work queue on which the callback is dispatched.  </p> <p>This value can specify one of the standard Media Foundation work queues, or a work queue created by the application. For list of standard Media Foundation work queues, see <strong>Work Queue Identifiers</strong>. To create a new work queue, call <strong>MFAllocateWorkQueue</strong>. The default value is <strong>MFASYNC_CALLBACK_QUEUE_STANDARD</strong>.</p> <p>If the work queue is not compatible with the value returned in <em>pdwFlags</em>, the Media Foundation platform returns <strong><see cref = "!:InvalidWorkqueue"/></strong> when it tries to dispatch the callback. (See <strong>MFPutWorkItem</strong>.)</p> </dd>
            </summary>
            <doc-id>bb970381</doc-id>
            <unmanaged>MFASYNC_CALLBACK_QUEUE_STANDARD</unmanaged>
            <unmanaged-short>MFASYNC_CALLBACK_QUEUE_STANDARD</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.WorkQueueType.Rt">
            <summary>
            No documentation.
            </summary>
            <doc-id>bb970381</doc-id>
            <unmanaged>MFASYNC_CALLBACK_QUEUE_RT</unmanaged>
            <unmanaged-short>MFASYNC_CALLBACK_QUEUE_RT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.WorkQueueType.Io">
            <summary>
            No documentation.
            </summary>
            <doc-id>bb970381</doc-id>
            <unmanaged>MFASYNC_CALLBACK_QUEUE_IO</unmanaged>
            <unmanaged-short>MFASYNC_CALLBACK_QUEUE_IO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.WorkQueueType.Timer">
            <summary>
            No documentation.
            </summary>
            <doc-id>bb970381</doc-id>
            <unmanaged>MFASYNC_CALLBACK_QUEUE_TIMER</unmanaged>
            <unmanaged-short>MFASYNC_CALLBACK_QUEUE_TIMER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.WorkQueueType.Multithreaded">
            <summary>
            No documentation.
            </summary>
            <doc-id>bb970381</doc-id>
            <unmanaged>MFASYNC_CALLBACK_QUEUE_MULTITHREADED</unmanaged>
            <unmanaged-short>MFASYNC_CALLBACK_QUEUE_MULTITHREADED</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.WorkQueueType.LongFunction">
            <summary>
            No documentation.
            </summary>
            <doc-id>bb970381</doc-id>
            <unmanaged>MFASYNC_CALLBACK_QUEUE_LONG_FUNCTION</unmanaged>
            <unmanaged-short>MFASYNC_CALLBACK_QUEUE_LONG_FUNCTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.WorkQueueType.PrivateMask">
            <summary>
            No documentation.
            </summary>
            <doc-id>bb970381</doc-id>
            <unmanaged>MFASYNC_CALLBACK_QUEUE_PRIVATE_MASK</unmanaged>
            <unmanaged-short>MFASYNC_CALLBACK_QUEUE_PRIVATE_MASK</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.WorkQueueType.All">
            <summary>
            No documentation.
            </summary>
            <doc-id>bb970381</doc-id>
            <unmanaged>MFASYNC_CALLBACK_QUEUE_ALL</unmanaged>
            <unmanaged-short>MFASYNC_CALLBACK_QUEUE_ALL</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.AsfProfileAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfProfileAttributeKeys.Maxpacketsize">
            <summary>Constant Maxpacketsize</summary>
            <unmanaged>MF_ASFPROFILE_MAXPACKETSIZE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfProfileAttributeKeys.Minpacketsize">
            <summary>Constant Minpacketsize</summary>
            <unmanaged>MF_ASFPROFILE_MINPACKETSIZE</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.AsfSplitterAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfSplitterAttributeKeys.PacketBoundary">
            <summary>Constant PacketBoundary</summary>
            <unmanaged>MFASFSPLITTER_PACKET_BOUNDARY</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.AsfStreamConfigAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfStreamConfigAttributeKeys.LeakyBucket1">
            <summary>Constant LeakyBucket1</summary>
            <unmanaged>MF_ASFSTREAMCONFIG_LEAKYBUCKET1</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfStreamConfigAttributeKeys.LeakyBucket2">
            <summary>Constant LeakyBucket2</summary>
            <unmanaged>MF_ASFSTREAMCONFIG_LEAKYBUCKET2</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.AudioFormatGuids">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.Base">
            <summary>Constant Base</summary>
            <unmanaged>MFAudioFormat_Base</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.Pcm">
            <summary>Constant Pcm</summary>
            <unmanaged>MFAudioFormat_PCM</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.Float">
            <summary>Constant Float</summary>
            <unmanaged>MFAudioFormat_Float</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.Dts">
            <summary>Constant Dts</summary>
            <unmanaged>MFAudioFormat_DTS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.DolbyAc3Spdif">
            <summary>Constant DolbyAc3Spdif</summary>
            <unmanaged>MFAudioFormat_Dolby_AC3_SPDIF</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.Drm">
            <summary>Constant Drm</summary>
            <unmanaged>MFAudioFormat_DRM</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.WMAudioV8">
            <summary>Constant WMAudioV8</summary>
            <unmanaged>MFAudioFormat_WMAudioV8</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.WMAudioV9">
            <summary>Constant WMAudioV9</summary>
            <unmanaged>MFAudioFormat_WMAudioV9</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.WMAudioLossless">
            <summary>Constant WMAudioLossless</summary>
            <unmanaged>MFAudioFormat_WMAudio_Lossless</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.Wmaspdif">
            <summary>Constant Wmaspdif</summary>
            <unmanaged>MFAudioFormat_WMASPDIF</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.MultisampledP1">
            <summary>Constant MultisampledP1</summary>
            <unmanaged>MFAudioFormat_MSP1</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.Mp3">
            <summary>Constant Mp3</summary>
            <unmanaged>MFAudioFormat_MP3</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.Mpeg">
            <summary>Constant Mpeg</summary>
            <unmanaged>MFAudioFormat_MPEG</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.Aac">
            <summary>Constant Aac</summary>
            <unmanaged>MFAudioFormat_AAC</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.Adts">
            <summary>Constant Adts</summary>
            <unmanaged>MFAudioFormat_ADTS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.AmrNb">
            <summary>Constant AmrNb</summary>
            <unmanaged>MFAudioFormat_AMR_NB</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.AmrWb">
            <summary>Constant AmrWb</summary>
            <unmanaged>MFAudioFormat_AMR_WB</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.AmrWp">
            <summary>Constant AmrWp</summary>
            <unmanaged>MFAudioFormat_AMR_WP</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.Flac">
            <summary>Constant Flac</summary>
            <unmanaged>MFAudioFormat_FLAC</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.Alac">
            <summary>Constant Alac</summary>
            <unmanaged>MFAudioFormat_ALAC</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.Opus">
            <summary>Constant Opus</summary>
            <unmanaged>MFAudioFormat_Opus</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.DolbyAc3">
            <summary>Constant DolbyAc3</summary>
            <unmanaged>MFAudioFormat_Dolby_AC3</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.DolbyDDPlus">
            <summary>Constant DolbyDDPlus</summary>
            <unmanaged>MFAudioFormat_Dolby_DDPlus</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.Vorbis">
            <summary>Constant Vorbis</summary>
            <unmanaged>MFAudioFormat_Vorbis</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.FloatSpatialObjects">
            <summary>Constant FloatSpatialObjects</summary>
            <unmanaged>MFAudioFormat_Float_SpatialObjects</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.Lpcm">
            <summary>Constant Lpcm</summary>
            <unmanaged>MFAudioFormat_LPCM</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.PcmHdcp">
            <summary>Constant PcmHdcp</summary>
            <unmanaged>MFAudioFormat_PCM_HDCP</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.DolbyAc3Hdcp">
            <summary>Constant DolbyAc3Hdcp</summary>
            <unmanaged>MFAudioFormat_Dolby_AC3_HDCP</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.AacHdcp">
            <summary>Constant AacHdcp</summary>
            <unmanaged>MFAudioFormat_AAC_HDCP</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.AdtsHdcp">
            <summary>Constant AdtsHdcp</summary>
            <unmanaged>MFAudioFormat_ADTS_HDCP</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioFormatGuids.BaseHdcp">
            <summary>Constant BaseHdcp</summary>
            <unmanaged>MFAudioFormat_Base_HDCP</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.AudioRendererAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioRendererAttributeKeys.EndpointId">
            <summary>Constant EndpointId</summary>
            <unmanaged>MF_AUDIO_RENDERER_ATTRIBUTE_ENDPOINT_ID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioRendererAttributeKeys.EndpointRole">
            <summary>Constant EndpointRole</summary>
            <unmanaged>MF_AUDIO_RENDERER_ATTRIBUTE_ENDPOINT_ROLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioRendererAttributeKeys.Flags">
            <summary>Constant Flags</summary>
            <unmanaged>MF_AUDIO_RENDERER_ATTRIBUTE_FLAGS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioRendererAttributeKeys.SessionId">
            <summary>Constant SessionId</summary>
            <unmanaged>MF_AUDIO_RENDERER_ATTRIBUTE_SESSION_ID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioRendererAttributeKeys.StreamCategory">
            <summary>Constant StreamCategory</summary>
            <unmanaged>MF_AUDIO_RENDERER_ATTRIBUTE_STREAM_CATEGORY</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.ByteStreamAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.ByteStreamAttributeKeys.ContentType">
            <summary>Constant ContentType</summary>
            <unmanaged>MF_BYTESTREAM_CONTENT_TYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ByteStreamAttributeKeys.Duration">
            <summary>Constant Duration</summary>
            <unmanaged>MF_BYTESTREAM_DURATION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ByteStreamAttributeKeys.EffectiveUrl">
            <summary>Constant EffectiveUrl</summary>
            <unmanaged>MF_BYTESTREAM_EFFECTIVE_URL</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ByteStreamAttributeKeys.IfoFileUri">
            <summary>Constant IfoFileUri</summary>
            <unmanaged>MF_BYTESTREAM_IFO_FILE_URI</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ByteStreamAttributeKeys.LastModifiedTime">
            <summary>Constant LastModifiedTime</summary>
            <unmanaged>MF_BYTESTREAM_LAST_MODIFIED_TIME</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ByteStreamAttributeKeys.OriginName">
            <summary>Constant OriginName</summary>
            <unmanaged>MF_BYTESTREAM_ORIGIN_NAME</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ByteStreamAttributeKeys.HandlerAcceptsShareWrite">
            <summary>Constant HandlerAcceptsShareWrite</summary>
            <unmanaged>MF_BYTESTREAMHANDLER_ACCEPTS_SHARE_WRITE</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.CaptureDeviceAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeVideoCapture">
            <summary>Constant SourceTypeVideoCapture</summary>
            <unmanaged>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_GUID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeAudioCapture">
            <summary>Constant SourceTypeAudioCapture</summary>
            <unmanaged>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_GUID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.FriendlyName">
            <summary>Constant FriendlyName</summary>
            <unmanaged>MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.MediaType">
            <summary>Constant MediaType</summary>
            <unmanaged>MF_DEVSOURCE_ATTRIBUTE_MEDIA_TYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceType">
            <summary>Constant SourceType</summary>
            <unmanaged>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeAudcapEndpointId">
            <summary>Constant SourceTypeAudcapEndpointId</summary>
            <unmanaged>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_ENDPOINT_ID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeAudcapRole">
            <summary>Constant SourceTypeAudcapRole</summary>
            <unmanaged>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_ROLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeVidcapCategory">
            <summary>Constant SourceTypeVidcapCategory</summary>
            <unmanaged>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_CATEGORY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeVidcapHwSource">
            <summary>Constant SourceTypeVidcapHwSource</summary>
            <unmanaged>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_HW_SOURCE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeVidcapMaxBuffers">
            <summary>Constant SourceTypeVidcapMaxBuffers</summary>
            <unmanaged>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_MAX_BUFFERS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureDeviceAttributeKeys.SourceTypeVidcapSymbolicLink">
            <summary>Constant SourceTypeVidcapSymbolicLink</summary>
            <unmanaged>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_SYMBOLIC_LINK</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.CaptureEngineAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineAttributeKeys.D3DManager">
            <summary>Constant D3DManager</summary>
            <unmanaged>MF_CAPTURE_ENGINE_D3D_MANAGER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineAttributeKeys.DecoderTransformFieldOfUseUnlockAttribute">
            <summary>Constant DecoderTransformFieldOfUseUnlockAttribute</summary>
            <unmanaged>MF_CAPTURE_ENGINE_DECODER_MFT_FIELDOFUSE_UNLOCK_Attribute</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineAttributeKeys.DisableDXVA">
            <summary>Constant DisableDXVA</summary>
            <unmanaged>MF_CAPTURE_ENGINE_DISABLE_DXVA</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineAttributeKeys.DisableHardwareTransforms">
            <summary>Constant DisableHardwareTransforms</summary>
            <unmanaged>MF_CAPTURE_ENGINE_DISABLE_HARDWARE_TRANSFORMS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineAttributeKeys.EncoderTransformFieldOfUseUnlockAttribute">
            <summary>Constant EncoderTransformFieldOfUseUnlockAttribute</summary>
            <unmanaged>MF_CAPTURE_ENGINE_ENCODER_MFT_FIELDOFUSE_UNLOCK_Attribute</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineAttributeKeys.EventGeneratorGuid">
            <summary>Constant EventGeneratorGuid</summary>
            <unmanaged>MF_CAPTURE_ENGINE_EVENT_GENERATOR_GUID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineAttributeKeys.EventStreamIndex">
            <summary>Constant EventStreamIndex</summary>
            <unmanaged>MF_CAPTURE_ENGINE_EVENT_STREAM_INDEX</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineAttributeKeys.MediaSourceConfig">
            <summary>Constant MediaSourceConfig</summary>
            <unmanaged>MF_CAPTURE_ENGINE_MEDIASOURCE_CONFIG</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineAttributeKeys.RecordSinkAudioMaxProcessedSamples">
            <summary>Constant RecordSinkAudioMaxProcessedSamples</summary>
            <unmanaged>MF_CAPTURE_ENGINE_RECORD_SINK_AUDIO_MAX_PROCESSED_SAMPLES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineAttributeKeys.RecordSinkAudioMaxUnprocessedSamples">
            <summary>Constant RecordSinkAudioMaxUnprocessedSamples</summary>
            <unmanaged>MF_CAPTURE_ENGINE_RECORD_SINK_AUDIO_MAX_UNPROCESSED_SAMPLES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineAttributeKeys.RecordSinkVideoMaxProcessedSamples">
            <summary>Constant RecordSinkVideoMaxProcessedSamples</summary>
            <unmanaged>MF_CAPTURE_ENGINE_RECORD_SINK_VIDEO_MAX_PROCESSED_SAMPLES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineAttributeKeys.RecordSinkVideoMaxUnprocessedSamples">
            <summary>Constant RecordSinkVideoMaxUnprocessedSamples</summary>
            <unmanaged>MF_CAPTURE_ENGINE_RECORD_SINK_VIDEO_MAX_UNPROCESSED_SAMPLES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineAttributeKeys.UseAudioDeviceOnly">
            <summary>Constant UseAudioDeviceOnly</summary>
            <unmanaged>MF_CAPTURE_ENGINE_USE_AUDIO_DEVICE_ONLY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineAttributeKeys.UseVideoDeviceOnly">
            <summary>Constant UseVideoDeviceOnly</summary>
            <unmanaged>MF_CAPTURE_ENGINE_USE_VIDEO_DEVICE_ONLY</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.DeviceStreamAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.DeviceStreamAttributeKeys.ExtensionPluginClsid">
            <summary>Constant ExtensionPluginClsid</summary>
            <unmanaged>MF_DEVICESTREAM_EXTENSION_PLUGIN_CLSID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.DeviceStreamAttributeKeys.ExtensionPluginConnectionPoint">
            <summary>Constant ExtensionPluginConnectionPoint</summary>
            <unmanaged>MF_DEVICESTREAM_EXTENSION_PLUGIN_CONNECTION_POINT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.DeviceStreamAttributeKeys.ImageStream">
            <summary>Constant ImageStream</summary>
            <unmanaged>MF_DEVICESTREAM_IMAGE_STREAM</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.DeviceStreamAttributeKeys.IndependentImageStream">
            <summary>Constant IndependentImageStream</summary>
            <unmanaged>MF_DEVICESTREAM_INDEPENDENT_IMAGE_STREAM</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.DeviceStreamAttributeKeys.MaxFrameBuffers">
            <summary>Constant MaxFrameBuffers</summary>
            <unmanaged>MF_DEVICESTREAM_MAX_FRAME_BUFFERS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.DeviceStreamAttributeKeys.StreamCategory">
            <summary>Constant StreamCategory</summary>
            <unmanaged>MF_DEVICESTREAM_STREAM_CATEGORY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.DeviceStreamAttributeKeys.StreamId">
            <summary>Constant StreamId</summary>
            <unmanaged>MF_DEVICESTREAM_STREAM_ID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.DeviceStreamAttributeKeys.TakephotoTrigger">
            <summary>Constant TakephotoTrigger</summary>
            <unmanaged>MF_DEVICESTREAM_TAKEPHOTO_TRIGGER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.DeviceStreamAttributeKeys.TransformStreamId">
            <summary>Constant TransformStreamId</summary>
            <unmanaged>MF_DEVICESTREAM_TRANSFORM_STREAM_ID</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.DLNAMediaSinkAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.DLNAMediaSinkAttributeKeys.AudioBitRate">
            <summary>Constant AudioBitRate</summary>
            <unmanaged>MF_MP2DLNA_AUDIO_BIT_RATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.DLNAMediaSinkAttributeKeys.EncodeQuality">
            <summary>Constant EncodeQuality</summary>
            <unmanaged>MF_MP2DLNA_ENCODE_QUALITY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.DLNAMediaSinkAttributeKeys.Statistics">
            <summary>Constant Statistics</summary>
            <unmanaged>MF_MP2DLNA_STATISTICS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.DLNAMediaSinkAttributeKeys.UseMmcss">
            <summary>Constant UseMmcss</summary>
            <unmanaged>MF_MP2DLNA_USE_MMCSS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.DLNAMediaSinkAttributeKeys.VideoBitRate">
            <summary>Constant VideoBitRate</summary>
            <unmanaged>MF_MP2DLNA_VIDEO_BIT_RATE</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.EventAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.EventAttributeKeys.DoThinning">
            <summary>Constant DoThinning</summary>
            <unmanaged>MF_EVENT_DO_THINNING</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EventAttributeKeys.TransformContext">
            <summary>Constant TransformContext</summary>
            <unmanaged>MF_EVENT_MFT_CONTEXT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EventAttributeKeys.TransformInputStreamId">
            <summary>Constant TransformInputStreamId</summary>
            <unmanaged>MF_EVENT_MFT_INPUT_STREAM_ID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EventAttributeKeys.OutputNode">
            <summary>Constant OutputNode</summary>
            <unmanaged>MF_EVENT_OUTPUT_NODE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EventAttributeKeys.PresentationTimeOffset">
            <summary>Constant PresentationTimeOffset</summary>
            <unmanaged>MF_EVENT_PRESENTATION_TIME_OFFSET</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EventAttributeKeys.ScrubsampleTime">
            <summary>Constant ScrubsampleTime</summary>
            <unmanaged>MF_EVENT_SCRUBSAMPLE_TIME</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EventAttributeKeys.Sessioncaps">
            <summary>Constant Sessioncaps</summary>
            <unmanaged>MF_EVENT_SESSIONCAPS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EventAttributeKeys.SessioncapsDelta">
            <summary>Constant SessioncapsDelta</summary>
            <unmanaged>MF_EVENT_SESSIONCAPS_DELTA</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EventAttributeKeys.SourceActualStart">
            <summary>Constant SourceActualStart</summary>
            <unmanaged>MF_EVENT_SOURCE_ACTUAL_START</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EventAttributeKeys.SourceCharacteristics">
            <summary>Constant SourceCharacteristics</summary>
            <unmanaged>MF_EVENT_SOURCE_CHARACTERISTICS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EventAttributeKeys.SourceCharacteristicsOld">
            <summary>Constant SourceCharacteristicsOld</summary>
            <unmanaged>MF_EVENT_SOURCE_CHARACTERISTICS_OLD</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EventAttributeKeys.SourceFakeStart">
            <summary>Constant SourceFakeStart</summary>
            <unmanaged>MF_EVENT_SOURCE_FAKE_START</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EventAttributeKeys.SourceProjectstart">
            <summary>Constant SourceProjectstart</summary>
            <unmanaged>MF_EVENT_SOURCE_PROJECTSTART</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EventAttributeKeys.SourceTopologyCanceled">
            <summary>Constant SourceTopologyCanceled</summary>
            <unmanaged>MF_EVENT_SOURCE_TOPOLOGY_CANCELED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EventAttributeKeys.StartPresentationTime">
            <summary>Constant StartPresentationTime</summary>
            <unmanaged>MF_EVENT_START_PRESENTATION_TIME</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EventAttributeKeys.StartPresentationTimeAtOutput">
            <summary>Constant StartPresentationTimeAtOutput</summary>
            <unmanaged>MF_EVENT_START_PRESENTATION_TIME_AT_OUTPUT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EventAttributeKeys.TopologyStatus">
            <summary>Constant TopologyStatus</summary>
            <unmanaged>MF_EVENT_TOPOLOGY_STATUS</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.EVRAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRAttributeKeys.SaRequiredSampleCount">
            <summary>Constant SaRequiredSampleCount</summary>
            <unmanaged>MF_SA_REQUIRED_SAMPLE_COUNT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRAttributeKeys.VideoZoomRect">
            <summary>Constant VideoZoomRect</summary>
            <unmanaged>VIDEO_ZOOM_RECT</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.EVRConfigAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRConfigAttributeKeys.AllowBatching">
            <summary>Constant AllowBatching</summary>
            <unmanaged>EVRConfig_AllowBatching</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRConfigAttributeKeys.AllowDropToBob">
            <summary>Constant AllowDropToBob</summary>
            <unmanaged>EVRConfig_AllowDropToBob</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRConfigAttributeKeys.AllowDropToHalfInterlace">
            <summary>Constant AllowDropToHalfInterlace</summary>
            <unmanaged>EVRConfig_AllowDropToHalfInterlace</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRConfigAttributeKeys.AllowDropToThrottle">
            <summary>Constant AllowDropToThrottle</summary>
            <unmanaged>EVRConfig_AllowDropToThrottle</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRConfigAttributeKeys.AllowScaling">
            <summary>Constant AllowScaling</summary>
            <unmanaged>EVRConfig_AllowScaling</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRConfigAttributeKeys.ForceBatching">
            <summary>Constant ForceBatching</summary>
            <unmanaged>EVRConfig_ForceBatching</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRConfigAttributeKeys.ForceBob">
            <summary>Constant ForceBob</summary>
            <unmanaged>EVRConfig_ForceBob</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRConfigAttributeKeys.ForceHalfInterlace">
            <summary>Constant ForceHalfInterlace</summary>
            <unmanaged>EVRConfig_ForceHalfInterlace</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRConfigAttributeKeys.ForceScaling">
            <summary>Constant ForceScaling</summary>
            <unmanaged>EVRConfig_ForceScaling</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRConfigAttributeKeys.ForceThrottle">
            <summary>Constant ForceThrottle</summary>
            <unmanaged>EVRConfig_ForceThrottle</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.EVRCustomVideoAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRCustomVideoAttributeKeys.MixerActivate">
            <summary>Constant MixerActivate</summary>
            <unmanaged>MF_ACTIVATE_CUSTOM_VIDEO_MIXER_ACTIVATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRCustomVideoAttributeKeys.MixerClsid">
            <summary>Constant MixerClsid</summary>
            <unmanaged>MF_ACTIVATE_CUSTOM_VIDEO_MIXER_CLSID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRCustomVideoAttributeKeys.MixerFlags">
            <summary>Constant MixerFlags</summary>
            <unmanaged>MF_ACTIVATE_CUSTOM_VIDEO_MIXER_FLAGS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRCustomVideoAttributeKeys.PresenterActivate">
            <summary>Constant PresenterActivate</summary>
            <unmanaged>MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_ACTIVATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRCustomVideoAttributeKeys.PresenterClsid">
            <summary>Constant PresenterClsid</summary>
            <unmanaged>MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_CLSID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRCustomVideoAttributeKeys.PresenterFlags">
            <summary>Constant PresenterFlags</summary>
            <unmanaged>MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_FLAGS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.EVRCustomVideoAttributeKeys.ActivateVideoWindow">
            <summary>Constant ActivateVideoWindow</summary>
            <unmanaged>MF_ACTIVATE_VIDEO_WINDOW</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaAttributeKeys.UserDataPayload">
            <summary>Constant UserDataPayload</summary>
            <unmanaged>MF_USER_DATA_PAYLOAD</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaAttributeKeys.XvpDisableFrc">
            <summary>Constant XvpDisableFrc</summary>
            <unmanaged>MF_XVP_DISABLE_FRC</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaAttributeKeys.LocalPluginControlPolicy">
            <summary>Constant LocalPluginControlPolicy</summary>
            <unmanaged>MF_LOCAL_PLUGIN_CONTROL_POLICY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaAttributeKeys.SourceStreamSupportsHardwareConnection">
            <summary>Constant SourceStreamSupportsHardwareConnection</summary>
            <unmanaged>MF_SOURCE_STREAM_SUPPORTS_HW_CONNECTION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaAttributeKeys.SupportsHardwareConnection">
            <summary>Constant SupportsHardwareConnection</summary>
            <unmanaged>MF_STREAM_SINK_SUPPORTS_HW_CONNECTION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaAttributeKeys.SupportsRotation">
            <summary>Constant SupportsRotation</summary>
            <unmanaged>MF_STREAM_SINK_SUPPORTS_ROTATION</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaEngineAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineAttributeKeys.AudioCategory">
            <summary>Constant AudioCategory</summary>
            <unmanaged>MF_MEDIA_ENGINE_AUDIO_CATEGORY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineAttributeKeys.AudioEndpointRole">
            <summary>Constant AudioEndpointRole</summary>
            <unmanaged>MF_MEDIA_ENGINE_AUDIO_ENDPOINT_ROLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineAttributeKeys.Callback">
            <summary>Constant Callback</summary>
            <unmanaged>MF_MEDIA_ENGINE_CALLBACK</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineAttributeKeys.ContentProtectionFlags">
            <summary>Constant ContentProtectionFlags</summary>
            <unmanaged>MF_MEDIA_ENGINE_CONTENT_PROTECTION_FLAGS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineAttributeKeys.ContentProtectionManager">
            <summary>Constant ContentProtectionManager</summary>
            <unmanaged>MF_MEDIA_ENGINE_CONTENT_PROTECTION_MANAGER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineAttributeKeys.DxgiManager">
            <summary>Constant DxgiManager</summary>
            <unmanaged>MF_MEDIA_ENGINE_DXGI_MANAGER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineAttributeKeys.Extension">
            <summary>Constant Extension</summary>
            <unmanaged>MF_MEDIA_ENGINE_EXTENSION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineAttributeKeys.OpmHwnd">
            <summary>Constant OpmHwnd</summary>
            <unmanaged>MF_MEDIA_ENGINE_OPM_HWND</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineAttributeKeys.PlaybackHwnd">
            <summary>Constant PlaybackHwnd</summary>
            <unmanaged>MF_MEDIA_ENGINE_PLAYBACK_HWND</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineAttributeKeys.PlaybackVisual">
            <summary>Constant PlaybackVisual</summary>
            <unmanaged>MF_MEDIA_ENGINE_PLAYBACK_VISUAL</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaEngineAttributeKeys.VideoOutputFormat">
            <summary>Constant VideoOutputFormat</summary>
            <unmanaged>MF_MEDIA_ENGINE_VIDEO_OUTPUT_FORMAT</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaFactory">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaFactory.Version">
            <summary>Constant Version</summary>
            <unmanaged>MF_VERSION</unmanaged>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateVideoPresenter(SharpDX.IUnknown,System.Guid,System.Guid,System.IntPtr@)">
            <summary>
            <p> </p><p>Creates the default video presenter for the enhanced video renderer (EVR).</p>
            </summary>
            <param name = "ownerRef"><dd> <p>Pointer to the owner of the object. If the object is aggregated, pass a reference to the aggregating object's <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface. Otherwise, set this parameter to <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "riidDevice"><dd> <p>Interface identifier (IID) of the video device interface that will be used for processing the video. Currently the only supported value is IID_IDirect3DDevice9.</p> </dd></param>
            <param name = "riid"><dd> <p>IID of the requested interface on the video presenter. The video presenter exposes the <strong><see cref = "T:SharpDX.MediaFoundation.VideoPresenter"/></strong> interface.</p> </dd></param>
            <param name = "videoPresenterOut"><dd> <p>Receives a reference to the requested interface on the video presenter. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms693842</doc-id>
            <unmanaged>HRESULT MFCreateVideoPresenter([In, Optional] IUnknown* pOwner,[In] const GUID&amp; riidDevice,[In] const GUID&amp; riid,[Out, Optional] void** ppVideoPresenter)</unmanaged>
            <unmanaged-short>MFCreateVideoPresenter</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateVideoMixer(SharpDX.IUnknown,System.Guid,System.Guid,System.IntPtr@)">
            <summary>
            <p> </p><p>Creates the default video mixer for the enhanced video renderer (EVR).</p>
            </summary>
            <param name = "ownerRef"><dd> <p>Pointer to the owner of this object. If the object is aggregated, pass a reference to the aggregating object's <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface. Otherwise, set this parameter to <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "riidDevice"><dd> <p>Interface identifier (IID) of the video device interface that will be used for processing the video. Currently the only supported value is IID_IDirect3DDevice9.</p> </dd></param>
            <param name = "riid"><dd> <p>IID of the requested interface on the video mixer.  The video mixer exposes the <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> interface.</p> </dd></param>
            <param name = "vOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms705653</doc-id>
            <unmanaged>HRESULT MFCreateVideoMixer([In, Optional] IUnknown* pOwner,[In] const GUID&amp; riidDevice,[In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>
            <unmanaged-short>MFCreateVideoMixer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateVideoMixerAndPresenter(SharpDX.IUnknown,SharpDX.IUnknown,System.Guid,System.IntPtr@,System.Guid,System.IntPtr@)">
            <summary>
            <p> </p><p>Creates the default video mixer and video presenter for the enhanced video renderer (EVR).</p>
            </summary>
            <param name = "mixerOwnerRef"><dd> <p>Pointer to the owner of the video mixer. If the mixer is aggregated, pass a reference to the aggregating object's <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface. Otherwise, set this parameter to <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "presenterOwnerRef"><dd> <p>Pointer to the owner of the video presenter. If the presenter is aggregated, pass a reference to the aggregating object's <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface. Otherwise, set this parameter to <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "riidMixer"><dd> <p>Interface identifier (IID) of the requested interface on the video mixer. The video mixer exposes the <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> interface.</p> </dd></param>
            <param name = "vVideoMixerOut"><dd> <p>Receives a reference to the requested interface on the video mixer. The caller must release the interface.</p> </dd></param>
            <param name = "riidPresenter"><dd> <p>IID of the requested interface on the video presenter. The video presenter exposes the <strong><see cref = "T:SharpDX.MediaFoundation.VideoPresenter"/></strong> interface.</p> </dd></param>
            <param name = "vVideoPresenterOut"><dd> <p>Receives a reference to the requested interface on the video presenter. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms694842</doc-id>
            <unmanaged>HRESULT MFCreateVideoMixerAndPresenter([In, Optional] IUnknown* pMixerOwner,[In, Optional] IUnknown* pPresenterOwner,[In] const GUID&amp; riidMixer,[Out] void** ppvVideoMixer,[In] const GUID&amp; riidPresenter,[Out] void** ppvVideoPresenter)</unmanaged>
            <unmanaged-short>MFCreateVideoMixerAndPresenter</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateVideoRenderer(System.Guid,System.IntPtr@)">
            <summary>
            <p> </p><p>Creates an instance of the enhanced video renderer (EVR) media sink.</p>
            </summary>
            <param name = "riidRenderer"><dd> <p>Interface identifier (IID) of the requested interface on the EVR.</p> </dd></param>
            <param name = "videoRendererOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This function creates the Media Foundation version of the EVR. To create the DirectShow EVR filter, call <strong>CoCreateInstance</strong> with the class identifier CLSID_EnhancedVideoRenderer.</p>
            </remarks>
            <doc-id>ms703814</doc-id>
            <unmanaged>HRESULT MFCreateVideoRenderer([In] const GUID&amp; riidRenderer,[Out, Optional] void** ppVideoRenderer)</unmanaged>
            <unmanaged-short>MFCreateVideoRenderer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateVideoSampleFromSurface(SharpDX.IUnknown)">
            <summary>
            <p> Creates a media sample that manages a Direct3D surface. </p>
            </summary>
            <param name = "unkSurfaceRef"><dd> <p> A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of the Direct3D surface. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
            <returns><dd> <p> Receives a reference to the sample's <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface. The caller must release the interface.</p> </dd></returns>
            <remarks>
            <p>The media sample created by this function exposes the following interfaces in addition to <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong>:</p><ul> <li> <strong><see cref = "T:SharpDX.MediaFoundation.DesiredSample"/></strong> </li> <li> <strong><see cref = "T:SharpDX.MediaFoundation.TrackedSample"/></strong> </li> </ul><p>If <em>pUnkSurface</em> is non-<strong><c>null</c></strong>, the sample contains a single media buffer, which holds a reference to the Direct3D surface. To get the Direct3D surface from the media buffer, call <strong>IMFGetService::GetService</strong> on the buffer, using the service identifier <see cref = "!:Buffer"/>. The media buffer does not implement <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2D"/></strong>, nor does it implement the <strong>IMFMediaBuffer::Lock</strong> and <strong>Unlock</strong> methods.</p><p>Alternatively, you can set <em>pUnkSurface</em> to <strong><c>null</c></strong>, and later add a DirectX surface buffer to the sample by calling <strong>IMFSample::AddBuffer</strong>. To create a DirectX surface buffer, call <strong>MFCreateDXSurfaceBuffer</strong>.</p>
            </remarks>
            <doc-id>ms703859</doc-id>
            <unmanaged>HRESULT MFCreateVideoSampleFromSurface([In] IUnknown* pUnkSurface,[Out] IMFSample** ppSample)</unmanaged>
            <unmanaged-short>MFCreateVideoSampleFromSurface</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateVideoSampleAllocator(System.Guid,System.IntPtr@)">
            <summary>
            <p>Creates an object that allocates video samples.</p>
            </summary>
            <param name = "riid"><dd> <p>The identifier of the interface to retrieve. Specify one of the following values:</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong>IID_IUnknown</strong></strong></dt> </dl> </td><td> <p>Retrieve an <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference.</p> </td></tr> <tr><td><dl> <dt><strong><strong>IID_IMFVideoSampleAllocator</strong></strong></dt> </dl> </td><td> <p>Retrieve an <strong><see cref = "T:SharpDX.MediaFoundation.VideoSampleAllocator"/></strong> reference.</p> </td></tr> <tr><td><dl> <dt><strong><strong>IID_IMFVideoSampleAllocatorCallback</strong></strong></dt> </dl> </td><td> <p>Retrieve an <strong><see cref = "T:SharpDX.MediaFoundation.VideoSampleAllocatorCallback"/></strong> reference.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "sampleAllocatorOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If the function succeeds, it returns <see cref = "F:SharpDX.Result.Ok"/>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ff384864</doc-id>
            <unmanaged>HRESULT MFCreateVideoSampleAllocator([In] const GUID&amp; riid,[Out] void** ppSampleAllocator)</unmanaged>
            <unmanaged-short>MFCreateVideoSampleAllocator</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.PCreateMediaPlayer(System.String,SharpDX.Mathematics.Interop.RawBool,System.Int32,SharpDX.MediaFoundation.PMediaPlayerCallback,System.IntPtr,SharpDX.MediaFoundation.PMediaPlayer@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Creates a new instance of the MFPlay player object.</p>
            </summary>
            <param name = "wszURLRef">No documentation.</param>
            <param name = "fStartPlayback">No documentation.</param>
            <param name = "creationOptions">No documentation.</param>
            <param name = "callbackRef">No documentation.</param>
            <param name = "hWnd">No documentation.</param>
            <param name = "mediaPlayerOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Before calling this function, call <strong>CoIntialize(Ex)</strong> from the same thread to initialize the COM library.</p><p>Internally, <strong>MFPCreateMediaPlayer</strong> calls <strong>MFStartup</strong> to initialize the Microsoft Media Foundation platform. When the player object is destroyed, it calls  <strong>MFShutdown</strong> to shut down the platform. It is not necessary for an application to call <strong>MFStartup</strong> or <strong>MFShutdown</strong> when using MFPlay.</p><strong>Note</strong>??If you use other Media Foundation APIs outside the life time of the player object, then your application should call <strong>MFStartup</strong> and <strong>MFShutdown</strong>.?
            </remarks>
            <doc-id>dd375520</doc-id>
            <unmanaged>HRESULT MFPCreateMediaPlayer([In, Optional] const wchar_t* pwszURL,[In] BOOL fStartPlayback,[In, Optional] unsigned int creationOptions,[In, Optional] IMFPMediaPlayerCallback* pCallback,[In, Optional] HWND hWnd,[Out, Optional] IMFPMediaPlayer** ppMediaPlayer)</unmanaged>
            <unmanaged-short>MFPCreateMediaPlayer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateASFContentInfo(SharpDX.MediaFoundation.ASFContentInfo@)">
            <summary>
            <p> </p><p>Creates the ASF Header Object object.</p>
            </summary>
            <param name = "iContentInfoOut">No documentation.</param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970315</doc-id>
            <unmanaged>HRESULT MFCreateASFContentInfo([In] IMFASFContentInfo** ppIContentInfo)</unmanaged>
            <unmanaged-short>MFCreateASFContentInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateASFProfile(SharpDX.MediaFoundation.ASFProfile@)">
            <summary>
            <p> </p><p>Creates the ASF profile object.</p>
            </summary>
            <param name = "iProfileOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFProfile"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms705632</doc-id>
            <unmanaged>HRESULT MFCreateASFProfile([In] IMFASFProfile** ppIProfile)</unmanaged>
            <unmanaged-short>MFCreateASFProfile</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateASFProfileFromPresentationDescriptor(SharpDX.MediaFoundation.PresentationDescriptor,SharpDX.MediaFoundation.ASFProfile@)">
            <summary>
            <p> </p><p>Creates an ASF profile object from a presentation descriptor.</p>
            </summary>
            <param name = "iPDRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the presentation descriptor that contains the profile information.</p> </dd></param>
            <param name = "iProfileOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFProfile"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms694279</doc-id>
            <unmanaged>HRESULT MFCreateASFProfileFromPresentationDescriptor([In] IMFPresentationDescriptor* pIPD,[In] IMFASFProfile** ppIProfile)</unmanaged>
            <unmanaged-short>MFCreateASFProfileFromPresentationDescriptor</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreatePresentationDescriptorFromASFProfile(SharpDX.MediaFoundation.ASFProfile,SharpDX.MediaFoundation.PresentationDescriptor@)">
            <summary>
            <p> </p><p>Creates a presentation descriptor from an ASF profile object.</p>
            </summary>
            <param name = "iProfileRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFProfile"/></strong> interface of the ASF profile object.</p> </dd></param>
            <param name = "iPDOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms704656</doc-id>
            <unmanaged>HRESULT MFCreatePresentationDescriptorFromASFProfile([In] IMFASFProfile* pIProfile,[In] IMFPresentationDescriptor** ppIPD)</unmanaged>
            <unmanaged-short>MFCreatePresentationDescriptorFromASFProfile</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateASFSplitter(SharpDX.MediaFoundation.ASFSplitter@)">
            <summary>
            <p> </p><p>Creates the ASF Splitter.</p>
            </summary>
            <param name = "iSplitterOut">No documentation.</param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970321</doc-id>
            <unmanaged>HRESULT MFCreateASFSplitter([In] IMFASFSplitter** ppISplitter)</unmanaged>
            <unmanaged-short>MFCreateASFSplitter</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateASFMultiplexer(SharpDX.MediaFoundation.ASFMultiplexer@)">
            <summary>
            <p> </p><p>Creates the ASF Multiplexer.</p>
            </summary>
            <param name = "iMultiplexerOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFMultiplexer"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970397</doc-id>
            <unmanaged>HRESULT MFCreateASFMultiplexer([In] IMFASFMultiplexer** ppIMultiplexer)</unmanaged>
            <unmanaged-short>MFCreateASFMultiplexer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateASFIndexer(SharpDX.MediaFoundation.ASFIndexer@)">
            <summary>
            <p> </p><p>Creates the ASF Indexer object.</p>
            </summary>
            <param name = "iIndexerOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFIndexer"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms704561</doc-id>
            <unmanaged>HRESULT MFCreateASFIndexer([In] IMFASFIndexer** ppIIndexer)</unmanaged>
            <unmanaged-short>MFCreateASFIndexer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateASFIndexerByteStream(SharpDX.MediaFoundation.IByteStream,System.Int64,SharpDX.MediaFoundation.IByteStream@)">
            <summary>
            <p> </p><p>Creates a byte stream to access the index in an ASF stream.</p>
            </summary>
            <param name = "iContentByteStreamRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream that contains the ASF stream.</p> </dd></param>
            <param name = "cbIndexStartOffset"><dd> <p>Byte offset of the index within the ASF stream. To get this value, call <strong>IMFASFIndexer::GetIndexPosition</strong>.</p> </dd></param>
            <param name = "iIndexByteStreamRef"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface. Use this interface to read from the index or write to the index. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table:</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The call succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Unexpected"/></strong></dt> </dl> </td><td> <p>The offset specified in <em>cbIndexStartOffset</em> is invalid.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970563</doc-id>
            <unmanaged>HRESULT MFCreateASFIndexerByteStream([In] IMFByteStream* pIContentByteStream,[In] unsigned longlong cbIndexStartOffset,[In] IMFByteStream** pIIndexByteStream)</unmanaged>
            <unmanaged-short>MFCreateASFIndexerByteStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateASFStreamSelector(SharpDX.MediaFoundation.ASFProfile,SharpDX.MediaFoundation.ASFStreamSelector@)">
            <summary>
            <p> </p><p>Creates the ASF stream selector.</p>
            </summary>
            <param name = "iASFProfileRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFProfile"/></strong> interface.</p> </dd></param>
            <param name = "selectorOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFStreamSelector"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms698963</doc-id>
            <unmanaged>HRESULT MFCreateASFStreamSelector([In] IMFASFProfile* pIASFProfile,[In] IMFASFStreamSelector** ppSelector)</unmanaged>
            <unmanaged-short>MFCreateASFStreamSelector</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateASFMediaSink(SharpDX.MediaFoundation.IByteStream,SharpDX.MediaFoundation.MediaSink@)">
            <summary>
            <p> </p><p>Creates the ASF media sink.</p>
            </summary>
            <param name = "iByteStreamRef"><dd> <p>Pointer to a byte stream that will be used to write the ASF stream.</p> </dd></param>
            <param name = "iMediaSinkOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSink"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms703955</doc-id>
            <unmanaged>HRESULT MFCreateASFMediaSink([In] IMFByteStream* pIByteStream,[In] IMFMediaSink** ppIMediaSink)</unmanaged>
            <unmanaged-short>MFCreateASFMediaSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateASFMediaSinkActivate(System.String,SharpDX.MediaFoundation.ASFContentInfo,SharpDX.MediaFoundation.Activate@)">
            <summary>
            <p> </p><p>Creates an activation object that can be used to create the ASF media sink.</p>
            </summary>
            <param name = "wszFileNameRef"><dd> <p>Null-terminated wide-character string that contains the output file name.</p> </dd></param>
            <param name = "contentInfoRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFContentInfo"/></strong> interface of an initialized ASF Header Object object. Use this interface to configure the ASF media sink.</p> </dd></param>
            <param name = "iActivateOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970403</doc-id>
            <unmanaged>HRESULT MFCreateASFMediaSinkActivate([In] const wchar_t* pwszFileName,[In] IMFASFContentInfo* pContentInfo,[In] IMFActivate** ppIActivate)</unmanaged>
            <unmanaged-short>MFCreateASFMediaSinkActivate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateWMVEncoderActivate(SharpDX.MediaFoundation.MediaType,SharpDX.ComObject,SharpDX.MediaFoundation.Activate@)">
            <summary>
            <p> Creates an activation object that can be used to create a Windows Media Video (WMV) encoder. </p>
            </summary>
            <param name = "mediaTypeRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. This parameter specifies the encoded output format.</p> </dd></param>
            <param name = "encodingConfigurationPropertiesRef"><dd> <p> A reference to the <strong><see cref = "T:SharpDX.ComObject"/></strong> interface of a property store that contains encoding parameters. Encoding parameters for the WMV encoder are defined in the header file wmcodecdsp.h. If you have an ASF ContentInfo object that contains an ASF profile object with all the streams for the output file, you can get the property store by calling <strong>IMFASFContentInfo::GetEncodingConfigurationPropertyStore</strong>. </p> </dd></param>
            <param name = "activateOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface. Use this interface to create the encoder. The caller must release the interface. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ms705622</doc-id>
            <unmanaged>HRESULT MFCreateWMVEncoderActivate([In] IMFMediaType* pMediaType,[In] IPropertyStore* pEncodingConfigurationProperties,[In] IMFActivate** ppActivate)</unmanaged>
            <unmanaged-short>MFCreateWMVEncoderActivate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateWMAEncoderActivate(SharpDX.MediaFoundation.MediaType,SharpDX.ComObject,SharpDX.MediaFoundation.Activate@)">
            <summary>
            <p> Creates an activation object that can be used to create a Windows Media Audio (WMA) encoder. </p>
            </summary>
            <param name = "mediaTypeRef"><dd> <p> A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. This parameter specifies the encoded output format.</p> </dd></param>
            <param name = "encodingConfigurationPropertiesRef"><dd> <p> A reference to the <strong><see cref = "T:SharpDX.ComObject"/></strong> interface of a property store that contains encoding parameters. Encoding parameters for the WMV encoder are defined in the header file wmcodecdsp.h. If you have an ASF ContentInfo object that contains an ASF profile object with all the streams for the output file, you can get the property store by calling <strong>IMFASFContentInfo::GetEncodingConfigurationPropertyStore</strong>. </p> </dd></param>
            <param name = "activateOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface. Use this interface to create the encoder. The caller must release the interface. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ms702208</doc-id>
            <unmanaged>HRESULT MFCreateWMAEncoderActivate([In] IMFMediaType* pMediaType,[In] IPropertyStore* pEncodingConfigurationProperties,[In] IMFActivate** ppActivate)</unmanaged>
            <unmanaged-short>MFCreateWMAEncoderActivate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateASFStreamingMediaSink(SharpDX.MediaFoundation.IByteStream,SharpDX.MediaFoundation.MediaSink@)">
            <summary>
            <p>Creates an activation object for the ASF streaming sink.</p><p>The  ASF streaming sink enables  an application to write streaming Advanced Systems Format (ASF)  packets to an HTTP byte stream. </p>
            </summary>
            <param name = "iByteStreamRef"><dd> <p> A reference to a byte stream object in which the ASF media sink writes the streamed content.</p> </dd></param>
            <param name = "iMediaSinkOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSink"/></strong> interface of the ASF streaming-media sink object. To create the media sink, the application must call <strong>IMFActivate::ActivateObject</strong> on the received reference. The caller must release the interface reference.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>To create the ASF streaming sink in another process, call <strong>MFCreateASFStreamingMediaSinkActivate</strong>. </p><p>An application can get a reference to the ASF ContentInfo Object by calling <strong>IUnknown::QueryInterface</strong> on the media sink object received in the <em>ppIMediaSink</em> parameter. The ContentInfo object is used to set the encoder configuration settings, provide stream properties supplied by an ASF profile, and add metadata information. These configuration settings populate the various ASF header objects of the encoded ASF file. For more information, see  
            Setting Properties in the ContentInfo Object.</p>
            </remarks>
            <doc-id>dd388087</doc-id>
            <unmanaged>HRESULT MFCreateASFStreamingMediaSink([In] IMFByteStream* pIByteStream,[In] IMFMediaSink** ppIMediaSink)</unmanaged>
            <unmanaged-short>MFCreateASFStreamingMediaSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateASFStreamingMediaSinkActivate(SharpDX.MediaFoundation.Activate,SharpDX.MediaFoundation.ASFContentInfo,SharpDX.MediaFoundation.Activate@)">
            <summary>
            <p>Creates an activation object for the ASF streaming sink.</p><p>The  ASF streaming sink enables  an application to write streaming Advanced Systems Format (ASF)  packets to an HTTP byte stream. The activation object can be used to create the ASF streaming sink in another process.</p>
            </summary>
            <param name = "byteStreamActivateRef"><dd> <p>A reference to the  <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface of an activation object. The caller  implements this interface.  The <strong>IMFActivate::ActivateObject</strong> method of the activation object must create a byte-stream object. The byte stream exposes the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface. The ASF streaming sink will write data to this byte stream.</p> </dd></param>
            <param name = "contentInfoRef"><dd> <p>A reference to an ASF ContentInfo Object that contains the properties that describe the ASF content. These  settings can contain  stream settings, encoding properties, and metadata. For more information about these properties, see Setting Properties in the ContentInfo Object.</p> </dd></param>
            <param name = "iActivateOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface of the activation object that is used to create the ASF streaming-media sink. To create the media sink, the application must call <strong>IMFActivate::ActivateObject</strong> by using the received reference. The <strong>ActivateObject</strong> method also calls   <strong>IMFActivate::Activate</strong> on the byte stream activate object specified by  <em>pByteStreamActivate</em>, to create it so that the media sink can write streamed content in the byte stream. The caller must release the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface reference of the media sink activation object received in <em>ppIActivate</em>.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Starting in Windows?7, Media Foundation provides an ASF streaming  sink that writes the content in  a live streaming scenario. This function should be used in secure transcode scenarios where this  media sink needs to be created and configured in the remote
            process. Like the ASF file sink, the new media sink performs ASF related tasks such as writing the ASF header, generating data packets (muxing). The content is written to a caller-implemented byte stream such as an HTTP byte stream.
            The caller must also provide an activation object that media sink can use to create the byte stream remotely.  </p><p>In addition, it performs transcryption for streaming protected content. It hosts the Windows Media Digital Rights Management (DRM) for Network Devices Output Trust Authority (OTA) that handles the license request and response. For more information, see <strong><see cref = "T:SharpDX.MediaFoundation.DRMNetHelper"/></strong> interface.</p><p>The new media sink does not perform any time adjustments.  If the clock seeks, the timestamps are not changed.</p>
            </remarks>
            <doc-id>dd388090</doc-id>
            <unmanaged>HRESULT MFCreateASFStreamingMediaSinkActivate([In] IMFActivate* pByteStreamActivate,[In] IMFASFContentInfo* pContentInfo,[In] IMFActivate** ppIActivate)</unmanaged>
            <unmanaged-short>MFCreateASFStreamingMediaSinkActivate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.Startup(System.Int32,System.Int32)">
            <summary>
            <p>Initializes Microsoft Media Foundation.</p>
            </summary>
            <param name = "version"><dd> <p>Version number. Use the value <strong><see cref = "F:SharpDX.MediaFoundation.MediaFactory.Version"/></strong>, defined in mfapi.h.</p> </dd></param>
            <param name = "dwFlags"><dd> <p>This parameter is optional when using C++ but required in C. The value must be one of the following flags: </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>MFSTARTUP_NOSOCKET</dt> </dl> </td><td> <p> Do not initialize the sockets library. </p> </td></tr> <tr><td> <dl> <dt>MFSTARTUP_LITE</dt> </dl> </td><td> <p> Equivalent to MFSTARTUP_NOSOCKET. </p> </td></tr> <tr><td> <dl> <dt>MFSTARTUP_FULL</dt> </dl> </td><td> <p> Initialize the entire Media Foundation platform. This is the default value when <em>dwFlags</em> is not specified. </p> </td></tr> </table> <p>?</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:BadStartupVersion"/></strong></dt> </dl> </td><td> <p> The <em>Version</em> parameter requires a newer version of Media Foundation than the version that is running.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:DisabledInSafemode"/></strong></dt> </dl> </td><td> <p> The Media Foundation platform is disabled because the system was started in "Safe Mode" (fail-safe boot). </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>Media Foundation is not implemented on the system.  This error can occur if the media components are not present (See KB2703761 for more info). </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> An application must call this function before using Media Foundation. Before your application quits, call <strong>MFShutdown</strong> once for every previous call to <strong>MFStartup</strong>. </p><p> Do not call <strong>MFStartup</strong> or <strong>MFShutdown</strong> from work queue threads. For more information about work queues, see Work Queues. </p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms702238</doc-id>
            <unmanaged>HRESULT MFStartup([In] ULONG Version,[In] DWORD dwFlags)</unmanaged>
            <unmanaged-short>MFStartup</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.Shutdown">
            <summary>
            <p>Shuts down the Microsoft Media Foundation platform. Call this function once for every call to <strong>MFStartup</strong>. Do not call this function from work queue threads.</p>
            </summary>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms694273</doc-id>
            <unmanaged>HRESULT MFShutdown()</unmanaged>
            <unmanaged-short>MFShutdown</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.LockPlatform">
            <summary>
            <p> </p><p>Blocks the <strong>MFShutdown</strong> function.</p>
            </summary>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This function prevents work queue threads from being shut down when <strong>MFShutdown</strong> is called. Use this function to ensure that asynchronous operations complete gracefully before the platform shuts down.</p><p>This function holds a lock on the Media Foundation platform. To unlock the platform, call <strong>MFUnlockPlatform</strong>. The application must call <strong>MFUnlockPlatform</strong> once for every call to <strong>MFLockPlatform</strong>.</p><p>The <strong>MFShutdown</strong> function blocks until the platform is unlocked, or until a fixed wait period has elapsed. (The wait period is a few seconds.) To avoid memory leaks, the application should unlock the platform before the wait period ends. For example, cancel any asynchronous operations that are waiting to complete and are holding a lock on the platform.</p><p>The default implementation of the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface automatically locks the Media Foundation platform when the result object is created. Releasing the interface unlocks the platform. Therefore, in most cases your application does not need to lock the platform directly. For more information, see Work Queues.</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms693588</doc-id>
            <unmanaged>HRESULT MFLockPlatform()</unmanaged>
            <unmanaged-short>MFLockPlatform</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.UnlockPlatform">
            <summary>
            <p> </p><p>Unlocks the Media Foundation platform after it was locked by a call to the <strong>MFLockPlatform</strong> function.</p>
            </summary>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The application must call <strong>MFUnlockPlatform</strong> once for every call to <strong>MFLockPlatform</strong>.</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms703879</doc-id>
            <unmanaged>HRESULT MFUnlockPlatform()</unmanaged>
            <unmanaged-short>MFUnlockPlatform</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.PutWorkItem(System.Int32,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p> Puts an asynchronous operation on a work queue.</p>
            </summary>
            <param name = "dwQueue"><dd> <p> The identifier for the work queue. This value can specify one of the standard Media Foundation work queues, or a work queue created by the application. For list of standard Media Foundation work queues, see <strong>Work Queue Identifiers</strong>. To create a new work queue, call <strong>MFAllocateWorkQueue</strong> or <strong>MFAllocateWorkQueueEx</strong>. </p> </dd></param>
            <param name = "callbackRef"><dd> <p> A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface. The caller must implement this interface. </p> </dd></param>
            <param name = "stateRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Possible values include the following.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidWorkqueue"/></strong></strong></dt> </dl> </td><td> <p>Invalid work queue. For more information, see <strong>IMFAsyncCallback::GetParameters</strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong>MFStartup</strong> function was not called, or <strong>MFShutdown</strong> was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> This function creates an asynchronous result object and puts the result object on the work queue. The work queue calls the <strong>IMFAsyncCallback::Invoke</strong> method specified by <em>pCallback</em>. </p>
            </remarks>
            <doc-id>ms702164</doc-id>
            <unmanaged>HRESULT MFPutWorkItem([In] DWORD dwQueue,[In] IMFAsyncCallback* pCallback,[In] IUnknown* pState)</unmanaged>
            <unmanaged-short>MFPutWorkItem</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.PutWorkItem2(System.Int32,System.Int32,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p> Puts an asynchronous operation on a work queue, with a specified priority.</p>
            </summary>
            <param name = "dwQueue"><dd> <p> The identifier for the work queue. This value can specify one of the standard Media Foundation work queues, or a work queue created by the application. For list of standard Media Foundation work queues, see <strong>Work Queue Identifiers</strong>. To create a new work queue, call <strong>MFAllocateWorkQueue</strong> or  MFAllocateWorkQueueEx. </p> </dd></param>
            <param name = "priority"><dd> <p>The priority of the work item. Work items are performed in order of priority.</p> </dd></param>
            <param name = "callbackRef"><dd> <p> A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface. The caller must implement this interface. </p> </dd></param>
            <param name = "stateRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Possible values include the following.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidWorkqueue"/></strong></strong></dt> </dl> </td><td> <p>Invalid work queue identifier.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong>MFStartup</strong> function was not called, or <strong>MFShutdown</strong> was called.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>hh162784</doc-id>
            <unmanaged>HRESULT MFPutWorkItem2([In] DWORD dwQueue,[In] LONG Priority,[In] IMFAsyncCallback* pCallback,[In, Optional] IUnknown* pState)</unmanaged>
            <unmanaged-short>MFPutWorkItem2</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.PutWorkItemEx(System.Int32,SharpDX.MediaFoundation.AsyncResult)">
            <summary>
            <p> Puts an asynchronous operation on a work queue. </p>
            </summary>
            <param name = "dwQueue"><dd> <p>The identifier for the work queue. This value can specify one of the standard Media Foundation work queues, or a work queue created by the application. For list of standard Media Foundation work queues, see <strong>Work Queue Identifiers</strong>. To create a new work queue, call <strong>MFAllocateWorkQueue</strong> or <strong>MFAllocateWorkQueueEx</strong>. </p> </dd></param>
            <param name = "resultRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface of an asynchronous result object. To create the result object, call <strong>MFCreateAsyncResult</strong>. </p> </dd></param>
            <returns><p> Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Possible values include the following.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p> Success.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidWorkqueue"/></strong></strong></dt> </dl> </td><td> <p>Invalid work queue identifier. For more information, see <strong>IMFAsyncCallback::GetParameters</strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong>MFStartup</strong> function was not called, or <strong>MFShutdown</strong> was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> To invoke the work-item, this function passes <em>pResult</em> to the <strong>MFInvokeCallback</strong> function. The callback is specified when you create the result object specified by <em>pResult</em>. </p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms697572</doc-id>
            <unmanaged>HRESULT MFPutWorkItemEx([In] DWORD dwQueue,[In] IMFAsyncResult* pResult)</unmanaged>
            <unmanaged-short>MFPutWorkItemEx</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.PutWorkItemEx2(System.Int32,System.Int32,SharpDX.MediaFoundation.AsyncResult)">
            <summary>
            <p>Puts an asynchronous operation on a work queue, with a specified priority.</p>
            </summary>
            <param name = "dwQueue"><dd> <p> The identifier for the work queue. This value can specify one of the standard Media Foundation work queues, or a work queue created by the application. For list of standard Media Foundation work queues, see <strong>Work Queue Identifiers</strong>. To create a new work queue, call <strong>MFAllocateWorkQueue</strong> or  <strong>MFAllocateWorkQueueEx</strong>.</p> </dd></param>
            <param name = "priority"><dd> <p>The priority of the work item. Work items are performed in order of priority.</p> </dd></param>
            <param name = "resultRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface of an asynchronous result object. To create the result object, call <strong>MFCreateAsyncResult</strong>.</p> </dd></param>
            <returns><p> Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Possible values include the following.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p> Success.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidWorkqueue"/></strong></strong></dt> </dl> </td><td> <p>Invalid work queue identifier.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong>MFStartup</strong> function was not called, or <strong>MFShutdown</strong> was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> To invoke the work item, this function passes <em>pResult</em> to the <strong>MFInvokeCallback</strong> function. The callback is specified when you create the result object specified by <em>pResult</em>. </p>
            </remarks>
            <doc-id>hh162785</doc-id>
            <unmanaged>HRESULT MFPutWorkItemEx2([In] DWORD dwQueue,[In] LONG Priority,[In] IMFAsyncResult* pResult)</unmanaged>
            <unmanaged-short>MFPutWorkItemEx2</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.PutWaitingWorkItem(System.IntPtr,System.Int32,SharpDX.MediaFoundation.AsyncResult,System.Int64@)">
            <summary>
            <p>Queues a work item that waits for an event to be signaled.</p>
            </summary>
            <param name = "hEvent"><dd> <p>A handle to an event object. To create an event object, call <strong>CreateEvent</strong> or <strong>CreateEventEx</strong>.</p> </dd></param>
            <param name = "priority"><dd> <p>The priority of the work item. Work items are performed in order of priority.</p> </dd></param>
            <param name = "resultRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface of an asynchronous result object. To create the result object, call <strong>MFCreateAsyncResult</strong>.</p> </dd></param>
            <param name = "keyRef"><dd> <p>Receives a key that can be used to cancel the wait. To cancel the wait, call <strong>MFCancelWorkItem</strong> and pass this key in the <em>Key</em> parameter. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function enables a component to wait for an event without blocking the current thread. </p><p>The function puts a work item on the specified work queue. This work item waits for the event given in <em>hEvent</em> to be signaled. When the event is signaled, the work item invokes a callback. (The callback is contained in the result object given in <em>pResult</em>. For more information, see <strong>MFCreateAsyncResult</strong>).</p><p>The work item is dispatched on a work queue by the <strong>IMFAsyncCallback::GetParameters</strong> method of the callback. The work queue can be any of the following:</p><ul> <li>The default work queue (<strong>MFASYNC_CALLBACK_QUEUE_STANDARD</strong>).</li> <li>The platform multithreaded queue (<strong>MFASYNC_CALLBACK_QUEUE_MULTITHREADED</strong>).</li> <li>A multithreaded queue returned by the <strong>MFLockSharedWorkQueue</strong> function.</li> <li>A serial queue created by the <strong>MFAllocateSerialWorkQueue</strong> function.</li> </ul><p>Do not use any of the following work queues: <strong>MFASYNC_CALLBACK_QUEUE_IO</strong>, <strong>MFASYNC_CALLBACK_QUEUE_LONG_FUNCTION</strong>, <strong>MFASYNC_CALLBACK_QUEUE_RT</strong>, or <strong>MFASYNC_CALLBACK_QUEUE_TIMER</strong>.</p>
            </remarks>
            <doc-id>hh162783</doc-id>
            <unmanaged>HRESULT MFPutWaitingWorkItem([In] void* hEvent,[In] LONG Priority,[In] IMFAsyncResult* pResult,[Out, Optional] unsigned longlong* pKey)</unmanaged>
            <unmanaged-short>MFPutWaitingWorkItem</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.AllocateSerialWorkQueue(System.Int32,System.Int32@)">
            <summary>
            <p>Creates a work queue that is guaranteed to serialize work items. The serial work queue wraps an existing multithreaded work queue. The serial work queue enforces a first-in, first-out (FIFO) execution order.</p>
            </summary>
            <param name = "dwWorkQueue"><dd> <p> The identifier of an existing work queue. This must be either a multithreaded queue or another serial work queue. Any of the following can be used:</p> <ul> <li>The default work queue (<strong>MFASYNC_CALLBACK_QUEUE_STANDARD</strong>)</li> <li>The platform multithreaded queue (<strong>MFASYNC_CALLBACK_QUEUE_MULTITHREADED</strong>)</li> <li>A multithreaded queue returned by the <strong>MFLockSharedWorkQueue</strong> function.</li> <li>A serial queue created by the <strong>MFAllocateSerialWorkQueue</strong> function.</li> </ul> </dd></param>
            <param name = "dwWorkQueueRef"><dd> <p>Receives an identifier for the new serial work queue. Use this identifier when queuing work items.</p> </dd></param>
            <returns><p>This function can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p> The application exceeded the maximum number of work queues. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong></dt> </dl> </td><td> <p> The application did not call <strong>MFStartup</strong>, or the application has already called <strong>MFShutdown</strong>. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>When you are done using the work queue, call <strong>MFUnlockWorkQueue</strong>.</p><p>Multithreaded queues use a thread pool, which  can reduce the total number of threads in the pipeline. However, they do not serialize work items. A serial work queue enables the application to get the benefits of the thread pool, without needing to perform manual serialization of its own work items.</p>
            </remarks>
            <doc-id>hh162744</doc-id>
            <unmanaged>HRESULT MFAllocateSerialWorkQueue([In] DWORD dwWorkQueue,[Out] DWORD* pdwWorkQueue)</unmanaged>
            <unmanaged-short>MFAllocateSerialWorkQueue</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.ScheduleWorkItemEx(SharpDX.MediaFoundation.AsyncResult,System.Int64,System.Int64@)">
            <summary>
            <p> </p><p>Schedules an asynchronous operation to be completed after a specified interval.</p>
            </summary>
            <param name = "resultRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface of an asynchronous result object. To create the result object, call <strong>MFCreateAsyncResult</strong>.</p> </dd></param>
            <param name = "timeout"><dd> <p>Time-out interval, in milliseconds. Set this parameter to a negative value. The callback is invoked after ?<em>Timeout</em> milliseconds. For example, if <em>Timeout</em> is ?5000, the callback is invoked after 5000 milliseconds.</p> </dd></param>
            <param name = "keyRef"><dd> <p>Receives a key that can be used to cancel the timer. To cancel the timer, call <strong>MFCancelWorkItem</strong> and pass this key in the <em>Key</em> parameter.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>When the timer interval elapses, the timer calls <strong>MFInvokeCallback</strong> with the <em>pResult</em> reference to invoke the asynchronous callback. The callback is specified when you create the result object.</p>
            </remarks>
            <doc-id>ms702259</doc-id>
            <unmanaged>HRESULT MFScheduleWorkItemEx([In] IMFAsyncResult* pResult,[In] longlong Timeout,[Out, Optional] unsigned longlong* pKey)</unmanaged>
            <unmanaged-short>MFScheduleWorkItemEx</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.ScheduleWorkItem(SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown,System.Int64,System.Int64@)">
            <summary>
            <p> </p><p>Schedules an asynchronous operation to be completed after a specified interval.</p>
            </summary>
            <param name = "callbackRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface. The caller must implement this interface.</p> </dd></param>
            <param name = "stateRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>
            <param name = "timeout"><dd> <p>Time-out interval, in milliseconds. Set this parameter to a negative value. The callback is invoked after ?<em>Timeout</em> milliseconds. For example, if <em>Timeout</em> is ?5000, the callback is invoked after 5000 milliseconds.</p> </dd></param>
            <param name = "keyRef"><dd> <p>Receives a key that can be used to cancel the timer. To cancel the timer, call <strong>MFCancelWorkItem</strong> and pass this key in the <em>Key</em> parameter.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This function creates an asynchronous result object. When the timer interval elapses, the <strong>IMFAsyncCallback::Invoke</strong> method specified by <em>pCallback</em> is called.</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms703045</doc-id>
            <unmanaged>HRESULT MFScheduleWorkItem([In] IMFAsyncCallback* pCallback,[In] IUnknown* pState,[In] longlong Timeout,[Out, Optional] unsigned longlong* pKey)</unmanaged>
            <unmanaged-short>MFScheduleWorkItem</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CancelWorkItem(System.Int64)">
            <summary>
            <p> Attempts to cancel an asynchronous operation that was scheduled with <strong>MFScheduleWorkItem</strong> or <strong>MFScheduleWorkItemEx</strong>.</p>
            </summary>
            <param name = "key">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Because work items are asynchronous, the  work-item callback might still be invoked after <strong>MFCancelWorkItem</strong> is called.</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms701633</doc-id>
            <unmanaged>HRESULT MFCancelWorkItem([In] unsigned longlong Key)</unmanaged>
            <unmanaged-short>MFCancelWorkItem</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.GetTimerPeriodicity(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the timer interval for the <strong>MFAddPeriodicCallback</strong> function.</p>
            </summary>
            <param name = "periodicity">No documentation.</param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms694873</doc-id>
            <unmanaged>HRESULT MFGetTimerPeriodicity([Out] DWORD* Periodicity)</unmanaged>
            <unmanaged-short>MFGetTimerPeriodicity</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.AddPeriodicCallback(SharpDX.FunctionCallback,SharpDX.IUnknown,System.Int32@)">
            <summary>
            <p> </p><p>Sets a callback function to be called at a fixed interval.</p>
            </summary>
            <param name = "callback"><dd> <p>Pointer to the callback function, of type <strong>MFPERIODICCALLBACK</strong>.</p> </dd></param>
            <param name = "contextRef"><dd> <p>Pointer to a caller-provided object that implements <strong><see cref = "T:SharpDX.IUnknown"/></strong>, or <strong><c>null</c></strong>. This parameter is passed to the callback function.</p> </dd></param>
            <param name = "dwKeyRef"><dd> <p>Receives a key that can be used to cancel the callback. To cancel the callback, call <strong>MFRemovePeriodicCallback</strong> and pass this key as the <em>dwKey</em> parameter.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To get the timer interval for the periodic callback, call <strong>MFGetTimerPeriodicity</strong>.</p>
            </remarks>
            <doc-id>ms704699</doc-id>
            <unmanaged>HRESULT MFAddPeriodicCallback([In] __function__stdcall* Callback,[In] IUnknown* pContext,[Out, Optional] DWORD* pdwKey)</unmanaged>
            <unmanaged-short>MFAddPeriodicCallback</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.RemovePeriodicCallback(System.Int32)">
            <summary>
            <p> </p><p>Cancels a callback function that was set by the <strong>MFAddPeriodicCallback</strong> function.</p>
            </summary>
            <param name = "dwKey">No documentation.</param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The callback is dispatched on another thread, and this function does not attempt to synchronize with the callback thread. Therefore, it is possible for the callback to be invoked after this function returns.</p>
            </remarks>
            <doc-id>ms704741</doc-id>
            <unmanaged>HRESULT MFRemovePeriodicCallback([In] DWORD dwKey)</unmanaged>
            <unmanaged-short>MFRemovePeriodicCallback</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueueEx(SharpDX.MediaFoundation.AsyncWorkqueueType,System.Int32@)">
            <summary>
            <p>Creates a new work queue. This function extends the capabilities of the  <strong>MFAllocateWorkQueue</strong> function by making it possible to create a  work queue that has a message loop.</p>
            </summary>
            <param name = "workQueueType">No documentation.</param>
            <param name = "dwWorkQueueRef">No documentation.</param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p>The application exceeded the maximum number of work queues.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong></dt> </dl> </td><td> <p>The application did not call <strong>MFStartup</strong>, or the application has already called <strong>MFShutdown</strong>.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>When you are done using the work queue, call <strong>MFUnlockWorkQueue</strong>.</p><p>The <strong>MFAllocateWorkQueue</strong> function is equivalent to calling <strong>MFAllocateWorkQueueEx</strong> with the value MF_STANDARD_WORKQUEUE for the <em>WorkQueueType</em> parameter.</p><p>This function is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd375150</doc-id>
            <unmanaged>HRESULT MFAllocateWorkQueueEx([In] MFASYNC_WORKQUEUE_TYPE WorkQueueType,[Out] DWORD* pdwWorkQueue)</unmanaged>
            <unmanaged-short>MFAllocateWorkQueueEx</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.AllocateWorkQueue(System.Int32@)">
            <summary>
            <p> Creates a new work queue.</p>
            </summary>
            <param name = "dwWorkQueueRef"><dd> <p>Receives an identifier for the work queue.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p> The application exceeded the maximum number of work queues. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong></dt> </dl> </td><td> <p> The application did not call <strong>MFStartup</strong>, or the application has already called <strong>MFShutdown</strong>. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>When you are done using the work queue, call <strong>MFUnlockWorkQueue</strong>.</p>
            </remarks>
            <doc-id>ms700204</doc-id>
            <unmanaged>HRESULT MFAllocateWorkQueue([Out] DWORD* pdwWorkQueue)</unmanaged>
            <unmanaged-short>MFAllocateWorkQueue</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.LockWorkQueue(System.Int32)">
            <summary>
            <p> Locks a work queue.</p>
            </summary>
            <param name = "dwWorkQueue"><dd> <p>The identifier for the work queue. The identifier is returned by the <strong>MFAllocateWorkQueue</strong> function. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function prevents the <strong>MFShutdown</strong> function from shutting down the work queue. Use this function to ensure that asynchronous operations on the work queue complete gracefully before the platform shuts down. The <strong>MFShutdown</strong> function blocks until the work queue is unlocked, or until a fixed wait period has elapsed. (The wait period is a few seconds.)</p><p>Call <strong>MFUnlockWorkQueue</strong> to unlock the work queue. Each call to <strong>MFLockWorkQueue</strong> must be matched by a corresponding call to <strong>MFUnlockWorkQueue</strong>.</p><p> </p><strong>Note</strong>??The <strong>MFAllocateWorkQueue</strong> function implicitly locks the work queue that it creates.?
            </remarks>
            <doc-id>aa367740</doc-id>
            <unmanaged>HRESULT MFLockWorkQueue([In] DWORD dwWorkQueue)</unmanaged>
            <unmanaged-short>MFLockWorkQueue</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.UnlockWorkQueue(System.Int32)">
            <summary>
            <p> </p><p>Unlocks a work queue.</p>
            </summary>
            <param name = "dwWorkQueue"><dd> <p>Identifier for the work queue to be unlocked. The identifier is returned by the <strong>MFAllocateWorkQueue</strong> function.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The application must call <strong>MFUnlockWorkQueue</strong> once for every call to <strong>MFAllocateWorkQueue</strong> and then once for every call to <strong>MFLockWorkQueue</strong>.</p>
            </remarks>
            <doc-id>aa372543</doc-id>
            <unmanaged>HRESULT MFUnlockWorkQueue([In] DWORD dwWorkQueue)</unmanaged>
            <unmanaged-short>MFUnlockWorkQueue</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.BeginRegisterWorkQueueWithMMCSS(System.Int32,System.String,System.Int32,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p> Associates a work queue with a Multimedia Class Scheduler Service (MMCSS) task.</p>
            </summary>
            <param name = "dwWorkQueueId"><dd> <p>The identifier of the work queue.  For private work queues, the identifier is returned by the <strong>MFAllocateWorkQueue</strong> function. For platform work queues, see <strong>Work Queue Identifiers</strong>.</p> </dd></param>
            <param name = "wszClass"><dd> <p> The name of the MMCSS task.For more information, see Multimedia Class Scheduler Service. </p> </dd></param>
            <param name = "dwTaskId"><dd> <p>The unique task identifier. To obtain a new task identifier, set this value to zero. </p> </dd></param>
            <param name = "doneCallbackRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>
            <param name = "doneStateRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This function is asynchronous. When the operation completes, the callback object's <strong>IMFAsyncCallback::Invoke</strong> method is called. At that point, the application should call <strong>MFEndRegisterWorkQueueWithMMCSS</strong> to complete the asynchronous request.</p><p>To unregister the work queue from the MMCSS task, call <strong>MFBeginUnregisterWorkQueueWithMMCSS</strong>.</p>
            </remarks>
            <doc-id>ms701600</doc-id>
            <unmanaged>HRESULT MFBeginRegisterWorkQueueWithMMCSS([In] DWORD dwWorkQueueId,[In] const wchar_t* wszClass,[In] DWORD dwTaskId,[In] IMFAsyncCallback* pDoneCallback,[In] IUnknown* pDoneState)</unmanaged>
            <unmanaged-short>MFBeginRegisterWorkQueueWithMMCSS</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.BeginRegisterWorkQueueWithMMCSSEx(System.Int32,System.String,System.Int32,System.Int32,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p> Associates a work queue with a Multimedia Class Scheduler Service (MMCSS) task.</p>
            </summary>
            <param name = "dwWorkQueueId"><dd> <p>The identifier of the work queue.  For private work queues, the identifier is returned by the <strong>MFAllocateWorkQueue</strong> function. For platform work queues, see <strong>Work Queue Identifiers</strong>.</p> </dd></param>
            <param name = "wszClass"><dd> <p> The name of the MMCSS task. For more information, see Multimedia Class Scheduler Service. </p> </dd></param>
            <param name = "dwTaskId"><dd> <p>The unique task identifier. To obtain a new task identifier, set this value to zero. </p> </dd></param>
            <param name = "lPriority"><dd> <p>The base relative priority for the work-queue threads. For more information, see <strong>AvSetMmThreadPriority</strong>.</p> </dd></param>
            <param name = "doneCallbackRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>
            <param name = "doneStateRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function extends the <strong>MFBeginRegisterWorkQueueWithMMCSS</strong> function by adding the <em>lPriority</em> parameter.</p><p>This function is asynchronous. When the operation completes, the callback object's <strong>IMFAsyncCallback::Invoke</strong> method is called. At that point, call <strong>MFEndRegisterWorkQueueWithMMCSS</strong> to complete the asynchronous request. </p><p>To unregister the work queue from the MMCSS task, call <strong>MFBeginUnregisterWorkQueueWithMMCSS</strong>.</p>
            </remarks>
            <doc-id>hh162745</doc-id>
            <unmanaged>HRESULT MFBeginRegisterWorkQueueWithMMCSSEx([In] DWORD dwWorkQueueId,[In] const wchar_t* wszClass,[In] DWORD dwTaskId,[In] LONG lPriority,[In] IMFAsyncCallback* pDoneCallback,[In] IUnknown* pDoneState)</unmanaged>
            <unmanaged-short>MFBeginRegisterWorkQueueWithMMCSSEx</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.EndRegisterWorkQueueWithMMCSS(SharpDX.MediaFoundation.AsyncResult,System.Int32@)">
            <summary>
            <p> </p><p>Completes an asynchronous request to associate a work queue with a Multimedia Class Scheduler Service (MMCSS) task.</p>
            </summary>
            <param name = "resultRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>IMFAsyncCallback::Invoke</strong> method.</p> </dd></param>
            <param name = "dwTaskIdRef"><dd> <p>The unique task identifier.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this function when the <strong>MFBeginRegisterWorkQueueWithMMCSS</strong> function completes asynchronously.</p><p>To unregister the work queue from the MMCSS class, call <strong>MFBeginUnregisterWorkQueueWithMMCSS</strong>.</p>
            </remarks>
            <doc-id>ms696982</doc-id>
            <unmanaged>HRESULT MFEndRegisterWorkQueueWithMMCSS([In] IMFAsyncResult* pResult,[Out] DWORD* pdwTaskId)</unmanaged>
            <unmanaged-short>MFEndRegisterWorkQueueWithMMCSS</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.BeginUnregisterWorkQueueWithMMCSS(System.Int32,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Unregisters a work queue from a Multimedia Class Scheduler Service (MMCSS) task.</p>
            </summary>
            <param name = "dwWorkQueueId"><dd> <p>The identifier of the work queue.  For private work queues, the identifier is returned by the <strong>MFAllocateWorkQueue</strong> function. For platform work queues, see <strong>Work Queue Identifiers</strong>.</p> </dd></param>
            <param name = "doneCallbackRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>
            <param name = "doneStateRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This function unregisters a work queue that was associated with an MMCSS class through the <strong>MFBeginRegisterWorkQueueWithMMCSS</strong> function.</p><p>This function is asynchronous. When the operation completes, the callback object's <strong>IMFAsyncCallback::Invoke</strong> method is called. At that point, the application should call <strong>MFEndUnregisterWorkQueueWithMMCSS</strong> to complete the asynchronous request.</p>
            </remarks>
            <doc-id>ms704613</doc-id>
            <unmanaged>HRESULT MFBeginUnregisterWorkQueueWithMMCSS([In] DWORD dwWorkQueueId,[In] IMFAsyncCallback* pDoneCallback,[In] IUnknown* pDoneState)</unmanaged>
            <unmanaged-short>MFBeginUnregisterWorkQueueWithMMCSS</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.EndUnregisterWorkQueueWithMMCSS(SharpDX.MediaFoundation.AsyncResult)">
            <summary>
            <p> </p><p>Completes an asynchronous request to unregister a work queue from a Multimedia Class Scheduler Service (MMCSS) task.</p>
            </summary>
            <param name = "resultRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>IMFAsyncCallback::Invoke</strong> method.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this function when the <strong>MFBeginUnregisterWorkQueueWithMMCSS</strong> function completes asynchronously.</p>
            </remarks>
            <doc-id>ms704803</doc-id>
            <unmanaged>HRESULT MFEndUnregisterWorkQueueWithMMCSS([In] IMFAsyncResult* pResult)</unmanaged>
            <unmanaged-short>MFEndUnregisterWorkQueueWithMMCSS</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.GetWorkQueueMMCSSClass(System.Int32,System.IntPtr,System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the Multimedia Class Scheduler Service (MMCSS) class currently associated with this work queue.</p>
            </summary>
            <param name = "dwWorkQueueId"><dd> <p>Identifier for the work queue. The identifier is retrieved by the <strong>MFAllocateWorkQueue</strong> function.</p> </dd></param>
            <param name = "wszClassRef"><dd> <p>Pointer to a buffer that receives the name of the MMCSS class. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "cchClassRef"><dd> <p>On input, specifies the size of the <em>pwszClass</em> buffer, in characters. On output, receives the required size of the buffer, in characters. The size includes the terminating null character.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:BufferTooSmall"/></strong></dt> </dl> </td><td> <p>The <em>pwszClass</em> buffer is too small to receive the task name.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the work queue is not associated with an MMCSS task, the function retrieves an empty string.</p><p>To associate a work queue with an MMCSS task, call <strong>MFBeginRegisterWorkQueueWithMMCSS</strong>.</p>
            </remarks>
            <doc-id>ms701582</doc-id>
            <unmanaged>HRESULT MFGetWorkQueueMMCSSClass([In] DWORD dwWorkQueueId,[Out, Buffer, Optional] wchar_t* pwszClass,[InOut] DWORD* pcchClass)</unmanaged>
            <unmanaged-short>MFGetWorkQueueMMCSSClass</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.GetWorkQueueMMCSSTaskId(System.Int32,System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the Multimedia Class Scheduler Service (MMCSS) task identifier currently associated with this work queue.</p>
            </summary>
            <param name = "dwWorkQueueId"><dd> <p>Identifier for the work queue. The identifier is retrieved by the <strong>MFAllocateWorkQueue</strong> function.</p> </dd></param>
            <param name = "dwTaskIdRef"><dd> <p>Receives the task identifier.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To associate a work queue with an MMCSS task, call <strong>MFBeginRegisterWorkQueueWithMMCSS</strong>.</p>
            </remarks>
            <doc-id>ms704780</doc-id>
            <unmanaged>HRESULT MFGetWorkQueueMMCSSTaskId([In] DWORD dwWorkQueueId,[Out] DWORD* pdwTaskId)</unmanaged>
            <unmanaged-short>MFGetWorkQueueMMCSSTaskId</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.RegisterPlatformWithMMCSS(System.String,System.Int32@,System.Int32)">
            <summary>
            <p>Registers the standard Microsoft Media Foundation platform work queues with the Multimedia Class Scheduler Service (MMCSS).
            </p>
            </summary>
            <param name = "wszClass"><dd> <p>The name of the MMCSS task. </p> </dd></param>
            <param name = "dwTaskIdRef"><dd> <p>The MMCSS task identifier. On input, specify an existing  MCCSS task group ID, or use the value zero to create a new task group. On output, receives the actual task group ID.</p> </dd></param>
            <param name = "lPriority"><dd> <p>The base priority of the work-queue threads. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>To unregister the platform work queues from the MMCSS class, call <strong>MFUnregisterPlatformFromMMCSS</strong>.</p>
            </remarks>
            <doc-id>hh162788</doc-id>
            <unmanaged>HRESULT MFRegisterPlatformWithMMCSS([In] const wchar_t* wszClass,[InOut] DWORD* pdwTaskId,[In] LONG lPriority)</unmanaged>
            <unmanaged-short>MFRegisterPlatformWithMMCSS</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.UnregisterPlatformFromMMCSS">
            <summary>
            <p>Unregisters the Microsoft Media Foundation platform work queues from a Multimedia Class Scheduler Service (MMCSS) task.</p>
            </summary>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh162801</doc-id>
            <unmanaged>HRESULT MFUnregisterPlatformFromMMCSS()</unmanaged>
            <unmanaged-short>MFUnregisterPlatformFromMMCSS</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.LockSharedWorkQueue(System.String,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            <p>Obtains and locks a shared work queue.</p>
            </summary>
            <param name = "wszClass"><dd> <p>The name of the MMCSS task.  </p> </dd></param>
            <param name = "basePriority"><dd> <p>The base priority of the work-queue threads.  If the regular-priority queue is being used (<em>wszClass</em>=""), then the value 0 must be passed in.</p> </dd></param>
            <param name = "dwTaskIdRef"><dd> <p>The MMCSS task identifier. On input, specify an existing MCCSS task group ID , or use the value zero to create a new task group. If the regular priority queue is being used (<em>wszClass</em>=""), then <strong><c>null</c></strong> must be passed in. On output, receives the actual task group ID. </p> </dd></param>
            <param name = "iDRef"><dd> <p>Receives an identifier for the new work queue. Use this identifier when queuing work items.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>A <em>multithreaded work queue</em> uses a thread pool to dispatch work items. Whenever a thread becomes available, it dequeues the next work item from the queue. Work items are dequeued in first-in-first-out order, but work items are not serialized. In other words, the work queue does not wait for a work item to complete before it starts the next work item. </p><p>Within a single process, the Microsoft Media Foundation platform creates up to one multithreaded queue for each Multimedia Class Scheduler Service (MMCSS) task. The <strong>MFLockSharedWorkQueue</strong> function checks whether a matching work queue already exists. If not, the function creates a new work queue and registers the work queue with MMCSS. The function returns the MMCSS task identifier (<em>pdwTaskId</em>) and the work queue identifier (<em>pID</em>). To queue a work item, pass the work queue identifier to any of the following functions: </p><ul> <li> <strong>MFPutWorkItem</strong> </li> <li> <strong>MFPutWorkItem2</strong> </li> <li> <strong>MFPutWorkItemEx</strong> </li> <li> <strong>MFPutWorkItemEx2</strong> </li> </ul><p>The <strong>MFLockSharedWorkQueue</strong> function also locks the queue. Before the process exits, call <strong>MFUnlockWorkQueue</strong> to unlock the work queue.</p><p>If the regular priority queue is being used (<em>wszClass</em>=""), then <c>null</c> must be passed in to <em>pdwTaskId</em> and the value 0 must be passed into <em>BasePriority</em>.</p>
            </remarks>
            <doc-id>hh162771</doc-id>
            <unmanaged>HRESULT MFLockSharedWorkQueue([In] const wchar_t* wszClass,[In] LONG BasePriority,[InOut] DWORD* pdwTaskId,[Out] DWORD* pID)</unmanaged>
            <unmanaged-short>MFLockSharedWorkQueue</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.GetWorkQueueMMCSSPriority(System.Int32,System.Int32@)">
            <summary>
            <p>Gets the relative thread priority of a work queue.</p>
            </summary>
            <param name = "dwWorkQueueId"><dd> <p>The identifier of the work queue. For private work queues, the identifier is returned by the <strong>MFAllocateWorkQueue</strong> function. For platform work queues, see <strong>Work Queue Identifiers</strong>.</p> </dd></param>
            <param name = "lPriority"><dd> <p>Receives the relative thread priority.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function returns the relative thread priority set by the <strong>MFBeginRegisterWorkQueueWithMMCSSEx</strong> function.</p>
            </remarks>
            <doc-id>hh162768</doc-id>
            <unmanaged>HRESULT MFGetWorkQueueMMCSSPriority([In] DWORD dwWorkQueueId,[Out] LONG* lPriority)</unmanaged>
            <unmanaged-short>MFGetWorkQueueMMCSSPriority</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateAsyncResult(SharpDX.IUnknown,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown,SharpDX.MediaFoundation.AsyncResult@)">
            <summary>
            <p> </p><p>Creates an asynchronous result object. Use this function if you are implementing an asynchronous method.</p>
            </summary>
            <param name = "unkObjectRef"><dd> <p>Pointer to the object stored in the asynchronous result. This reference is returned by the <strong>IMFAsyncResult::GetObject</strong> method. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "callbackRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface. This interface is implemented by the caller of the asynchronous method.</p> </dd></param>
            <param name = "unkStateRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object. This value is provided by the caller of the asynchronous method. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "asyncResultOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To invoke the callback specified in <em>pCallback</em>, call the <strong>MFInvokeCallback</strong> function.</p>
            </remarks>
            <doc-id>ms698952</doc-id>
            <unmanaged>HRESULT MFCreateAsyncResult([In] IUnknown* punkObject,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState,[Out] IMFAsyncResult** ppAsyncResult)</unmanaged>
            <unmanaged-short>MFCreateAsyncResult</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.InvokeCallback(SharpDX.MediaFoundation.AsyncResult)">
            <summary>
            <p> Invokes a callback method to complete an asynchronous operation. </p>
            </summary>
            <param name = "asyncResultRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. To create this object, call <strong>MFCreateAsyncResult</strong>.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidWorkqueue"/></strong></strong></dt> </dl> </td><td> <p>Invalid work queue. For more information, see <strong>IMFAsyncCallback::GetParameters</strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "M:SharpDX.MediaFoundation.MediaFactory.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The <strong>MFShutdown</strong> function was called to shut down the Media Foundation platform.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> If you are implementing an asynchronous method, use this function to invoke the caller's <strong>IMFAsyncCallback::Invoke</strong> method.</p><p>The callback is invoked from a Media Foundation work queue. For more information, see Writing an Asynchronous Method.</p><p>The <strong>MFShutdown</strong> function shuts down the work queue threads, so the callback is not guaranteed to be invoked after <strong>MFShutdown</strong> is called.</p>
            </remarks>
            <doc-id>ms695400</doc-id>
            <unmanaged>HRESULT MFInvokeCallback([In] IMFAsyncResult* pAsyncResult)</unmanaged>
            <unmanaged-short>MFInvokeCallback</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateFile(SharpDX.MediaFoundation.FileAccessMode,SharpDX.MediaFoundation.FileOpenMode,SharpDX.MediaFoundation.FileFlags,System.String,SharpDX.MediaFoundation.IByteStream@)">
            <summary>
            <p> Creates a byte stream from a file. </p>
            </summary>
            <param name = "accessMode"><dd> <p> The requested access mode, specified as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.FileAccessMode"/></strong> enumeration. </p> </dd></param>
            <param name = "openMode"><dd> <p> The behavior of the function if the file already exists or does not exist, specified as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.FileOpenMode"/></strong> enumeration. </p> </dd></param>
            <param name = "fFlags"><dd> <p> Bitwise <strong>OR</strong> of values from the <strong><see cref = "T:SharpDX.MediaFoundation.FileFlags"/></strong> enumeration. </p> </dd></param>
            <param name = "wszFileURLRef"><dd> <p> Pointer to a null-terminated string that contains the file name. </p> </dd></param>
            <param name = "iByteStreamOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of the byte stream. The caller must release the interface. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms696166</doc-id>
            <unmanaged>HRESULT MFCreateFile([In] MF_FILE_ACCESSMODE AccessMode,[In] MF_FILE_OPENMODE OpenMode,[In] MF_FILE_FLAGS fFlags,[In] const wchar_t* pwszFileURL,[Out] IMFByteStream** ppIByteStream)</unmanaged>
            <unmanaged-short>MFCreateFile</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateTempFile(SharpDX.MediaFoundation.FileAccessMode,SharpDX.MediaFoundation.FileOpenMode,SharpDX.MediaFoundation.FileFlags,SharpDX.MediaFoundation.IByteStream@)">
            <summary>
            <p> Creates a byte stream that is backed by a temporary local file. </p>
            </summary>
            <param name = "accessMode"><dd> <p> The requested access mode, specified as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.FileAccessMode"/></strong> enumeration. </p> </dd></param>
            <param name = "openMode"><dd> <p> The behavior of the function if the file already exists or does not exist, specified as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.FileOpenMode"/></strong> enumeration. </p> </dd></param>
            <param name = "fFlags"><dd> <p> Bitwise <strong>OR</strong> of values from the <strong><see cref = "T:SharpDX.MediaFoundation.FileFlags"/></strong> enumeration. </p> </dd></param>
            <param name = "iByteStreamOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of the byte stream. The caller must release the interface. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> This function creates a file in the system temporary folder, and then returns a byte stream object for that file. The full path name of the file is storted in the <strong><see cref = "!:OriginName"/></strong> attribute. The file is created with the <strong>FILE_FLAG_DELETE_ON_CLOSE</strong> flag, and is deleted after the byte stream is released.</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms695209</doc-id>
            <unmanaged>HRESULT MFCreateTempFile([In] MF_FILE_ACCESSMODE AccessMode,[In] MF_FILE_OPENMODE OpenMode,[In] MF_FILE_FLAGS fFlags,[Out] IMFByteStream** ppIByteStream)</unmanaged>
            <unmanaged-short>MFCreateTempFile</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.BeginCreateFile(SharpDX.MediaFoundation.FileAccessMode,SharpDX.MediaFoundation.FileOpenMode,SharpDX.MediaFoundation.FileFlags,System.String,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown,SharpDX.IUnknown@)">
            <summary>
            <p> </p><p>Begins an asynchronous request to create a byte stream from a file.</p>
            </summary>
            <param name = "accessMode"><dd> <p>The requested access mode, specified as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.FileAccessMode"/></strong> enumeration.</p> </dd></param>
            <param name = "openMode"><dd> <p>The behavior of the function if the file already exists or does not exist, specified as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.FileOpenMode"/></strong> enumeration.</p> </dd></param>
            <param name = "fFlags"><dd> <p>Bitwise <strong>OR</strong> of values from the <strong><see cref = "T:SharpDX.MediaFoundation.FileFlags"/></strong> enumeration.</p> </dd></param>
            <param name = "wszFilePathRef"><dd> <p>Pointer to a null-terminated string containing the file name.</p> </dd></param>
            <param name = "callbackRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface</p> </dd></param>
            <param name = "stateRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>
            <param name = "cancelCookieOut"><dd> <p>Receives an <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference or the value <strong><c>null</c></strong>. If the value is not <strong><c>null</c></strong>, you can cancel the asynchronous operation by passing this reference to the <strong>MFCancelCreateFile</strong> function. The caller must release the interface. This parameter is optional and can be <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>When the request is completed, the callback object's <strong>IMFAsyncCallback::Invoke</strong> method is called. The callback object should then call the <strong>MFEndCreateFile</strong> function to get a reference to the byte stream.</p>
            </remarks>
            <doc-id>ms702074</doc-id>
            <unmanaged>HRESULT MFBeginCreateFile([In] MF_FILE_ACCESSMODE AccessMode,[In] MF_FILE_OPENMODE OpenMode,[In] MF_FILE_FLAGS fFlags,[In] const wchar_t* pwszFilePath,[In] IMFAsyncCallback* pCallback,[In] IUnknown* pState,[Out] IUnknown** ppCancelCookie)</unmanaged>
            <unmanaged-short>MFBeginCreateFile</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.EndCreateFile(SharpDX.MediaFoundation.AsyncResult,SharpDX.MediaFoundation.IByteStream@)">
            <summary>
            <p> </p><p>Completes an asynchronous request to create a byte stream from a file.</p>
            </summary>
            <param name = "resultRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>Invoke</strong> method.</p> </dd></param>
            <param name = "fileOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of the byte stream. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this function when the <strong>MFBeginCreateFile</strong> function completes asynchronously.</p>
            </remarks>
            <doc-id>ms703984</doc-id>
            <unmanaged>HRESULT MFEndCreateFile([In] IMFAsyncResult* pResult,[Out] IMFByteStream** ppFile)</unmanaged>
            <unmanaged-short>MFEndCreateFile</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CancelCreateFile(SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Cancels an asynchronous request to create a byte stream from a file.</p>
            </summary>
            <param name = "cancelCookieRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of the cancellation object. This reference is received in the <em>ppCancelCookie</em> parameter of the <strong>MFBeginCreateFile</strong> function.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>You can use this function to cancel a previous call to <strong>MFBeginCreateFile</strong>. Because that function is asynchronous, however, it might complete before the operation can be canceled. Therefore, your callback might still be invoked after you call this function.</p>
            </remarks>
            <doc-id>ms702218</doc-id>
            <unmanaged>HRESULT MFCancelCreateFile([In] IUnknown* pCancelCookie)</unmanaged>
            <unmanaged-short>MFCancelCreateFile</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateMemoryBuffer(System.Int32)">
            <summary>
            <p> </p><p>Allocates system memory and creates a media buffer to manage it.</p>
            </summary>
            <param name = "cbMaxLength"><dd> <p>Size of the buffer, in bytes.</p> </dd></param>
            <returns><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of the media buffer. The caller must release the interface.</p> </dd></returns>
            <remarks>
            <p>The function allocates a buffer with a 1-byte memory alignment. To allocate a buffer that is aligned to a larger memory boundary, call <strong>MFCreateAlignedMemoryBuffer</strong>.</p><p>When the media buffer object is destroyed, it releases the allocated memory.</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms695212</doc-id>
            <unmanaged>HRESULT MFCreateMemoryBuffer([In] DWORD cbMaxLength,[Out] IMFMediaBuffer** ppBuffer)</unmanaged>
            <unmanaged-short>MFCreateMemoryBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateMediaBufferWrapper(SharpDX.MediaFoundation.MediaBuffer,System.Int32,System.Int32,SharpDX.MediaFoundation.MediaBuffer@)">
            <summary>
            <p>Creates a media buffer that wraps an existing media buffer. The new media buffer points to the same memory as the original media buffer, or to an offset from the start of the memory.</p>
            </summary>
            <param name = "bufferRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of the original media buffer. </p> </dd></param>
            <param name = "cbOffset"><dd> <p>The start of the new buffer, as an offset in bytes from the start of the original buffer. </p> </dd></param>
            <param name = "dwLength"><dd> <p>The size of the new buffer. The value of <em>cbOffset</em> + <em>dwLength</em> must be less than or equal to the size of valid data the original buffer. (The size of the valid data is returned by the <strong>IMFMediaBuffer::GetCurrentLength</strong> method.) </p> </dd></param>
            <param name = "bufferOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> The requested offset or the requested length is not valid. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The maximum size of the wrapper buffer is limited to the size of the valid data in the original buffer. This might be less than the allocated size of the original buffer. To set the size of the valid data, call <strong>IMFMediaBuffer::SetCurrentLength</strong>.</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>aa370450</doc-id>
            <unmanaged>HRESULT MFCreateMediaBufferWrapper([In] IMFMediaBuffer* pBuffer,[In] DWORD cbOffset,[In] DWORD dwLength,[Out] IMFMediaBuffer** ppBuffer)</unmanaged>
            <unmanaged-short>MFCreateMediaBufferWrapper</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateLegacyMediaBufferOnMFMediaBuffer(SharpDX.MediaFoundation.Sample,SharpDX.MediaFoundation.MediaBuffer,System.Int32,SharpDX.MediaFoundation.IMediaBuffer@)">
            <summary>
            <p> </p><p>Converts a Media Foundation media buffer into a buffer that is compatible with DirectX Media Objects (DMOs).</p>
            </summary>
            <param name = "sampleRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface of the sample that contains the Media Foundation buffer. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "mFMediaBufferRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of the Media Foundation buffer.</p> </dd></param>
            <param name = "cbOffset"><dd> <p>Offset in bytes from the start of the Media Foundation buffer. This offset defines where the DMO buffer starts. If this parameter is zero, the DMO buffer starts at the beginning of the Media Foundation buffer.</p> </dd></param>
            <param name = "mediaBufferOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IMediaBuffer"/></strong> interface. This interface is documented in the DirectShow SDK documentation. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument. The <em>pIMFMediaBuffer</em> parameter must not be <strong><c>null</c></strong>.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The DMO buffer created by this function also exposes the <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface. If <em>pIMFSample</em> is <strong><c>null</c></strong>, all of the <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> methods return <see cref = "!:NotInitializeD"/>. Otherwise, they call through to the <em>pIMFSample</em> reference.</p><p>If the Media Foundation buffer specified by <em>pIMFMediaBuffer</em> exposes the <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2D"/></strong> interface, the DMO buffer also exposes <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2D"/></strong>.</p>
            </remarks>
            <doc-id>ms696233</doc-id>
            <unmanaged>HRESULT MFCreateLegacyMediaBufferOnMFMediaBuffer([In, Optional] IMFSample* pSample,[In] IMFMediaBuffer* pMFMediaBuffer,[In] DWORD cbOffset,[Out] IMediaBuffer** ppMediaBuffer)</unmanaged>
            <unmanaged-short>MFCreateLegacyMediaBufferOnMFMediaBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.MapDX9FormatToDXGIFormat(System.Int32)">
            <summary>
            <p>Converts a Microsoft Direct3D?9 format identifier to a Microsoft DirectX Graphics Infrastructure (DXGI) format identifier.</p>
            </summary>
            <param name = "dx9"><dd> <p>The <strong>D3DFORMAT</strong> value or FOURCC code to convert.</p> </dd></param>
            <returns><p>Returns a <strong><see cref = "T:SharpDX.DXGI.Format"/></strong> value.</p></returns>
            <doc-id>hh162772</doc-id>
            <unmanaged>DXGI_FORMAT MFMapDX9FormatToDXGIFormat([In] DWORD dx9)</unmanaged>
            <unmanaged-short>MFMapDX9FormatToDXGIFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.MapDXGIFormatToDX9Format(SharpDX.DXGI.Format)">
            <summary>
            <p>Converts a Microsoft DirectX Graphics Infrastructure (DXGI) format identifier to a Microsoft Direct3D?9 format identifier.</p>
            </summary>
            <param name = "dx11"><dd> <p>The <strong><see cref = "T:SharpDX.DXGI.Format"/></strong> value to convert.</p> </dd></param>
            <returns><p>Returns a <strong>D3DFORMAT</strong> value or FOURCC code.</p></returns>
            <doc-id>hh162773</doc-id>
            <unmanaged>DWORD MFMapDXGIFormatToDX9Format([In] DXGI_FORMAT dx11)</unmanaged>
            <unmanaged-short>MFMapDXGIFormatToDX9Format</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.LockDXGIDeviceManager(System.Int32@,SharpDX.MediaFoundation.DXGIDeviceManager@)">
            <summary>
            <p>Locks the shared Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager.</p>
            </summary>
            <param name = "resetTokenRef"><dd> <p>Receives a token that identifies this instance of the DXGI Device Manager. Use this token when calling <strong>IMFDXGIDeviceManager::ResetDevice</strong>. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "managerOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function obtains a reference to a  DXGI Device Manager instance that can be shared between components. The Microsoft Media Foundation platform creates this instance of the  DXGI Device Manager as a singleton object. Alternatively, you can create a new DXGI Device Manager by calling <strong>MFCreateDXGIDeviceManager</strong>.</p><p>The first time this function is called, the Media Foundation platform creates the shared DXGI Device Manager. </p><p>When you are done use the <strong><see cref = "T:SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> reference, call the <strong>MFUnlockDXGIDeviceManager</strong>.</p>
            </remarks>
            <doc-id>hh162770</doc-id>
            <unmanaged>HRESULT MFLockDXGIDeviceManager([Out, Optional] unsigned int* pResetToken,[Out] IMFDXGIDeviceManager** ppManager)</unmanaged>
            <unmanaged-short>MFLockDXGIDeviceManager</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.UnlockDXGIDeviceManager">
            <summary>
            <p>Unlocks the shared Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager.</p>
            </summary>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Call this function after a successful call to the <strong>MFLockDXGIDeviceManager</strong> function.</p>
            </remarks>
            <doc-id>hh162800</doc-id>
            <unmanaged>HRESULT MFUnlockDXGIDeviceManager()</unmanaged>
            <unmanaged-short>MFUnlockDXGIDeviceManager</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateDXSurfaceBuffer(System.Guid,SharpDX.IUnknown,SharpDX.Mathematics.Interop.RawBool,SharpDX.MediaFoundation.MediaBuffer@)">
            <summary>
            <p> Creates a media buffer object that manages a Direct3D 9 surface. </p>
            </summary>
            <param name = "riid"><dd> <p> Identifies the type of Direct3D 9 surface. Currently this value must be <strong>IID_IDirect3DSurface9</strong>. </p> </dd></param>
            <param name = "unkSurfaceRef"><dd> <p> A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of the DirectX surface. </p> </dd></param>
            <param name = "fBottomUpWhenLinear"><dd> <p> If <strong>TRUE</strong>, the buffer's <strong>IMF2DBuffer::ContiguousCopyTo</strong> method copies the buffer into a bottom-up format. The bottom-up format is compatible with GDI for uncompressed RGB images. If this parameter is <strong><see cref = "F:SharpDX.Result.False"/></strong>, the <strong>ContiguousCopyTo</strong> method copies the buffer into a top-down format, which is compatible with DirectX. </p> <p>For more information about top-down versus bottom-up images, see Image Stride.</p> </dd></param>
            <param name = "bufferOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> interface. The caller must release the buffer. </p> </dd></param>
            <returns><p> The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This function creates a media buffer object that holds a reference to the Direct3D surface specified in <em>punkSurface</em>. Locking the buffer gives the caller access to the surface memory. When the buffer object is destroyed, it releases the surface. For more information about media buffers, see Media Buffers.</p><strong>Note</strong>??This function does not allocate the Direct3D surface itself.?<p> The buffer object created by this function also exposes the <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2D"/></strong> interface. For more information, see DirectX Surface Buffer. </p><p>This function does not support DXGI surfaces.</p>
            </remarks>
            <doc-id>ms703840</doc-id>
            <unmanaged>HRESULT MFCreateDXSurfaceBuffer([In] const GUID&amp; riid,[In] IUnknown* punkSurface,[In] BOOL fBottomUpWhenLinear,[Out] IMFMediaBuffer** ppBuffer)</unmanaged>
            <unmanaged-short>MFCreateDXSurfaceBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateWICBitmapBuffer(System.Guid,SharpDX.IUnknown,SharpDX.MediaFoundation.MediaBuffer@)">
            <summary>
            <p>Creates a media buffer object that manages a Windows Imaging Component (WIC) bitmap.</p>
            </summary>
            <param name = "riid"><dd> <p>Set this parameter to <code>__uuidof(<see cref = "!:SharpDX.WIC.Bitmap"/>)</code>.</p> </dd></param>
            <param name = "unkSurfaceRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of the bitmap surface. The bitmap surface must be a WIC bitmap that exposes the <strong><see cref = "!:SharpDX.WIC.Bitmap"/></strong> interface.</p> </dd></param>
            <param name = "bufferOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh162764</doc-id>
            <unmanaged>HRESULT MFCreateWICBitmapBuffer([In] const GUID&amp; riid,[In] IUnknown* punkSurface,[Out] IMFMediaBuffer** ppBuffer)</unmanaged>
            <unmanaged-short>MFCreateWICBitmapBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateDXGISurfaceBuffer(System.Guid,SharpDX.IUnknown,System.Int32,SharpDX.Mathematics.Interop.RawBool,SharpDX.MediaFoundation.MediaBuffer@)">
            <summary>
            <p>Creates a media buffer to manage a Microsoft DirectX Graphics Infrastructure (DXGI) surface.</p>
            </summary>
            <param name = "riid"><dd> <p> Identifies the type of DXGI surface. This value must be <strong>IID_ID3D11Texture2D</strong>. </p> </dd></param>
            <param name = "unkSurfaceRef"><dd> <p> A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of the DXGI surface. </p> </dd></param>
            <param name = "uSubresourceIndex"><dd> <p>The zero-based index of a subresource of the surface. The media buffer object is associated with this subresource.</p> </dd></param>
            <param name = "fBottomUpWhenLinear"><dd> <p> If <strong>TRUE</strong>, the buffer's <strong>IMF2DBuffer::ContiguousCopyTo</strong> method copies the buffer into a bottom-up format. The bottom-up format is compatible with GDI for uncompressed RGB images. If this parameter is <strong><see cref = "F:SharpDX.Result.False"/></strong>, the <strong>ContiguousCopyTo</strong> method copies the buffer into a top-down format, which is compatible with Direct3D. </p> <p>For more information about top-down versus bottom-up images, see Image Stride.</p> </dd></param>
            <param name = "bufferOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> interface. The caller must release the buffer. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The returned buffer object supports the following interfaces:</p><ul> <li> <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2D"/></strong> </li> <li> <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2D2"/></strong> </li> <li> <strong><see cref = "T:SharpDX.MediaFoundation.DXGIBuffer"/></strong> </li> <li> <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> </li> </ul>
            </remarks>
            <doc-id>hh162751</doc-id>
            <unmanaged>HRESULT MFCreateDXGISurfaceBuffer([In] const GUID&amp; riid,[In] IUnknown* punkSurface,[In] unsigned int uSubresourceIndex,[In] BOOL fBottomUpWhenLinear,[Out] IMFMediaBuffer** ppBuffer)</unmanaged>
            <unmanaged-short>MFCreateDXGISurfaceBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateVideoSampleAllocatorEx(System.Guid,System.IntPtr@)">
            <summary>
            <p>Creates an object that allocates video samples that are compatible with Microsoft DirectX Graphics Infrastructure (DXGI).</p>
            </summary>
            <param name = "riid"><dd> <p>The identifier of the interface to retrieve. Specify one of the following values.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong>IID_IUnknown</strong></strong></dt> </dl> </td><td> <p>Retrieve an <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference.</p> </td></tr> <tr><td><dl> <dt><strong><strong>IID_IMFVideoSampleAllocator</strong></strong></dt> </dl> </td><td> <p>Retrieve an <strong><see cref = "T:SharpDX.MediaFoundation.VideoSampleAllocator"/></strong> reference.</p> </td></tr> <tr><td><dl> <dt><strong><strong>IID_IMFVideoSampleAllocatorEx</strong></strong></dt> </dl> </td><td> <p>Retrieve an <strong><see cref = "T:SharpDX.MediaFoundation.VideoSampleAllocatorEx"/></strong> reference.</p> </td></tr> <tr><td><dl> <dt><strong><strong>IID_IMFVideoSampleAllocatorCallback</strong></strong></dt> </dl> </td><td> <p>Retrieve an <strong><see cref = "T:SharpDX.MediaFoundation.VideoSampleAllocatorCallback"/></strong> reference.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "sampleAllocatorOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function creates an allocator for DXGI video surfaces. The buffers created by this allocator expose the <strong><see cref = "T:SharpDX.MediaFoundation.DXGIBuffer"/></strong> interface. To create an allocator for Microsoft Direct3D?9 video surfaces, call <strong>MFCreateVideoSampleAllocator</strong>.</p>
            </remarks>
            <doc-id>hh162763</doc-id>
            <unmanaged>HRESULT MFCreateVideoSampleAllocatorEx([In] const GUID&amp; riid,[Out] void** ppSampleAllocator)</unmanaged>
            <unmanaged-short>MFCreateVideoSampleAllocatorEx</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateDXGIDeviceManager(System.Int32@,SharpDX.MediaFoundation.DXGIDeviceManager)">
            <summary>
            <p>Creates an instance of the Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager.</p>
            </summary>
            <param name = "resetToken"><dd> <p> Receives a token that identifies this instance of the DXGI Device Manager. Use this token when calling <strong>IMFDXGIDeviceManager::ResetDevice</strong>. </p> </dd></param>
            <param name = "deviceManagerOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>When you create an <strong><see cref = "T:SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> with <strong>MFCreateDXGIDeviceManager</strong>, a Microsoft Direct3D?11 device is not associated with the device manager. To associate a Direct3D?11 device with the device manager, call <strong>IMFDXGIDeviceManager::ResetDevice</strong>, passing in the reference to the Direct3D?11 device. To create a Direct3D?11 device, call <strong>D3D11CreateDevice</strong>. The device should be created with the <strong>D3D11_CREATE_DEVICE_VIDEO_SUPPORT</strong> device creation flag which is defined in the <strong><see cref = "!:SharpDX.Direct3D11.DeviceCreationFlags"/></strong> enumeration.</p>
            </remarks>
            <doc-id>hh162750</doc-id>
            <unmanaged>HRESULT MFCreateDXGIDeviceManager([Out] unsigned int* resetToken,[Out, Fast] IMFDXGIDeviceManager** ppDeviceManager)</unmanaged>
            <unmanaged-short>MFCreateDXGIDeviceManager</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateAlignedMemoryBuffer(System.Int32,System.Int32,SharpDX.MediaFoundation.MediaBuffer@)">
            <summary>
            <p> Allocates system memory with a specified byte alignment and creates a media buffer to manage the memory. </p>
            </summary>
            <param name = "cbMaxLength"><dd> <p>Size of the buffer, in bytes.</p> </dd></param>
            <param name = "cbAligment"><dd> <p> Specifies the memory alignment for the buffer. Use one of the following constants. </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MF_1_BYTE_ALIGNMENT</strong></dt> <dt>0x00000000</dt> </dl> </td><td> <p> Align to 1 bytes. </p> </td></tr> <tr><td><dl> <dt><strong>MF_2_BYTE_ALIGNMENT</strong></dt> <dt>0x00000001</dt> </dl> </td><td> <p> Align to 2 bytes. </p> </td></tr> <tr><td><dl> <dt><strong>MF_4_BYTE_ALIGNMENT</strong></dt> <dt>0x00000003</dt> </dl> </td><td> <p> Align to 4 bytes. </p> </td></tr> <tr><td><dl> <dt><strong>MF_8_BYTE_ALIGNMENT</strong></dt> <dt>0x00000007</dt> </dl> </td><td> <p> Align to 8 bytes. </p> </td></tr> <tr><td><dl> <dt><strong>MF_16_BYTE_ALIGNMENT</strong></dt> <dt>0x0000000F</dt> </dl> </td><td> <p> Align to 16 bytes. </p> </td></tr> <tr><td><dl> <dt><strong>MF_32_BYTE_ALIGNMENT</strong></dt> <dt>0x0000001F</dt> </dl> </td><td> <p> Align to 32 bytes. </p> </td></tr> <tr><td><dl> <dt><strong>MF_64_BYTE_ALIGNMENT</strong></dt> <dt>0x0000003F</dt> </dl> </td><td> <p> Align to 64 bytes. </p> </td></tr> <tr><td><dl> <dt><strong>MF_128_BYTE_ALIGNMENT</strong></dt> <dt>0x0000007F</dt> </dl> </td><td> <p> Align to 128 bytes. </p> </td></tr> <tr><td><dl> <dt><strong>MF_256_BYTE_ALIGNMENT</strong></dt> <dt>0x000000FF</dt> </dl> </td><td> <p> Align to 256 bytes. </p> </td></tr> <tr><td><dl> <dt><strong>MF_512_BYTE_ALIGNMENT</strong></dt> <dt>0x000001FF</dt> </dl> </td><td> <p> Align to 512 bytes. </p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "bufferOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of the media buffer. The caller must release the interface. </p> </dd></param>
            <returns><p> The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> When the media buffer object is destroyed, it releases the allocated memory. </p>
            </remarks>
            <doc-id>bb970523</doc-id>
            <unmanaged>HRESULT MFCreateAlignedMemoryBuffer([In] DWORD cbMaxLength,[In] DWORD cbAligment,[Out] IMFMediaBuffer** ppBuffer)</unmanaged>
            <unmanaged-short>MFCreateAlignedMemoryBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateMediaEvent(System.Int32,System.Guid,SharpDX.Result,System.Nullable{SharpDX.Win32.Variant},SharpDX.MediaFoundation.MediaEvent@)">
            <summary>
            <p> </p><p>Creates a media event object.</p>
            </summary>
            <param name = "met"><dd> <p>The event type. See <strong>IMFMediaEvent::GetType</strong>. For a list of event types, see Media Foundation Events.</p> </dd></param>
            <param name = "guidExtendedType"><dd> <p>The extended type. See <strong>IMFMediaEvent::GetExtendedType</strong>. If the event type does not have an extended type, use the value GUID_NULL.</p> </dd></param>
            <param name = "hrStatus"><dd> <p>The event status. See <strong>IMFMediaEvent::GetStatus</strong> </p> </dd></param>
            <param name = "vValueRef"><dd> <p>The value associated with the event, if any. See <strong>IMFMediaEvent::GetValue</strong>. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "eventOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEvent"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms697521</doc-id>
            <unmanaged>HRESULT MFCreateMediaEvent([In] DWORD met,[In] const GUID&amp; guidExtendedType,[In] HRESULT hrStatus,[In, Optional] const PROPVARIANT* pvValue,[Out] IMFMediaEvent** ppEvent)</unmanaged>
            <unmanaged-short>MFCreateMediaEvent</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateEventQueue(SharpDX.MediaFoundation.MediaEventQueue@)">
            <summary>
            <p> </p><p>Creates an event queue.</p>
            </summary>
            <param name = "mediaEventQueueOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEventQueue"/></strong> interface of the event queue. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This function creates a helper object that you can use to implement the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEventGenerator"/></strong> interface.</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms695252</doc-id>
            <unmanaged>HRESULT MFCreateEventQueue([Out] IMFMediaEventQueue** ppMediaEventQueue)</unmanaged>
            <unmanaged-short>MFCreateEventQueue</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateSample">
            <summary>
            <p> </p><p>Creates an empty media sample.</p>
            </summary>
            <returns><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface of the media sample. The caller must release the interface.</p> </dd></returns>
            <remarks>
            <p>Initially the sample does not contain any media buffers.</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms702276</doc-id>
            <unmanaged>HRESULT MFCreateSample([Out] IMFSample** ppIMFSample)</unmanaged>
            <unmanaged-short>MFCreateSample</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateAttributes(SharpDX.MediaFoundation.MediaAttributes,System.Int32)">
            <summary>
            <p> Creates an empty attribute store. </p>
            </summary>
            <param name = "mFAttributesOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <param name = "cInitialSize"><dd> <p>The initial number of elements allocated for the attribute store. The attribute store grows as needed. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Attributes are used throughout Microsoft Media Foundation to configure objects, describe media formats, query object properties, and other purposes. For more information, see Attributes in Media Foundation.</p><p>For a complete list of all the defined attribute GUIDs in Media Foundation, see Media Foundation Attributes.</p>
            </remarks>
            <doc-id>ms701878</doc-id>
            <unmanaged>HRESULT MFCreateAttributes([Out, Fast] IMFAttributes** ppMFAttributes,[In] unsigned int cInitialSize)</unmanaged>
            <unmanaged-short>MFCreateAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.InitAttributesFromBlob(SharpDX.MediaFoundation.MediaAttributes,System.Byte[],System.Int32)">
            <summary>
            <p> </p><p>Initializes the contents of an attribute store from a byte array.</p>
            </summary>
            <param name = "attributesRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of the attribute store.</p> </dd></param>
            <param name = "bufRef"><dd> <p>Pointer to the array that contains the initialization data.</p> </dd></param>
            <param name = "cbBufSize"><dd> <p>Size of the <em>pBuf</em> array, in bytes.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The buffer is not valid.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Use this function to deserialize an attribute store that was serialized with the <strong>MFGetAttributesAsBlob</strong> function.</p><p>This function deletes any attributes that were previously stored in <em>pAttributes</em>.</p>
            </remarks>
            <doc-id>ms703978</doc-id>
            <unmanaged>HRESULT MFInitAttributesFromBlob([In] IMFAttributes* pAttributes,[In, Buffer] const unsigned char* pBuf,[In] unsigned int cbBufSize)</unmanaged>
            <unmanaged-short>MFInitAttributesFromBlob</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.GetAttributesAsBlobSize(SharpDX.MediaFoundation.MediaAttributes,System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the size of the buffer needed for the <strong>MFGetAttributesAsBlob</strong> function.</p>
            </summary>
            <param name = "attributesRef">No documentation.</param>
            <param name = "cbBufSizeRef">No documentation.</param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Use this function to find the size of the array that is needed for the <strong>MFGetAttributesAsBlob</strong> function.</p>
            </remarks>
            <doc-id>ms697064</doc-id>
            <unmanaged>HRESULT MFGetAttributesAsBlobSize([In] IMFAttributes* pAttributes,[Out] unsigned int* pcbBufSize)</unmanaged>
            <unmanaged-short>MFGetAttributesAsBlobSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.GetAttributesAsBlob(SharpDX.MediaFoundation.MediaAttributes,System.Byte[],System.Int32)">
            <summary>
            <p> </p><p>Converts the contents of an attribute store to a byte array.</p>
            </summary>
            <param name = "attributesRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of the attribute store.</p> </dd></param>
            <param name = "bufRef"><dd> <p>Pointer to an array that receives the attribute data.</p> </dd></param>
            <param name = "cbBufSize"><dd> <p>Size of the <em>pBuf</em> array, in bytes. To get the required size of the buffer, call <strong>MFGetAttributesAsBlobSize</strong>.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:BufferTooSmall"/></strong></dt> </dl> </td><td> <p>The buffer given in <em>pBuf</em> is too small.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The function skips any attributes with <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference values (MF_ATTRIBUTE_IUNKNOWN); they are not stored in the array.</p><p>To convert the byte array back into an attribute store, call <strong>MFInitAttributesFromBlob</strong>.</p><p>To write an attribute store to a stream, call the <strong>MFSerializeAttributesToStream</strong> function.</p>
            </remarks>
            <doc-id>ms694877</doc-id>
            <unmanaged>HRESULT MFGetAttributesAsBlob([In] IMFAttributes* pAttributes,[Out, Buffer] unsigned char* pBuf,[In] unsigned int cbBufSize)</unmanaged>
            <unmanaged-short>MFGetAttributesAsBlob</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.TRegister(System.Guid,System.Guid,System.String,System.Int32,System.Int32,SharpDX.MediaFoundation.TRegisterTypeInformation[],System.Int32,SharpDX.MediaFoundation.TRegisterTypeInformation[],SharpDX.MediaFoundation.MediaAttributes)">
            <summary>
            <p> Adds information about a Media Foundation transform (MFT) to the registry. </p><p>Applications can enumerate the MFT by calling the <strong>MFTEnum</strong> or <strong>MFTEnumEx</strong> function.</p>
            </summary>
            <param name = "clsidMFT">No documentation.</param>
            <param name = "guidCategory">No documentation.</param>
            <param name = "szNameRef">No documentation.</param>
            <param name = "flags">No documentation.</param>
            <param name = "cInputTypes">No documentation.</param>
            <param name = "inputTypesRef">No documentation.</param>
            <param name = "cOutputTypes">No documentation.</param>
            <param name = "outputTypesRef">No documentation.</param>
            <param name = "attributesRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The registry entries created by this function are read by the following functions: </p><table> <tr><th>Function</th><th>Description</th></tr> <tr><td> <strong>MFTEnum</strong> </td><td>Enumerates MFTs by media type and category.</td></tr> <tr><td> <strong>MFTEnumEx</strong> </td><td>Extended version of <strong>MFTEnum</strong>.</td></tr> <tr><td> <strong>MFTGetInfo</strong> </td><td>Looks up an MFT by CLSID and retrieves the registry information.</td></tr> </table><p>?</p><p>This function does not register the CLSID of the MFT for the <strong>CoCreateInstance</strong> or <strong>CoGetClassObject</strong> functions. </p><p> To remove the entries from the registry, call <strong>MFTUnregister</strong>. If you remove an MFT from the system, you should always call <strong>MFTUnregister</strong>.</p><p> The formats given in the <em>pInputTypes</em> and <em>pOutputTypes</em> parameters are intended to help applications search for MFTs by format. Applications can use the <strong>MFTEnum</strong> or <strong>MFTEnumEx</strong> functions to enumerate MFTs that match a particular set of formats.</p><p>It is recommended  to specify at least one input type in <em>pInputTypes</em> and one output type in the <em>pOutputTypes</em> parameter. Otherwise, the MFT might be skipped in the enumeration.</p><p>On 64-bit Windows, the 32-bit version of this function registers the MFT in the 32-bit node of the registry. For more information, see 32-bit and 64-bit Application Data in the Registry.</p>
            </remarks>
            <doc-id>ms705640</doc-id>
            <unmanaged>HRESULT MFTRegister([In] GUID clsidMFT,[In] GUID guidCategory,[In] wchar_t* pszName,[In] unsigned int Flags,[In] unsigned int cInputTypes,[In, Buffer, Optional] MFT_REGISTER_TYPE_INFO* pInputTypes,[In] unsigned int cOutputTypes,[In, Buffer, Optional] MFT_REGISTER_TYPE_INFO* pOutputTypes,[In, Optional] IMFAttributes* pAttributes)</unmanaged>
            <unmanaged-short>MFTRegister</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.TUnregister(System.Guid)">
            <summary>
            <p> Unregisters a Media Foundation transform (MFT). </p>
            </summary>
            <param name = "clsidMFT"><dd> <p> The CLSID of the MFT. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> This function removes the registry entries created by the <strong>MFTRegister</strong> function.</p><p>It is safe to call <strong>MFTUnregister</strong> twice with the same CLSID. If the CLSID is not found in the registry, the function succeeds and does nothing.</p>
            </remarks>
            <doc-id>ms696199</doc-id>
            <unmanaged>HRESULT MFTUnregister([In] GUID clsidMFT)</unmanaged>
            <unmanaged-short>MFTUnregister</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.TRegisterLocal(SharpDX.ComObject,System.Guid,System.String,System.Int32,System.Int32,SharpDX.MediaFoundation.TRegisterTypeInformation[],System.Int32,SharpDX.MediaFoundation.TRegisterTypeInformation[])">
            <summary>
            <p>Registers a Media Foundation transform (MFT) in the caller's process.</p>
            </summary>
            <param name = "classFactoryRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.ComObject"/></strong> interface of a class factory object. The class factory creates the MFT.</p> </dd></param>
            <param name = "guidCategory"><dd> <p>A <see cref = "T:System.Guid"/> that specifies the category of the MFT. For a list of MFT categories, see <strong>MFT_CATEGORY</strong>.</p> </dd></param>
            <param name = "szNameRef"><dd> <p>A wide-character null-terminated string that contains the friendly name of the MFT.</p> </dd></param>
            <param name = "flags"><dd> <p>A bitwise <strong>OR</strong> of zero or more flags from the <strong>_MFT_ENUM_FLAG</strong> enumeration.</p> </dd></param>
            <param name = "cInputTypes"><dd> <p>The number of elements in the <em>pInputTypes</em> array.</p> </dd></param>
            <param name = "inputTypesRef"><dd> <p>A reference to an array of <strong><see cref = "T:SharpDX.MediaFoundation.TRegisterTypeInformation"/></strong> structures. Each member of the array specifies an input format that the MFT supports. This parameter can be <strong><c>null</c></strong> if <em>cInputTypes</em> is zero.</p> </dd></param>
            <param name = "cOutputTypes"><dd> <p>The number of elements in the <em>pOutputTypes</em> array.</p> </dd></param>
            <param name = "outputTypesRef"><dd> <p>A reference to an array of <strong><see cref = "T:SharpDX.MediaFoundation.TRegisterTypeInformation"/></strong> structures. Each member of the array defines an output format that the MFT supports. This parameter can be <strong><c>null</c></strong> if <em>cOutputTypes</em> is zero.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The primary purpose of this function is to make an MFT available for automatic topology resolution without making the MFT available to other processes or applications.</p><p>After you call this function, the MFT can be enumerated by calling the <strong>MFTEnumEx</strong> function with the <strong>MFT_ENUM_FLAG_LOCALMFT</strong> flag. The MFT can be enumerated from within the same process, but is not visible to other processes.</p><p>The <em>pClassFactory</em> parameter specifies a class factory object that creates the MFT. The class factory's <strong>IClassFactory::CreateInstance</strong> method must return an object that supports the <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> interface.</p><strong>Note</strong>??The <strong>MFTEnumEx</strong> function retrieves a list of <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> references. However, the class factory does not need to support the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface. Instead, the <strong>MFTEnumEx</strong> function provides an implementation of <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> that wraps the class factory.?<p>To unregister the MFT from the current process, call <strong>MFTUnregisterLocal</strong>.</p><p>If you need to register an MFT in the Protected Media Path (PMP) process, use the <strong><see cref = "T:SharpDX.MediaFoundation.LocalMFTRegistration"/></strong> interface.</p>
            </remarks>
            <doc-id>dd388656</doc-id>
            <unmanaged>HRESULT MFTRegisterLocal([In] IClassFactory* pClassFactory,[In] const GUID&amp; guidCategory,[In] const wchar_t* pszName,[In] unsigned int Flags,[In] unsigned int cInputTypes,[In, Buffer, Optional] const MFT_REGISTER_TYPE_INFO* pInputTypes,[In] unsigned int cOutputTypes,[In, Buffer, Optional] const MFT_REGISTER_TYPE_INFO* pOutputTypes)</unmanaged>
            <unmanaged-short>MFTRegisterLocal</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.TUnregisterLocal(SharpDX.ComObject)">
            <summary>
            <p>Unregisters one or more Media Foundation transforms (MFTs) from the caller's process.</p>
            </summary>
            <param name = "classFactoryRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.ComObject"/></strong> interface of a class factory object. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>HRESULT_FROM_WIN32(<strong>ERROR_NOT_FOUND</strong>)</strong></dt> </dl> </td><td> <p>The MFT specified by the <em>pClassFactory</em> parameter was not registered in this process.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Use this function to unregister a local MFT that was previously registered through the <strong>MFTRegisterLocal</strong> function.</p><p>If the <em>pClassFactory</em> parameter is <strong><c>null</c></strong>, all local MFTs in the process are unregistered. Otherwise, the function unregisters the MFT associated with the class factory specified by the <em>pClassFactory</em> parameter. In that case, the <em>pClassFactory</em> parameter should equal a reference value that was previously passed to  the <strong>MFTRegisterLocal</strong> function.</p>
            </remarks>
            <doc-id>dd388658</doc-id>
            <unmanaged>HRESULT MFTUnregisterLocal([In, Optional] IClassFactory* pClassFactory)</unmanaged>
            <unmanaged-short>MFTUnregisterLocal</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.TRegisterLocalByCLSID(System.Guid,System.Guid,System.String,System.Int32,System.Int32,SharpDX.MediaFoundation.TRegisterTypeInformation[],System.Int32,SharpDX.MediaFoundation.TRegisterTypeInformation[])">
            <summary>
            <p>Registers a Media Foundation transform (MFT) in the caller's process.</p>
            </summary>
            <param name = "clisdMFT"><dd> <p>The class identifier (CLSID) of the MFT.</p> </dd></param>
            <param name = "guidCategory"><dd> <p>A <see cref = "T:System.Guid"/> that specifies the category of the MFT. For a list of MFT categories, see <strong>MFT_CATEGORY</strong>.</p> </dd></param>
            <param name = "szNameRef"><dd> <p>A wide-character null-terminated string that contains the friendly name of the MFT.</p> </dd></param>
            <param name = "flags"><dd> <p>A bitwise <strong>OR</strong> of zero or more flags from the <strong>_MFT_ENUM_FLAG</strong> enumeration.</p> </dd></param>
            <param name = "cInputTypes"><dd> <p>The number of elements in the <em>pInputTypes</em> array.</p> </dd></param>
            <param name = "inputTypesRef"><dd> <p>A reference to an array of <strong><see cref = "T:SharpDX.MediaFoundation.TRegisterTypeInformation"/></strong> structures. Each member of the array specifies an input format that the MFT supports. This parameter can be <strong><c>null</c></strong> if <em>cInputTypes</em> is zero.</p> </dd></param>
            <param name = "cOutputTypes"><dd> <p>The number of elements in the <em>pOutputTypes</em> array.</p> </dd></param>
            <param name = "outputTypesRef"><dd> <p>A reference to an array of <strong><see cref = "T:SharpDX.MediaFoundation.TRegisterTypeInformation"/></strong> structures. Each member of the array defines an output format that the MFT supports. This parameter can be <strong><c>null</c></strong> if <em>cOutputTypes</em> is zero.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The primary purpose of this function is to make an MFT available for automatic topology resolution without making the MFT available to other processes or applications.</p><p>After you call this function, the MFT can be enumerated by calling the <strong>MFTEnumEx</strong> function with the <strong>MFT_ENUM_FLAG_LOCALMFT</strong> flag. The MFT can be enumerated from within the same process, but is not visible to other processes.</p><p>To unregister the MFT from the current process, call <strong>MFTUnregisterLocalByCLSID</strong>.</p><p>If you need to register an MFT in the Protected Media Path (PMP) process, use the <strong><see cref = "T:SharpDX.MediaFoundation.LocalMFTRegistration"/></strong> interface.</p>
            </remarks>
            <doc-id>dd388657</doc-id>
            <unmanaged>HRESULT MFTRegisterLocalByCLSID([In] const GUID&amp; clisdMFT,[In] const GUID&amp; guidCategory,[In] const wchar_t* pszName,[In] unsigned int Flags,[In] unsigned int cInputTypes,[In, Buffer, Optional] const MFT_REGISTER_TYPE_INFO* pInputTypes,[In] unsigned int cOutputTypes,[In, Buffer, Optional] const MFT_REGISTER_TYPE_INFO* pOutputTypes)</unmanaged>
            <unmanaged-short>MFTRegisterLocalByCLSID</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.TUnregisterLocalByCLSID(System.Guid)">
            <summary>
            <p>Unregisters a Media Foundation transform (MFT) from the caller's process.</p>
            </summary>
            <param name = "clsidMFT"><dd> <p>The class identifier (CLSID) of the MFT.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>HRESULT_FROM_WIN32(<strong>ERROR_NOT_FOUND</strong>)</strong></dt> </dl> </td><td> <p>The MFT specified by the <em>clsidMFT</em> parameter was not registered in this process.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Use this function to unregister a local MFT that was previously registered through the <strong>MFTRegisterLocalByCLSID</strong> function.</p>
            </remarks>
            <doc-id>dd388659</doc-id>
            <unmanaged>HRESULT MFTUnregisterLocalByCLSID([In] GUID clsidMFT)</unmanaged>
            <unmanaged-short>MFTUnregisterLocalByCLSID</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.TEnum(System.Guid,System.Int32,System.Nullable{SharpDX.MediaFoundation.TRegisterTypeInformation},System.Nullable{SharpDX.MediaFoundation.TRegisterTypeInformation},SharpDX.MediaFoundation.MediaAttributes,System.Guid[],System.Int32@)">
            <summary>
            <p> Enumerates Media Foundation transforms (MFTs) in the registry. </p><p>Starting in Windows?7, applications should use the <strong>MFTEnumEx</strong> function instead.</p>
            </summary>
            <param name = "guidCategory">No documentation.</param>
            <param name = "flags">No documentation.</param>
            <param name = "inputTypeRef">No documentation.</param>
            <param name = "outputTypeRef">No documentation.</param>
            <param name = "attributesRef">No documentation.</param>
            <param name = "clsidMFTOut">No documentation.</param>
            <param name = "cMFTsRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> This function returns a list of all the MFTs in the specified category that match the search criteria given by the <em>pInputType</em>, <em>pOutputType</em>, and <em>pAttributes</em> parameters. Any of those parameters can be <strong><c>null</c></strong>. </p><p> If no MFTs match the criteria, the method succeeds but returns the value zero in <em>pcMFTs</em>. </p>
            </remarks>
            <doc-id>ms701774</doc-id>
            <unmanaged>HRESULT MFTEnum([In] GUID guidCategory,[In] unsigned int Flags,[In, Optional] MFT_REGISTER_TYPE_INFO* pInputType,[In, Optional] MFT_REGISTER_TYPE_INFO* pOutputType,[In, Optional] IMFAttributes* pAttributes,[Out, Buffer] GUID** ppclsidMFT,[Out] unsigned int* pcMFTs)</unmanaged>
            <unmanaged-short>MFTEnum</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.TEnumEx(System.Guid,System.Int32,System.Nullable{SharpDX.MediaFoundation.TRegisterTypeInformation},System.Nullable{SharpDX.MediaFoundation.TRegisterTypeInformation},System.IntPtr@,System.Int32@)">
            <summary>
            <p>Gets a list of Microsoft Media Foundation transforms (MFTs) that match specified search criteria. This function extends the <strong>MFTEnum</strong> function.</p>
            </summary>
            <param name = "guidCategory">No documentation.</param>
            <param name = "flags">No documentation.</param>
            <param name = "inputTypeRef">No documentation.</param>
            <param name = "outputTypeRef">No documentation.</param>
            <param name = "pMFTActivateOut">No documentation.</param>
            <param name = "numMFTActivateRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The <em>Flags</em> parameter controls which MFTs are enumerated, and the order in which they are returned. The flags for this parameter fall into several groups.</p><p> </p><p>The first set of flags specifies how an MFT processes data.</p><table> <tr><th>Flag</th><th>Description</th></tr> <tr><td> <p>MFT_ENUM_FLAG_SYNCMFT</p> </td><td> <p>The MFT performs synchronous data processing in software. This is the original MFT processing model, and is  compatible with Windows?Vista.</p> </td></tr> <tr><td> <p>MFT_ENUM_FLAG_ASYNCMFT</p> </td><td> <p>The MFT performs asynchronous data processing in software. This processing model requires Windows?7. For more information, see Asynchronous MFTs.</p> </td></tr> <tr><td> <p>MFT_ENUM_FLAG_HARDWARE</p> </td><td> <p>The MFT performs hardware-based data processing, using either the AVStream driver or a GPU-based proxy MFT. MFTs in this category always process data asynchronously. For more information, see Hardware MFTs.</p> </td></tr> </table><p>?</p><p>Every MFT falls into exactly one of these categories.  To enumerate a category, set the corresponding flag in the <em>Flags</em> parameter. You can combine these flags to enumerate more than one category. If none of these flags is specified, the default category is synchronous MFTs (<strong>MFT_ENUM_FLAG_SYNCMFT</strong>).</p><p> </p><p> </p><p>Next, the following flags include MFTs that are otherwise  excluded from the results. By default, flags that match these criteria are excluded from the results. Use any these flags to include them.</p><table> <tr><th>Flag</th><th>Description</th></tr> <tr><td> <p><strong>MFT_ENUM_FLAG_FIELDOFUSE</strong></p> </td><td> <p>Include MFTs that must be unlocked by the application.</p> </td></tr> <tr><td> <p><strong>MFT_ENUM_FLAG_LOCALMFT</strong></p> </td><td> <p>Include MFTs that are registered in the caller's process through either the <strong>MFTRegisterLocal</strong> or <strong>MFTRegisterLocalByCLSID</strong> function.</p> </td></tr> <tr><td> <p><strong>MFT_ENUM_FLAG_TRANSCODE_ONLY</strong></p> </td><td> <p>Include MFTs that are optimized for transcoding rather than playback.</p> </td></tr> </table><p>?</p><p> </p><p> </p><p>The last flag is used to sort and filter the results:</p><table> <tr><th>Flag</th><th>Description</th></tr> <tr><td> <p><strong>MFT_ENUM_FLAG_SORTANDFILTER</strong></p> </td><td> <p>Sort and filter the results.</p> </td></tr> </table><p>?</p><p>If the <strong>MFT_ENUM_FLAG_SORTANDFILTER</strong> flag is set, the <strong>MFTEnumEx</strong> function sorts the results as follows:</p><ul> <li>Local: If the <strong>MFT_ENUM_FLAG_LOCALMFT</strong> flag is set, local MFTs appear first in the list. To register a local MFT, call the <strong>MFTRegisterLocal</strong> or <strong>MFTRegisterLocalByCLSID</strong> function.</li> <li>Merit: MFTs with a merit value appear next on the list, in order of merit value (highest to lowest). For more information about merit, see <see cref = "!:MftCodecMeritAttribute"/>. </li> <li>Preferred: If an MFT is listed in the plug-in control's preferred list, it appears next in the list. For more information about the plug-in control, see <strong><see cref = "T:SharpDX.MediaFoundation.PluginControl"/></strong>.</li> <li>If an MFT appears on the blocked list, it is excluded from the results. For more information about the blocked list, see <strong>IMFPluginControl::IsDisabled</strong>.</li> <li>Any other MFTs that match the search criteria appear at the end of the list, unsorted.</li> </ul><p>If you do not set the <strong>MFT_ENUM_FLAG_SORTANDFILTER</strong> flag, the <strong>MFTEnumEx</strong> function returns an unsorted list.</p><p>Setting the <em>Flags</em> parameter to zero is equivalent to using the value <strong>MFT_ENUM_FLAG_SYNCMFT</strong> | <strong>MFT_ENUM_FLAG_LOCALMFT</strong> | <strong>MFT_ENUM_FLAG_SORTANDFILTER</strong>.</p><p>Setting <em>Flags</em> to <strong>MFT_ENUM_FLAG_SYNCMFT</strong> is equivalent to calling the <strong>MFTEnum</strong> function.</p><p>If no MFTs match the search criteria, the function returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>, unless some other error occurs. Therefore, always check the count received in the <em>pcMFTActivate</em> parameter before you dereference the <em>pppMFTActivate</em> reference.</p><strong>Note</strong>??There is no way to enumerate just local MFTs and nothing else. Setting <em>Flags</em> equal to <strong>MFT_ENUM_FLAG_LOCALMFT</strong> is equivalent to  including the <strong>MFT_ENUM_FLAG_SYNCMFT</strong> flag. However, if you also sort the results by specifying the <strong>MFT_ENUM_FLAG_SORTANDFILTER</strong> flag, local MFTs appear first in the list.?
            </remarks>
            <doc-id>dd388652</doc-id>
            <unmanaged>HRESULT MFTEnumEx([In] GUID guidCategory,[In] unsigned int Flags,[In, Optional] const MFT_REGISTER_TYPE_INFO* pInputType,[In, Optional] const MFT_REGISTER_TYPE_INFO* pOutputType,[Out] IMFActivate*** pppMFTActivate,[Out] unsigned int* pnumMFTActivate)</unmanaged>
            <unmanaged-short>MFTEnumEx</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.TEnum2(System.Guid,System.Int32,System.Nullable{SharpDX.MediaFoundation.TRegisterTypeInformation},System.Nullable{SharpDX.MediaFoundation.TRegisterTypeInformation},SharpDX.MediaFoundation.MediaAttributes,SharpDX.MediaFoundation.Activate[],System.Int32@)">
            <summary>
            <p> Gets a list of Microsoft Media Foundation transforms (MFTs) that match specified search criteria. This function extends the <strong>MFTEnumEx</strong> function to allow external applications and internal components to discover the hardware MFTs that correspond to a specific video adapter.  </p>
            </summary>
            <param name = "guidCategory">No documentation.</param>
            <param name = "flags">No documentation.</param>
            <param name = "inputTypeRef">No documentation.</param>
            <param name = "outputTypeRef">No documentation.</param>
            <param name = "attributesRef">No documentation.</param>
            <param name = "pMFTActivateOut">No documentation.</param>
            <param name = "numMFTActivateRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The <em>Flags</em> parameter controls which MFTs are enumerated, and the order in which they are returned. The flags for this parameter fall into several groups.</p><p> </p><p>The first set of flags specifies how an MFT processes data.</p><table> <tr><th>Flag</th><th>Description</th></tr> <tr><td> <p>MFT_ENUM_FLAG_SYNCMFT</p> </td><td> <p>The MFT performs synchronous data processing in software. This is the original MFT processing model, and is  compatible with Windows?Vista.</p> </td></tr> <tr><td> <p>MFT_ENUM_FLAG_ASYNCMFT</p> </td><td> <p>The MFT performs asynchronous data processing in software. This processing model requires Windows?7. For more information, see Asynchronous MFTs.</p> </td></tr> <tr><td> <p>MFT_ENUM_FLAG_HARDWARE</p> </td><td> <p>The MFT performs hardware-based data processing, using either the AVStream driver or a GPU-based proxy MFT. MFTs in this category always process data asynchronously. For more information, see Hardware MFTs.</p> </td></tr> </table><p>?</p><p>Every MFT falls into exactly one of these categories.  To enumerate a category, set the corresponding flag in the <em>Flags</em> parameter. You can combine these flags to enumerate more than one category. If none of these flags is specified, the default category is synchronous MFTs (<strong>MFT_ENUM_FLAG_SYNCMFT</strong>).</p><p> </p><p> </p><p>Next, the following flags include MFTs that are otherwise  excluded from the results. By default, flags that match these criteria are excluded from the results. Use any these flags to include them.</p><table> <tr><th>Flag</th><th>Description</th></tr> <tr><td> <p><strong>MFT_ENUM_FLAG_FIELDOFUSE</strong></p> </td><td> <p>Include MFTs that must be unlocked by the application.</p> </td></tr> <tr><td> <p><strong>MFT_ENUM_FLAG_LOCALMFT</strong></p> </td><td> <p>Include MFTs that are registered in the caller's process through either the <strong>MFTRegisterLocal</strong> or <strong>MFTRegisterLocalByCLSID</strong> function.</p> </td></tr> <tr><td> <p><strong>MFT_ENUM_FLAG_TRANSCODE_ONLY</strong></p> </td><td> <p>Include MFTs that are optimized for transcoding rather than playback.</p> </td></tr> </table><p>?</p><p> </p><p> </p><p>The last flag is used to sort and filter the results:</p><table> <tr><th>Flag</th><th>Description</th></tr> <tr><td> <p><strong>MFT_ENUM_FLAG_SORTANDFILTER</strong></p> </td><td> <p>Sort and filter the results.</p> </td></tr> </table><p>?</p><p>If the <strong>MFT_ENUM_FLAG_SORTANDFILTER</strong> flag is set, the <strong>MFTEnum2</strong> function sorts the results as follows:</p><ul> <li>Local: If the <strong>MFT_ENUM_FLAG_LOCALMFT</strong> flag is set, local MFTs appear first in the list. To register a local MFT, call the <strong>MFTRegisterLocal</strong> or <strong>MFTRegisterLocalByCLSID</strong> function.</li> <li>Merit: MFTs with a merit value appear next on the list, in order of merit value (highest to lowest). For more information about merit, see <see cref = "!:MftCodecMeritAttribute"/>. </li> <li>Preferred: If an MFT is listed in the plug-in control's preferred list, it appears next in the list. For more information about the plug-in control, see <strong><see cref = "T:SharpDX.MediaFoundation.PluginControl"/></strong>.</li> <li>If an MFT appears on the blocked list, it is excluded from the results. For more information about the blocked list, see <strong>IMFPluginControl::IsDisabled</strong>.</li> <li>Any other MFTs that match the search criteria appear at the end of the list, unsorted.</li> </ul><p>If you do not set the <strong>MFT_ENUM_FLAG_SORTANDFILTER</strong> flag, the <strong>MFTEnum2</strong> function returns an unsorted list.</p><p>Setting the <em>Flags</em> parameter to zero is equivalent to using the value <strong>MFT_ENUM_FLAG_SYNCMFT</strong> | <strong>MFT_ENUM_FLAG_LOCALMFT</strong> | <strong>MFT_ENUM_FLAG_SORTANDFILTER</strong>.</p><p>Setting <em>Flags</em> to <strong>MFT_ENUM_FLAG_SYNCMFT</strong> is equivalent to calling the <strong>MFTEnum</strong> function.</p><p>If no MFTs match the search criteria, the function returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>, unless some other error occurs. Therefore, always check the count received in the <em>pcMFTActivate</em> parameter before you dereference the <em>pppMFTActivate</em> reference.</p><strong>Note</strong>??There is no way to enumerate just local MFTs and nothing else. Setting <em>Flags</em> equal to <strong>MFT_ENUM_FLAG_LOCALMFT</strong> is equivalent to  including the <strong>MFT_ENUM_FLAG_SYNCMFT</strong> flag. However, if you also sort the results by specifying the <strong>MFT_ENUM_FLAG_SORTANDFILTER</strong> flag, local MFTs appear first in the list.?
            </remarks>
            <doc-id>mt739436</doc-id>
            <unmanaged>HRESULT MFTEnum2([In] GUID guidCategory,[In] unsigned int Flags,[In, Optional] const MFT_REGISTER_TYPE_INFO* pInputType,[In, Optional] const MFT_REGISTER_TYPE_INFO* pOutputType,[In, Optional] IMFAttributes* pAttributes,[Out, Buffer] IMFActivate*** pppMFTActivate,[Out] unsigned int* pnumMFTActivate)</unmanaged>
            <unmanaged-short>MFTEnum2</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.TGetInfo(System.Guid,System.IntPtr,SharpDX.MediaFoundation.TRegisterTypeInformation[],System.Int32@,SharpDX.MediaFoundation.TRegisterTypeInformation[],System.Int32@,SharpDX.MediaFoundation.MediaAttributes@)">
            <summary>
            <p> Gets information from the registry about a Media Foundation transform (MFT). </p>
            </summary>
            <param name = "clsidMFT"><dd> <p> The CLSID of the MFT. </p> </dd></param>
            <param name = "szNameRef"><dd> <p> Receives a reference to a wide-character string containing the friendly name of the MFT. The caller must free the string by calling <strong>CoTaskMemFree</strong>. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
            <param name = "inputTypesOut"><dd> <p> Receives a reference to an array of <strong><see cref = "T:SharpDX.MediaFoundation.TRegisterTypeInformation"/></strong> structures. Each member of the array describes an input format that the MFT supports. The caller must free the array by calling <strong>CoTaskMemFree</strong>. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
            <param name = "cInputTypesRef"><dd> <p> Receives the number of elements in the <em>ppInputTypes</em> array. If <em>ppInputTypes</em> is <strong><c>null</c></strong>, this parameter is ignored and can be <strong><c>null</c></strong>. </p> </dd></param>
            <param name = "outputTypesOut"><dd> <p> Receives a reference to an array of <strong><see cref = "T:SharpDX.MediaFoundation.TRegisterTypeInformation"/></strong> structures. Each member of the array describes an output format that the MFT supports. The caller must free the array by calling <strong>CoTaskMemFree</strong>. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
            <param name = "cOutputTypesRef"><dd> <p> Receives the number of elements in the <em>ppOutputType</em> array. If <em>ppOutputTypes</em> is <strong><c>null</c></strong>, this parameter is ignored and can be <strong><c>null</c></strong>. </p> </dd></param>
            <param name = "attributesOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of an attribute store. The caller must release the interface. The attribute store might contain attributes that are stored in the registry for the specified MFT. (For more information, see <strong>MFTRegister</strong>.)  If no attributes are stored in the registry for this MFT, the attribute store is empty. </p> <p>This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ms703830</doc-id>
            <unmanaged>HRESULT MFTGetInfo([In] GUID clsidMFT,[Out, Optional] wchar_t** pszName,[Out, Buffer, Optional] MFT_REGISTER_TYPE_INFO** ppInputTypes,[Out, Optional] unsigned int* pcInputTypes,[Out, Buffer, Optional] MFT_REGISTER_TYPE_INFO** ppOutputTypes,[Out, Optional] unsigned int* pcOutputTypes,[Out, Optional] IMFAttributes** ppAttributes)</unmanaged>
            <unmanaged-short>MFTGetInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.GetPluginControl(SharpDX.MediaFoundation.PluginControl@)">
            <summary>
            <p>Gets a reference to the Microsoft Media Foundation plug-in manager.</p>
            </summary>
            <param name = "pluginControlOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.PluginControl"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd388507</doc-id>
            <unmanaged>HRESULT MFGetPluginControl([Out] IMFPluginControl** ppPluginControl)</unmanaged>
            <unmanaged-short>MFGetPluginControl</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.GetMFTMerit(SharpDX.IUnknown,System.Int32,System.Byte[],System.Int32@)">
            <summary>
            <p>Gets the merit value of a hardware codec.</p>
            </summary>
            <param name = "mFTRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of the Media Foundation transform (MFT) that represents the codec.</p> </dd></param>
            <param name = "cbVerifier"><dd> <p>The size, in bytes, of the <em>verifier</em> array.</p> </dd></param>
            <param name = "verifier"><dd> <p>The address of a buffer that contains one of the following:</p> <ul> <li>The class identifier (CLSID) of the MFT.</li> <li>A null-terminated wide-character string that contains the symbol link for the underlying hardware device. Include the size of the terminating null in the value of <em>cbVerifier</em>.</li> </ul> </dd></param>
            <param name = "merit"><dd> <p>Receives the merit value.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The function fails if the MFT does not represent a hardware device with a valid Output Protection Manager (OPM) certificate. </p>
            </remarks>
            <doc-id>dd388506</doc-id>
            <unmanaged>HRESULT MFGetMFTMerit([InOut] IUnknown* pMFT,[In] unsigned int cbVerifier,[In, Buffer] const unsigned char* verifier,[Out] DWORD* merit)</unmanaged>
            <unmanaged-short>MFGetMFTMerit</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.RegisterLocalSchemeHandler(System.String,SharpDX.MediaFoundation.Activate)">
            <summary>
            <p>Registers a scheme handler in the caller's process.</p>
            </summary>
            <param name = "szScheme"><dd> <p>A string that contains the scheme. The scheme includes the trailing ':' character; for example,  "http:".</p> </dd></param>
            <param name = "activateRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface of an activation  object. The caller implements this interface. The  <strong>IMFActivate::ActivateObject</strong> method of the activation object must create a scheme handler object. The scheme handler exposes the  <strong><see cref = "T:SharpDX.MediaFoundation.SchemeHandler"/></strong> interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Scheme handlers are used in Microsoft Media Foundation during the source resolution process, which creates a media  source from a URL. For more information, see  Scheme Handlers and Byte-Stream Handlers.</p><p>Within a process, local scheme handlers take precedence over scheme handlers that are registered in the  registry. Local scheme handlers are not visible to other processes.</p><p>Use this function if you want to register a custom scheme handler for your application, but do not want the  handler available to other applications.</p>
            </remarks>
            <doc-id>hh162787</doc-id>
            <unmanaged>HRESULT MFRegisterLocalSchemeHandler([In] const wchar_t* szScheme,[In] IMFActivate* pActivate)</unmanaged>
            <unmanaged-short>MFRegisterLocalSchemeHandler</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.RegisterLocalByteStreamHandler(System.String,System.String,SharpDX.MediaFoundation.Activate)">
            <summary>
            <p>Registers a byte-stream handler in the caller's process.</p>
            </summary>
            <param name = "szFileExtension"><dd> <p>A string that contains the file name extension for this handler.</p> </dd></param>
            <param name = "szMimeType"><dd> <p>A string that contains the MIME type for this handler.</p> </dd></param>
            <param name = "activateRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface of an activation object. The caller implements this interface. The <strong>IMFActivate::ActivateObject</strong> method of the activation object must create a byte-stream handler. The byte-stream handler exposes the <strong><see cref = "T:SharpDX.MediaFoundation.ByteStreamHandler"/></strong> interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Byte-stream handlers are used in Microsoft Media Foundation during the source resolution process, which creates a media source from a URL. For more information, see Scheme Handlers and Byte-Stream Handlers.</p><p>Within a process, local byte-stream handlers take precedence over byte-stream handlers that are registered in the registry. Local byte-stream handlers are not visible to other processes.</p><p>Use this function if you want to register a custom byte-stream handler for your application, but do not want the handler available to other applications.</p><p>Either <em>szFileExtension</em> or <em>szMimeType</em> can be <strong><c>null</c></strong>; at least one must be non-<strong><c>null</c></strong>.</p>
            </remarks>
            <doc-id>hh162786</doc-id>
            <unmanaged>HRESULT MFRegisterLocalByteStreamHandler([In] const wchar_t* szFileExtension,[In] const wchar_t* szMimeType,[In] IMFActivate* pActivate)</unmanaged>
            <unmanaged-short>MFRegisterLocalByteStreamHandler</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateMFByteStreamWrapper(SharpDX.MediaFoundation.IByteStream,SharpDX.MediaFoundation.IByteStream@)">
            <summary>
            <p>Creates a wrapper for a byte stream.</p>
            </summary>
            <param name = "streamRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of the original byte stream.</p> </dd></param>
            <param name = "streamWrapperOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of the wrapper. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> methods on the wrapper call directly through to the original byte stream, except for the <strong>IMFByteStream::Close</strong> method. Calling <strong>Close</strong> on the wrapper closes the wrapper object, but leaves the original byte stream open.</p>
            </remarks>
            <doc-id>hh162755</doc-id>
            <unmanaged>HRESULT MFCreateMFByteStreamWrapper([In] IMFByteStream* pStream,[Out] IMFByteStream** ppStreamWrapper)</unmanaged>
            <unmanaged-short>MFCreateMFByteStreamWrapper</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateMediaExtensionActivate(System.String,SharpDX.IUnknown,System.Guid,System.IntPtr@)">
            <summary>
            <p>Creates an activation object for a Windows Runtime class.</p>
            </summary>
            <param name = "szActivatableClassId"><dd> <p>The class identifier that is associated with the activatable runtime class.</p> </dd></param>
            <param name = "configurationRef"><dd> <p>A reference to an optional <strong>IPropertySet</strong> object, which is used to configure the Windows Runtime class. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "riid"><dd> <p>The interface identifier (IID) of the interface being requested. The activation object created  by this function supports the following interfaces:</p> <ul> <li> <strong><see cref = "T:SharpDX.ComObject"/></strong> </li> <li> <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> </li> <li> <strong>IPersistStream</strong> </li> </ul> </dd></param>
            <param name = "vObjectOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>To create the Windows Runtime object, call <strong>IMFActivate::ActivateObject</strong> or <strong>IClassFactory::CreateInstance</strong>.</p>
            </remarks>
            <doc-id>hh162753</doc-id>
            <unmanaged>HRESULT MFCreateMediaExtensionActivate([In] const wchar_t* szActivatableClassId,[In, Optional] IUnknown* pConfiguration,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>
            <unmanaged-short>MFCreateMediaExtensionActivate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateMuxStreamAttributes(SharpDX.MediaFoundation.Collection,SharpDX.MediaFoundation.MediaAttributes@)">
            <summary>
            No documentation.
            </summary>
            <param name = "attributesToMuxRef">No documentation.</param>
            <param name = "muxAttribsOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT MFCreateMuxStreamAttributes([In] IMFCollection* pAttributesToMux,[Out] IMFAttributes** ppMuxAttribs)</unmanaged>
            <unmanaged-short>MFCreateMuxStreamAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateMuxStreamMediaType(SharpDX.MediaFoundation.Collection,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            No documentation.
            </summary>
            <param name = "mediaTypesToMuxRef">No documentation.</param>
            <param name = "muxMediaTypeOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT MFCreateMuxStreamMediaType([In] IMFCollection* pMediaTypesToMux,[Out] IMFMediaType** ppMuxMediaType)</unmanaged>
            <unmanaged-short>MFCreateMuxStreamMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateMuxStreamSample(SharpDX.MediaFoundation.Collection,SharpDX.MediaFoundation.Sample@)">
            <summary>
            No documentation.
            </summary>
            <param name = "samplesToMuxRef">No documentation.</param>
            <param name = "muxSampleOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT MFCreateMuxStreamSample([In] IMFCollection* pSamplesToMux,[Out] IMFSample** ppMuxSample)</unmanaged>
            <unmanaged-short>MFCreateMuxStreamSample</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.ValidateMediaTypeSize(System.Guid,System.Byte[],System.Int32)">
            <summary>
            <p> Validates the size of a buffer for a video format block. </p>
            </summary>
            <param name = "formatType"><dd> <p><see cref = "T:System.Guid"/> that specifies the type of format block. It must be one of the following values:</p> <dl><dt><strong>FORMAT_DvInfo</strong></dt><dt><strong>FORMAT_MFVideoFormat</strong></dt><dt><strong>FORMAT_MPEG2Video</strong></dt><dt><strong>FORMAT_MPEGStreams</strong></dt><dt><strong>FORMAT_MPEGVideo</strong></dt><dt><strong>FORMAT_VideoInfo</strong></dt><dt><strong>FORMAT_VideoInfo2</strong></dt><dt><strong>FORMAT_WaveFormatEx</strong></dt> </dl> </dd></param>
            <param name = "blockRef"><dd> <p> Pointer to a buffer that contains the format block. </p> </dd></param>
            <param name = "cbSize"><dd> <p> Size of the <em>pBlock</em> buffer, in bytes. </p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The buffer that contains the format block is large enough. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidMediaType"/></strong></dt> </dl> </td><td> <p> The buffer that contains the format block is too small, or the format block is not valid. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedFormat"/></strong></dt> </dl> </td><td> <p> This function does not support the specified format type. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms698993</doc-id>
            <unmanaged>HRESULT MFValidateMediaTypeSize([In] GUID FormatType,[In, Buffer, Optional] unsigned char* pBlock,[In] unsigned int cbSize)</unmanaged>
            <unmanaged-short>MFValidateMediaTypeSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateMediaType(SharpDX.MediaFoundation.MediaType)">
            <summary>
            <p> </p><p>Creates an empty media type.</p>
            </summary>
            <param name = "mFTypeOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The media type is created without any attributes. </p>
            </remarks>
            <doc-id>ms693861</doc-id>
            <unmanaged>HRESULT MFCreateMediaType([Out, Fast] IMFMediaType** ppMFType)</unmanaged>
            <unmanaged-short>MFCreateMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateMFVideoFormatFromMFMediaType(SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.VideoFormat@,System.Int32@)">
            <summary>
            <p>[This API is not supported and may be altered or unavailable in the future. Applications should avoid using the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure, and use media type attributes instead. For more information, see Video Media Types.]</p><p> Creates an <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure from a video media type.</p>
            </summary>
            <param name = "mFTypeRef">No documentation.</param>
            <param name = "mFVFOut">No documentation.</param>
            <param name = "cbSizeRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>aa473827</doc-id>
            <unmanaged>HRESULT MFCreateMFVideoFormatFromMFMediaType([In] IMFMediaType* pMFType,[Out] MFVIDEOFORMAT** ppMFVF,[Out, Optional] unsigned int* pcbSize)</unmanaged>
            <unmanaged-short>MFCreateMFVideoFormatFromMFMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateWaveFormatExFromMFMediaType(SharpDX.MediaFoundation.MediaType,System.IntPtr@,System.Int32@,System.Int32)">
            <summary>
            <p> </p><p>Converts a Media Foundation audio media type to a <strong><see cref = "T:SharpDX.Multimedia.WaveFormat"/></strong> structure.</p>
            </summary>
            <param name = "mFTypeRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type.</p> </dd></param>
            <param name = "wFOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.Multimedia.WaveFormat"/></strong> structure. The caller must release the memory allocated for the structure by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>
            <param name = "cbSizeRef"><dd> <p>Receives the size of the <strong><see cref = "T:SharpDX.Multimedia.WaveFormat"/></strong> structure.</p> </dd></param>
            <param name = "flags"><dd> <p>Contains a flag from the <strong><see cref = "T:SharpDX.MediaFoundation.WaveFormatExConvertFlags"/></strong> enumeration.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the <strong>wFormatTag</strong> member of the returned structure is <strong>WAVE_FORMAT_EXTENSIBLE</strong>, you can cast the reference to a <strong><see cref = "T:SharpDX.Multimedia.WaveFormatExtensible"/></strong> structure.</p>
            </remarks>
            <doc-id>ms702177</doc-id>
            <unmanaged>HRESULT MFCreateWaveFormatExFromMFMediaType([In] IMFMediaType* pMFType,[Out] WAVEFORMATEX** ppWF,[Out, Optional] unsigned int* pcbSize,[In] unsigned int Flags)</unmanaged>
            <unmanaged-short>MFCreateWaveFormatExFromMFMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CalculateBitmapImageSize(SharpDX.Win32.BitmapInfoHeader[],System.Int32,System.Int32@,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Retrieves the image size for a video format. Given a <strong><see cref = "T:SharpDX.Win32.BitmapInfoHeader"/></strong> structure, this function calculates the correct value of the <strong>biSizeImage</strong> member. </p>
            </summary>
            <param name = "bMIHRef">No documentation.</param>
            <param name = "cbBufSize">No documentation.</param>
            <param name = "cbImageSizeRef">No documentation.</param>
            <param name = "bKnownRef">No documentation.</param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> The <strong><see cref = "T:SharpDX.Win32.BitmapInfoHeader"/></strong> structure is not valid, or the value of <em>cbBufSize</em> is too small. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> Before calling this function, you must set at least the following members of the <strong><see cref = "T:SharpDX.Win32.BitmapInfoHeader"/></strong> structure:</p><ul> <li><strong>biCompression</strong></li> <li><strong>biBitCount</strong></li> <li><strong>biWidth</strong></li> <li><strong>biHeight</strong></li> </ul><p>Also, if <strong>biCompression</strong> is <strong>BI_BITFIELDS</strong>, the <strong><see cref = "T:SharpDX.Win32.BitmapInfoHeader"/></strong> structure must be followed by an array of color masks. </p><p> This function fails if the <strong><see cref = "T:SharpDX.Win32.BitmapInfoHeader"/></strong> structure describes a format that is not a video format. For example, it fails if <strong>biCompresson</strong> is <strong>BI_JPEG</strong> or <strong>BI_PNG</strong> .</p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms697582</doc-id>
            <unmanaged>HRESULT MFCalculateBitmapImageSize([In, Buffer] const BITMAPINFOHEADER* pBMIH,[In] unsigned int cbBufSize,[Out] unsigned int* pcbImageSize,[Out, Optional] BOOL* pbKnown)</unmanaged>
            <unmanaged-short>MFCalculateBitmapImageSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CalculateImageSize(System.Guid,System.Int32,System.Int32,System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the image size, in bytes, for an uncompressed video format.</p>
            </summary>
            <param name = "guidSubtype"><dd> <p>Media subtype for the video format. For a list of subtypes, see Media Type GUIDs.</p> </dd></param>
            <param name = "unWidth"><dd> <p>Width of the image, in pixels.</p> </dd></param>
            <param name = "unHeight"><dd> <p>Height of the image, in pixels.</p> </dd></param>
            <param name = "cbImageSizeRef"><dd> <p>Receives the size of each frame, in bytes. If the format is compressed or is not recognized, the value is zero.</p> </dd></param>
            <returns><p>The function returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970318</doc-id>
            <unmanaged>HRESULT MFCalculateImageSize([In] const GUID&amp; guidSubtype,[In] unsigned int unWidth,[In] unsigned int unHeight,[Out] unsigned int* pcbImageSize)</unmanaged>
            <unmanaged-short>MFCalculateImageSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.FrameRateToAverageTimePerFrame(System.Int32,System.Int32,System.Int64@)">
            <summary>
            <p> Converts a video frame rate into a frame duration.</p>
            </summary>
            <param name = "unNumerator"><dd> <p>The numerator of the frame rate. </p> </dd></param>
            <param name = "unDenominator"><dd> <p> The denominator of the frame rate. </p> </dd></param>
            <param name = "unAverageTimePerFrameRef"><dd> <p> Receives the average duration of a video frame, in 100-nanosecond units. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function is useful for calculating time stamps on a sample, given the frame rate.</p><p>Also, average time per frame is used in the older <strong><see cref = "!:SharpDX.Win32.Unsupported.VideoInfoHeader"/></strong> and <strong><see cref = "!:SharpDX.MediaFoundation.VideoInformationHeader2"/></strong> format structures. This function provides a standard conversion so that all components in the pipeline can use consistent values, if they need to translate between the older format structures and the media type attributes used in Media Foundation.</p><p> For certain common frame rates, the function gets the frame duration from a look-up table:</p><table> <tr><th>Frames per second (floating point)</th><th>Frames per second (fractional)</th><th>Average time per frame</th></tr> <tr><td>59.94</td><td>60000/1001</td><td>166833</td></tr> <tr><td>29.97</td><td>30000/1001</td><td>333667</td></tr> <tr><td>23.976</td><td>24000/1001</td><td>417188</td></tr> <tr><td>60</td><td>60/1</td><td>166667</td></tr> <tr><td>30</td><td>30/1</td><td>333333</td></tr> <tr><td>50</td><td>50/1</td><td>200000</td></tr> <tr><td>25</td><td>25/1</td><td>400000</td></tr> <tr><td>24</td><td>24/1</td><td>416667</td></tr> </table><p>?</p><p> Most video content uses one of the frame rates listed here. For other frame rates, the function calculates the duration.</p>
            </remarks>
            <doc-id>aa370467</doc-id>
            <unmanaged>HRESULT MFFrameRateToAverageTimePerFrame([In] unsigned int unNumerator,[In] unsigned int unDenominator,[Out] unsigned longlong* punAverageTimePerFrame)</unmanaged>
            <unmanaged-short>MFFrameRateToAverageTimePerFrame</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.AverageTimePerFrameToFrameRate(System.Int64,System.Int32@,System.Int32@)">
            <summary>
            <p> </p><p>Calculates the frame rate, in frames per second, from the average duration of a video frame.</p>
            </summary>
            <param name = "unAverageTimePerFrame"><dd> <p>The average duration of a video frame, in 100-nanosecond units.</p> </dd></param>
            <param name = "unNumeratorRef"><dd> <p>Receives the numerator of the frame rate.</p> </dd></param>
            <param name = "unDenominatorRef"><dd> <p>Receives the denominator of the frame rate.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Average time per frame is used in the older <strong><see cref = "!:SharpDX.Win32.Unsupported.VideoInfoHeader"/></strong> and <strong><see cref = "!:SharpDX.MediaFoundation.VideoInformationHeader2"/></strong> format structures. This function provides a standard conversion so that all components in the pipeline can use consistent values, if they need to translate between the older format structures and the media type attributes used in Media Foundation.</p><p>This function uses a look-up table for certain common durations. The table is listed in the Remarks section for the <strong>MFFrameRateToAverageTimePerFrame</strong> function.</p>
            </remarks>
            <doc-id>bb970468</doc-id>
            <unmanaged>HRESULT MFAverageTimePerFrameToFrameRate([In] unsigned longlong unAverageTimePerFrame,[Out] unsigned int* punNumerator,[Out] unsigned int* punDenominator)</unmanaged>
            <unmanaged-short>MFAverageTimePerFrameToFrameRate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.InitMediaTypeFromMFVideoFormat(SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.VideoFormat[],System.Int32)">
            <summary>
            <p>[This API is not supported and may be altered or unavailable in the future. Applications should avoid using the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure, and use media type attributes instead. For more information, see Video Media Types.]</p><p>Initializes a media type from an <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure.</p>
            </summary>
            <param name = "mFTypeRef">No documentation.</param>
            <param name = "mFVFRef">No documentation.</param>
            <param name = "cbBufSize">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>aa473795</doc-id>
            <unmanaged>HRESULT MFInitMediaTypeFromMFVideoFormat([In] IMFMediaType* pMFType,[In, Buffer] const MFVIDEOFORMAT* pMFVF,[In] unsigned int cbBufSize)</unmanaged>
            <unmanaged-short>MFInitMediaTypeFromMFVideoFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.InitMediaTypeFromWaveFormatEx(SharpDX.MediaFoundation.MediaType,SharpDX.Multimedia.WaveFormat[],System.Int32)">
            <summary>
            <p> Initializes a media type from a <strong><see cref = "T:SharpDX.Multimedia.WaveFormat"/></strong> structure. </p>
            </summary>
            <param name = "mFTypeRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type to initialize. To create the uninitialized media type object, call <strong>MFCreateMediaType</strong>.</p> </dd></param>
            <param name = "waveFormatRef"><dd> <p>Pointer to a <strong><see cref = "T:SharpDX.Multimedia.WaveFormat"/></strong> structure that describes the media type. The caller must fill in the structure members before calling this function.</p> </dd></param>
            <param name = "cbBufSize"><dd> <p>Size of the <strong><see cref = "T:SharpDX.Multimedia.WaveFormat"/></strong> structure, in bytes.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms700801</doc-id>
            <unmanaged>HRESULT MFInitMediaTypeFromWaveFormatEx([In] IMFMediaType* pMFType,[In, Buffer] const WAVEFORMATEX* pWaveFormat,[In] unsigned int cbBufSize)</unmanaged>
            <unmanaged-short>MFInitMediaTypeFromWaveFormatEx</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CompareFullToPartialMediaType(SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.MediaType)">
            <summary>
            <p> </p><p>Compares a full media type to a partial media type.</p>
            </summary>
            <param name = "mFTypeFullRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of the full media type.</p> </dd></param>
            <param name = "mFTypePartialRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of the partial media type.</p> </dd></param>
            <returns><p>If the full media type is compatible with the partial media type, the function returns <strong>TRUE</strong>. Otherwise, the function returns <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p></returns>
            <remarks>
            <p>A pipeline component can return a partial media type to describe a range of possible formats the component might accept. A partial media type has at least a major type <see cref = "T:System.Guid"/>, but might be missing some of the other attributes that are needed to fully describe the type. The missing attributes represent "don't care" values for the partial type. For example, a partial video type might be missing the attributes for the width and height of the video.</p><p>This function returns <strong>TRUE</strong> if the following conditions are both true:</p><ul> <li> The partial media type contains a major type <see cref = "T:System.Guid"/>. </li> <li> All of the attributes in the partial type exist in the full type and are set to the same value. </li> </ul><p> Otherwise, the function returns <strong><see cref = "F:SharpDX.Result.False"/></strong>. </p>
            </remarks>
            <doc-id>ms697237</doc-id>
            <unmanaged>BOOL MFCompareFullToPartialMediaType([In] IMFMediaType* pMFTypeFull,[In] IMFMediaType* pMFTypePartial)</unmanaged>
            <unmanaged-short>MFCompareFullToPartialMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.WrapMediaType(SharpDX.MediaFoundation.MediaType,System.Guid,System.Guid,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            <p> Creates a media type that wraps another media type. </p>
            </summary>
            <param name = "origRef"><dd> <p> A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type to wrap in a new media type. </p> </dd></param>
            <param name = "majorType"><dd> <p>A  <see cref = "T:System.Guid"/> that specifies the major type for the new media type. For a list of possible values, see Major Media Types. </p> </dd></param>
            <param name = "subType"><dd> <p>A  <see cref = "T:System.Guid"/> that specifies the subtype for the new media type. For possible values, see:</p> <ul> <li> <strong>Audio Subtypes</strong> </li> <li> Video Subtypes </li> </ul> <p>Applications can define custom subtype GUIDs.</p> </dd></param>
            <param name = "wrapOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of the new media type that wraps the original media type. The caller must release the interface. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The original media type (<em>pOrig</em>) is stored in the new media type under the <strong><see cref = "!:WrappedType"/></strong> attribute. To extract the original media type, call <strong>MFUnwrapMediaType</strong>. </p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms701782</doc-id>
            <unmanaged>HRESULT MFWrapMediaType([In] IMFMediaType* pOrig,[In] const GUID&amp; MajorType,[In] const GUID&amp; SubType,[Out] IMFMediaType** ppWrap)</unmanaged>
            <unmanaged-short>MFWrapMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.UnwrapMediaType(SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            <p> Retrieves a media type that was wrapped in another media type by the <strong>MFWrapMediaType</strong> function. </p>
            </summary>
            <param name = "wrapRef">No documentation.</param>
            <param name = "origOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms696190</doc-id>
            <unmanaged>HRESULT MFUnwrapMediaType([In] IMFMediaType* pWrap,[Out] IMFMediaType** ppOrig)</unmanaged>
            <unmanaged-short>MFUnwrapMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateVideoMediaType(SharpDX.MediaFoundation.VideoFormat@,SharpDX.MediaFoundation.VideoMediaType@)">
            <summary>
            <p>[This API is not supported and may be altered or unavailable in the future. Applications should avoid using the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure, and use media type attributes instead. For more information, see Video Media Types.]</p><p> Creates a video media type from an <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure. </p>
            </summary>
            <param name = "videoFormatRef">No documentation.</param>
            <param name = "iVideoMediaTypeOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> Instead of using the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure to initialize a video media type, you can call <strong>MFCreateMediaType</strong> and set the media type attributes directly. </p><strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?
            </remarks>
            <doc-id>aa473781</doc-id>
            <unmanaged>HRESULT MFCreateVideoMediaType([In] const MFVIDEOFORMAT* pVideoFormat,[Out] IMFVideoMediaType** ppIVideoMediaType)</unmanaged>
            <unmanaged-short>MFCreateVideoMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateVideoMediaTypeFromSubtype(System.Guid,SharpDX.MediaFoundation.VideoMediaType@)">
            <summary>
            <p> Creates a partial video media type with a specified subtype. </p>
            </summary>
            <param name = "aMSubtypeRef"><dd> <p> Pointer to a <see cref = "T:System.Guid"/> that specifies the subtype. See Video Subtype GUIDs. </p> </dd></param>
            <param name = "iVideoMediaTypeOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.VideoMediaType"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> This function creates a media type and sets the major type equal to <strong><see cref = "!:Video"/></strong> and the subtype equal to the value specified in <em>pAMSubtype</em>. </p><p>You can get the same result with the following steps:</p><ol> <li> Call <strong>MFCreateMediaType</strong>. This function returns a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. </li> <li> Set the <strong><see cref = "!:MajorType"/></strong> attribute to <strong><see cref = "!:Video"/></strong>. </li> <li> Set the <strong><see cref = "!:Subtype"/></strong> attribute to the subtype. </li> </ol><strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?
            </remarks>
            <doc-id>aa473791</doc-id>
            <unmanaged>HRESULT MFCreateVideoMediaTypeFromSubtype([In] const GUID* pAMSubtype,[Out] IMFVideoMediaType** ppIVideoMediaType)</unmanaged>
            <unmanaged-short>MFCreateVideoMediaTypeFromSubtype</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.IsFormatYUV(System.Int32)">
            <summary>
            <p> </p><p>Queries whether a FOURCC code or <strong>D3DFORMAT</strong> value is a YUV format.</p>
            </summary>
            <param name = "format"><dd> <p>FOURCC code or <strong>D3DFORMAT</strong> value.</p> </dd></param>
            <returns><p>The function returns one of the following values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>TRUE</strong></dt> </dl> </td><td> <p>The value specifies a YUV format.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.False"/></strong></dt> </dl> </td><td> <p>The value does not specify a recognized YUV format.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This function checks whether <em>Format</em> specifies a YUV format. Not every YUV format is recognized by this function. However, if a YUV format is not recognized by this function, it is probably not supported for video rendering or DirectX video acceleration (DXVA).</p>
            </remarks>
            <doc-id>ms704010</doc-id>
            <unmanaged>BOOL MFIsFormatYUV([In] DWORD Format)</unmanaged>
            <unmanaged-short>MFIsFormatYUV</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateVideoMediaTypeFromBitMapInfoHeader(SharpDX.Win32.BitmapInfoHeader@,System.Int32,System.Int32,SharpDX.MediaFoundation.VideoInterlaceMode,System.Int64,System.Int64,System.Int64,System.Int32,SharpDX.MediaFoundation.VideoMediaType@)">
            <summary>
            <p> This function is not implemented.</p>
            </summary>
            <param name = "bmihBitMapInfoHeaderRef"><dd> <p>Reserved.</p> </dd></param>
            <param name = "dwPixelAspectRatioX"><dd> <p>Reserved.</p> </dd></param>
            <param name = "dwPixelAspectRatioY"><dd> <p>Reserved.</p> </dd></param>
            <param name = "interlaceMode"><dd> <p>Reserved.</p> </dd></param>
            <param name = "videoFlags"><dd> <p>Reserved.</p> </dd></param>
            <param name = "qwFramesPerSecondNumerator"><dd> <p>Reserved.</p> </dd></param>
            <param name = "qwFramesPerSecondDenominator"><dd> <p>Reserved.</p> </dd></param>
            <param name = "dwMaxBitRate"><dd> <p>Reserved.</p> </dd></param>
            <param name = "iVideoMediaTypeOut"><dd> <p>Reserved.</p> </dd></param>
            <returns><p>Returns <strong>E_FAIL</strong>.</p></returns>
            <remarks>
            <strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?
            </remarks>
            <doc-id>aa473801</doc-id>
            <unmanaged>HRESULT MFCreateVideoMediaTypeFromBitMapInfoHeader([In] const BITMAPINFOHEADER* pbmihBitMapInfoHeader,[In] DWORD dwPixelAspectRatioX,[In] DWORD dwPixelAspectRatioY,[In] MFVideoInterlaceMode InterlaceMode,[In] unsigned longlong VideoFlags,[In] unsigned longlong qwFramesPerSecondNumerator,[In] unsigned longlong qwFramesPerSecondDenominator,[In] DWORD dwMaxBitRate,[Out] IMFVideoMediaType** ppIVideoMediaType)</unmanaged>
            <unmanaged-short>MFCreateVideoMediaTypeFromBitMapInfoHeader</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.GetStrideForBitmapInfoHeader(System.Int32,System.Int32,System.Int32@)">
            <summary>
            <p> Calculates the minimum surface stride for a video format. </p>
            </summary>
            <param name = "format"><dd> <p>FOURCC code or <strong>D3DFORMAT</strong> value that specifies the video format. If you have a video subtype <see cref = "T:System.Guid"/>, you can use the first <strong><see cref = "T:System.Int32"/></strong> of the subtype.</p> </dd></param>
            <param name = "dwWidth"><dd> <p>Width of the image, in pixels.</p> </dd></param>
            <param name = "strideRef"><dd> <p>Receives the minimum surface stride, in pixels.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> This function calculates the minimum stride needed to hold the image in memory. Use this function if you are allocating buffers in system memory. Surfaces allocated in video memory might require a larger stride, depending on the graphics card. </p><p> If you are working with a DirectX surface buffer, use the <strong>IMF2DBuffer::Lock2D</strong> method to find the surface stride. </p><p> For planar YUV formats, this function returns the stride for the Y plane. Depending on the format, the chroma planes might have a different stride. </p><strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?
            </remarks>
            <doc-id>aa473720</doc-id>
            <unmanaged>HRESULT MFGetStrideForBitmapInfoHeader([In] DWORD format,[In] DWORD dwWidth,[Out] LONG* pStride)</unmanaged>
            <unmanaged-short>MFGetStrideForBitmapInfoHeader</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.GetPlaneSize(System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the image size, in bytes, for an uncompressed video format.</p>
            </summary>
            <param name = "format"><dd> <p>FOURCC code or <strong>D3DFORMAT</strong> value that specifies the video format.</p> </dd></param>
            <param name = "dwWidth"><dd> <p>Width of the image, in pixels.</p> </dd></param>
            <param name = "dwHeight"><dd> <p>Height of the image, in pixels.</p> </dd></param>
            <param name = "dwPlaneSizeRef"><dd> <p>Receives the size of one frame, in bytes. If the format is compressed or is not recognized, this value is zero.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> This function is equivalent to the <strong>MFCalculateImageSize</strong> function. </p><strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll.?
            </remarks>
            <doc-id>aa473798</doc-id>
            <unmanaged>HRESULT MFGetPlaneSize([In] DWORD format,[In] DWORD dwWidth,[In] DWORD dwHeight,[Out] DWORD* pdwPlaneSize)</unmanaged>
            <unmanaged-short>MFGetPlaneSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateVideoMediaTypeFromBitMapInfoHeaderEx(SharpDX.Win32.BitmapInfoHeader[],System.Int32,System.Int32,System.Int32,SharpDX.MediaFoundation.VideoInterlaceMode,System.Int64,System.Int32,System.Int32,System.Int32,SharpDX.MediaFoundation.VideoMediaType@)">
            <summary>
            <p>Creates a video media type from a <strong><see cref = "T:SharpDX.Win32.BitmapInfoHeader"/></strong> structure.</p>
            </summary>
            <param name = "bmihBitMapInfoHeaderRef">No documentation.</param>
            <param name = "cbBitMapInfoHeader">No documentation.</param>
            <param name = "dwPixelAspectRatioX">No documentation.</param>
            <param name = "dwPixelAspectRatioY">No documentation.</param>
            <param name = "interlaceMode">No documentation.</param>
            <param name = "videoFlags">No documentation.</param>
            <param name = "dwFramesPerSecondNumerator">No documentation.</param>
            <param name = "dwFramesPerSecondDenominator">No documentation.</param>
            <param name = "dwMaxBitRate">No documentation.</param>
            <param name = "iVideoMediaTypeOut">No documentation.</param>
            <returns><p>If the function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd388121</doc-id>
            <unmanaged>HRESULT MFCreateVideoMediaTypeFromBitMapInfoHeaderEx([In, Buffer] const BITMAPINFOHEADER* pbmihBitMapInfoHeader,[In] unsigned int cbBitMapInfoHeader,[In] DWORD dwPixelAspectRatioX,[In] DWORD dwPixelAspectRatioY,[In] MFVideoInterlaceMode InterlaceMode,[In] unsigned longlong VideoFlags,[In] DWORD dwFramesPerSecondNumerator,[In] DWORD dwFramesPerSecondDenominator,[In] DWORD dwMaxBitRate,[Out] IMFVideoMediaType** ppIVideoMediaType)</unmanaged>
            <unmanaged-short>MFCreateVideoMediaTypeFromBitMapInfoHeaderEx</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateMediaTypeFromRepresentation(System.Guid,System.IntPtr,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            <p> </p><p>Creates a Media Foundation media type from another format representation.</p>
            </summary>
            <param name = "guidRepresentation"><dd> <p><see cref = "T:System.Guid"/> that specifies which format representation to convert. The following value is defined.</p> <table> <tr><th><see cref = "T:System.Guid"/></th><th>Description</th></tr> <tr><td>AM_MEDIA_TYPE_REPRESENTATION</td><td>Convert a DirectShow <strong><see cref = "!:SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure.</td></tr> </table> <p>?</p> </dd></param>
            <param name = "vRepresentationRef"><dd> <p>Pointer to a buffer that contains the format representation to convert. The layout of the buffer depends on the value of <em>guidRepresentation</em>.</p> </dd></param>
            <param name = "iMediaTypeOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedRepresentation"/></strong></dt> </dl> </td><td> <p>The <see cref = "T:System.Guid"/> specified in <em>guidRepresentation</em> is not supported.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the original format is a DirectShow audio media type, and the format type is not recognized, the function sets the following attributes on the converted media type.</p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <strong><see cref = "!:AmFormatType"/></strong> </td><td>Contains the format type <see cref = "T:System.Guid"/>.</td></tr> <tr><td> <strong><see cref = "!:UserData"/></strong> </td><td>Contains the format block.</td></tr> </table><p>?</p>
            </remarks>
            <doc-id>aa369931</doc-id>
            <unmanaged>HRESULT MFCreateMediaTypeFromRepresentation([In] GUID guidRepresentation,[In] void* pvRepresentation,[Out] IMFMediaType** ppIMediaType)</unmanaged>
            <unmanaged-short>MFCreateMediaTypeFromRepresentation</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateAudioMediaType(SharpDX.Multimedia.WaveFormat@,SharpDX.MediaFoundation.AudioMediaType@)">
            <summary>
            <p>[This API is not supported and may be altered or unavailable in the future.]</p><p>Creates an audio media type from a <strong><see cref = "T:SharpDX.Multimedia.WaveFormat"/></strong> structure.</p>
            </summary>
            <param name = "audioFormatRef"><dd> <p>Pointer to a <strong><see cref = "T:SharpDX.Multimedia.WaveFormat"/></strong> structure that describes the audio format.</p> </dd></param>
            <param name = "iAudioMediaTypeOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.AudioMediaType"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The <strong><see cref = "T:SharpDX.MediaFoundation.AudioMediaType"/></strong> interface is deprecrated, so applications should avoid using this function. To create a media type from a <strong><see cref = "T:SharpDX.Multimedia.WaveFormat"/></strong> structure, do the following: </p><ol> <li> Call <strong>MFCreateMediaType</strong>. This function returns a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. The returned media type object is initially empty. </li> <li> Call <strong>MFInitMediaTypeFromWaveFormatEx</strong> to populate the media type from the <strong><see cref = "T:SharpDX.Multimedia.WaveFormat"/></strong> structure. </li> </ol><p> Alternatively, you can call <strong>MFCreateMediaType</strong> and then set the media type attributes directly. </p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>aa473812</doc-id>
            <unmanaged>HRESULT MFCreateAudioMediaType([In] const WAVEFORMATEX* pAudioFormat,[Out] IMFAudioMediaType** ppIAudioMediaType)</unmanaged>
            <unmanaged-short>MFCreateAudioMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.GetUncompressedVideoFormat(SharpDX.MediaFoundation.VideoFormat@)">
            <summary>
            <p>[This API is not supported and may be altered or unavailable in the future. Applications should avoid using the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure, and use media type attributes instead. For more information, see Video Media Types.]</p><p>Returns the FOURCC or <strong>D3DFORMAT</strong> value for an uncompressed video format.</p>
            </summary>
            <param name = "videoFormatRef">No documentation.</param>
            <returns><p>Returns a FOURCC or <strong>D3DFORMAT</strong> value that identifies the video format. If the video format is compressed or not recognized, the return value is D3DFMT_UNKNOWN.</p></returns>
            <remarks>
            <strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?
            </remarks>
            <doc-id>aa473806</doc-id>
            <unmanaged>DWORD MFGetUncompressedVideoFormat([In] const MFVIDEOFORMAT* pVideoFormat)</unmanaged>
            <unmanaged-short>MFGetUncompressedVideoFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.InitVideoFormat(SharpDX.MediaFoundation.VideoFormat@,SharpDX.MediaFoundation.StandardVideoFormat)">
            <summary>
            <p>[This API is not supported and may be altered or unavailable in the future. Applications should avoid using the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure, and use media type attributes instead. For more information, see Video Media Types.]</p><p> Initializes an <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure for a standard video format such as DVD, analog television, or ATSC digital television.</p>
            </summary>
            <param name = "videoFormatRef">No documentation.</param>
            <param name = "type">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?
            </remarks>
            <doc-id>aa473783</doc-id>
            <unmanaged>HRESULT MFInitVideoFormat([In] MFVIDEOFORMAT* pVideoFormat,[In] MFStandardVideoFormat type)</unmanaged>
            <unmanaged-short>MFInitVideoFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.InitVideoFormatRgb(SharpDX.MediaFoundation.VideoFormat@,System.Int32,System.Int32,System.Int32)">
            <summary>
            <p>[This API is not supported and may be altered or unavailable in the future. Applications should avoid using the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure, and use media type attributes instead. For more information, see Video Media Types.]</p><p> Initializes an <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure for an uncompressed RGB video format.</p>
            </summary>
            <param name = "videoFormatRef">No documentation.</param>
            <param name = "dwWidth">No documentation.</param>
            <param name = "dwHeight">No documentation.</param>
            <param name = "d3Dfmt">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> This function fills in some reasonable default values for the specified RGB format. </p><p> Developers are encouraged to use media type attributes instead of using the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure. See Media Type Attributes. </p><p> In general, you should avoid calling this function. If you know all of the format details, you can fill in the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure without this function. If you do not know all of the format details, attributes are preferable to using the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure. </p><strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?
            </remarks>
            <doc-id>aa473797</doc-id>
            <unmanaged>HRESULT MFInitVideoFormat_RGB([In] MFVIDEOFORMAT* pVideoFormat,[In] DWORD dwWidth,[In] DWORD dwHeight,[In] DWORD D3Dfmt)</unmanaged>
            <unmanaged-short>MFInitVideoFormat_RGB</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.ConvertColorInfoToDXVA(System.Int32@,SharpDX.MediaFoundation.VideoFormat@)">
            <summary>
            <p>[This API is not supported and may be altered or unavailable in the future. Applications should avoid using the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure, and use media type attributes instead. For more information, see Extended Color Information.]</p><p> Converts the extended color information from an <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> to the equivalent DirectX Video Acceleration (DXVA) color information. </p>
            </summary>
            <param name = "dwToDXVARef">No documentation.</param>
            <param name = "fromFormatRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?
            </remarks>
            <doc-id>bb970405</doc-id>
            <unmanaged>HRESULT MFConvertColorInfoToDXVA([Out] DWORD* pdwToDXVA,[In] const MFVIDEOFORMAT* pFromFormat)</unmanaged>
            <unmanaged-short>MFConvertColorInfoToDXVA</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.ConvertColorInfoFromDXVA(SharpDX.MediaFoundation.VideoFormat@,System.Int32)">
            <summary>
            <p>[This API is not supported and may be altered or unavailable in the future. Applications should avoid using the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure, and use media type attributes instead. For more information, see Extended Color Information.]</p><p> Sets the extended color information in a <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure.</p>
            </summary>
            <param name = "toFormatRef">No documentation.</param>
            <param name = "dwFromDXVA">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function sets the following fields in the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure.</p><ul> <li><strong>videoInfo.<see cref = "T:SharpDX.MediaFoundation.NominalRange"/></strong></li> <li><strong>videoInfo.<see cref = "T:SharpDX.MediaFoundation.VideoLighting"/></strong></li> <li><strong>videoInfo.<see cref = "T:SharpDX.MediaFoundation.VideoPrimaries"/></strong></li> <li><strong>videoInfo.<see cref = "T:SharpDX.MediaFoundation.VideoTransferFunction"/></strong></li> <li><strong>videoInfo.<see cref = "T:SharpDX.MediaFoundation.VideoTransferMatrix"/></strong></li> <li><strong>videoInfo.SourceChromaSubsampling</strong></li> </ul><strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?
            </remarks>
            <doc-id>bb970494</doc-id>
            <unmanaged>HRESULT MFConvertColorInfoFromDXVA([InOut] MFVIDEOFORMAT* pToFormat,[In] DWORD dwFromDXVA)</unmanaged>
            <unmanaged-short>MFConvertColorInfoFromDXVA</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CopyImage(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            <p> Copies an image or image plane from one buffer to another. </p>
            </summary>
            <param name = "destRef"><dd> <p> Pointer to the start of the first row of pixels in the destination buffer. </p> </dd></param>
            <param name = "lDestStride"><dd> <p> Stride of the destination buffer, in bytes. </p> </dd></param>
            <param name = "srcRef"><dd> <p> Pointer to the start of the first row of pixels in the source image. </p> </dd></param>
            <param name = "lSrcStride"><dd> <p> Stride of the source image, in bytes. </p> </dd></param>
            <param name = "dwWidthInBytes"><dd> <p> Width of the image, in bytes. </p> </dd></param>
            <param name = "dwLines"><dd> <p> Number of rows of pixels to copy. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> This function copies a single plane of the image. For planar YUV formats, you must call the function once for each plane. In this case, <em>pDest</em> and <em>pSrc</em> must point to the start of each plane. </p><p> This function is optimized if the MMX, SSE, or SSE2 instruction sets are available on the processor. The function performs a non-temporal store (the data is written to memory directly without polluting the cache). </p><strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?
            </remarks>
            <doc-id>bb970554</doc-id>
            <unmanaged>HRESULT MFCopyImage([Out, Buffer] unsigned char* pDest,[In] LONG lDestStride,[In, Buffer] const unsigned char* pSrc,[In] LONG lSrcStride,[In] DWORD dwWidthInBytes,[In] DWORD dwLines)</unmanaged>
            <unmanaged-short>MFCopyImage</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.ConvertFromFP16Array(System.Single[],System.Int16[],System.Int32)">
            <summary>
            <p> Converts an array of 16-bit floating-point numbers into an array of 32-bit floating-point numbers. </p>
            </summary>
            <param name = "destRef"><dd> <p> Pointer to an array of <strong>float</strong> values. The array must contain at least <em>dwCount</em> elements. </p> </dd></param>
            <param name = "srcRef"><dd> <p> Pointer to an array of 16-bit floating-point values, typed as <strong>WORD</strong> values. The array must contain at least <em>dwCount</em> elements. </p> </dd></param>
            <param name = "dwCount"><dd> <p> Number of elements in the <em>pSrc</em> array to convert. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The function converts <em>dwCount</em> values in the <em>pSrc</em> array and writes them into the <em>pDest</em> array. </p><strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?
            </remarks>
            <doc-id>bb970412</doc-id>
            <unmanaged>HRESULT MFConvertFromFP16Array([Out, Buffer] float* pDest,[In, Buffer] const unsigned short* pSrc,[In] DWORD dwCount)</unmanaged>
            <unmanaged-short>MFConvertFromFP16Array</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.ConvertToFP16Array(System.Int16[],System.Single[],System.Int32)">
            <summary>
            <p> Converts an array of 32-bit floating-point numbers into an array of 16-bit floating-point numbers. </p>
            </summary>
            <param name = "destRef"><dd> <p>Pointer to an array of 16-bit floating-point values, typed as <strong>WORD</strong> values. The array must contain at least <em>dwCount</em> elements.</p> </dd></param>
            <param name = "srcRef"><dd> <p>Pointer to an array of <strong>float</strong> values. The array must contain at least <em>dwCount</em> elements.</p> </dd></param>
            <param name = "dwCount"><dd> <p>Number of elements in the <em>pSrc</em> array to convert.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The function converts the values in the <em>pSrc</em> array and writes them into the <em>pDest</em> array. </p><strong>Note</strong>??Prior to Windows?7, this function was exported from evr.dll. Starting in Windows?7, this function is exported from mfplat.dll, and evr.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?
            </remarks>
            <doc-id>aa473816</doc-id>
            <unmanaged>HRESULT MFConvertToFP16Array([Out, Buffer] unsigned short* pDest,[In, Buffer] const float* pSrc,[In] DWORD dwCount)</unmanaged>
            <unmanaged-short>MFConvertToFP16Array</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.Create2DMediaBuffer(System.Int32,System.Int32,System.Int32,SharpDX.Mathematics.Interop.RawBool,SharpDX.MediaFoundation.MediaBuffer@)">
            <summary>
            <p>Creates a system-memory buffer object to hold 2D image data.</p>
            </summary>
            <param name = "dwWidth"><dd> <p>Width of the image, in pixels. </p> </dd></param>
            <param name = "dwHeight"><dd> <p>Height of the image, in pixels.</p> </dd></param>
            <param name = "dwFourCC"><dd> <p>A <strong>FOURCC</strong> code or D3DFORMAT value that specifies the video format. If you have a video subtype <see cref = "T:System.Guid"/>, you can use the first <strong><see cref = "T:System.Int32"/></strong> of the subtype. </p> </dd></param>
            <param name = "fBottomUp"><dd> <p>If <strong>TRUE,</strong> the buffer's <strong>IMF2DBuffer::ContiguousCopyTo</strong> method copies the buffer into a bottom-up format. The bottom-up format is compatible with GDI for uncompressed RGB images. If this parameter is <strong><see cref = "F:SharpDX.Result.False"/></strong>, the <strong>ContiguousCopyTo</strong> method copies the buffer into a top-down format, which is compatible with DirectX.  </p> <p>For more information about top-down versus bottom-up images, see Image Stride. </p> </dd></param>
            <param name = "bufferOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> interface.</p> </dd></param>
            <returns><p>This function can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidMediaType"/></strong></dt> </dl> </td><td> <p>Unrecognized video format.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The returned buffer object also exposes the <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2D2"/></strong> interface.</p>
            </remarks>
            <doc-id>hh162746</doc-id>
            <unmanaged>HRESULT MFCreate2DMediaBuffer([In] DWORD dwWidth,[In] DWORD dwHeight,[In] DWORD dwFourCC,[In] BOOL fBottomUp,[Out] IMFMediaBuffer** ppBuffer)</unmanaged>
            <unmanaged-short>MFCreate2DMediaBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateMediaBufferFromMediaType(SharpDX.MediaFoundation.MediaType,System.Int64,System.Int32,System.Int32,SharpDX.MediaFoundation.MediaBuffer@)">
            <summary>
            <p>Allocates a system-memory buffer that is optimal for a specified media type.</p>
            </summary>
            <param name = "mediaTypeRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type.</p> </dd></param>
            <param name = "llDuration"><dd> <p>The sample duration. This value is required for audio formats.</p> </dd></param>
            <param name = "dwMinLength"><dd> <p>The minimum size of the buffer, in bytes. The actual buffer size might be larger. Specify zero to allocate the default buffer size for the media type.</p> </dd></param>
            <param name = "dwMinAlignment"><dd> <p>The minimum memory alignment for the buffer. Specify zero to use the default memory alignment.</p> </dd></param>
            <param name = "bufferOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>For video formats, if the format is recognized, the function creates a 2-D buffer that implements the <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2D2"/></strong> interface. Otherwise it creates a linear buffer. To get the  <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2D2"/></strong> interface, call <strong>QueryInterface</strong> on the reference returned in <em>ppBuffer</em>. If the <strong>QueryInterface</strong> method fails, use the <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> interface to access the buffer memory.</p><p>For audio formats, the function allocates a buffer that is large enough to contain <em>llDuration</em> audio samples, or <em>dwMinLength</em>, whichever is larger.</p><p>This function always allocates system memory. For Direct3D surfaces, use the <strong>MFCreateDXGISurfaceBuffer</strong> or <strong>MFCreateDXSurfaceBuffer</strong> function.</p>
            </remarks>
            <doc-id>hh162752</doc-id>
            <unmanaged>HRESULT MFCreateMediaBufferFromMediaType([In] IMFMediaType* pMediaType,[In] longlong llDuration,[In] DWORD dwMinLength,[In] DWORD dwMinAlignment,[Out] IMFMediaBuffer** ppBuffer)</unmanaged>
            <unmanaged-short>MFCreateMediaBufferFromMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateCollection(SharpDX.MediaFoundation.Collection@)">
            <summary>
            <p> </p><p>Creates an empty collection object.</p>
            </summary>
            <param name = "iMFCollectionOut"><dd> <p>Receives a reference to the collection object's <strong><see cref = "T:SharpDX.MediaFoundation.Collection"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms698852</doc-id>
            <unmanaged>HRESULT MFCreateCollection([Out] IMFCollection** ppIMFCollection)</unmanaged>
            <unmanaged-short>MFCreateCollection</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.HeapAlloc(System.Int32,System.Int32,System.String,System.Int32,SharpDX.MediaFoundation.EAllocationType)">
            <summary>
            <p> </p><p>Allocates a block of memory.</p>
            </summary>
            <param name = "nSize"><dd> <p>Number of bytes to allocate.</p> </dd></param>
            <param name = "dwFlags"><dd> <p>Zero or more flags. For a list of valid flags, see <strong>HeapAlloc</strong> in the Windows SDK documentation.</p> </dd></param>
            <param name = "szFileRef"><dd> <p> Reserved. Set to <strong><c>null</c></strong>. </p> </dd></param>
            <param name = "line"><dd> <p> Reserved. Set to zero. </p> </dd></param>
            <param name = "eat"><dd> <p> Reserved. Set to <strong>eAllocationTypeIgnore</strong>. </p> </dd></param>
            <returns><p>If the function succeeds, it returns a reference to the allocated memory block. If the function fails, it returns <strong><c>null</c></strong>.</p></returns>
            <remarks>
            <p>In the current version of Media Foundation, this function is equivalent to calling the <strong>HeapAlloc</strong> function and specifying the heap of the calling process.</p><p>To free the allocated memory, call <strong>MFHeapFree</strong>.</p>
            </remarks>
            <doc-id>aa473790</doc-id>
            <unmanaged>void* MFHeapAlloc([In] unsigned int nSize,[In] ULONG dwFlags,[In, Optional] char* pszFile,[In] int line,[In] EAllocationType eat)</unmanaged>
            <unmanaged-short>MFHeapAlloc</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.HeapFree(System.IntPtr)">
            <summary>
            <p> </p><p>Frees a block of memory that was allocated by calling the <strong>MFHeapAlloc</strong> function.</p>
            </summary>
            <param name = "vRef">No documentation.</param>
            <doc-id>aa473826</doc-id>
            <unmanaged>void MFHeapFree([In] void* pv)</unmanaged>
            <unmanaged-short>MFHeapFree</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.LlMulDiv(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            <p>Calculates ((a * b) + d) / c, where each term is a 64-bit signed value.</p>
            </summary>
            <param name = "a"><dd> <p>A multiplier.</p> </dd></param>
            <param name = "b"><dd> <p>Another multiplier.</p> </dd></param>
            <param name = "c"><dd> <p>The divisor.</p> </dd></param>
            <param name = "d"><dd> <p>The rounding factor.</p> </dd></param>
            <returns><p>Returns the result of the calculation. If numeric overflow occurs, the function returns _I64_MAX (positive overflow) or LLONG_MIN (negative overflow). If Mfplat.dll cannot be loaded, the function returns _I64_MAX.</p></returns>
            <remarks>
            <strong>Note</strong>??A previous version of this topic described the parameters incorrectly. The divisor is <em>c</em> and the rounding factor is <em>d</em>.?
            </remarks>
            <doc-id>dd388510</doc-id>
            <unmanaged>longlong MFllMulDiv([In] longlong a,[In] longlong b,[In] longlong c,[In] longlong d)</unmanaged>
            <unmanaged-short>MFllMulDiv</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.GetContentProtectionSystemCLSID(System.Guid,System.Guid@)">
            <summary>
            <p>Gets the class identifier for a content protection system.</p>
            </summary>
            <param name = "guidProtectionSystemID"><dd> <p>The <see cref = "T:System.Guid"/> that identifies the content protection system.</p> </dd></param>
            <param name = "clsidRef"><dd> <p>Receives the class identifier to the content protection system.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The class identifier can be used to create the input trust authority (ITA) for the content protection system. Call <strong>CoCreateInstance</strong> or <strong>IMFPMPHost::CreateObjectByCLSID</strong> to get an <strong><see cref = "T:SharpDX.MediaFoundation.TrustedInput"/></strong> reference.</p>
            </remarks>
            <doc-id>hh162766</doc-id>
            <unmanaged>HRESULT MFGetContentProtectionSystemCLSID([In] const GUID&amp; guidProtectionSystemID,[Out] GUID* pclsid)</unmanaged>
            <unmanaged-short>MFGetContentProtectionSystemCLSID</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateMediaSession(SharpDX.MediaFoundation.MediaAttributes,SharpDX.MediaFoundation.MediaSession@)">
            <summary>
            <p> </p><p>Creates the Media Session in the application's process.</p>
            </summary>
            <param name = "configurationRef">No documentation.</param>
            <param name = "mediaSessionOut">No documentation.</param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> If your application does not play protected content, you can use this function to create the Media Session in the application's process. To use the Media Session for protected content, you must call <strong>MFCreatePMPMediaSession</strong>. </p><p> You can use the <em>pConfiguration</em> parameter to specify any of the following attributes: </p><ul> <li> <strong><see cref = "!:GlobalTime"/></strong> </li> <li> <strong><see cref = "T:SharpDX.MediaFoundation.QualityManager"/></strong> </li> <li> <strong><see cref = "!:Topoloader"/></strong> </li> <li> <see cref = "!:LowLatency"/> </li> </ul>
            </remarks>
            <doc-id>ms700174</doc-id>
            <unmanaged>HRESULT MFCreateMediaSession([In] IMFAttributes* pConfiguration,[Out] IMFMediaSession** ppMediaSession)</unmanaged>
            <unmanaged-short>MFCreateMediaSession</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreatePMPMediaSession(System.Int32,SharpDX.MediaFoundation.MediaAttributes,SharpDX.MediaFoundation.MediaSession@,SharpDX.MediaFoundation.Activate@)">
            <summary>
            <p> Creates an instance of the Media Session inside a Protected Media Path (PMP) process. </p>
            </summary>
            <param name = "dwCreationFlags">No documentation.</param>
            <param name = "configurationRef">No documentation.</param>
            <param name = "mediaSessionOut">No documentation.</param>
            <param name = "enablerActivateOut">No documentation.</param>
            <returns><p> The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>You can use the <em>pConfiguration</em> parameter to set any of the following attributes:</p><ul> <li> <strong><see cref = "T:SharpDX.MediaFoundation.ContentProtectionManager"/></strong> </li> <li> <strong><see cref = "!:GlobalTime"/></strong> </li> <li> <strong><see cref = "T:SharpDX.MediaFoundation.QualityManager"/></strong> </li> <li> <strong><see cref = "!:RemoteSourceMode"/></strong> </li> <li> <strong><see cref = "!:ServerContext"/></strong> </li> <li> <strong><see cref = "!:Topoloader"/></strong> </li> </ul><p>If this function cannot create the PMP Media Session because a trusted binary was revoked, the <em>ppEnablerActivate</em> parameter receives an <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface reference. The application can use this reference to create a content enabler object, which can then be used to download an updated binary:</p><ol> <li> Call <strong>IMFActivate::ActivateObject</strong> with the interface identifier IID_IMFContentEnabler to get an <strong><see cref = "T:SharpDX.MediaFoundation.ContentEnabler"/></strong> interface reference. </li> <li> Use that interface to download the updated binary. </li> <li> Call <strong>MFCreatePMPMediaSession</strong> again. </li> </ol><p>If the function successfully creates the PMP Media Session, the <em>ppEnablerActivate</em> parameter receives the value <strong><c>null</c></strong>.</p><p>Do not make calls to the PMP Media Session from a thread that is processing a window message sent from another thread. To test whether the current thread falls into this category, call <strong>InSendMessage</strong>.</p>
            </remarks>
            <doc-id>ms703144</doc-id>
            <unmanaged>HRESULT MFCreatePMPMediaSession([In] DWORD dwCreationFlags,[In] IMFAttributes* pConfiguration,[Out] IMFMediaSession** ppMediaSession,[Out, Optional] IMFActivate** ppEnablerActivate)</unmanaged>
            <unmanaged-short>MFCreatePMPMediaSession</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateSourceResolver(SharpDX.MediaFoundation.SourceResolver)">
            <summary>
            <p> Creates the source resolver, which is used to create a media source from a URL or byte stream. </p>
            </summary>
            <param name = "iSourceResolverOut"><dd> <p>Receives a reference to the source resolver's <strong><see cref = "T:SharpDX.MediaFoundation.SourceResolver"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <strong>Note</strong>??Prior to Windows?7, this function was exported from mf.dll. Starting in Windows?7, this function is exported from mfplat.dll, and mf.dll exports a stub function that calls into mfplat.dll. For more information, see Library Changes in Windows?7.?
            </remarks>
            <doc-id>ms697433</doc-id>
            <unmanaged>HRESULT MFCreateSourceResolver([Out, Fast] IMFSourceResolver** ppISourceResolver)</unmanaged>
            <unmanaged-short>MFCreateSourceResolver</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreatePropertyStore(SharpDX.ComObject@)">
            <summary>
            <p>[This API is not supported and may be altered or unavailable in the future. Instead, applications should use the <strong>PSCreateMemoryPropertyStore</strong> function to create property stores.]</p><p> Creates an empty property store object.</p>
            </summary>
            <param name = "storeOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.ComObject"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms702984</doc-id>
            <unmanaged>HRESULT CreatePropertyStore([Out] IPropertyStore** ppStore)</unmanaged>
            <unmanaged-short>CreatePropertyStore</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.GetSupportedSchemes(SharpDX.Win32.Variant@)">
            <summary>
            <p> </p><p>Retrieves the URL schemes that are registered for the source resolver.</p>
            </summary>
            <param name = "propVarSchemeArrayRef"><dd> <p>Pointer to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that receives the URL schemes. Before calling this method, call <strong>PropVariantInit</strong> to initialize the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong>. If the method succeeds, the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> contains an array of wide-character strings. The <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> data type is VT_VECTOR | VT_LPWSTR. The caller must release the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> by calling <strong>PropVariantClear</strong>.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms702236</doc-id>
            <unmanaged>HRESULT MFGetSupportedSchemes([Out] PROPVARIANT* pPropVarSchemeArray)</unmanaged>
            <unmanaged-short>MFGetSupportedSchemes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.GetSupportedMimeTypes(SharpDX.Win32.Variant@)">
            <summary>
            <p> </p><p>Retrieves the MIME types that are registered for the source resolver.</p>
            </summary>
            <param name = "propVarMimeTypeArrayRef"><dd> <p>Pointer to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that receives the MIME types. Before calling this method, call <strong>PropVariantInit</strong> to initialize the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong>. If the method succeeds, the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> contains an array of wide-character strings. The <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> data type is VT_VECTOR | VT_LPWSTR. The caller must release the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> by calling <strong>PropVariantClear</strong>.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms699844</doc-id>
            <unmanaged>HRESULT MFGetSupportedMimeTypes([Out] PROPVARIANT* pPropVarMimeTypeArray)</unmanaged>
            <unmanaged-short>MFGetSupportedMimeTypes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateTopology(SharpDX.MediaFoundation.Topology@)">
            <summary>
            <p> </p><p>Creates a topology object.</p>
            </summary>
            <param name = "topoOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Topology"/></strong> interface of the topology object. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms701584</doc-id>
            <unmanaged>HRESULT MFCreateTopology([Out] IMFTopology** ppTopo)</unmanaged>
            <unmanaged-short>MFCreateTopology</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateTopologyNode(SharpDX.MediaFoundation.TopologyType,SharpDX.MediaFoundation.TopologyNode@)">
            <summary>
            <p> Creates a topology node.</p>
            </summary>
            <param name = "nodeType"><dd> <p> The type of node to create, specified as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.TopologyType"/></strong> enumeration.</p> </dd></param>
            <param name = "nodeOut"><dd> <p> Receives a reference to the node's <strong><see cref = "T:SharpDX.MediaFoundation.TopologyNode"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ms697574</doc-id>
            <unmanaged>HRESULT MFCreateTopologyNode([In] MF_TOPOLOGY_TYPE NodeType,[Out] IMFTopologyNode** ppNode)</unmanaged>
            <unmanaged-short>MFCreateTopologyNode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.GetTopoNodeCurrentType(SharpDX.MediaFoundation.TopologyNode,System.Int32,SharpDX.Mathematics.Interop.RawBool,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            <p>Gets the media type for a stream associated with a topology node.</p>
            </summary>
            <param name = "nodeRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.TopologyNode"/></strong> interface.</p> </dd></param>
            <param name = "dwStreamIndex"><dd> <p>The identifier of the stream to query. This parameter is interpreted as follows:</p> <ul> <li>Transform nodes: The value is the zero-based index of the input or output stream.</li> <li>All other node types: The value must be zero.</li> </ul> </dd></param>
            <param name = "fOutput"><dd> <p><strong>If TRUE</strong>, the function gets an output type<strong>. If <see cref = "F:SharpDX.Result.False"/></strong>, the function gets an input type. This parameter is interpreted as follows:</p> <ul> <li>Output nodes: The value must be <strong>TRUE</strong>.</li> <li>Source nodes: The value must be <strong><see cref = "F:SharpDX.Result.False"/></strong>.</li> <li>Tee nodes: The value is ignored.</li> <li>Transform nodes: If the value is <strong>TRUE</strong>, the <em>dwStreamIndex</em> parameter is the index for an output stream. Otherwise, <em>dwStreamIndex</em> is the index for an input stream.</li> </ul> </dd></param>
            <param name = "typeOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The stream index is invalid.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This function gets the actual media type from the object that is associated with the topology node. The <em>pNode</em> parameter should specify a node that belongs to a fully resolved topology.  If the node belongs to a partial topology, the function will probably fail. </p><p>Tee nodes do not have an associated object to query. For tee nodes, the function gets the node's input type, if available. Otherwise, if no input type is available, the function gets the media type of the node's primary output stream. The primary output stream is identified by the <strong><see cref = "!:Primaryoutput"/></strong> attribute.</p>
            </remarks>
            <doc-id>dd388509</doc-id>
            <unmanaged>HRESULT MFGetTopoNodeCurrentType([In] IMFTopologyNode* pNode,[In] DWORD dwStreamIndex,[In] BOOL fOutput,[Out] IMFMediaType** ppType)</unmanaged>
            <unmanaged-short>MFGetTopoNodeCurrentType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.GetService(SharpDX.IUnknown,System.Guid,System.Guid,System.IntPtr@)">
            <summary>
            <p>Queries an object for a specified service interface.</p><p>This function is a helper function that wraps the <strong>IMFGetService::GetService</strong> method. The function queries the object for the <strong><see cref = "T:SharpDX.MediaFoundation.ServiceProvider"/></strong> interface and, if successful, calls <strong>GetService</strong> on the object.</p>
            </summary>
            <param name = "unkObjectRef">No documentation.</param>
            <param name = "guidService">No documentation.</param>
            <param name = "riid">No documentation.</param>
            <param name = "vObjectOut">No documentation.</param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedService"/></strong></dt> </dl> </td><td> <p> The service requested cannot be found in the object represented by <em>punkObject</em>. </p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms694284</doc-id>
            <unmanaged>HRESULT MFGetService([In] IUnknown* punkObject,[In] const GUID&amp; guidService,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>
            <unmanaged-short>MFGetService</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.GetSystemTime">
            <summary>
            <p> Returns the system time. </p>
            </summary>
            <returns><p> Returns the system time, in 100-nanosecond units. </p></returns>
            <doc-id>ms704625</doc-id>
            <unmanaged>longlong MFGetSystemTime()</unmanaged>
            <unmanaged-short>MFGetSystemTime</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreatePresentationClock(SharpDX.MediaFoundation.PresentationClock@)">
            <summary>
            <p>Creates the presentation clock. The presentation clock is used to schedule the time at which samples are rendered and to synchronize multiple streams.
            </p>
            </summary>
            <param name = "presentationClockOut"><dd> <p>Receives a reference to the clock's <strong><see cref = "T:SharpDX.MediaFoundation.PresentationClock"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The caller must shut down the presentation clock by calling <strong>IMFShutdown::Shutdown</strong> on the clock.</p><p>Typically applications do not create the presentation clock. The Media Session automatically creates the presentation clock. To get a reference to the presentation clock from the Media Session, call <strong>IMFMediaSession::GetClock</strong>.</p>
            </remarks>
            <doc-id>ms702174</doc-id>
            <unmanaged>HRESULT MFCreatePresentationClock([Out] IMFPresentationClock** ppPresentationClock)</unmanaged>
            <unmanaged-short>MFCreatePresentationClock</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateSystemTimeSource(SharpDX.MediaFoundation.PresentationTimeSource@)">
            <summary>
            <p> </p><p>Creates a presentation time source that is based on the system time.</p>
            </summary>
            <param name = "systemTimeSourceOut"><dd> <p>Receives a reference to the object's <strong><see cref = "T:SharpDX.MediaFoundation.PresentationTimeSource"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms705610</doc-id>
            <unmanaged>HRESULT MFCreateSystemTimeSource([Out] IMFPresentationTimeSource** ppSystemTimeSource)</unmanaged>
            <unmanaged-short>MFCreateSystemTimeSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreatePresentationDescriptor(System.Int32,SharpDX.MediaFoundation.StreamDescriptor[],SharpDX.MediaFoundation.PresentationDescriptor@)">
            <summary>
            <p> </p><p>Creates a presentation descriptor.</p>
            </summary>
            <param name = "cStreamDescriptors"><dd> <p>Number of elements in the <em>apStreamDescriptors</em> array.</p> </dd></param>
            <param name = "apStreamDescriptors"><dd> <p>Array of <strong><see cref = "T:SharpDX.MediaFoundation.StreamDescriptor"/></strong> interface references. Each reference represents a stream descriptor for one stream in the presentation.</p> </dd></param>
            <param name = "presentationDescriptorOut"><dd> <p>Receives a reference to an <strong><see cref = "T:SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the presentation descriptor. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> If you are writing a custom media source, you can use this function to create the source presentation descriptor. The presentation descriptor is created with no streams selected. Generally, a media source should select at least one stream by default. To select a stream, call <strong>IMFPresentationDescriptor::SelectStream</strong>. </p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms695404</doc-id>
            <unmanaged>HRESULT MFCreatePresentationDescriptor([In] DWORD cStreamDescriptors,[In, Buffer, Optional] IMFStreamDescriptor** apStreamDescriptors,[Out] IMFPresentationDescriptor** ppPresentationDescriptor)</unmanaged>
            <unmanaged-short>MFCreatePresentationDescriptor</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.RequireProtectedEnvironment(SharpDX.MediaFoundation.PresentationDescriptor)">
            <summary>
            <p> </p><p>Queries whether a media presentation requires the Protected Media Path (PMP).</p>
            </summary>
            <param name = "presentationDescriptorRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of a presentation descriptor. The presentation descriptor is created by the media source, and describes the presentation.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>This presentation requires a protected environment.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>S_FALSE</strong></strong></dt> </dl> </td><td> <p>This presentation does not require a protected environment.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If this function returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>, it means the PMP is required for this presentation. Call <strong>MFCreatePMPMediaSession</strong> to create the PMP session object.</p><p>If the function returns <strong>S_FALSE</strong>, you can use the unprotected pipeline. Call <strong>MFCreateMediaSession</strong> to create the regular Media Session object.</p><p>Internally, this function checks whether any of the stream descriptors in the presentation have the <strong><see cref = "!:Protected"/></strong> attribute with the value <strong>TRUE</strong>.</p>
            </remarks>
            <doc-id>ms697052</doc-id>
            <unmanaged>HRESULT MFRequireProtectedEnvironment([In] IMFPresentationDescriptor* pPresentationDescriptor)</unmanaged>
            <unmanaged-short>MFRequireProtectedEnvironment</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.SerializePresentationDescriptor(SharpDX.MediaFoundation.PresentationDescriptor,System.Int32@,System.Byte[])">
            <summary>
            <p> </p><p>Serializes a presentation descriptor to a byte array.</p>
            </summary>
            <param name = "pDRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the presentation descriptor to serialize.</p> </dd></param>
            <param name = "cbDataRef"><dd> <p>Receives the size of the <em>ppbData</em> array, in bytes.</p> </dd></param>
            <param name = "bDataOut"><dd> <p>Receives a reference to an array of bytes containing the serialized presentation descriptor. The caller must free the memory for the array by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To deserialize the presentation descriptor, pass the byte array to the <strong>MFDeserializePresentationDescriptor</strong> function.</p>
            </remarks>
            <doc-id>ms705608</doc-id>
            <unmanaged>HRESULT MFSerializePresentationDescriptor([In] IMFPresentationDescriptor* pPD,[Out] DWORD* pcbData,[Out, Buffer] unsigned char** ppbData)</unmanaged>
            <unmanaged-short>MFSerializePresentationDescriptor</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.DeserializePresentationDescriptor(System.Int32,System.Byte[],SharpDX.MediaFoundation.PresentationDescriptor@)">
            <summary>
            <p> </p><p>Deserializes a presentation descriptor from a byte array.</p>
            </summary>
            <param name = "cbData"><dd> <p>Size of the <em>pbData</em> array, in bytes.</p> </dd></param>
            <param name = "bDataRef"><dd> <p>Pointer to an array of bytes that contains the serialized presentation descriptor.</p> </dd></param>
            <param name = "pDOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the presentation descriptor. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms697044</doc-id>
            <unmanaged>HRESULT MFDeserializePresentationDescriptor([In] DWORD cbData,[In, Buffer] unsigned char* pbData,[Out] IMFPresentationDescriptor** ppPD)</unmanaged>
            <unmanaged-short>MFDeserializePresentationDescriptor</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateStreamDescriptor(System.Int32,System.Int32,SharpDX.MediaFoundation.MediaType[],SharpDX.MediaFoundation.StreamDescriptor@)">
            <summary>
            <p> Creates a stream descriptor. </p>
            </summary>
            <param name = "dwStreamIdentifier"><dd> <p> Stream identifier. </p> </dd></param>
            <param name = "cMediaTypes"><dd> <p> Number of elements in the <em>apMediaTypes</em> array. </p> </dd></param>
            <param name = "apMediaTypes"><dd> <p> Pointer to an array of <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface references. These references are used to initialize the media type handler for the stream descriptor. </p> </dd></param>
            <param name = "descriptorOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.StreamDescriptor"/></strong> interface of the new stream descriptor. The caller must release the interface. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> If you are writing a custom media source, you can use this function to create stream descriptors for the source. This function automatically creates the stream descriptor media type handler and initializes it with the list of types given in <em>apMediaTypes</em>. The function does not set the current media type on the handler, however. To set the type, call <strong>IMFMediaTypeHandler::SetCurrentMediaType</strong>. </p><p>This function is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms698990</doc-id>
            <unmanaged>HRESULT MFCreateStreamDescriptor([In] DWORD dwStreamIdentifier,[In] DWORD cMediaTypes,[In, Buffer] IMFMediaType** apMediaTypes,[Out] IMFStreamDescriptor** ppDescriptor)</unmanaged>
            <unmanaged-short>MFCreateStreamDescriptor</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateSimpleTypeHandler(SharpDX.MediaFoundation.MediaTypeHandler@)">
            <summary>
            <p> </p><p>Creates a media-type handler that supports a single media type at a time.</p>
            </summary>
            <param name = "handlerOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaTypeHandler"/></strong> interface of the media-type handler. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The media-type handler created by this function supports one media type at a time. Set the media type by calling <strong>IMFMediaTypeHandler::SetCurrentMediaType</strong>. After the type is set, <strong>IMFMediaTypeHandler::IsMediaTypeSupported</strong> always checks against that type.</p>
            </remarks>
            <doc-id>ms696988</doc-id>
            <unmanaged>HRESULT MFCreateSimpleTypeHandler([Out] IMFMediaTypeHandler** ppHandler)</unmanaged>
            <unmanaged-short>MFCreateSimpleTypeHandler</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.ShutdownObject(SharpDX.IUnknown)">
            <summary>
            <p>Shuts down a Media Foundation object and releases all resources associated with the object.</p><p>This function is a helper function that wraps the <strong>IMFShutdown::Shutdown</strong> method. The function queries the object for the <strong><see cref = "T:SharpDX.MediaFoundation.Shutdownable"/></strong> interface and, if successful, calls <strong>Shutdown</strong> on the object.</p>
            </summary>
            <param name = "unkRef">No documentation.</param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This function is not related to the <strong>MFShutdown</strong> function, which shuts down the Media Foundation platform, as described in Initializing Media Foundation. </p>
            </remarks>
            <doc-id>ms701968</doc-id>
            <unmanaged>HRESULT MFShutdownObject([In] IUnknown* pUnk)</unmanaged>
            <unmanaged-short>MFShutdownObject</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateAudioRenderer(SharpDX.MediaFoundation.MediaAttributes,SharpDX.MediaFoundation.MediaSink@)">
            <summary>
            <p> Creates the Streaming Audio Renderer. </p>
            </summary>
            <param name = "audioAttributesRef">No documentation.</param>
            <param name = "sinkOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>To configure the audio renderer, set any of the following attributes on the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface specified in the <em>pAudioAttributes</em> parameter.</p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <strong><see cref = "!:EndpointId"/></strong> </td><td>The audio endpoint device identifier.</td></tr> <tr><td> <strong><see cref = "!:EndpointRole"/></strong> </td><td>The audio endpoint role.</td></tr> <tr><td> <strong><see cref = "!:Flags"/></strong> </td><td>Miscellaneous configuration flags.</td></tr> <tr><td> <strong><see cref = "!:SessionId"/></strong> </td><td>The audio policy class.</td></tr> <tr><td> <see cref = "!:StreamCategory"/> </td><td>The audio stream category.</td></tr> <tr><td> <see cref = "!:LowLatency"/> </td><td>Enables low-latency audio streaming.</td></tr> </table><p>?</p>
            </remarks>
            <doc-id>ms701557</doc-id>
            <unmanaged>HRESULT MFCreateAudioRenderer([In] IMFAttributes* pAudioAttributes,[Out] IMFMediaSink** ppSink)</unmanaged>
            <unmanaged-short>MFCreateAudioRenderer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateAudioRendererActivate(SharpDX.MediaFoundation.Activate@)">
            <summary>
            <p> </p><p>Creates an activation object for the Streaming Audio Renderer.</p>
            </summary>
            <param name = "activateOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>To create the audio renderer, call <strong>IMFActivate::ActivateObject</strong> on the retrieved <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> reference.</p><strong>Note</strong>??To avoid a memory leak, call <strong>IMFActivate::ShutdownObject</strong> before releasing the final reference to the audio renderer or the audio renderer activate object.?<p>To configure the audio renderer, set any of the following attributes on the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> object before calling <strong>ActivateObject</strong>. (If you are using the Media Session, the Media Session automatically calls <strong>ActivateObject</strong> when you queue the topology.)</p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <strong><see cref = "!:EndpointId"/></strong> </td><td>The audio endpoint device identifier.</td></tr> <tr><td> <strong><see cref = "!:EndpointRole"/></strong> </td><td>The audio endpoint role.</td></tr> <tr><td> <strong><see cref = "!:Flags"/></strong> </td><td>Miscellaneous configuration flags.</td></tr> <tr><td> <strong><see cref = "!:SessionId"/></strong> </td><td>The audio policy class.</td></tr> <tr><td> <see cref = "!:StreamCategory"/> </td><td>The audio stream category.</td></tr> <tr><td> <see cref = "!:LowLatency"/> </td><td>Enables low-latency audio streaming.</td></tr> </table><p>?</p>
            </remarks>
            <doc-id>ms702998</doc-id>
            <unmanaged>HRESULT MFCreateAudioRendererActivate([Out] IMFActivate** ppActivate)</unmanaged>
            <unmanaged-short>MFCreateAudioRendererActivate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateVideoRendererActivate(System.IntPtr,SharpDX.MediaFoundation.Activate@)">
            <summary>
            <p> </p><p>Creates an activation object for the enhanced video renderer (EVR) media sink.</p>
            </summary>
            <param name = "hwndVideo"><dd> <p>Handle to the window where the video will be displayed.</p> </dd></param>
            <param name = "activateOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface. Use this interface to create the EVR. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To create the EVR, call <strong>IMFActivate::ActivateObject</strong> on the retrieved <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> reference. (If you are using the Media Session, the Media Session automatically calls <strong>ActivateObject</strong> when you queue the topology.)</p><p>To configure the EVR, set any of the following attributes on the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> object before calling <strong>ActivateObject</strong>.</p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <strong><see cref = "!:MixerActivate"/></strong> </td><td>Activation object for a custom mixer.</td></tr> <tr><td> <strong><see cref = "!:MixerClsid"/></strong> </td><td>CLSID for a custom mixer.</td></tr> <tr><td> <strong><see cref = "!:MixerFlags"/></strong> </td><td>Flags for creating a custom mixer.</td></tr> <tr><td> <strong><see cref = "!:PresenterActivate"/></strong> </td><td>Activation object for a custom presenter.</td></tr> <tr><td> <strong><see cref = "!:PresenterClsid"/></strong> </td><td>CLSID for a custom presenter.</td></tr> <tr><td> <strong><see cref = "!:PresenterFlags"/></strong> </td><td>Flags for creating a custom presenter.</td></tr> </table><p>?</p><p>When <strong>IMFActivate::ActivateObject</strong> is called, the activation objects sets the video window on the EVR by calling <strong>IMFVideoDisplayControl::SetVideoPosition</strong>. Passing <strong><c>null</c></strong> for the <em>hwndVideo</em> parameter is not an error, but no video will render unless the EVR has a valid video window.</p>
            </remarks>
            <doc-id>ms693543</doc-id>
            <unmanaged>HRESULT MFCreateVideoRendererActivate([In] HWND hwndVideo,[Out] IMFActivate** ppActivate)</unmanaged>
            <unmanaged-short>MFCreateVideoRendererActivate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateMPEG4MediaSink(SharpDX.MediaFoundation.IByteStream,SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.MediaSink@)">
            <summary>
            <p>Creates a media sink for authoring MP4 files.</p>
            </summary>
            <param name = "iByteStreamRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream.  The media sink writes the MP4 file to this byte stream. The byte stream must be writable and support seeking.</p> </dd></param>
            <param name = "videoMediaTypeRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of a video media type. This type specifies the format of the video stream.</p> <p>This parameter can be <strong><c>null</c></strong>, but not if <em>pAudioMediaType</em> is <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "audioMediaTypeRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of an audio media type. This type specifies the format of the audio stream.</p> <p>This parameter can be <strong><c>null</c></strong>, but not if <em>pVideoMediaType</em> is <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "iMediaSinkOut"><dd> <p>Receives a reference to the MP4 media sink's <strong><see cref = "T:SharpDX.MediaFoundation.MediaSink"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The MP4 media sink supports a maximum of one video stream and one audio stream. The initial stream formats are given in the <em>pVideoMediaType</em> and <em>pAudioMediaType</em> parameters. To create an MP4 file with one stream, set the other stream type to <strong><c>null</c></strong>. For example, to create an audio-only file, set <em>pVideoMediaType</em> to <strong><c>null</c></strong>. </p><p>The number of streams is fixed when you create the media sink. The sink does not support the <strong>IMFMediaSink::AddStreamSink</strong> method.</p><p>To author 3GP files, use the <strong>MFCreate3GPMediaSink</strong> function.</p>
            </remarks>
            <doc-id>dd388100</doc-id>
            <unmanaged>HRESULT MFCreateMPEG4MediaSink([In] IMFByteStream* pIByteStream,[In, Optional] IMFMediaType* pVideoMediaType,[In, Optional] IMFMediaType* pAudioMediaType,[Out] IMFMediaSink** ppIMediaSink)</unmanaged>
            <unmanaged-short>MFCreateMPEG4MediaSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.Create3GPMediaSink(SharpDX.MediaFoundation.IByteStream,SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.MediaSink@)">
            <summary>
            <p>Creates a media sink for authoring 3GP files.</p>
            </summary>
            <param name = "iByteStreamRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream.  The media sink writes the 3GP file to this byte stream. The byte stream must be writable and support seeking.</p> </dd></param>
            <param name = "videoMediaTypeRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of a video media type. This type specifies the format of the video stream.</p> <p>This parameter can be <strong><c>null</c></strong>, but not if <em>pAudioMediaType</em> is <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "audioMediaTypeRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of an audio media type. This type specifies the format of the audio stream.</p> <p>This parameter can be <strong><c>null</c></strong>, but not if <em>pVideoMediaType</em> is <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "iMediaSinkOut"><dd> <p>Receives a reference to the 3GP media sink's <strong><see cref = "T:SharpDX.MediaFoundation.MediaSink"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The 3GP media sink supports a maximum of one video stream and one audio stream. The initial stream formats are given in the <em>pVideoMediaType</em> and <em>pAudioMediaType</em> parameters. To create an MP4 file with one stream, set the other stream type to <strong><c>null</c></strong>. For example, to create an audio-only file, set <em>pVideoMediaType</em> to <strong><c>null</c></strong>. </p><p>The number of streams is fixed when you create the media sink. The sink does not support the <strong>IMFMediaSink::AddStreamSink</strong> method.</p><p>To author MP4 files, use the <strong>MFCreateMPEG4MediaSink</strong> function.</p>
            </remarks>
            <doc-id>dd388084</doc-id>
            <unmanaged>HRESULT MFCreate3GPMediaSink([In] IMFByteStream* pIByteStream,[In, Optional] IMFMediaType* pVideoMediaType,[In, Optional] IMFMediaType* pAudioMediaType,[Out] IMFMediaSink** ppIMediaSink)</unmanaged>
            <unmanaged-short>MFCreate3GPMediaSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateMP3MediaSink(SharpDX.MediaFoundation.IByteStream,SharpDX.MediaFoundation.MediaSink@)">
            <summary>
            <p>Creates the MP3 media sink.</p>
            </summary>
            <param name = "targetByteStreamRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream.  The media sink writes the MP3 file to this byte stream. The byte stream must be writable.</p> </dd></param>
            <param name = "mediaSinkOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSink"/></strong> interface of the MP3 media sink.. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The MP3  media sink takes compressed MP3
            audio samples as input, and writes an MP3 file with ID3 headers as output. The MP3 media sink does not perform MP3 audio encoding. </p>
            </remarks>
            <doc-id>dd388098</doc-id>
            <unmanaged>HRESULT MFCreateMP3MediaSink([In] IMFByteStream* pTargetByteStream,[Out] IMFMediaSink** ppMediaSink)</unmanaged>
            <unmanaged-short>MFCreateMP3MediaSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateAC3MediaSink(SharpDX.MediaFoundation.IByteStream,SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.MediaSink@)">
            <summary>
            <p>Creates an instance of the AC-3 media sink.</p>
            </summary>
            <param name = "targetByteStreamRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream. The media sink writes the AC-3 file to this byte stream. The byte stream must be writable. </p> </dd></param>
            <param name = "audioMediaTypeRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. This parameter specifies the media type for the AC-3 audio stream. The media type must contain the following attributes.</p> <table> <tr><th>Attribute</th><th>Value</th></tr> <tr><td> <see cref = "!:MajorType"/> </td><td><strong><see cref = "!:Audio"/></strong></td></tr> <tr><td> <see cref = "!:Subtype"/> </td><td><strong><see cref = "!:DolbyAc3"/></strong> or <strong><see cref = "!:DolbyDDPlus"/></strong></td></tr> </table> <p>?</p> </dd></param>
            <param name = "mediaSinkOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSink"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The AC-3 media sink takes compressed AC-3 audio as input and writes the audio to the  byte stream without modification. The primary use for this media sink is to stream AC-3 audio over a network. The media sink does not perform AC-3 audio encoding.</p>
            </remarks>
            <doc-id>hh162747</doc-id>
            <unmanaged>HRESULT MFCreateAC3MediaSink([In] IMFByteStream* pTargetByteStream,[In] IMFMediaType* pAudioMediaType,[Out] IMFMediaSink** ppMediaSink)</unmanaged>
            <unmanaged-short>MFCreateAC3MediaSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateADTSMediaSink(SharpDX.MediaFoundation.IByteStream,SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.MediaSink@)">
            <summary>
            <p>Creates an instance of the audio data transport stream (ADTS) media sink.</p>
            </summary>
            <param name = "targetByteStreamRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream. The media sink writes the ADTS stream to this byte stream. The byte stream must be writable.</p> </dd></param>
            <param name = "audioMediaTypeRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. This parameter specifies the media type for the ADTS stream. The media type must contain the following attributes.</p> <table> <tr><th>Attribute</th><th>Value</th></tr> <tr><td> <see cref = "!:MajorType"/> </td><td><strong><see cref = "!:Audio"/></strong></td></tr> <tr><td> <see cref = "!:Subtype"/> </td><td><strong><see cref = "!:Aac"/></strong></td></tr> <tr><td> <see cref = "!:AacPayloadType"/> </td><td>0 (raw AAC) or 1 (ADTS)</td></tr> </table> <p>?</p> </dd></param>
            <param name = "mediaSinkOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSink"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The ADTS media sink converts Advanced Audio Coding (AAC) audio packets into an ADTS stream. The primary use for this media sink is to stream ADTS over a network. The output is not an audio file, but a stream of audio frames with ADTS headers.</p><p>The media sink can accept raw AAC frames (<see cref = "!:AacPayloadType"/> = 0) or ADTS packets (<see cref = "!:AacPayloadType"/> = 1). If the input is raw AAC, the media sink inserts an ADTS header at the start of each audio frame. If the input is ADTS packets, the media sink passes the packets through to the byte stream, without modification.</p>
            </remarks>
            <doc-id>hh162748</doc-id>
            <unmanaged>HRESULT MFCreateADTSMediaSink([In] IMFByteStream* pTargetByteStream,[In] IMFMediaType* pAudioMediaType,[Out] IMFMediaSink** ppMediaSink)</unmanaged>
            <unmanaged-short>MFCreateADTSMediaSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateMuxSink(System.Guid,SharpDX.MediaFoundation.MediaAttributes,SharpDX.MediaFoundation.IByteStream,SharpDX.MediaFoundation.MediaSink@)">
            <summary>
            <p>Creates a generic media sink that wraps a multiplexer Microsoft Media Foundation transform (MFT).</p>
            </summary>
            <param name = "guidOutputSubType"><dd> <p>The subtype <see cref = "T:System.Guid"/> of the output type for the MFT.</p> </dd></param>
            <param name = "outputAttributesRef"><dd> <p>A list of format attributes for the MFT output type. This parameter is optional and can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "outputByteStreamRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream. The output from the MFT is written to this byte stream. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "muxSinkOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSink"/></strong> interface of the media sink. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function attempts to find a multiplexer MFT that supports an output type with the following definition:</p><ul> <li>Major type: <strong><see cref = "!:Stream"/></strong></li> <li>Subtype: <em>guidOutputSubType</em></li> <li>Additional format attributes (optional)</li> </ul><p>To provide a list of additional format attributes:</p><ol> <li>Call <strong>MFCreateAttributes</strong> to get an <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> reference.</li> <li>Use the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface to set the attributes. (See Media Type Attributes.)</li> <li>Pass the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> reference in the <em>pOutputAttributes</em> parameter.</li> </ol><p>The multiplexer MFT must be registered in the <strong><see cref = "!:Multiplexer"/></strong> category.</p>
            </remarks>
            <doc-id>hh162756</doc-id>
            <unmanaged>HRESULT MFCreateMuxSink([In] GUID guidOutputSubType,[In, Optional] IMFAttributes* pOutputAttributes,[In, Optional] IMFByteStream* pOutputByteStream,[Out] IMFMediaSink** ppMuxSink)</unmanaged>
            <unmanaged-short>MFCreateMuxSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateFMPEG4MediaSink(SharpDX.MediaFoundation.IByteStream,SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.MediaSink@)">
            <summary>
            <p>Creates a media sink for authoring fragmented MP4 files.</p>
            </summary>
            <param name = "iByteStreamRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream.  The media sink writes the MP4 file to this byte stream. The byte stream must be writable and support seeking.</p> </dd></param>
            <param name = "videoMediaTypeRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of a video media type. This type specifies the format of the video stream.</p> <p>This parameter can be <strong><c>null</c></strong>, but not if <em>pAudioMediaType</em> is <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "audioMediaTypeRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of an audio media type. This type specifies the format of the audio stream.</p> <p>This parameter can be <strong><c>null</c></strong>, but not if <em>pVideoMediaType</em> is <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "iMediaSinkOut"><dd> <p>Receives a reference to the MP4 media sink's <strong><see cref = "T:SharpDX.MediaFoundation.MediaSink"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>jj247578</doc-id>
            <unmanaged>HRESULT MFCreateFMPEG4MediaSink([In] IMFByteStream* pIByteStream,[In, Optional] IMFMediaType* pVideoMediaType,[In, Optional] IMFMediaType* pAudioMediaType,[Out] IMFMediaSink** ppIMediaSink)</unmanaged>
            <unmanaged-short>MFCreateFMPEG4MediaSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateAVIMediaSink(SharpDX.MediaFoundation.IByteStream,SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.MediaSink@)">
            <summary>
            <p>Creates an Audio-Video Interleaved (AVI) Sink.</p>
            </summary>
            <param name = "iByteStreamRef"><dd> <p>Pointer to the byte stream that will be used to write the AVI file.</p> </dd></param>
            <param name = "videoMediaTypeRef"><dd> <p>Pointer to the media type of the video input stream</p> </dd></param>
            <param name = "audioMediaTypeRef"><dd> <p>Pointer to the media type of the audio input stream</p> </dd></param>
            <param name = "iMediaSinkOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSink"/></strong> Interface.  The caller must release this interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn302108</doc-id>
            <unmanaged>HRESULT MFCreateAVIMediaSink([In] IMFByteStream* pIByteStream,[In] IMFMediaType* pVideoMediaType,[In, Optional] IMFMediaType* pAudioMediaType,[Out] IMFMediaSink** ppIMediaSink)</unmanaged>
            <unmanaged-short>MFCreateAVIMediaSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateWAVEMediaSink(SharpDX.MediaFoundation.IByteStream,SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.MediaSink@)">
            <summary>
            <p> Creates an WAVE archive sink.  The WAVE archive sink takes
            audio and writes it to an .wav file.
            </p>
            </summary>
            <param name = "targetByteStreamRef"><dd> <p> Pointer to the byte stream that will be used to write the .wav file.</p> </dd></param>
            <param name = "audioMediaTypeRef"><dd> <p>Pointer to the audio media type.</p> </dd></param>
            <param name = "mediaSinkOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSink"/></strong> interface.  The caller must release this interface.</p> </dd></param>
            <returns>No documentation.</returns>
            <doc-id>dn302112</doc-id>
            <unmanaged>HRESULT MFCreateWAVEMediaSink([In] IMFByteStream* pTargetByteStream,[In] IMFMediaType* pAudioMediaType,[Out] IMFMediaSink** ppMediaSink)</unmanaged>
            <unmanaged-short>MFCreateWAVEMediaSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateTopoLoader(SharpDX.MediaFoundation.TopoLoader@)">
            <summary>
            <p> </p><p>Creates a new instance of the topology loader.</p>
            </summary>
            <param name = "objOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.TopoLoader"/></strong> interface of the topology loader. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms694159</doc-id>
            <unmanaged>HRESULT MFCreateTopoLoader([Out] IMFTopoLoader** ppObj)</unmanaged>
            <unmanaged-short>MFCreateTopoLoader</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateSampleGrabberSinkActivate(SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.SampleGrabberSinkCallback,SharpDX.MediaFoundation.Activate@)">
            <summary>
            <p> </p><p>Creates an activation object for the sample grabber media sink.</p>
            </summary>
            <param name = "iMFMediaTypeRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface, defining the media type for the sample grabber's input stream. </p> </dd></param>
            <param name = "iMFSampleGrabberSinkCallbackRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.SampleGrabberSinkCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>
            <param name = "iActivateOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface. Use this interface to complete the creation of the sample grabber. The caller must release the interface. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>To create the sample grabber sink, call <strong>IMFActivate::ActivateObject</strong> on the reference received in the <em>ppIActivate</em> parameter.</p><p>Before calling <strong>ActivateObject</strong>, you can configure the sample grabber by setting any of the following attributes on the <em>ppIActivate</em> reference:</p><ul> <li> <see cref = "!:IgnoreClock"/> </li> <li> <strong><see cref = "!:SampleTimeOffset"/></strong> </li> </ul>
            </remarks>
            <doc-id>ms702068</doc-id>
            <unmanaged>HRESULT MFCreateSampleGrabberSinkActivate([In] IMFMediaType* pIMFMediaType,[In] IMFSampleGrabberSinkCallback* pIMFSampleGrabberSinkCallback,[Out] IMFActivate** ppIActivate)</unmanaged>
            <unmanaged-short>MFCreateSampleGrabberSinkActivate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateStandardQualityManager(SharpDX.MediaFoundation.QualityManager@)">
            <summary>
            <p> </p><p>Creates the default implementation of the quality manager.</p>
            </summary>
            <param name = "qualityManagerOut"><dd> <p>Receives a reference to the quality manager's <strong><see cref = "T:SharpDX.MediaFoundation.QualityManager"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms701594</doc-id>
            <unmanaged>HRESULT MFCreateStandardQualityManager([Out] IMFQualityManager** ppQualityManager)</unmanaged>
            <unmanaged-short>MFCreateStandardQualityManager</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateSequencerSource(SharpDX.IUnknown,SharpDX.MediaFoundation.SequencerSource@)">
            <summary>
            <p> </p><p>Creates the sequencer source.</p>
            </summary>
            <param name = "reservedRef"><dd> <p>Reserved. Must be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "sequencerSourceOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.SequencerSource"/></strong> interface of the sequencer source. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms704663</doc-id>
            <unmanaged>HRESULT MFCreateSequencerSource([In] IUnknown* pReserved,[Out] IMFSequencerSource** ppSequencerSource)</unmanaged>
            <unmanaged-short>MFCreateSequencerSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateSequencerSegmentOffset(System.Int32,System.Int64,SharpDX.Win32.Variant@)">
            <summary>
            <p> Creates a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that can be used to seek within a sequencer source presentation. </p>
            </summary>
            <param name = "dwId"><dd> <p> Sequencer element identifier. This value specifies the segment in which to begin playback. The element identifier is returned in the <strong>IMFSequencerSource::AppendTopology</strong> method. </p> </dd></param>
            <param name = "hnsOffset"><dd> <p> Starting position within the segment, in 100-nanosecond units. </p> </dd></param>
            <param name = "varSegmentOffsetRef"><dd> <p> Pointer to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong>. The method fills in the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> with the information needed for performing a seek operation. The caller must free the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> by calling <strong>PropVariantClear</strong>. </p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> returned in <em>pvarSegmentOffset</em> can be used for the <em>pvarStartPosition</em> parameter in the <strong>IMFMediaSession::Start</strong> method. Use the time format <strong><see cref = "T:System.Guid"/> MF_TIME_FORMAT_SEGMENT_OFFSET</strong>. </p>
            </remarks>
            <doc-id>ms697268</doc-id>
            <unmanaged>HRESULT MFCreateSequencerSegmentOffset([In] DWORD dwId,[In] longlong hnsOffset,[Out] PROPVARIANT* pvarSegmentOffset)</unmanaged>
            <unmanaged-short>MFCreateSequencerSegmentOffset</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateAggregateSource(SharpDX.MediaFoundation.Collection,SharpDX.MediaFoundation.MediaSource@)">
            <summary>
            <p>Creates a media source that aggregates a collection of media sources. </p>
            </summary>
            <param name = "sourceCollectionRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Collection"/></strong> interface of the collection object that contains a list of media sources. </p> </dd></param>
            <param name = "aggSourceOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSource"/></strong> interface of the aggregated media source. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> The <em>pSourceCollection</em> collection does not contain any elements.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The aggregated media source is useful for combining  streams from separate media sources. For example, you can use it to  combine a video capture source and an audio capture source. </p>
            </remarks>
            <doc-id>dd388085</doc-id>
            <unmanaged>HRESULT MFCreateAggregateSource([In] IMFCollection* pSourceCollection,[Out] IMFMediaSource** ppAggSource)</unmanaged>
            <unmanaged-short>MFCreateAggregateSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateCredentialCache(SharpDX.MediaFoundation.NetCredentialCache@)">
            <summary>
            <p> </p><p>Creates a credential cache object. An application can use this object to implement a custom credential manager.</p>
            </summary>
            <param name = "cacheOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.NetCredentialCache"/></strong> interface of the new credential cache object. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms704802</doc-id>
            <unmanaged>HRESULT MFCreateCredentialCache([Out] IMFNetCredentialCache** ppCache)</unmanaged>
            <unmanaged-short>MFCreateCredentialCache</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateProxyLocator(System.String,SharpDX.ComObject,SharpDX.MediaFoundation.NetProxyLocator@)">
            <summary>
            <p> </p><p>Creates a default proxy locator.</p>
            </summary>
            <param name = "szProtocolRef"><dd> <p>The name of the protocol.</p> <strong>Note</strong>??In this release of Media Foundation, the default proxy locator does not support RTSP. ? </dd></param>
            <param name = "proxyConfigRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.ComObject"/></strong> interface of a property store that contains the proxy configuration in the <strong>MFNETSOURCE_PROXYSETTINGS</strong> property.</p> </dd></param>
            <param name = "proxyLocatorOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.NetProxyLocator"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms701595</doc-id>
            <unmanaged>HRESULT MFCreateProxyLocator([In] const wchar_t* pszProtocol,[In] IPropertyStore* pProxyConfig,[Out] IMFNetProxyLocator** ppProxyLocator)</unmanaged>
            <unmanaged-short>MFCreateProxyLocator</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateNetSchemePlugin(System.Guid,System.IntPtr)">
            <summary>
            <p> </p><p>Creates the scheme handler for the network source.</p>
            </summary>
            <param name = "riid"><dd> <p>Interface identifier (IID) of the interface to retrieve.</p> </dd></param>
            <param name = "vHandlerOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface. The scheme handler exposes the <strong><see cref = "T:SharpDX.MediaFoundation.SchemeHandler"/></strong> interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>aa378396</doc-id>
            <unmanaged>HRESULT MFCreateNetSchemePlugin([In] const GUID&amp; riid,[In] void** ppvHandler)</unmanaged>
            <unmanaged-short>MFCreateNetSchemePlugin</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreatePMPServer(System.Int32,SharpDX.MediaFoundation.PMPServer@)">
            <summary>
            <p> </p><p>Creates the protected media path (PMP) server object.</p>
            </summary>
            <param name = "dwCreationFlags"><dd> <p>A member of the <strong><see cref = "T:SharpDX.MediaFoundation.PmpsessionCreationFlags"/></strong> enumeration that specifies how to create the PMP session.</p> </dd></param>
            <param name = "pMPServerOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.PMPServer"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded. </p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms696183</doc-id>
            <unmanaged>HRESULT MFCreatePMPServer([In] DWORD dwCreationFlags,[Out] IMFPMPServer** ppPMPServer)</unmanaged>
            <unmanaged-short>MFCreatePMPServer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateRemoteDesktopPlugin(SharpDX.MediaFoundation.RemoteDesktopPlugin@)">
            <summary>
            <p> </p><p>Creates the remote desktop plug-in object. Use this object if the application is running in a Terminal Services client session.</p>
            </summary>
            <param name = "pluginOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.RemoteDesktopPlugin"/></strong> interface of the plug-in object. The caller must release the interface.</p> </dd></param>
            <returns><p> The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The function succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_ACCESSDENIED</strong></dt> </dl> </td><td> <p>Remote desktop connections are not allowed by the current session policy.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms703133</doc-id>
            <unmanaged>HRESULT MFCreateRemoteDesktopPlugin([Out] IMFRemoteDesktopPlugin** ppPlugin)</unmanaged>
            <unmanaged-short>MFCreateRemoteDesktopPlugin</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateNamedPropertyStore(SharpDX.ComObject@)">
            <summary>
            <p>[This API is not supported and may be altered or unavailable in the future. Instead, applications should use the <strong>PSCreateMemoryPropertyStore</strong> function to create named property stores.]</p><p>Creates an empty property store to hold name/value pairs.</p>
            </summary>
            <param name = "storeOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.ComObject"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>aa367379</doc-id>
            <unmanaged>HRESULT CreateNamedPropertyStore([Out] INamedPropertyStore** ppStore)</unmanaged>
            <unmanaged-short>CreateNamedPropertyStore</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateSampleCopierMFT(SharpDX.MediaFoundation.Transform@)">
            <summary>
            <p>Creates an instance of the sample copier transform.</p>
            </summary>
            <param name = "copierMFTOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The sample copier is a Media Foundation transform (MFT) that copies data from input samples to output samples without modifying the data. The following data is copied from the sample:</p><ul> <li>All Sample Attributes.</li> <li>The time stamp and duration.</li> <li>Sample flags (see <strong>IMFSample::SetSampleFlags</strong>).</li> <li>The data in the media buffers. If the input sample contains multiple buffers, the data is copied into a single buffer on the output sample.</li> </ul><p>This MFT is useful in the following situation:</p><ul> <li>One pipeline object, such as a media source, allocates media samples for output.</li> <li>Another pipeline object, such as a media sink, allocates its own media samples for input. For example, the object might require buffers allocated from a special memory pool, such as video memory.</li> </ul><p>The following diagram shows this situation with a media source and a media sink.</p><p></p><p>In order for the media sink to receive data from the media source, the data must be copied into the media samples owned by the media sink. The sample copier can be used for this purpose.</p><p>A specific example of such a media sink is the  Enhanced Video Renderer (EVR). The EVR allocates samples that contain Direct3D surface buffers, so it cannot receive video samples directly from a media source. Starting in Windows?7, the topology loader automatically handles this case by inserting the sample copier between the media source and the EVR.</p>
            </remarks>
            <doc-id>dd388101</doc-id>
            <unmanaged>HRESULT MFCreateSampleCopierMFT([Out] IMFTransform** ppCopierMFT)</unmanaged>
            <unmanaged-short>MFCreateSampleCopierMFT</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateTranscodeProfile(SharpDX.MediaFoundation.TranscodeProfile@)">
            <summary>
            <p>Creates an empty transcode profile object.</p><p>The transcode profile stores configuration settings for the output file. These configuration settings are specified by the caller, and include audio and video stream properties, encoder settings, and  container settings. To set these properties, the caller must call the appropriate <strong><see cref = "T:SharpDX.MediaFoundation.TranscodeProfile"/></strong> methods.</p><p>The configured transcode profile is passed to the <strong>MFCreateTranscodeTopology</strong> function.  The underlying topology builder uses these settings to build the transcode topology.</p>
            </summary>
            <param name = "transcodeProfileOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The <strong>MFCreateTranscodeProfile</strong> function creates an empty transcode profile. You must configure the transcode profile setting attributes that define the media types and the container properties. Use the following methods to configure the profile:</p><ul> <li> <strong>IMFTranscodeProfile::SetAudioAttributes</strong> </li> <li> <strong>IMFTranscodeProfile::SetVideoAttributes</strong> </li> <li> <strong>IMFTranscodeProfile::SetContainerAttributes</strong> </li> </ul><p>For example code that uses this function, see the following topics:</p><ul> <li> Tutorial: Encoding an MP4 File </li> <li> Tutorial: Encoding a WMA File </li> </ul>
            </remarks>
            <doc-id>dd388113</doc-id>
            <unmanaged>HRESULT MFCreateTranscodeProfile([Out] IMFTranscodeProfile** ppTranscodeProfile)</unmanaged>
            <unmanaged-short>MFCreateTranscodeProfile</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateTranscodeTopology(SharpDX.MediaFoundation.MediaSource,System.String,SharpDX.MediaFoundation.TranscodeProfile,SharpDX.MediaFoundation.Topology@)">
            <summary>
            <p>Creates a partial transcode topology.</p><p>The underlying topology builder creates a partial topology by connecting the required pipeline objects:
            source, encoder, and sink. The encoder and the sink are configured according to the settings specified by the caller in the transcode profile. </p><p>To create the transcode profile object, call the <strong>MFCreateTranscodeProfile</strong> function and set the required attributes by calling the appropriate the <strong><see cref = "T:SharpDX.MediaFoundation.TranscodeProfile"/></strong> methods. </p><p>The configured transcode profile is passed to the <strong>MFCreateTranscodeTopology</strong> function, which creates the transcode topology with the appropriate settings. The caller can then set this topology on the Media Session and start the session to begin the encoding process. When the Media Session ends, the transcoded file is generated.</p>
            </summary>
            <param name = "srcRef">No documentation.</param>
            <param name = "wszOutputFilePathRef">No documentation.</param>
            <param name = "profileRef">No documentation.</param>
            <param name = "transcodeTopoOut">No documentation.</param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The function call succeeded, and <em>ppTranscodeTopo</em> receives a reference to the transcode topology.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>pwszOutputFilePath</em> contains invalid characters.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:MediaSourceNoStreamsSelected"/></strong></dt> </dl> </td><td> <p>No streams are selected in the media source.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TranscodeNoContainertype"/></strong></dt> </dl> </td><td> <p>The profile does not contain the <see cref = "!:TranscodeContainertype"/> attribute.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TranscodeNoMatchingEncoder"/></strong></dt> </dl> </td><td> <p>For one or more streams, cannot find an encoder that accepts the media type given in the profile.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TranscodeProfileNoMatchingStreams"/></strong></dt> </dl> </td><td> <p>The profile does not specify a media type for any of the selected streams on the media source.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>For example code that uses this function, see the following topics:</p><ul> <li> Tutorial: Encoding an MP4 File </li> <li> Tutorial: Encoding a WMA File </li> </ul>
            </remarks>
            <doc-id>dd388118</doc-id>
            <unmanaged>HRESULT MFCreateTranscodeTopology([In] IMFMediaSource* pSrc,[In] const wchar_t* pwszOutputFilePath,[In] IMFTranscodeProfile* pProfile,[Out] IMFTopology** ppTranscodeTopo)</unmanaged>
            <unmanaged-short>MFCreateTranscodeTopology</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateTranscodeTopologyFromByteStream(SharpDX.MediaFoundation.MediaSource,SharpDX.MediaFoundation.IByteStream,SharpDX.MediaFoundation.TranscodeProfile,SharpDX.MediaFoundation.Topology@)">
            <summary>
            <p>Creates a topology for transcoding to a byte stream.</p>
            </summary>
            <param name = "srcRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSource"/></strong> interface of a media source. The media source provides that source content for transcoding.</p> </dd></param>
            <param name = "outputStreamRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream. The transcoded output will be written to this byte stream.</p> </dd></param>
            <param name = "profileRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.TranscodeProfile"/></strong> interface of a transcoding profile. </p> </dd></param>
            <param name = "transcodeTopoOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Topology"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function creates a partial topology that contains the media source, the encoder, and the media sink. </p>
            </remarks>
            <doc-id>hh162762</doc-id>
            <unmanaged>HRESULT MFCreateTranscodeTopologyFromByteStream([In] IMFMediaSource* pSrc,[In] IMFByteStream* pOutputStream,[In] IMFTranscodeProfile* pProfile,[Out] IMFTopology** ppTranscodeTopo)</unmanaged>
            <unmanaged-short>MFCreateTranscodeTopologyFromByteStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.TranscodeGetAudioOutputAvailableTypes(System.Guid,SharpDX.MediaFoundation.TransformEnumFlag,SharpDX.MediaFoundation.MediaAttributes)">
            <summary>
            <p>Gets a list of output formats from an audio encoder.</p>
            </summary>
            <param name = "guidSubType"><dd> <p>Specifies the subtype of the output media. The encoder uses this value as a filter when it is enumerating the available output types. For information about the audio subtypes, see  <strong>Audio Subtype GUIDs</strong>. </p> </dd></param>
            <param name = "dwMFTFlags"><dd> <p>Bitwise <strong>OR</strong> of zero or more flags from the <strong>_MFT_ENUM_FLAG</strong> enumeration. </p> </dd></param>
            <param name = "codecConfigRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of an attribute store. The attribute store specifies the encoder configuration settings. This parameter can be <strong><c>null</c></strong>. The attribute store can hold any of the following attributes.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><see cref = "!:MftFieldofuseUnlockAttribute"/></strong></dt> </dl> </td><td> <p>Set this attribute to unlock an encoder that has field-of-use descriptions.</p> </td></tr> <tr><td><dl> <dt><strong><see cref = "!:TranscodeEncodingprofile"/></strong></dt> </dl> </td><td> <p>Specifies a device conformance profile for a Windows Media encoder.</p> </td></tr> <tr><td><dl> <dt><strong><see cref = "!:TranscodeQualityvsspeed"/></strong></dt> </dl> </td><td> <p>Sets the tradeoff between encoding quality and encoding speed.</p> </td></tr> </table> <p>?</p> </dd></param>
            <returns><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Collection"/></strong> interface of a collection object that contains a list of preferred audio media types. The collection contains <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> references. The caller must release the interface reference.</p> </dd></returns>
            <remarks>
            <p>This function assumes the encoder will be used in its default encoding mode, which is typically constant bit-rate (CBR) encoding. Therefore, the types returned by the function might not work with other modes, such as variable bit-rate (VBR) encoding.</p><p>Internally, this function works by calling <strong>MFTEnumEx</strong> to find a matching encoder, and then calling <strong>IMFTransform::GetOutputAvailableType</strong> to get the encoder's output types.</p>
            </remarks>
            <doc-id>dd388655</doc-id>
            <unmanaged>HRESULT MFTranscodeGetAudioOutputAvailableTypes([In] const GUID&amp; guidSubType,[In] DWORD dwMFTFlags,[In, Optional] IMFAttributes* pCodecConfig,[Out] IMFCollection** ppAvailableTypes)</unmanaged>
            <unmanaged-short>MFTranscodeGetAudioOutputAvailableTypes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateTranscodeSinkActivate(SharpDX.MediaFoundation.Activate@)">
            <summary>
            <p>Creates the transcode sink activation object.</p><p>The transcode sink activation object can be used to create any of the following file sinks:</p><ul> <li>3GP file sink</li> <li>MP3 file sink</li> <li>MP4 file sink</li> </ul><p>The transcode sink activation object exposes the <strong><see cref = "T:SharpDX.MediaFoundation.TranscodeSinkInfoProvider"/></strong> interface.</p>
            </summary>
            <param name = "activateOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd388115</doc-id>
            <unmanaged>HRESULT MFCreateTranscodeSinkActivate([Out] IMFActivate** ppActivate)</unmanaged>
            <unmanaged-short>MFCreateTranscodeSinkActivate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateTrackedSample(SharpDX.MediaFoundation.TrackedSample@)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.MediaFoundation.TrackedSample"/></strong> object that tracks the reference counts on a video media sample.</p>
            </summary>
            <param name = "mFSampleOut">No documentation.</param>
            <returns>No documentation.</returns>
            <doc-id>hh162761</doc-id>
            <unmanaged>HRESULT MFCreateTrackedSample([Out] IMFTrackedSample** ppMFSample)</unmanaged>
            <unmanaged-short>MFCreateTrackedSample</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateMFByteStreamOnStream(SharpDX.Win32.IStream,SharpDX.MediaFoundation.ByteStream)">
            <summary>
            <p>Creates a Microsoft Media Foundation byte stream that wraps an <strong><see cref = "T:SharpDX.Win32.IStream"/></strong> reference.</p>
            </summary>
            <param name = "streamRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.Win32.IStream"/></strong> interface.</p> </dd></param>
            <param name = "byteStreamOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value.</p></returns>
            <remarks>
            <p>This function enables applications to pass an <strong><see cref = "T:SharpDX.Win32.IStream"/></strong> object to a Media Foundation API that takes an <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> reference.</p>
            </remarks>
            <doc-id>dd388095</doc-id>
            <unmanaged>HRESULT MFCreateMFByteStreamOnStream([In] IStream* pStream,[Out, Fast] IMFByteStream** ppByteStream)</unmanaged>
            <unmanaged-short>MFCreateMFByteStreamOnStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateStreamOnMFByteStream(SharpDX.MediaFoundation.IByteStream,SharpDX.Win32.IStream@)">
            <summary>
            <p>Returns an <strong><see cref = "T:SharpDX.Win32.IStream"/></strong> reference that wraps a Microsoft Media Foundation byte stream.</p>
            </summary>
            <param name = "byteStreamRef">No documentation.</param>
            <param name = "streamOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function enables an application to pass a Media Foundation byte stream to an API that takes an <strong><see cref = "T:SharpDX.Win32.IStream"/></strong> reference.</p>
            </remarks>
            <doc-id>hh162759</doc-id>
            <unmanaged>HRESULT MFCreateStreamOnMFByteStream([In] IMFByteStream* pByteStream,[Out] IStream** ppStream)</unmanaged>
            <unmanaged-short>MFCreateStreamOnMFByteStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateMFByteStreamOnStreamEx(SharpDX.IUnknown,SharpDX.MediaFoundation.ByteStream)">
            <summary>
            <p>Creates a Microsoft Media Foundation byte stream that wraps an <strong>IRandomAccessStream</strong> object.</p>
            </summary>
            <param name = "unkStreamRef">No documentation.</param>
            <param name = "byteStreamOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh162754</doc-id>
            <unmanaged>HRESULT MFCreateMFByteStreamOnStreamEx([In] IUnknown* punkStream,[Out, Fast] IMFByteStream** ppByteStream)</unmanaged>
            <unmanaged-short>MFCreateMFByteStreamOnStreamEx</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateStreamOnMFByteStreamEx(SharpDX.MediaFoundation.IByteStream,System.Guid,System.IntPtr@)">
            <summary>
            <p>Creates an <strong>IRandomAccessStream</strong> object that wraps a Microsoft Media Foundation byte stream.</p>
            </summary>
            <param name = "byteStreamRef">No documentation.</param>
            <param name = "riid">No documentation.</param>
            <param name = "vOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The returned byte stream object exposes the <strong><see cref = "T:SharpDX.MediaFoundation.ServiceProvider"/></strong> interface. To get the original <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> reference, call <strong>IMFGetService::GetService</strong> using the service identifier <strong><see cref = "!:WrappedObject"/></strong>.</p>
            </remarks>
            <doc-id>hh162760</doc-id>
            <unmanaged>HRESULT MFCreateStreamOnMFByteStreamEx([In] IMFByteStream* pByteStream,[In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>
            <unmanaged-short>MFCreateStreamOnMFByteStreamEx</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateMediaTypeFromProperties(SharpDX.IUnknown,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            <p>Create an <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> from properties.</p>
            </summary>
            <param name = "unkStreamRef">No documentation.</param>
            <param name = "mediaTypeOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>jj247579</doc-id>
            <unmanaged>HRESULT MFCreateMediaTypeFromProperties([In] IUnknown* punkStream,[Out] IMFMediaType** ppMediaType)</unmanaged>
            <unmanaged-short>MFCreateMediaTypeFromProperties</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreatePropertiesFromMediaType(SharpDX.MediaFoundation.MediaType,System.Guid,System.IntPtr@)">
            <summary>
            <p>Creates properties from a <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong>.</p>
            </summary>
            <param name = "mediaTypeRef">No documentation.</param>
            <param name = "riid">No documentation.</param>
            <param name = "vOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>jj247580</doc-id>
            <unmanaged>HRESULT MFCreatePropertiesFromMediaType([In] IMFMediaType* pMediaType,[In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>
            <unmanaged-short>MFCreatePropertiesFromMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.EnumDeviceSources(SharpDX.MediaFoundation.MediaAttributes,System.IntPtr@,System.Int32@)">
            <summary>
            <p>Enumerates a list of audio or video capture devices.</p>
            </summary>
            <param name = "attributesRef"><dd> <p>Pointer to an attribute store that contains search criteria. To create the attribute store, call <strong>MFCreateAttributes</strong>. Set one or more of the following attributes on the attribute store:</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><see cref = "!:SourceType"/></strong></dt> </dl> </td><td> <p>Specifies whether to enumerate audio or video devices. (Required.)</p> </td></tr> <tr><td><dl> <dt><strong><see cref = "!:SourceTypeAudcapRole"/></strong></dt> </dl> </td><td> <p>For audio capture devices, specifies the device role. (Optional.)</p> </td></tr> <tr><td><dl> <dt><strong><see cref = "!:SourceTypeVidcapCategory"/></strong></dt> </dl> </td><td> <p>For video capture devices, specifies the device category. (Optional.)</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "pSourceActivateOut"><dd> <p>Receives an array of <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface references. Each reference represents an activation object for a media source. The function allocates the memory for the array. The caller must release the references in the array and call <strong>CoTaskMemFree</strong> to free the memory for the array.</p> </dd></param>
            <param name = "cSourceActivateRef"><dd> <p>Receives the number of elements in the <em>pppSourceActivate</em> array. If no capture devices match the search criteria, this parameter receives the value 0.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Each returned <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> reference represents a capture device, and can be used to create a media source for that device. You can also use the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> reference to query for attributes that describe the device. The following attributes might be set:</p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <see cref = "!:FriendlyName"/> </td><td>The display name of the device.</td></tr> <tr><td> <see cref = "T:SharpDX.MediaFoundation.MediaType"/> </td><td>The major type and subtype GUIDs that describe the device's output format.</td></tr> <tr><td> <see cref = "!:SourceType"/> </td><td>The type of capture device (audio or video).</td></tr> <tr><td> <see cref = "!:SourceTypeAudcapEndpointId"/> </td><td>The audio endpoint ID string. (Audio devices only.)</td></tr> <tr><td> <see cref = "!:SourceTypeVidcapCategory"/> </td><td>The device category. (Video devices only.)</td></tr> <tr><td> <see cref = "!:SourceTypeVidcapHwSource"/> </td><td> Whether a device is a hardware or software device. (Video devices only.)</td></tr> <tr><td> <see cref = "!:SourceTypeVidcapSymbolicLink"/> </td><td>The symbolic link for the device driver. (Video devices only.)</td></tr> </table><p>?</p><p>To create a media source from an <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> reference, call the <strong>IMFActivate::ActivateObject</strong> method.</p>
            </remarks>
            <doc-id>dd388503</doc-id>
            <unmanaged>HRESULT MFEnumDeviceSources([In] IMFAttributes* pAttributes,[Out] IMFActivate*** pppSourceActivate,[Out] unsigned int* pcSourceActivate)</unmanaged>
            <unmanaged-short>MFEnumDeviceSources</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateDeviceSource(SharpDX.MediaFoundation.MediaAttributes,SharpDX.MediaFoundation.MediaSource@)">
            <summary>
            <p>Creates a media source for a hardware capture device.</p>
            </summary>
            <param name = "attributesRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of an attribute store, which is used to select the device. See Remarks.</p> </dd></param>
            <param name = "sourceOut"><dd> <p>Receives a reference to the media source's <strong><see cref = "T:SharpDX.MediaFoundation.MediaSource"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <strong>Important</strong>??When the capture device is no longer needed, you must shut down the device by calling <strong>Shutdown</strong> on the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSource"/></strong> object you obtained by calling <strong>MFCreateDeviceSource</strong>. Failure to call <strong>Shutdown</strong> can result in memory links because the system may keep a reference to <strong><see cref = "T:SharpDX.MediaFoundation.MediaSource"/></strong> resources until <strong>Shutdown</strong> is called.?<p>The <em>pAttributes</em> parameter specifies an attribute store. To create the attribute store, call the <strong>MFCreateAttributes</strong> function.  You must set the <see cref = "!:SourceType"/> attribute, which specifies the type of device (audio or video).</p><p>For audio capture devices, optionally set one of the following attributes:</p><p></p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <p><see cref = "!:SourceTypeAudcapEndpointId"/> </p> </td><td> <p>Specifies the audio endpoint ID of the audio capture device.</p> </td></tr> <tr><td> <p><see cref = "!:SourceTypeAudcapRole"/> </p> </td><td> <p>Specifies the device role. If this attribute is set, the function uses the default audio capture device for that device role.</p> <p>Do not combine this attribute with the <see cref = "!:SourceTypeAudcapEndpointId"/> attribute.</p> </td></tr> </table><p>?</p><p>If neither attribute is specified, the function selects the default audio capture device for the <strong>eCommunications</strong> role.</p><p>For video capture devices, you must set the following attribute:</p><p></p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <p><see cref = "!:SourceTypeVidcapSymbolicLink"/> </p> </td><td> <p>Specifies the symbolic link to the device.</p> </td></tr> </table><p>?</p>
            </remarks>
            <doc-id>dd388091</doc-id>
            <unmanaged>HRESULT MFCreateDeviceSource([In] IMFAttributes* pAttributes,[Out] IMFMediaSource** ppSource)</unmanaged>
            <unmanaged-short>MFCreateDeviceSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateDeviceSourceActivate(SharpDX.MediaFoundation.MediaAttributes,SharpDX.MediaFoundation.Activate@)">
            <summary>
            <p>Creates an activation object that represents a hardware capture device.</p>
            </summary>
            <param name = "attributesRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of an attribute store, which is used to select the device. See Remarks.</p> </dd></param>
            <param name = "activateOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns>No documentation.</returns>
            <remarks>
            <p>This function creates an activation object that can be used to create a media source for a hardware device. To create the media source itself, call <strong>IMFActivate::ActivateObject</strong>.</p><p>The <em>pAttributes</em> parameter specifies an attribute store. To create the attribute store, call the <strong>MFCreateAttributes</strong> function.  You must set the <see cref = "!:SourceType"/> attribute, which specifies the type of device (audio or video).</p><p>For audio capture devices, optionally set one of the following attributes:</p><p></p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <p><see cref = "!:SourceTypeAudcapEndpointId"/> </p> </td><td> <p>Specifies the audio endpoint ID of the audio capture device.</p> </td></tr> <tr><td> <p><see cref = "!:SourceTypeAudcapRole"/> </p> </td><td> <p>Specifies the device role. If this attribute is set, the function uses the default audio capture device for that device role.</p> <p>Do not combine this attribute with the <see cref = "!:SourceTypeAudcapEndpointId"/> attribute.</p> </td></tr> </table><p>?</p><p>If neither attribute is specified, the function selects the default audio capture device for the <strong>eCommunications</strong> role.</p><p>For video capture devices, you must set the following attribute:</p><p></p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <p><see cref = "!:SourceTypeVidcapSymbolicLink"/> </p> </td><td> <p>Specifies the symbolic link to the device.</p> </td></tr> </table><p>?</p>
            </remarks>
            <doc-id>dd388093</doc-id>
            <unmanaged>HRESULT MFCreateDeviceSourceActivate([In] IMFAttributes* pAttributes,[Out] IMFActivate** ppActivate)</unmanaged>
            <unmanaged-short>MFCreateDeviceSourceActivate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateProtectedEnvironmentAccess(SharpDX.MediaFoundation.ProtectedEnvironmentAccess@)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.MediaFoundation.ProtectedEnvironmentAccess"/></strong> object that allows content protection systems to perform a handshake with the protected environment.</p>
            </summary>
            <param name = "accessOut">No documentation.</param>
            <returns>No documentation.</returns>
            <doc-id>hh162758</doc-id>
            <unmanaged>HRESULT MFCreateProtectedEnvironmentAccess([Out] IMFProtectedEnvironmentAccess** ppAccess)</unmanaged>
            <unmanaged-short>MFCreateProtectedEnvironmentAccess</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.LoadSignedLibrary(System.String,SharpDX.MediaFoundation.SignedLibrary@)">
            <summary>
            <p>Loads a dynamic link library that is signed for the protected environment.</p>
            </summary>
            <param name = "szNameRef"><dd> <p>The name of the dynamic link library to load.  This dynamic link library must be signed for the protected environment.</p> </dd></param>
            <param name = "libOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.SignedLibrary"/></strong> interface for the library.</p> </dd></param>
            <returns>No documentation.</returns>
            <remarks>
            <p>A singlemodule load count is maintained on the dynamic link library (as it is with <strong>LoadLibrary</strong>).  This load count  is freed when the final release is called on the <strong><see cref = "T:SharpDX.MediaFoundation.SignedLibrary"/></strong> object.</p>
            </remarks>
            <doc-id>hh162769</doc-id>
            <unmanaged>HRESULT MFLoadSignedLibrary([In] const wchar_t* pszName,[Out] IMFSignedLibrary** ppLib)</unmanaged>
            <unmanaged-short>MFLoadSignedLibrary</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.GetSystemId(SharpDX.MediaFoundation.SystemId@)">
            <summary>
            <p>Returns an <strong><see cref = "T:SharpDX.MediaFoundation.SystemId"/></strong> object for retrieving system id data.</p>
            </summary>
            <param name = "idOut">No documentation.</param>
            <returns>No documentation.</returns>
            <doc-id>hh162767</doc-id>
            <unmanaged>HRESULT MFGetSystemId([Out] IMFSystemId** ppId)</unmanaged>
            <unmanaged-short>MFGetSystemId</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.GetLocalId(System.Byte[],System.Int32,System.IntPtr)">
            <summary>
            <p>Gets the local system ID.</p>
            </summary>
            <param name = "verifier"><dd> <p>Application-specific verifier value.</p> </dd></param>
            <param name = "size"><dd> <p>Length in bytes of verifier.</p> </dd></param>
            <param name = "id"><dd> <p>Returned ID string.  This value must be freed by the caller by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p></returns>
            <doc-id>jj128335</doc-id>
            <unmanaged>HRESULT MFGetLocalId([In, Buffer] const unsigned char* verifier,[In] unsigned int size,[Out] wchar_t** id)</unmanaged>
            <unmanaged-short>MFGetLocalId</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateContentProtectionDevice(System.Guid,SharpDX.MediaFoundation.ContentProtectionDevice@)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.MediaFoundation.ContentProtectionDevice"/></strong> interface for the specified media protection system.</p>
            </summary>
            <param name = "protectionSystemId">No documentation.</param>
            <param name = "contentProtectionDevice">No documentation.</param>
            <returns>No documentation.</returns>
            <doc-id>mt219225</doc-id>
            <unmanaged>HRESULT MFCreateContentProtectionDevice([In] const GUID&amp; ProtectionSystemId,[Out] IMFContentProtectionDevice** ContentProtectionDevice)</unmanaged>
            <unmanaged-short>MFCreateContentProtectionDevice</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.IsContentProtectionDeviceSupported(System.Guid,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Checks whether a hardware security processor is supported for the specified media protection system.</p>
            </summary>
            <param name = "protectionSystemId"><dd> <p>The identifier of the protection system that you want to check.</p> </dd></param>
            <param name = "isSupported"><dd> <p><strong>TRUE</strong> if the hardware security processor is supported for the specified protection system; otherwise <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></param>
            <returns>No documentation.</returns>
            <doc-id>mt219226</doc-id>
            <unmanaged>HRESULT MFIsContentProtectionDeviceSupported([In] const GUID&amp; ProtectionSystemId,[Out] BOOL* isSupported)</unmanaged>
            <unmanaged-short>MFIsContentProtectionDeviceSupported</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateContentDecryptorContext(System.Guid,SharpDX.MediaFoundation.DXGIDeviceManager,SharpDX.MediaFoundation.ContentProtectionDevice,SharpDX.MediaFoundation.ContentDecryptorContext@)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.MediaFoundation.ContentDecryptorContext"/></strong> interface for the specified media protection system.  </p>
            </summary>
            <param name = "guidMediaProtectionSystemId">No documentation.</param>
            <param name = "d3DManagerRef">No documentation.</param>
            <param name = "contentProtectionDeviceRef">No documentation.</param>
            <param name = "contentDecryptorContextOut">No documentation.</param>
            <returns>No documentation.</returns>
            <doc-id>mt219224</doc-id>
            <unmanaged>HRESULT MFCreateContentDecryptorContext([In] const GUID&amp; guidMediaProtectionSystemId,[In, Optional] IMFDXGIDeviceManager* pD3DManager,[In] IMFContentProtectionDevice* pContentProtectionDevice,[Out] IMFContentDecryptorContext** ppContentDecryptorContext)</unmanaged>
            <unmanaged-short>MFCreateContentDecryptorContext</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateSensorGroup(System.String,SharpDX.MediaFoundation.SensorGroup@)">
            <summary>
            <p>Locks the shared Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager.</p>
            </summary>
            <param name = "sensorGroupSymbolicLink"><dd> <p>Receives a token that identifies this instance of the DXGI Device Manager. Use this token when calling <strong>IMFDXGIDeviceManager::ResetDevice</strong>. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "sensorGroupOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function obtains a reference to a  DXGI Device Manager instance that can be shared between components. The Microsoft Media Foundation platform creates this instance of the  DXGI Device Manager as a singleton object. Alternatively, you can create a new DXGI Device Manager by calling <strong>MFCreateDXGIDeviceManager</strong>.</p><p>The first time this function is called, the Media Foundation platform creates the shared DXGI Device Manager. </p><p>When you are done use the <strong><see cref = "T:SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> reference, call the <strong>MFUnlockDXGIDeviceManager</strong>.</p>
            </remarks>
            <doc-id>hh162770</doc-id>
            <unmanaged>HRESULT MFCreateSensorGroup([In] const wchar_t* SensorGroupSymbolicLink,[Out] IMFSensorGroup** ppSensorGroup)</unmanaged>
            <unmanaged-short>MFCreateSensorGroup</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateSensorStream(System.Int32,SharpDX.MediaFoundation.MediaAttributes,SharpDX.MediaFoundation.Collection,SharpDX.MediaFoundation.SensorStream@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Creates an instance of the <strong><see cref = "T:SharpDX.MediaFoundation.SensorStream"/></strong> interface.</p>
            </summary>
            <param name = "streamId">No documentation.</param>
            <param name = "attributesRef">No documentation.</param>
            <param name = "mediaTypeCollectionRef">No documentation.</param>
            <param name = "streamOut">No documentation.</param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>The supplied <strong><see cref = "T:SharpDX.MediaFoundation.SensorGroup"/></strong> is null.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The supplied <strong>LPCWSTR</strong> is null.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>mt797980</doc-id>
            <unmanaged>HRESULT MFCreateSensorStream([In] DWORD StreamId,[In, Optional] IMFAttributes* pAttributes,[In] IMFCollection* pMediaTypeCollection,[Out] IMFSensorStream** ppStream)</unmanaged>
            <unmanaged-short>MFCreateSensorStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateSensorActivityMonitor(SharpDX.MediaFoundation.SensorActivitiesReportCallback,SharpDX.MediaFoundation.SensorActivityMonitor@)">
            <summary>
            <p>Initializes a new instance of the <strong><see cref = "T:SharpDX.MediaFoundation.SensorActivityMonitor"/></strong> interface.</p>
            </summary>
            <param name = "callbackRef">No documentation.</param>
            <param name = "activityMonitorOut">No documentation.</param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>The <em>ppActivityMonitor</em> parameter is null.</p> </td></tr> </table><p> </p></returns>
            <doc-id>mt493237</doc-id>
            <unmanaged>HRESULT MFCreateSensorActivityMonitor([In] IMFSensorActivitiesReportCallback* pCallback,[Out] IMFSensorActivityMonitor** ppActivityMonitor)</unmanaged>
            <unmanaged-short>MFCreateSensorActivityMonitor</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateSourceReaderFromURL(System.String,SharpDX.MediaFoundation.MediaAttributes,SharpDX.MediaFoundation.SourceReader)">
            <summary>
            <p>Creates the source reader from a URL.</p>
            </summary>
            <param name = "wszURLRef"><dd> <p>The URL  of a media file to open.</p> </dd></param>
            <param name = "attributesRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this parameter to configure the source reader. For more information, see Source Reader Attributes. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "sourceReaderOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.SourceReader"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Call <strong>CoInitialize(Ex)</strong> and <strong>MFStartup</strong> before calling this function.</p><p> Internally, the source reader calls the <strong>IMFSourceResolver::CreateObjectFromURL</strong> method to create a media source from the URL. </p><p>This function is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd388110</doc-id>
            <unmanaged>HRESULT MFCreateSourceReaderFromURL([In] const wchar_t* pwszURL,[In, Optional] IMFAttributes* pAttributes,[Out, Fast] IMFSourceReader** ppSourceReader)</unmanaged>
            <unmanaged-short>MFCreateSourceReaderFromURL</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateSourceReaderFromByteStream(SharpDX.MediaFoundation.IByteStream,SharpDX.MediaFoundation.MediaAttributes,SharpDX.MediaFoundation.SourceReader)">
            <summary>
            <p>Creates the source reader from a byte stream.</p>
            </summary>
            <param name = "byteStreamRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream. This byte stream will provide the source data for the source reader.</p> </dd></param>
            <param name = "attributesRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this parameter to configure the source reader. For more information, see Source Reader Attributes. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "sourceReaderOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.SourceReader"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Call <strong>CoInitialize(Ex)</strong> and <strong>MFStartup</strong> before calling this function.</p><p> Internally, the source reader calls the <strong>IMFSourceResolver::CreateObjectFromByteStream</strong> method to create a media source from the byte stream. Therefore, a byte-stream handler must be registered for the byte stream. For more information about byte-stream handlers, see Scheme Handlers and Byte-Stream Handlers. </p><p>This function is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd388106</doc-id>
            <unmanaged>HRESULT MFCreateSourceReaderFromByteStream([In] IMFByteStream* pByteStream,[In, Optional] IMFAttributes* pAttributes,[Out, Fast] IMFSourceReader** ppSourceReader)</unmanaged>
            <unmanaged-short>MFCreateSourceReaderFromByteStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateSourceReaderFromMediaSource(SharpDX.MediaFoundation.MediaSource,SharpDX.MediaFoundation.MediaAttributes,SharpDX.MediaFoundation.SourceReader)">
            <summary>
            <p>Creates the source reader from a media source.</p>
            </summary>
            <param name = "mediaSourceRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSource"/></strong> interface of a media source.</p> </dd></param>
            <param name = "attributesRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this parameter to configure the source reader. For more information, see Source Reader Attributes. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "sourceReaderOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.SourceReader"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:DrmUnsupported"/></strong></strong></dt> </dl> </td><td> <p>The source contains protected content.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call <strong>CoInitialize(Ex)</strong> and <strong>MFStartup</strong> before calling this function.</p><p>By default, when the application releases the source reader, the source reader shuts down the media source by calling <strong>IMFMediaSource::Shutdown</strong> on the media source. At that point, the application can no longer use the media source.</p><p>To change this default behavior, set the <see cref = "!:DisconnectMediasourceOnShutdown"/> attribute in the <em>pAttributes</em> parameter. If this attribute is <strong>TRUE</strong>, the application is responsible for  shutting down the media source.</p><p>When using the Source Reader, do not call any of the following methods on the media source:</p><ul> <li> <strong>IMFMediaSource::Pause</strong> </li> <li> <strong>IMFMediaSource::Start</strong> </li> <li> <strong>IMFMediaSource::Stop</strong> </li> <li>All <strong><see cref = "T:SharpDX.MediaFoundation.MediaEventGenerator"/></strong> methods</li> </ul><p>This function is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd388108</doc-id>
            <unmanaged>HRESULT MFCreateSourceReaderFromMediaSource([In] IMFMediaSource* pMediaSource,[In, Optional] IMFAttributes* pAttributes,[Out, Fast] IMFSourceReader** ppSourceReader)</unmanaged>
            <unmanaged-short>MFCreateSourceReaderFromMediaSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateSinkWriterFromURL(System.String,SharpDX.MediaFoundation.IByteStream,SharpDX.MediaFoundation.MediaAttributes)">
            <summary>
            <p>Creates the sink writer from a URL or byte stream.</p>
            </summary>
            <param name = "wszOutputURLRef"><dd> <p>A null-terminated string that contains the URL of the output file. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "byteStreamRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream. This parameter can be <strong><c>null</c></strong>.</p> <p>If this parameter is a valid reference, the sink writer writes to the provided byte stream. (The byte stream must be writable.) Otherwise, if <em>pByteStream</em> is <strong><c>null</c></strong>, the sink writer creates a new file named <em>pwszOutputURL</em>.</p> </dd></param>
            <param name = "attributesRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this parameter to configure the sink writer. For more information, see Sink Writer Attributes. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
            <returns><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.SinkWriter"/></strong> interface. The caller must release the interface.</p> </dd></returns>
            <remarks>
            <p>Call <strong>CoInitialize(Ex)</strong> and <strong>MFStartup</strong> before calling this function.</p><p>The first three parameters to this function can be <strong><c>null</c></strong>; however, only certain combinations are valid:</p><p> </p><table> <tr><th>Description</th><th><em>pwszOutputURL</em></th><th><em>pByteStream</em></th><th><em>pAttributes</em></th></tr> <tr><td>Specify a byte stream, with no URL.</td><td><strong><c>null</c></strong></td><td>non-<strong><c>null</c></strong></td><td>Required (must not be <strong><c>null</c></strong>).</td></tr> <tr><td>Specify a URL, with no byte stream.</td><td>not <strong><c>null</c></strong></td><td><strong><c>null</c></strong></td><td>Optional (may be <strong><c>null</c></strong>).</td></tr> <tr><td>Specify both a URL and a byte stream.</td><td>non-<strong><c>null</c></strong></td><td>non-<strong><c>null</c></strong></td><td>Optional (may be <strong><c>null</c></strong>).</td></tr> </table><p>?</p><p>The <em>pAttributes</em> parameter is required in the first case and optional in the others.</p><ul> <li>Case 1: Specify a byte stream without a URL. The <em>pAttributes</em> parameter must point to an attribute store that contains the <see cref = "!:TranscodeContainertype"/> attribute. The sink writer uses the  <see cref = "!:TranscodeContainertype"/> attribute to determine the type of file container to write, such as ASF or MP4.</li> <li>Case 2: Specify a URL without a byte stream. The sink writer creates a new file named <em>pwszOutputURL</em>. If <em>pAttributes</em> specifies an attribute store with the <see cref = "!:TranscodeContainertype"/> attribute, the sink writer uses that attribute to determine the type of file container. Otherwise, if the <see cref = "!:TranscodeContainertype"/> attribute is absent or <em>pAttributes</em> is <strong><c>null</c></strong>, the sink writer uses the file name extension to select the container type; for example, ".asf" for an ASF file.</li> <li>Case 3: Specify both a URL and a byte stream. The sink writer writes to the byte stream. The URL provided in <em>pwszOutputURL</em> is informational only; the sink writer does not create a new file. If <em>pAttributes</em> specifies an attribute store with the <see cref = "!:TranscodeContainertype"/> attribute, the sink writer uses that attribute to determine the type of file container. Otherwise, the sink writer uses the file name extension to select the container type. The <see cref = "!:TranscodeContainertype"/> attribute overrides the URL file name extension in this case.</li> </ul><p>This function is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd388105</doc-id>
            <unmanaged>HRESULT MFCreateSinkWriterFromURL([In, Optional] const wchar_t* pwszOutputURL,[In, Optional] IMFByteStream* pByteStream,[In, Optional] IMFAttributes* pAttributes,[Out] IMFSinkWriter** ppSinkWriter)</unmanaged>
            <unmanaged-short>MFCreateSinkWriterFromURL</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateSinkWriterFromMediaSink(SharpDX.MediaFoundation.MediaSink,SharpDX.MediaFoundation.MediaAttributes,SharpDX.MediaFoundation.SinkWriter@)">
            <summary>
            <p>Creates the sink writer from a media sink.</p>
            </summary>
            <param name = "mediaSinkRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSink"/></strong> interface of a media sink. </p> </dd></param>
            <param name = "attributesRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this parameter to configure the sink writer. For more information, see Sink Writer Attributes. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
            <param name = "sinkWriterOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.SinkWriter"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Call <strong>CoInitialize(Ex)</strong> and <strong>MFStartup</strong> before calling this function.</p><p>When you are done using the media sink, call the media sink's <strong>IMFMediaSink::Shutdown</strong> method. (The sink writer does not shut down the media sink.) Release the sink writer before calling <strong>Shutdown</strong> on the media sink.</p><p>This function is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd388103</doc-id>
            <unmanaged>HRESULT MFCreateSinkWriterFromMediaSink([In] IMFMediaSink* pMediaSink,[In, Optional] IMFAttributes* pAttributes,[Out] IMFSinkWriter** ppSinkWriter)</unmanaged>
            <unmanaged-short>MFCreateSinkWriterFromMediaSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.SerializeAttributesToStream(SharpDX.MediaFoundation.MediaAttributes,System.Int32,SharpDX.Win32.IStream)">
            <summary>
            <p> </p><p>Writes the contents of an attribute store to a stream.</p>
            </summary>
            <param name = "attrRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of the attribute store.</p> </dd></param>
            <param name = "dwOptions"><dd> <p>Bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.AttributeSerializeOptions"/></strong> enumeration.</p> </dd></param>
            <param name = "stmRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.Win32.IStream"/></strong> interface of the stream where the attributes are saved.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If <em>dwOptions</em> contains the MF_ATTRIBUTE_SERIALIZE_UNKNOWN_BYREF flag, the function serializes <strong><see cref = "T:SharpDX.IUnknown"/></strong> references in the attribute store, as follows:</p><ul> <li> <p>If the <strong><see cref = "T:SharpDX.Win32.IStream"/></strong> reference exposes the <strong><see cref = "T:SharpDX.MediaFoundation.ObjectReferenceStream"/></strong> interface (through <strong>QueryInterface</strong>), the function calls <strong>IMFObjectReferenceStream::SaveReference</strong> to serialize each reference.</p> </li> <li> <p>Otherwise, the function calls <strong>CoMarshalInterface</strong> to serialize a proxy for the object.</p> </li> </ul><p>If <em>dwOptions</em> does not include the MF_ATTRIBUTE_SERIALIZE_UNKNOWN_BYREF flag, the function skips <strong><see cref = "T:SharpDX.IUnknown"/></strong> references in the attribute store.</p><p>To load the attributes from the stream, call <strong>MFDeserializeAttributesFromStream</strong>.</p><p>The main purpose of this function is to marshal attributes across process boundaries.</p>
            </remarks>
            <doc-id>ms702278</doc-id>
            <unmanaged>HRESULT MFSerializeAttributesToStream([In] IMFAttributes* pAttr,[In] DWORD dwOptions,[In] IStream* pStm)</unmanaged>
            <unmanaged-short>MFSerializeAttributesToStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.DeserializeAttributesFromStream(SharpDX.MediaFoundation.MediaAttributes,System.Int32,SharpDX.Win32.IStream)">
            <summary>
            <p> </p><p>Loads attributes from a stream into an attribute store.</p>
            </summary>
            <param name = "attrRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of the attribute store.</p> </dd></param>
            <param name = "dwOptions"><dd> <p>Bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.AttributeSerializeOptions"/></strong> enumeration.</p> </dd></param>
            <param name = "stmRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.Win32.IStream"/></strong> interface of the stream from which to read the attributes.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Use this function to deserialize an attribute store that was serialized with the <strong>MFSerializeAttributesToStream</strong> function.</p><p>If <em>dwOptions</em> contains the MF_ATTRIBUTE_SERIALIZE_UNKNOWN_BYREF flag, the function deserializes <strong><see cref = "T:SharpDX.IUnknown"/></strong> references from the stream, as follows:</p><ul> <li> <p>If the <strong><see cref = "T:SharpDX.Win32.IStream"/></strong> reference exposes the <strong><see cref = "T:SharpDX.MediaFoundation.ObjectReferenceStream"/></strong> interface (through <strong>QueryInterface</strong>), the function calls <strong>IMFObjectReferenceStream::LoadReference</strong> to deserialize each reference.</p> </li> <li> <p>Otherwise, the function calls <strong>CoUnmarshalInterface</strong> to deserialize a proxy for the object.</p> </li> </ul><p>This function deletes any attributes that were previously stored in <em>pAttr</em>.</p>
            </remarks>
            <doc-id>ms703162</doc-id>
            <unmanaged>HRESULT MFDeserializeAttributesFromStream([In] IMFAttributes* pAttr,[In] DWORD dwOptions,[In] IStream* pStm)</unmanaged>
            <unmanaged-short>MFDeserializeAttributesFromStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaFactory.CreateTransformActivate(SharpDX.MediaFoundation.Activate@)">
            <summary>
            <p>Creates a generic activation object for Media Foundation transforms (MFTs).</p>
            </summary>
            <param name = "activateOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Most applications will not use this function; it is used internally by the <strong>MFTEnumEx</strong> function. </p><p>An <em>activation object</em> is a helper object that creates another object, somewhat similar to a class factory. The <strong>MFCreateTransformActivate</strong> function creates an activation object for MFTs. Before this activation object can create an MFT, the caller must initialize the activation object by setting one or more attributes on it.</p><table> <tr><th>Attribute</th><th>Description</th></tr> <tr><td> <see cref = "!:MftTransformClsidAttribute"/> </td><td>Required. Contains the CLSID of the MFT. The activation object creates the MFT by passing this CLSID to the <strong>CoCreateInstance</strong> function.</td></tr> <tr><td> <see cref = "!:TransformCategoryAttribute"/> </td><td>Optional. Specifies the category of the MFT.</td></tr> <tr><td> <see cref = "!:TransformFlagsAttribute"/> </td><td>Contains various flags that describe the MFT. For hardware-based MFTs, set the <strong>MFT_ENUM_FLAG_HARDWARE</strong> flag. Otherwise, this attribute is optional.</td></tr> <tr><td> <see cref = "!:MftCodecMeritAttribute"/> </td><td> <p>Optional. Contains the merit value of a hardware codec.</p> <p>If this attribute is set and its value is greater than zero, the activation object calls <strong>MFGetMFTMerit</strong> to get the trusted merit value for the MFT. If the trusted merit is less than the value of this attribute, the activation object's <strong>IMFActivate::ActivateObject</strong> method fails and returns <strong><see cref = "!:InvalidCodecMerit"/></strong>.</p> </td></tr> <tr><td> <see cref = "!:MftEnumHardwareUrlAttribute"/> </td><td>Required for hardware-based MFTs. Specifies the symbolic link for the hardware device. The device proxy uses this value to configure the MFT.</td></tr> <tr><td> <see cref = "!:MftFieldofuseUnlockAttribute"/> </td><td> <p>Optional. Contains an <strong><see cref = "T:SharpDX.MediaFoundation.FieldOfUseMFTUnlock"/></strong> reference, which can be used to unlock the MFT. The <strong><see cref = "T:SharpDX.MediaFoundation.FieldOfUseMFTUnlock"/></strong> interface is used with MFTs that have usage restrictions.</p> <p>If this attribute is set and the <see cref = "!:TransformFlagsAttribute"/> attribute contains the <strong>MFT_ENUM_FLAG_FIELDOFUSE</strong> flag, the activation object calls <strong>IMFFieldOfUseMFTUnlock::Unlock</strong> when it creates the MFT. An application can also set the <see cref = "!:MftFieldofuseUnlockAttribute"/> attribute without setting the <strong>MFT_ENUM_FLAG_FIELDOFUSE</strong> flag. In that case, the application must call <strong>Unlock</strong>.</p> </td></tr> <tr><td> <see cref = "!:MftPreferredEncoderProfile"/> </td><td> <p>Optional. Contains the encoding profile for an encoder. The value of this attribute is an <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> reference.</p> <p>If this attribute is set and the value of the <see cref = "!:TransformCategoryAttribute"/> attribute is <strong><see cref = "!:AudioEncoder"/></strong> or <strong><see cref = "!:VideoEncoder"/></strong>, the activation object uses the encoding profile to configure the MFT. The MFT must expose either <strong>ICodecAPI</strong> or <strong><see cref = "T:SharpDX.ComObject"/></strong> for this purpose.</p> </td></tr> <tr><td> <see cref = "!:MftPreferredOutputtypeAttribute"/> </td><td> <p>Optional. Specifies the preferred output format for an encoder.</p> <p>If this attribute set and the value of the <see cref = "!:TransformCategoryAttribute"/> attribute is <strong><see cref = "!:AudioEncoder"/></strong> or <strong><see cref = "!:VideoEncoder"/></strong>, the activation object sets this media type on the MFT.</p> </td></tr> </table><p>?</p><p>For more information about activation objects, see Activation Objects.  </p>
            </remarks>
            <doc-id>dd388120</doc-id>
            <unmanaged>HRESULT MFCreateTransformActivate([Out] IMFActivate** ppActivate)</unmanaged>
            <unmanaged-short>MFCreateTransformActivate</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaServiceKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaServiceKeys.MetadataProvider">
            <summary>Constant MetadataProvider</summary>
            <unmanaged>MF_METADATA_PROVIDER_SERVICE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaServiceKeys.PMPServer">
            <summary>Constant PMPServer</summary>
            <unmanaged>MF_PMP_SERVER_CONTEXT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaServiceKeys.Qualiy">
            <summary>Constant Qualiy</summary>
            <unmanaged>MF_QUALITY_SERVICES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaServiceKeys.RateControl">
            <summary>Constant RateControl</summary>
            <unmanaged>MF_RATE_CONTROL_SERVICE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaServiceKeys.RemoteProxy">
            <summary>Constant RemoteProxy</summary>
            <unmanaged>MF_REMOTE_PROXY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaServiceKeys.Sami">
            <summary>Constant Sami</summary>
            <unmanaged>MF_SAMI_SERVICE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaServiceKeys.SourcePresentationProvider">
            <summary>Constant SourcePresentationProvider</summary>
            <unmanaged>MF_SOURCE_PRESENTATION_PROVIDER_SERVICE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaServiceKeys.TimeCode">
            <summary>Constant TimeCode</summary>
            <unmanaged>MF_TIMECODE_SERVICE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaServiceKeys.ToplogyNodeAttributeEditor">
            <summary>Constant ToplogyNodeAttributeEditor</summary>
            <unmanaged>MF_TOPONODE_ATTRIBUTE_EDITOR_SERVICE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaServiceKeys.WrappedObject">
            <summary>Constant WrappedObject</summary>
            <unmanaged>MF_WRAPPED_OBJECT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaServiceKeys.WorkQueue">
            <summary>Constant WorkQueue</summary>
            <unmanaged>MF_WORKQUEUE_SERVICES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaServiceKeys.SaveJob">
            <summary>Constant SaveJob</summary>
            <unmanaged>MFNET_SAVEJOB_SERVICE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaServiceKeys.NetworkSourceStatistics">
            <summary>Constant NetworkSourceStatistics</summary>
            <unmanaged>MFNETSOURCE_STATISTICS_SERVICE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaServiceKeys.AudioPolicy">
            <summary>Constant AudioPolicy</summary>
            <unmanaged>MR_AUDIO_POLICY_SERVICE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaServiceKeys.Buffer">
            <summary>Constant Buffer</summary>
            <unmanaged>MR_BUFFER_SERVICE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaServiceKeys.CapturePolicyVolume">
            <summary>Constant CapturePolicyVolume</summary>
            <unmanaged>MR_CAPTURE_POLICY_VOLUME_SERVICE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaServiceKeys.PolicyVolume">
            <summary>Constant PolicyVolume</summary>
            <unmanaged>MR_POLICY_VOLUME_SERVICE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaServiceKeys.StreamVolume">
            <summary>Constant StreamVolume</summary>
            <unmanaged>MR_STREAM_VOLUME_SERVICE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaServiceKeys.VideoAcceleration">
            <summary>Constant VideoAcceleration</summary>
            <unmanaged>MR_VIDEO_ACCELERATION_SERVICE</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaSessionAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaSessionAttributeKeys.ApproxEventOccurrenceTime">
            <summary>Constant ApproxEventOccurrenceTime</summary>
            <unmanaged>MF_SESSION_APPROX_EVENT_OCCURRENCE_TIME</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaSessionAttributeKeys.ContentProtectionManager">
            <summary>Constant ContentProtectionManager</summary>
            <unmanaged>MF_SESSION_CONTENT_PROTECTION_MANAGER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaSessionAttributeKeys.GlobalTime">
            <summary>Constant GlobalTime</summary>
            <unmanaged>MF_SESSION_GLOBAL_TIME</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaSessionAttributeKeys.QualityManager">
            <summary>Constant QualityManager</summary>
            <unmanaged>MF_SESSION_QUALITY_MANAGER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaSessionAttributeKeys.RemoteSourceMode">
            <summary>Constant RemoteSourceMode</summary>
            <unmanaged>MF_SESSION_REMOTE_SOURCE_MODE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaSessionAttributeKeys.ServerContext">
            <summary>Constant ServerContext</summary>
            <unmanaged>MF_SESSION_SERVER_CONTEXT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaSessionAttributeKeys.Topoloader">
            <summary>Constant Topoloader</summary>
            <unmanaged>MF_SESSION_TOPOLOADER</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaTypeAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AacAudioProfileLevelIndication">
            <summary>Constant AacAudioProfileLevelIndication</summary>
            <unmanaged>MF_MT_AAC_AUDIO_PROFILE_LEVEL_INDICATION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AacPayloadType">
            <summary>Constant AacPayloadType</summary>
            <unmanaged>MF_MT_AAC_PAYLOAD_TYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AllSamplesIndependent">
            <summary>Constant AllSamplesIndependent</summary>
            <unmanaged>MF_MT_ALL_SAMPLES_INDEPENDENT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AmFormatType">
            <summary>Constant AmFormatType</summary>
            <unmanaged>MF_MT_AM_FORMAT_TYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.ArbitraryFormat">
            <summary>Constant ArbitraryFormat</summary>
            <unmanaged>MF_MT_ARBITRARY_FORMAT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.ArbitraryHeader">
            <summary>Constant ArbitraryHeader</summary>
            <unmanaged>MF_MT_ARBITRARY_HEADER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AudioAvgBytesPerSecond">
            <summary>Constant AudioAvgBytesPerSecond</summary>
            <unmanaged>MF_MT_AUDIO_AVG_BYTES_PER_SECOND</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AudioBitsPerSample">
            <summary>Constant AudioBitsPerSample</summary>
            <unmanaged>MF_MT_AUDIO_BITS_PER_SAMPLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AudioBlockAlignment">
            <summary>Constant AudioBlockAlignment</summary>
            <unmanaged>MF_MT_AUDIO_BLOCK_ALIGNMENT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AudioChannelMask">
            <summary>Constant AudioChannelMask</summary>
            <unmanaged>MF_MT_AUDIO_CHANNEL_MASK</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AudioFloatSamplesPerSecond">
            <summary>Constant AudioFloatSamplesPerSecond</summary>
            <unmanaged>MF_MT_AUDIO_FLOAT_SAMPLES_PER_SECOND</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AudioFolddownMatrix">
            <summary>Constant AudioFolddownMatrix</summary>
            <unmanaged>MF_MT_AUDIO_FOLDDOWN_MATRIX</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AudioNumChannels">
            <summary>Constant AudioNumChannels</summary>
            <unmanaged>MF_MT_AUDIO_NUM_CHANNELS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AudioPreferWaveformatex">
            <summary>Constant AudioPreferWaveformatex</summary>
            <unmanaged>MF_MT_AUDIO_PREFER_WAVEFORMATEX</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AudioSamplesPerBlock">
            <summary>Constant AudioSamplesPerBlock</summary>
            <unmanaged>MF_MT_AUDIO_SAMPLES_PER_BLOCK</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AudioSamplesPerSecond">
            <summary>Constant AudioSamplesPerSecond</summary>
            <unmanaged>MF_MT_AUDIO_SAMPLES_PER_SECOND</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AudioValidBitsPerSample">
            <summary>Constant AudioValidBitsPerSample</summary>
            <unmanaged>MF_MT_AUDIO_VALID_BITS_PER_SAMPLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AudioWmadrcAvgref">
            <summary>Constant AudioWmadrcAvgref</summary>
            <unmanaged>MF_MT_AUDIO_WMADRC_AVGREF</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AudioWmadrcAvgtarget">
            <summary>Constant AudioWmadrcAvgtarget</summary>
            <unmanaged>MF_MT_AUDIO_WMADRC_AVGTARGET</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AudioWmadrcPeakref">
            <summary>Constant AudioWmadrcPeakref</summary>
            <unmanaged>MF_MT_AUDIO_WMADRC_PEAKREF</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AudioWmadrcPeaktarget">
            <summary>Constant AudioWmadrcPeaktarget</summary>
            <unmanaged>MF_MT_AUDIO_WMADRC_PEAKTARGET</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AvgBitErrorRate">
            <summary>Constant AvgBitErrorRate</summary>
            <unmanaged>MF_MT_AVG_BIT_ERROR_RATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.AvgBitrate">
            <summary>Constant AvgBitrate</summary>
            <unmanaged>MF_MT_AVG_BITRATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.Compressed">
            <summary>Constant Compressed</summary>
            <unmanaged>MF_MT_COMPRESSED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.CustomVideoPrimaries">
            <summary>Constant CustomVideoPrimaries</summary>
            <unmanaged>MF_MT_CUSTOM_VIDEO_PRIMARIES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.DefaultStride">
            <summary>Constant DefaultStride</summary>
            <unmanaged>MF_MT_DEFAULT_STRIDE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.DrmFlags">
            <summary>Constant DrmFlags</summary>
            <unmanaged>MF_MT_DRM_FLAGS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.DvAauxCtrlPack0">
            <summary>Constant DvAauxCtrlPack0</summary>
            <unmanaged>MF_MT_DV_AAUX_CTRL_PACK_0</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.DvAauxCtrlPack1">
            <summary>Constant DvAauxCtrlPack1</summary>
            <unmanaged>MF_MT_DV_AAUX_CTRL_PACK_1</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.DvAauxSrcPack0">
            <summary>Constant DvAauxSrcPack0</summary>
            <unmanaged>MF_MT_DV_AAUX_SRC_PACK_0</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.DvAauxSrcPack1">
            <summary>Constant DvAauxSrcPack1</summary>
            <unmanaged>MF_MT_DV_AAUX_SRC_PACK_1</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.DvVauxCtrlPack">
            <summary>Constant DvVauxCtrlPack</summary>
            <unmanaged>MF_MT_DV_VAUX_CTRL_PACK</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.DvVauxSrcPack">
            <summary>Constant DvVauxSrcPack</summary>
            <unmanaged>MF_MT_DV_VAUX_SRC_PACK</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.FixedSizeSamples">
            <summary>Constant FixedSizeSamples</summary>
            <unmanaged>MF_MT_FIXED_SIZE_SAMPLES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.FrameRate">
            <summary>Constant FrameRate</summary>
            <unmanaged>MF_MT_FRAME_RATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.FrameRateRangeMax">
            <summary>Constant FrameRateRangeMax</summary>
            <unmanaged>MF_MT_FRAME_RATE_RANGE_MAX</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.FrameRateRangeMin">
            <summary>Constant FrameRateRangeMin</summary>
            <unmanaged>MF_MT_FRAME_RATE_RANGE_MIN</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.FrameSize">
            <summary>Constant FrameSize</summary>
            <unmanaged>MF_MT_FRAME_SIZE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.GeometricAperture">
            <summary>Constant GeometricAperture</summary>
            <unmanaged>MF_MT_GEOMETRIC_APERTURE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.H264Capabilities">
            <summary>Constant H264Capabilities</summary>
            <unmanaged>MF_MT_H264_CAPABILITIES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.H264MaxCodecConfigDelay">
            <summary>Constant H264MaxCodecConfigDelay</summary>
            <unmanaged>MF_MT_H264_MAX_CODEC_CONFIG_DELAY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.H264MaxMbPerSec">
            <summary>Constant H264MaxMbPerSec</summary>
            <unmanaged>MF_MT_H264_MAX_MB_PER_SEC</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.H264RateControlModes">
            <summary>Constant H264RateControlModes</summary>
            <unmanaged>MF_MT_H264_RATE_CONTROL_MODES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.H264SimulcastSupport">
            <summary>Constant H264SimulcastSupport</summary>
            <unmanaged>MF_MT_H264_SIMULCAST_SUPPORT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.H264SupportedRateControlModes">
            <summary>Constant H264SupportedRateControlModes</summary>
            <unmanaged>MF_MT_H264_SUPPORTED_RATE_CONTROL_MODES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.H264SupportedSliceModes">
            <summary>Constant H264SupportedSliceModes</summary>
            <unmanaged>MF_MT_H264_SUPPORTED_SLICE_MODES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.H264SupportedSyncFrameTypes">
            <summary>Constant H264SupportedSyncFrameTypes</summary>
            <unmanaged>MF_MT_H264_SUPPORTED_SYNC_FRAME_TYPES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.H264SupportedUsages">
            <summary>Constant H264SupportedUsages</summary>
            <unmanaged>MF_MT_H264_SUPPORTED_USAGES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.H264SvcCapabilities">
            <summary>Constant H264SvcCapabilities</summary>
            <unmanaged>MF_MT_H264_SVC_CAPABILITIES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.H264Usage">
            <summary>Constant H264Usage</summary>
            <unmanaged>MF_MT_H264_USAGE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.ImageLossTolerant">
            <summary>Constant ImageLossTolerant</summary>
            <unmanaged>MF_MT_IMAGE_LOSS_TOLERANT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.InterlaceMode">
            <summary>Constant InterlaceMode</summary>
            <unmanaged>MF_MT_INTERLACE_MODE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.MajorType">
            <summary>Constant MajorType</summary>
            <unmanaged>MF_MT_MAJOR_TYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.MaxKeyframeSpacing">
            <summary>Constant MaxKeyframeSpacing</summary>
            <unmanaged>MF_MT_MAX_KEYFRAME_SPACING</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.MinimumDisplayAperture">
            <summary>Constant MinimumDisplayAperture</summary>
            <unmanaged>MF_MT_MINIMUM_DISPLAY_APERTURE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.MpegSequenceHeader">
            <summary>Constant MpegSequenceHeader</summary>
            <unmanaged>MF_MT_MPEG_SEQUENCE_HEADER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.MpegStartTimeCode">
            <summary>Constant MpegStartTimeCode</summary>
            <unmanaged>MF_MT_MPEG_START_TIME_CODE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.Mpeg2ContentPACKET">
            <summary>Constant Mpeg2ContentPACKET</summary>
            <unmanaged>MF_MT_MPEG2_CONTENT_PACKET</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.Mpeg2Flags">
            <summary>Constant Mpeg2Flags</summary>
            <unmanaged>MF_MT_MPEG2_FLAGS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.Mpeg2Level">
            <summary>Constant Mpeg2Level</summary>
            <unmanaged>MF_MT_MPEG2_LEVEL</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.Mpeg2Profile">
            <summary>Constant Mpeg2Profile</summary>
            <unmanaged>MF_MT_MPEG2_PROFILE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.Mpeg2STANDARD">
            <summary>Constant Mpeg2STANDARD</summary>
            <unmanaged>MF_MT_MPEG2_STANDARD</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.Mpeg2TIMECODE">
            <summary>Constant Mpeg2TIMECODE</summary>
            <unmanaged>MF_MT_MPEG2_TIMECODE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.Mpeg4CurrentSampleEntry">
            <summary>Constant Mpeg4CurrentSampleEntry</summary>
            <unmanaged>MF_MT_MPEG4_CURRENT_SAMPLE_ENTRY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.Mpeg4SampleDescription">
            <summary>Constant Mpeg4SampleDescription</summary>
            <unmanaged>MF_MT_MPEG4_SAMPLE_DESCRIPTION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.Original4cc">
            <summary>Constant Original4cc</summary>
            <unmanaged>MF_MT_ORIGINAL_4CC</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.OriginalWaveFormatTag">
            <summary>Constant OriginalWaveFormatTag</summary>
            <unmanaged>MF_MT_ORIGINAL_WAVE_FORMAT_TAG</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.PadControlFlags">
            <summary>Constant PadControlFlags</summary>
            <unmanaged>MF_MT_PAD_CONTROL_FLAGS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.Palette">
            <summary>Constant Palette</summary>
            <unmanaged>MF_MT_PALETTE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.PanScanAperture">
            <summary>Constant PanScanAperture</summary>
            <unmanaged>MF_MT_PAN_SCAN_APERTURE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.PanScanEnabled">
            <summary>Constant PanScanEnabled</summary>
            <unmanaged>MF_MT_PAN_SCAN_ENABLED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.PixelAspectRatio">
            <summary>Constant PixelAspectRatio</summary>
            <unmanaged>MF_MT_PIXEL_ASPECT_RATIO</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.SampleSize">
            <summary>Constant SampleSize</summary>
            <unmanaged>MF_MT_SAMPLE_SIZE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.SourceContentHint">
            <summary>Constant SourceContentHint</summary>
            <unmanaged>MF_MT_SOURCE_CONTENT_HINT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.Subtype">
            <summary>Constant Subtype</summary>
            <unmanaged>MF_MT_SUBTYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.TimestampCanBeDTS">
            <summary>Constant TimestampCanBeDTS</summary>
            <unmanaged>MF_MT_TIMESTAMP_CAN_BE_DTS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.TransferFunction">
            <summary>Constant TransferFunction</summary>
            <unmanaged>MF_MT_TRANSFER_FUNCTION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.UserData">
            <summary>Constant UserData</summary>
            <unmanaged>MF_MT_USER_DATA</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.Video3d">
            <summary>Constant Video3d</summary>
            <unmanaged>MF_MT_VIDEO_3D</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.Video3dFirstIsLeft">
            <summary>Constant Video3dFirstIsLeft</summary>
            <unmanaged>MF_MT_VIDEO_3D_FIRST_IS_LEFT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.Video3dFormat">
            <summary>Constant Video3dFormat</summary>
            <unmanaged>MF_MT_VIDEO_3D_FORMAT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.Video3dLeftIsBase">
            <summary>Constant Video3dLeftIsBase</summary>
            <unmanaged>MF_MT_VIDEO_3D_LEFT_IS_BASE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.Video3dNumViews">
            <summary>Constant Video3dNumViews</summary>
            <unmanaged>MF_MT_VIDEO_3D_NUM_VIEWS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.VideoChromaSiting">
            <summary>Constant VideoChromaSiting</summary>
            <unmanaged>MF_MT_VIDEO_CHROMA_SITING</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.VideoLighting">
            <summary>Constant VideoLighting</summary>
            <unmanaged>MF_MT_VIDEO_LIGHTING</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.VideoNominalRange">
            <summary>Constant VideoNominalRange</summary>
            <unmanaged>MF_MT_VIDEO_NOMINAL_RANGE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.VideoPrimaries">
            <summary>Constant VideoPrimaries</summary>
            <unmanaged>MF_MT_VIDEO_PRIMARIES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.VideoRotation">
            <summary>Constant VideoRotation</summary>
            <unmanaged>MF_MT_VIDEO_ROTATION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.WrappedType">
            <summary>Constant WrappedType</summary>
            <unmanaged>MF_MT_WRAPPED_TYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeAttributeKeys.YuvMatrix">
            <summary>Constant YuvMatrix</summary>
            <unmanaged>MF_MT_YUV_MATRIX</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaTypeGuids">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeGuids.Default">
            <summary>Constant Default</summary>
            <unmanaged>MFMediaType_Default</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeGuids.Audio">
            <summary>Constant Audio</summary>
            <unmanaged>MFMediaType_Audio</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeGuids.Video">
            <summary>Constant Video</summary>
            <unmanaged>MFMediaType_Video</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeGuids.Protected">
            <summary>Constant Protected</summary>
            <unmanaged>MFMediaType_Protected</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeGuids.Sami">
            <summary>Constant Sami</summary>
            <unmanaged>MFMediaType_SAMI</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeGuids.Script">
            <summary>Constant Script</summary>
            <unmanaged>MFMediaType_Script</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeGuids.Image">
            <summary>Constant Image</summary>
            <unmanaged>MFMediaType_Image</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeGuids.Html">
            <summary>Constant Html</summary>
            <unmanaged>MFMediaType_HTML</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeGuids.Binary">
            <summary>Constant Binary</summary>
            <unmanaged>MFMediaType_Binary</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeGuids.FileTransfer">
            <summary>Constant FileTransfer</summary>
            <unmanaged>MFMediaType_FileTransfer</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeGuids.Stream">
            <summary>Constant Stream</summary>
            <unmanaged>MFMediaType_Stream</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeGuids.MultiplexedFrames">
            <summary>Constant MultiplexedFrames</summary>
            <unmanaged>MFMediaType_MultiplexedFrames</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeGuids.Subtitle">
            <summary>Constant Subtitle</summary>
            <unmanaged>MFMediaType_Subtitle</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaTypeGuids.Perception">
            <summary>Constant Perception</summary>
            <unmanaged>MFMediaType_Perception</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.Mpeg4MediaSinkAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.Mpeg4MediaSinkAttributeKeys.MoovBeforeMdat">
            <summary>Constant MoovBeforeMdat</summary>
            <unmanaged>MF_MPEG4SINK_MOOV_BEFORE_MDAT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.Mpeg4MediaSinkAttributeKeys.SpsppsPassthrough">
            <summary>Constant SpsppsPassthrough</summary>
            <unmanaged>MF_MPEG4SINK_SPSPPS_PASSTHROUGH</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.NaluAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.NaluAttributeKeys.LengthInformation">
            <summary>Constant LengthInformation</summary>
            <unmanaged>MF_NALU_LENGTH_INFORMATION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.NaluAttributeKeys.LengthSet">
            <summary>Constant LengthSet</summary>
            <unmanaged>MF_NALU_LENGTH_SET</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AppContext">
            <summary>Constant AppContext</summary>
            <unmanaged>MF_PD_APP_CONTEXT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfCodeclist">
            <summary>Constant AsfCodeclist</summary>
            <unmanaged>MF_PD_ASF_CODECLIST</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfContentencryptionKeyid">
            <summary>Constant AsfContentencryptionKeyid</summary>
            <unmanaged>MF_PD_ASF_CONTENTENCRYPTION_KEYID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfContentencryptionLicenseUrl">
            <summary>Constant AsfContentencryptionLicenseUrl</summary>
            <unmanaged>MF_PD_ASF_CONTENTENCRYPTION_LICENSE_URL</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfContentencryptionSecretData">
            <summary>Constant AsfContentencryptionSecretData</summary>
            <unmanaged>MF_PD_ASF_CONTENTENCRYPTION_SECRET_DATA</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfContentencryptionType">
            <summary>Constant AsfContentencryptionType</summary>
            <unmanaged>MF_PD_ASF_CONTENTENCRYPTION_TYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfContentencryptionexEncryptionData">
            <summary>Constant AsfContentencryptionexEncryptionData</summary>
            <unmanaged>MF_PD_ASF_CONTENTENCRYPTIONEX_ENCRYPTION_DATA</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfDataLength">
            <summary>Constant AsfDataLength</summary>
            <unmanaged>MF_PD_ASF_DATA_LENGTH</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfDataStartOffset">
            <summary>Constant AsfDataStartOffset</summary>
            <unmanaged>MF_PD_ASF_DATA_START_OFFSET</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfFilepropertiesCreationTime">
            <summary>Constant AsfFilepropertiesCreationTime</summary>
            <unmanaged>MF_PD_ASF_FILEPROPERTIES_CREATION_TIME</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfFilepropertiesFileId">
            <summary>Constant AsfFilepropertiesFileId</summary>
            <unmanaged>MF_PD_ASF_FILEPROPERTIES_FILE_ID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfFilepropertiesFlags">
            <summary>Constant AsfFilepropertiesFlags</summary>
            <unmanaged>MF_PD_ASF_FILEPROPERTIES_FLAGS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfFilepropertiesMaxBitrate">
            <summary>Constant AsfFilepropertiesMaxBitrate</summary>
            <unmanaged>MF_PD_ASF_FILEPROPERTIES_MAX_BITRATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfFilepropertiesMaxPacketSize">
            <summary>Constant AsfFilepropertiesMaxPacketSize</summary>
            <unmanaged>MF_PD_ASF_FILEPROPERTIES_MAX_PACKET_SIZE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfFilepropertiesMinPacketSize">
            <summary>Constant AsfFilepropertiesMinPacketSize</summary>
            <unmanaged>MF_PD_ASF_FILEPROPERTIES_MIN_PACKET_SIZE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfFilepropertiesPackets">
            <summary>Constant AsfFilepropertiesPackets</summary>
            <unmanaged>MF_PD_ASF_FILEPROPERTIES_PACKETS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfFilepropertiesPlayDuration">
            <summary>Constant AsfFilepropertiesPlayDuration</summary>
            <unmanaged>MF_PD_ASF_FILEPROPERTIES_PLAY_DURATION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfFilepropertiesPreroll">
            <summary>Constant AsfFilepropertiesPreroll</summary>
            <unmanaged>MF_PD_ASF_FILEPROPERTIES_PREROLL</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfFilepropertiesSendDuration">
            <summary>Constant AsfFilepropertiesSendDuration</summary>
            <unmanaged>MF_PD_ASF_FILEPROPERTIES_SEND_DURATION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfInfoHasAudio">
            <summary>Constant AsfInfoHasAudio</summary>
            <unmanaged>MF_PD_ASF_INFO_HAS_AUDIO</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfInfoHasNonAudioVideo">
            <summary>Constant AsfInfoHasNonAudioVideo</summary>
            <unmanaged>MF_PD_ASF_INFO_HAS_NON_AUDIO_VIDEO</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfInfoHasVideo">
            <summary>Constant AsfInfoHasVideo</summary>
            <unmanaged>MF_PD_ASF_INFO_HAS_VIDEO</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfLanglist">
            <summary>Constant AsfLanglist</summary>
            <unmanaged>MF_PD_ASF_LANGLIST</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfLanglistLegacyorder">
            <summary>Constant AsfLanglistLegacyorder</summary>
            <unmanaged>MF_PD_ASF_LANGLIST_LEGACYORDER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfMarker">
            <summary>Constant AsfMarker</summary>
            <unmanaged>MF_PD_ASF_MARKER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfMetadataIsVbr">
            <summary>Constant AsfMetadataIsVbr</summary>
            <unmanaged>MF_PD_ASF_METADATA_IS_VBR</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfMetadataLeakyBucketPairs">
            <summary>Constant AsfMetadataLeakyBucketPairs</summary>
            <unmanaged>MF_PD_ASF_METADATA_LEAKY_BUCKET_PAIRS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfMetadataV8Bufferaverage">
            <summary>Constant AsfMetadataV8Bufferaverage</summary>
            <unmanaged>MF_PD_ASF_METADATA_V8_BUFFERAVERAGE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfMetadataV8Vbrpeak">
            <summary>Constant AsfMetadataV8Vbrpeak</summary>
            <unmanaged>MF_PD_ASF_METADATA_V8_VBRPEAK</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AsfScript">
            <summary>Constant AsfScript</summary>
            <unmanaged>MF_PD_ASF_SCRIPT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AudioEncodingBitrate">
            <summary>Constant AudioEncodingBitrate</summary>
            <unmanaged>MF_PD_AUDIO_ENCODING_BITRATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.AudioIsvariablebitrate">
            <summary>Constant AudioIsvariablebitrate</summary>
            <unmanaged>MF_PD_AUDIO_ISVARIABLEBITRATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.Duration">
            <summary>Constant Duration</summary>
            <unmanaged>MF_PD_DURATION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.LastModifiedTime">
            <summary>Constant LastModifiedTime</summary>
            <unmanaged>MF_PD_LAST_MODIFIED_TIME</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.MimeType">
            <summary>Constant MimeType</summary>
            <unmanaged>MF_PD_MIME_TYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.PlaybackBoundaryTime">
            <summary>Constant PlaybackBoundaryTime</summary>
            <unmanaged>MF_PD_PLAYBACK_BOUNDARY_TIME</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.PlaybackElementId">
            <summary>Constant PlaybackElementId</summary>
            <unmanaged>MF_PD_PLAYBACK_ELEMENT_ID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.PmphostContext">
            <summary>Constant PmphostContext</summary>
            <unmanaged>MF_PD_PMPHOST_CONTEXT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.PreferredLanguage">
            <summary>Constant PreferredLanguage</summary>
            <unmanaged>MF_PD_PREFERRED_LANGUAGE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.SamiStylelist">
            <summary>Constant SamiStylelist</summary>
            <unmanaged>MF_PD_SAMI_STYLELIST</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.TotalFileSize">
            <summary>Constant TotalFileSize</summary>
            <unmanaged>MF_PD_TOTAL_FILE_SIZE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.PresentationDescriptionAttributeKeys.VideoEncodingBitrate">
            <summary>Constant VideoEncodingBitrate</summary>
            <unmanaged>MF_PD_VIDEO_ENCODING_BITRATE</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.ProtectionAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.ProtectionAttributeKeys.GraphicsTransferAesEncryption">
            <summary>Constant GraphicsTransferAesEncryption</summary>
            <unmanaged>MFPROTECTION_GRAPHICS_TRANSFER_AES_ENCRYPTION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ProtectionAttributeKeys.VideoFrames">
            <summary>Constant VideoFrames</summary>
            <unmanaged>MFPROTECTION_VIDEO_FRAMES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ProtectionAttributeKeys.BestEffort">
            <summary>Constant BestEffort</summary>
            <unmanaged>MFPROTECTIONATTRIBUTE_BEST_EFFORT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ProtectionAttributeKeys.FailOver">
            <summary>Constant FailOver</summary>
            <unmanaged>MFPROTECTIONATTRIBUTE_FAIL_OVER</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.ResultCode">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.DxgiDeviceNotInitializeD">
            <summary>Constant DxgiDeviceNotInitializeD</summary>
            <unmanaged>MF_E_DXGI_DEVICE_NOT_INITIALIZED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.DxgiNewVideoDevice">
            <summary>Constant DxgiNewVideoDevice</summary>
            <unmanaged>MF_E_DXGI_NEW_VIDEO_DEVICE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.DxgiVideoDeviceLocked">
            <summary>Constant DxgiVideoDeviceLocked</summary>
            <unmanaged>MF_E_DXGI_VIDEO_DEVICE_LOCKED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.PlatformNotInitializeD">
            <summary>Constant PlatformNotInitializeD</summary>
            <unmanaged>MF_E_PLATFORM_NOT_INITIALIZED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.BufferTooSmall">
            <summary>Constant BufferTooSmall</summary>
            <unmanaged>MF_E_BUFFERTOOSMALL</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InvalidRequest">
            <summary>Constant InvalidRequest</summary>
            <unmanaged>MF_E_INVALIDREQUEST</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InvalidStreamNumber">
            <summary>Constant InvalidStreamNumber</summary>
            <unmanaged>MF_E_INVALIDSTREAMNUMBER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InvalidMediaType">
            <summary>Constant InvalidMediaType</summary>
            <unmanaged>MF_E_INVALIDMEDIATYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NotAccepting">
            <summary>Constant NotAccepting</summary>
            <unmanaged>MF_E_NOTACCEPTING</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NotInitializeD">
            <summary>Constant NotInitializeD</summary>
            <unmanaged>MF_E_NOT_INITIALIZED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.UnsupportedRepresentation">
            <summary>Constant UnsupportedRepresentation</summary>
            <unmanaged>MF_E_UNSUPPORTED_REPRESENTATION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NoMoreTypes">
            <summary>Constant NoMoreTypes</summary>
            <unmanaged>MF_E_NO_MORE_TYPES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.UnsupportedService">
            <summary>Constant UnsupportedService</summary>
            <unmanaged>MF_E_UNSUPPORTED_SERVICE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.Unexpected">
            <summary>Constant Unexpected</summary>
            <unmanaged>MF_E_UNEXPECTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InvalidName">
            <summary>Constant InvalidName</summary>
            <unmanaged>MF_E_INVALIDNAME</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InvalidType">
            <summary>Constant InvalidType</summary>
            <unmanaged>MF_E_INVALIDTYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InvalidFileFormat">
            <summary>Constant InvalidFileFormat</summary>
            <unmanaged>MF_E_INVALID_FILE_FORMAT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InvalidIndex">
            <summary>Constant InvalidIndex</summary>
            <unmanaged>MF_E_INVALIDINDEX</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InvalidTimestamp">
            <summary>Constant InvalidTimestamp</summary>
            <unmanaged>MF_E_INVALID_TIMESTAMP</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.UnsupportedScheme">
            <summary>Constant UnsupportedScheme</summary>
            <unmanaged>MF_E_UNSUPPORTED_SCHEME</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.UnsupportedByteStreamType">
            <summary>Constant UnsupportedByteStreamType</summary>
            <unmanaged>MF_E_UNSUPPORTED_BYTESTREAM_TYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.UnsupportedTimeFormat">
            <summary>Constant UnsupportedTimeFormat</summary>
            <unmanaged>MF_E_UNSUPPORTED_TIME_FORMAT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NoSampleTimestamp">
            <summary>Constant NoSampleTimestamp</summary>
            <unmanaged>MF_E_NO_SAMPLE_TIMESTAMP</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NoSampleDuration">
            <summary>Constant NoSampleDuration</summary>
            <unmanaged>MF_E_NO_SAMPLE_DURATION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InvalidStreamData">
            <summary>Constant InvalidStreamData</summary>
            <unmanaged>MF_E_INVALID_STREAM_DATA</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.RtUnavailable">
            <summary>Constant RtUnavailable</summary>
            <unmanaged>MF_E_RT_UNAVAILABLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.UnsupportedRate">
            <summary>Constant UnsupportedRate</summary>
            <unmanaged>MF_E_UNSUPPORTED_RATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.ThinningUnsupported">
            <summary>Constant ThinningUnsupported</summary>
            <unmanaged>MF_E_THINNING_UNSUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.ReverseUnsupported">
            <summary>Constant ReverseUnsupported</summary>
            <unmanaged>MF_E_REVERSE_UNSUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.UnsupportedRateTransition">
            <summary>Constant UnsupportedRateTransition</summary>
            <unmanaged>MF_E_UNSUPPORTED_RATE_TRANSITION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.RateChangePreempted">
            <summary>Constant RateChangePreempted</summary>
            <unmanaged>MF_E_RATE_CHANGE_PREEMPTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NotFound">
            <summary>Constant NotFound</summary>
            <unmanaged>MF_E_NOT_FOUND</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NotAvailable">
            <summary>Constant NotAvailable</summary>
            <unmanaged>MF_E_NOT_AVAILABLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NoClock">
            <summary>Constant NoClock</summary>
            <unmanaged>MF_E_NO_CLOCK</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.MultipleBegin">
            <summary>Constant MultipleBegin</summary>
            <unmanaged>MF_E_MULTIPLE_BEGIN</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.MultipleSubScribers">
            <summary>Constant MultipleSubScribers</summary>
            <unmanaged>MF_E_MULTIPLE_SUBSCRIBERS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TimerOrphaned">
            <summary>Constant TimerOrphaned</summary>
            <unmanaged>MF_E_TIMER_ORPHANED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.StateTransitionPending">
            <summary>Constant StateTransitionPending</summary>
            <unmanaged>MF_E_STATE_TRANSITION_PENDING</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.UnsupportedStateTransition">
            <summary>Constant UnsupportedStateTransition</summary>
            <unmanaged>MF_E_UNSUPPORTED_STATE_TRANSITION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.UnrecoverableErrorOccurred">
            <summary>Constant UnrecoverableErrorOccurred</summary>
            <unmanaged>MF_E_UNRECOVERABLE_ERROR_OCCURRED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.SampleHasTooManyBuffers">
            <summary>Constant SampleHasTooManyBuffers</summary>
            <unmanaged>MF_E_SAMPLE_HAS_TOO_MANY_BUFFERS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.SampleNotWritable">
            <summary>Constant SampleNotWritable</summary>
            <unmanaged>MF_E_SAMPLE_NOT_WRITABLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InvalidKey">
            <summary>Constant InvalidKey</summary>
            <unmanaged>MF_E_INVALID_KEY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.BadStartupVersion">
            <summary>Constant BadStartupVersion</summary>
            <unmanaged>MF_E_BAD_STARTUP_VERSION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.UnsupportedCaption">
            <summary>Constant UnsupportedCaption</summary>
            <unmanaged>MF_E_UNSUPPORTED_CAPTION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InvalidPosition">
            <summary>Constant InvalidPosition</summary>
            <unmanaged>MF_E_INVALID_POSITION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.Attributenotfound">
            <summary>Constant Attributenotfound</summary>
            <unmanaged>MF_E_ATTRIBUTENOTFOUND</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.PropertyTypeNotAllowEd">
            <summary>Constant PropertyTypeNotAllowEd</summary>
            <unmanaged>MF_E_PROPERTY_TYPE_NOT_ALLOWED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.PropertyTypeNotSupported">
            <summary>Constant PropertyTypeNotSupported</summary>
            <unmanaged>MF_E_PROPERTY_TYPE_NOT_SUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.PropertyEmpty">
            <summary>Constant PropertyEmpty</summary>
            <unmanaged>MF_E_PROPERTY_EMPTY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.PropertyNotEmpty">
            <summary>Constant PropertyNotEmpty</summary>
            <unmanaged>MF_E_PROPERTY_NOT_EMPTY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.PropertyVectorNotAllowEd">
            <summary>Constant PropertyVectorNotAllowEd</summary>
            <unmanaged>MF_E_PROPERTY_VECTOR_NOT_ALLOWED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.PropertyVectorRequired">
            <summary>Constant PropertyVectorRequired</summary>
            <unmanaged>MF_E_PROPERTY_VECTOR_REQUIRED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.OperationCancelled">
            <summary>Constant OperationCancelled</summary>
            <unmanaged>MF_E_OPERATION_CANCELLED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.ByteStreamNotSeekable">
            <summary>Constant ByteStreamNotSeekable</summary>
            <unmanaged>MF_E_BYTESTREAM_NOT_SEEKABLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.DisabledInSafemode">
            <summary>Constant DisabledInSafemode</summary>
            <unmanaged>MF_E_DISABLED_IN_SAFEMODE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.CannotParseByteStream">
            <summary>Constant CannotParseByteStream</summary>
            <unmanaged>MF_E_CANNOT_PARSE_BYTESTREAM</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.SourceResolverMutuallyExclusiveFlags">
            <summary>Constant SourceResolverMutuallyExclusiveFlags</summary>
            <unmanaged>MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.MediaProcWrongState">
            <summary>Constant MediaProcWrongState</summary>
            <unmanaged>MF_E_MEDIAPROC_WRONGSTATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.RtThroughputNotAvailable">
            <summary>Constant RtThroughputNotAvailable</summary>
            <unmanaged>MF_E_RT_THROUGHPUT_NOT_AVAILABLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.RtTooManyClassEs">
            <summary>Constant RtTooManyClassEs</summary>
            <unmanaged>MF_E_RT_TOO_MANY_CLASSES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.RtWouldblock">
            <summary>Constant RtWouldblock</summary>
            <unmanaged>MF_E_RT_WOULDBLOCK</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NoBitpump">
            <summary>Constant NoBitpump</summary>
            <unmanaged>MF_E_NO_BITPUMP</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.RtOufOfMemory">
            <summary>Constant RtOufOfMemory</summary>
            <unmanaged>MF_E_RT_OUTOFMEMORY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.RtWorkqueueClassNotSpecified">
            <summary>Constant RtWorkqueueClassNotSpecified</summary>
            <unmanaged>MF_E_RT_WORKQUEUE_CLASS_NOT_SPECIFIED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InsufficientBuffer">
            <summary>Constant InsufficientBuffer</summary>
            <unmanaged>MF_E_INSUFFICIENT_BUFFER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.CannotCreateSink">
            <summary>Constant CannotCreateSink</summary>
            <unmanaged>MF_E_CANNOT_CREATE_SINK</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.ByteStreamUnknownLength">
            <summary>Constant ByteStreamUnknownLength</summary>
            <unmanaged>MF_E_BYTESTREAM_UNKNOWN_LENGTH</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.SessionPausewhilestopped">
            <summary>Constant SessionPausewhilestopped</summary>
            <unmanaged>MF_E_SESSION_PAUSEWHILESTOPPED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.FormatChangeNotSupported">
            <summary>Constant FormatChangeNotSupported</summary>
            <unmanaged>MF_E_FORMAT_CHANGE_NOT_SUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InvalidWorkqueue">
            <summary>Constant InvalidWorkqueue</summary>
            <unmanaged>MF_E_INVALID_WORKQUEUE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.DrmUnsupported">
            <summary>Constant DrmUnsupported</summary>
            <unmanaged>MF_E_DRM_UNSUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.Unauthorized">
            <summary>Constant Unauthorized</summary>
            <unmanaged>MF_E_UNAUTHORIZED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.OutOfRange">
            <summary>Constant OutOfRange</summary>
            <unmanaged>MF_E_OUT_OF_RANGE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InvalidCodecMerit">
            <summary>Constant InvalidCodecMerit</summary>
            <unmanaged>MF_E_INVALID_CODEC_MERIT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.HwMftFailedStartStreaming">
            <summary>Constant HwMftFailedStartStreaming</summary>
            <unmanaged>MF_E_HW_MFT_FAILED_START_STREAMING</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.OperationInProgress">
            <summary>Constant OperationInProgress</summary>
            <unmanaged>MF_E_OPERATION_IN_PROGRESS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.HardwareDrmUnsupported">
            <summary>Constant HardwareDrmUnsupported</summary>
            <unmanaged>MF_E_HARDWARE_DRM_UNSUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AsfParsingincomplete">
            <summary>Constant AsfParsingincomplete</summary>
            <unmanaged>MF_E_ASF_PARSINGINCOMPLETE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AsfMissingData">
            <summary>Constant AsfMissingData</summary>
            <unmanaged>MF_E_ASF_MISSINGDATA</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AsfInvalidData">
            <summary>Constant AsfInvalidData</summary>
            <unmanaged>MF_E_ASF_INVALIDDATA</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AsfOpaquePacket">
            <summary>Constant AsfOpaquePacket</summary>
            <unmanaged>MF_E_ASF_OPAQUEPACKET</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AsfNoindex">
            <summary>Constant AsfNoindex</summary>
            <unmanaged>MF_E_ASF_NOINDEX</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AsfOufOfRange">
            <summary>Constant AsfOufOfRange</summary>
            <unmanaged>MF_E_ASF_OUTOFRANGE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AsfIndexNotLoaded">
            <summary>Constant AsfIndexNotLoaded</summary>
            <unmanaged>MF_E_ASF_INDEXNOTLOADED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AsfTooManyPayloads">
            <summary>Constant AsfTooManyPayloads</summary>
            <unmanaged>MF_E_ASF_TOO_MANY_PAYLOADS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AsfUnsupportedStreamType">
            <summary>Constant AsfUnsupportedStreamType</summary>
            <unmanaged>MF_E_ASF_UNSUPPORTED_STREAM_TYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AsfDroppedPacket">
            <summary>Constant AsfDroppedPacket</summary>
            <unmanaged>MF_E_ASF_DROPPED_PACKET</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NoEventsAvailable">
            <summary>Constant NoEventsAvailable</summary>
            <unmanaged>MF_E_NO_EVENTS_AVAILABLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InvalidStateTransition">
            <summary>Constant InvalidStateTransition</summary>
            <unmanaged>MF_E_INVALID_STATE_TRANSITION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.EndOfStream">
            <summary>Constant EndOfStream</summary>
            <unmanaged>MF_E_END_OF_STREAM</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.Shutdown">
            <summary>Constant Shutdown</summary>
            <unmanaged>MF_E_SHUTDOWN</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.Mp3NotFound">
            <summary>Constant Mp3NotFound</summary>
            <unmanaged>MF_E_MP3_NOTFOUND</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.Mp3OufOfData">
            <summary>Constant Mp3OufOfData</summary>
            <unmanaged>MF_E_MP3_OUTOFDATA</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.Mp3NotMp3">
            <summary>Constant Mp3NotMp3</summary>
            <unmanaged>MF_E_MP3_NOTMP3</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.Mp3NotSupported">
            <summary>Constant Mp3NotSupported</summary>
            <unmanaged>MF_E_MP3_NOTSUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NoDuration">
            <summary>Constant NoDuration</summary>
            <unmanaged>MF_E_NO_DURATION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InvalidFormat">
            <summary>Constant InvalidFormat</summary>
            <unmanaged>MF_E_INVALID_FORMAT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.PropertyNotFound">
            <summary>Constant PropertyNotFound</summary>
            <unmanaged>MF_E_PROPERTY_NOT_FOUND</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.PropertyReadOnly">
            <summary>Constant PropertyReadOnly</summary>
            <unmanaged>MF_E_PROPERTY_READ_ONLY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.PropertyNotAllowEd">
            <summary>Constant PropertyNotAllowEd</summary>
            <unmanaged>MF_E_PROPERTY_NOT_ALLOWED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.MediaSourceNotStarted">
            <summary>Constant MediaSourceNotStarted</summary>
            <unmanaged>MF_E_MEDIA_SOURCE_NOT_STARTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.UnsupportedFormat">
            <summary>Constant UnsupportedFormat</summary>
            <unmanaged>MF_E_UNSUPPORTED_FORMAT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.Mp3BadCrc">
            <summary>Constant Mp3BadCrc</summary>
            <unmanaged>MF_E_MP3_BAD_CRC</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NotProtected">
            <summary>Constant NotProtected</summary>
            <unmanaged>MF_E_NOT_PROTECTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.MediaSourceWrongState">
            <summary>Constant MediaSourceWrongState</summary>
            <unmanaged>MF_E_MEDIA_SOURCE_WRONGSTATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.MediaSourceNoStreamsSelected">
            <summary>Constant MediaSourceNoStreamsSelected</summary>
            <unmanaged>MF_E_MEDIA_SOURCE_NO_STREAMS_SELECTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.CannotFindKeyframeSample">
            <summary>Constant CannotFindKeyframeSample</summary>
            <unmanaged>MF_E_CANNOT_FIND_KEYFRAME_SAMPLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.UnsupportedCharacteristics">
            <summary>Constant UnsupportedCharacteristics</summary>
            <unmanaged>MF_E_UNSUPPORTED_CHARACTERISTICS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NoAudioRecordingDevice">
            <summary>Constant NoAudioRecordingDevice</summary>
            <unmanaged>MF_E_NO_AUDIO_RECORDING_DEVICE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AudioRecordingDeviceInUse">
            <summary>Constant AudioRecordingDeviceInUse</summary>
            <unmanaged>MF_E_AUDIO_RECORDING_DEVICE_IN_USE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AudioRecordingDeviceInvalidated">
            <summary>Constant AudioRecordingDeviceInvalidated</summary>
            <unmanaged>MF_E_AUDIO_RECORDING_DEVICE_INVALIDATED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.VideoRecordingDeviceInvalidated">
            <summary>Constant VideoRecordingDeviceInvalidated</summary>
            <unmanaged>MF_E_VIDEO_RECORDING_DEVICE_INVALIDATED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.VideoRecordingDevicePreempted">
            <summary>Constant VideoRecordingDevicePreempted</summary>
            <unmanaged>MF_E_VIDEO_RECORDING_DEVICE_PREEMPTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetworkResourceFailure">
            <summary>Constant NetworkResourceFailure</summary>
            <unmanaged>MF_E_NETWORK_RESOURCE_FAILURE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetWrite">
            <summary>Constant NetWrite</summary>
            <unmanaged>MF_E_NET_WRITE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetRead">
            <summary>Constant NetRead</summary>
            <unmanaged>MF_E_NET_READ</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetRequireNetwork">
            <summary>Constant NetRequireNetwork</summary>
            <unmanaged>MF_E_NET_REQUIRE_NETWORK</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetRequireAsync">
            <summary>Constant NetRequireAsync</summary>
            <unmanaged>MF_E_NET_REQUIRE_ASYNC</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetBwlevelNotSupported">
            <summary>Constant NetBwlevelNotSupported</summary>
            <unmanaged>MF_E_NET_BWLEVEL_NOT_SUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetStreamGroupsNotSupported">
            <summary>Constant NetStreamGroupsNotSupported</summary>
            <unmanaged>MF_E_NET_STREAMGROUPS_NOT_SUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetManualssNotSupported">
            <summary>Constant NetManualssNotSupported</summary>
            <unmanaged>MF_E_NET_MANUALSS_NOT_SUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetInvalidPresentationDescriptor">
            <summary>Constant NetInvalidPresentationDescriptor</summary>
            <unmanaged>MF_E_NET_INVALID_PRESENTATION_DESCRIPTOR</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetCachestreamNotFound">
            <summary>Constant NetCachestreamNotFound</summary>
            <unmanaged>MF_E_NET_CACHESTREAM_NOT_FOUND</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetRequireInput">
            <summary>Constant NetRequireInput</summary>
            <unmanaged>MF_E_NET_REQUIRE_INPUT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetRedirect">
            <summary>Constant NetRedirect</summary>
            <unmanaged>MF_E_NET_REDIRECT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetRedirectToProxy">
            <summary>Constant NetRedirectToProxy</summary>
            <unmanaged>MF_E_NET_REDIRECT_TO_PROXY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetTooManyRedirects">
            <summary>Constant NetTooManyRedirects</summary>
            <unmanaged>MF_E_NET_TOO_MANY_REDIRECTS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetTimeout">
            <summary>Constant NetTimeout</summary>
            <unmanaged>MF_E_NET_TIMEOUT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetClientClose">
            <summary>Constant NetClientClose</summary>
            <unmanaged>MF_E_NET_CLIENT_CLOSE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetBadControlData">
            <summary>Constant NetBadControlData</summary>
            <unmanaged>MF_E_NET_BAD_CONTROL_DATA</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetIncompatibleServer">
            <summary>Constant NetIncompatibleServer</summary>
            <unmanaged>MF_E_NET_INCOMPATIBLE_SERVER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetUnsafeUrl">
            <summary>Constant NetUnsafeUrl</summary>
            <unmanaged>MF_E_NET_UNSAFE_URL</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetCacheNoData">
            <summary>Constant NetCacheNoData</summary>
            <unmanaged>MF_E_NET_CACHE_NO_DATA</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetEol">
            <summary>Constant NetEol</summary>
            <unmanaged>MF_E_NET_EOL</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetBadRequest">
            <summary>Constant NetBadRequest</summary>
            <unmanaged>MF_E_NET_BAD_REQUEST</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetInternalServerError">
            <summary>Constant NetInternalServerError</summary>
            <unmanaged>MF_E_NET_INTERNAL_SERVER_ERROR</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetSessionNotFound">
            <summary>Constant NetSessionNotFound</summary>
            <unmanaged>MF_E_NET_SESSION_NOT_FOUND</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetNoconnection">
            <summary>Constant NetNoconnection</summary>
            <unmanaged>MF_E_NET_NOCONNECTION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetConnectionFailure">
            <summary>Constant NetConnectionFailure</summary>
            <unmanaged>MF_E_NET_CONNECTION_FAILURE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetIncompatiblePushserver">
            <summary>Constant NetIncompatiblePushserver</summary>
            <unmanaged>MF_E_NET_INCOMPATIBLE_PUSHSERVER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetServerAccessDenied">
            <summary>Constant NetServerAccessDenied</summary>
            <unmanaged>MF_E_NET_SERVER_ACCESSDENIED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetProxyAccessDenied">
            <summary>Constant NetProxyAccessDenied</summary>
            <unmanaged>MF_E_NET_PROXY_ACCESSDENIED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetCannotconnect">
            <summary>Constant NetCannotconnect</summary>
            <unmanaged>MF_E_NET_CANNOTCONNECT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetInvalidPushTemplate">
            <summary>Constant NetInvalidPushTemplate</summary>
            <unmanaged>MF_E_NET_INVALID_PUSH_TEMPLATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetInvalidPushPublishingPoint">
            <summary>Constant NetInvalidPushPublishingPoint</summary>
            <unmanaged>MF_E_NET_INVALID_PUSH_PUBLISHING_POINT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetBusy">
            <summary>Constant NetBusy</summary>
            <unmanaged>MF_E_NET_BUSY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetResourceGone">
            <summary>Constant NetResourceGone</summary>
            <unmanaged>MF_E_NET_RESOURCE_GONE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetErrorFromProxy">
            <summary>Constant NetErrorFromProxy</summary>
            <unmanaged>MF_E_NET_ERROR_FROM_PROXY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetProxyTimeout">
            <summary>Constant NetProxyTimeout</summary>
            <unmanaged>MF_E_NET_PROXY_TIMEOUT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetServerUnavailable">
            <summary>Constant NetServerUnavailable</summary>
            <unmanaged>MF_E_NET_SERVER_UNAVAILABLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetTooMuchData">
            <summary>Constant NetTooMuchData</summary>
            <unmanaged>MF_E_NET_TOO_MUCH_DATA</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetSessionInvalid">
            <summary>Constant NetSessionInvalid</summary>
            <unmanaged>MF_E_NET_SESSION_INVALID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.OfflineMode">
            <summary>Constant OfflineMode</summary>
            <unmanaged>MF_E_OFFLINE_MODE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetUdpBlocked">
            <summary>Constant NetUdpBlocked</summary>
            <unmanaged>MF_E_NET_UDP_BLOCKED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetUnsupportedConfiguration">
            <summary>Constant NetUnsupportedConfiguration</summary>
            <unmanaged>MF_E_NET_UNSUPPORTED_CONFIGURATION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetProtocolDisabled">
            <summary>Constant NetProtocolDisabled</summary>
            <unmanaged>MF_E_NET_PROTOCOL_DISABLED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NetCompanionDriverDisconnect">
            <summary>Constant NetCompanionDriverDisconnect</summary>
            <unmanaged>MF_E_NET_COMPANION_DRIVER_DISCONNECT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AlreadyInitializeD">
            <summary>Constant AlreadyInitializeD</summary>
            <unmanaged>MF_E_ALREADY_INITIALIZED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.BandwidthOverrun">
            <summary>Constant BandwidthOverrun</summary>
            <unmanaged>MF_E_BANDWIDTH_OVERRUN</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.LateSample">
            <summary>Constant LateSample</summary>
            <unmanaged>MF_E_LATE_SAMPLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.FlushNeeded">
            <summary>Constant FlushNeeded</summary>
            <unmanaged>MF_E_FLUSH_NEEDED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InvalidProfile">
            <summary>Constant InvalidProfile</summary>
            <unmanaged>MF_E_INVALID_PROFILE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.IndexNotCommitted">
            <summary>Constant IndexNotCommitted</summary>
            <unmanaged>MF_E_INDEX_NOT_COMMITTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NoIndex">
            <summary>Constant NoIndex</summary>
            <unmanaged>MF_E_NO_INDEX</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.CannotIndexInPlace">
            <summary>Constant CannotIndexInPlace</summary>
            <unmanaged>MF_E_CANNOT_INDEX_IN_PLACE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.MissingAsfLeakybucket">
            <summary>Constant MissingAsfLeakybucket</summary>
            <unmanaged>MF_E_MISSING_ASF_LEAKYBUCKET</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InvalidAsfStreamId">
            <summary>Constant InvalidAsfStreamId</summary>
            <unmanaged>MF_E_INVALID_ASF_STREAMID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.StreamsInkRemoved">
            <summary>Constant StreamsInkRemoved</summary>
            <unmanaged>MF_E_STREAMSINK_REMOVED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.StreamsInksOutOfSync">
            <summary>Constant StreamsInksOutOfSync</summary>
            <unmanaged>MF_E_STREAMSINKS_OUT_OF_SYNC</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.StreamsInksFixed">
            <summary>Constant StreamsInksFixed</summary>
            <unmanaged>MF_E_STREAMSINKS_FIXED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.StreamsInkExists">
            <summary>Constant StreamsInkExists</summary>
            <unmanaged>MF_E_STREAMSINK_EXISTS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.SampleallocatorCanceled">
            <summary>Constant SampleallocatorCanceled</summary>
            <unmanaged>MF_E_SAMPLEALLOCATOR_CANCELED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.SampleallocatorEmpty">
            <summary>Constant SampleallocatorEmpty</summary>
            <unmanaged>MF_E_SAMPLEALLOCATOR_EMPTY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.SinkAlreadystopped">
            <summary>Constant SinkAlreadystopped</summary>
            <unmanaged>MF_E_SINK_ALREADYSTOPPED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AsfFilesinkBitRateUnknown">
            <summary>Constant AsfFilesinkBitRateUnknown</summary>
            <unmanaged>MF_E_ASF_FILESINK_BITRATE_UNKNOWN</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.SinkNoStreams">
            <summary>Constant SinkNoStreams</summary>
            <unmanaged>MF_E_SINK_NO_STREAMS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.MetadataTooLong">
            <summary>Constant MetadataTooLong</summary>
            <unmanaged>MF_E_METADATA_TOO_LONG</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.SinkNoSamplesProcessed">
            <summary>Constant SinkNoSamplesProcessed</summary>
            <unmanaged>MF_E_SINK_NO_SAMPLES_PROCESSED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.SinkHeadersNotFound">
            <summary>Constant SinkHeadersNotFound</summary>
            <unmanaged>MF_E_SINK_HEADERS_NOT_FOUND</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.VideoRenNoProcampHw">
            <summary>Constant VideoRenNoProcampHw</summary>
            <unmanaged>MF_E_VIDEO_REN_NO_PROCAMP_HW</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.VideoRenNoDeinterlaceHw">
            <summary>Constant VideoRenNoDeinterlaceHw</summary>
            <unmanaged>MF_E_VIDEO_REN_NO_DEINTERLACE_HW</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.VideoRenCopyProtFailed">
            <summary>Constant VideoRenCopyProtFailed</summary>
            <unmanaged>MF_E_VIDEO_REN_COPYPROT_FAILED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.VideoRenSurfaceNotShared">
            <summary>Constant VideoRenSurfaceNotShared</summary>
            <unmanaged>MF_E_VIDEO_REN_SURFACE_NOT_SHARED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.VideoDeviceLocked">
            <summary>Constant VideoDeviceLocked</summary>
            <unmanaged>MF_E_VIDEO_DEVICE_LOCKED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NewVideoDevice">
            <summary>Constant NewVideoDevice</summary>
            <unmanaged>MF_E_NEW_VIDEO_DEVICE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NoVideoSampleAvailable">
            <summary>Constant NoVideoSampleAvailable</summary>
            <unmanaged>MF_E_NO_VIDEO_SAMPLE_AVAILABLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NoAudioPlaybackDevice">
            <summary>Constant NoAudioPlaybackDevice</summary>
            <unmanaged>MF_E_NO_AUDIO_PLAYBACK_DEVICE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AudioPlaybackDeviceInUse">
            <summary>Constant AudioPlaybackDeviceInUse</summary>
            <unmanaged>MF_E_AUDIO_PLAYBACK_DEVICE_IN_USE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AudioPlaybackDeviceInvalidated">
            <summary>Constant AudioPlaybackDeviceInvalidated</summary>
            <unmanaged>MF_E_AUDIO_PLAYBACK_DEVICE_INVALIDATED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AudioServiceNotRunning">
            <summary>Constant AudioServiceNotRunning</summary>
            <unmanaged>MF_E_AUDIO_SERVICE_NOT_RUNNING</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TopoInvalidOptionalNode">
            <summary>Constant TopoInvalidOptionalNode</summary>
            <unmanaged>MF_E_TOPO_INVALID_OPTIONAL_NODE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TopoCannotFindDecrementYptor">
            <summary>Constant TopoCannotFindDecrementYptor</summary>
            <unmanaged>MF_E_TOPO_CANNOT_FIND_DECRYPTOR</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TopoCodecNotFound">
            <summary>Constant TopoCodecNotFound</summary>
            <unmanaged>MF_E_TOPO_CODEC_NOT_FOUND</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TopoCannotConnect">
            <summary>Constant TopoCannotConnect</summary>
            <unmanaged>MF_E_TOPO_CANNOT_CONNECT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TopoUnsupported">
            <summary>Constant TopoUnsupported</summary>
            <unmanaged>MF_E_TOPO_UNSUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TopoInvalidTimeAttributes">
            <summary>Constant TopoInvalidTimeAttributes</summary>
            <unmanaged>MF_E_TOPO_INVALID_TIME_ATTRIBUTES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TopoLoopsInTopology">
            <summary>Constant TopoLoopsInTopology</summary>
            <unmanaged>MF_E_TOPO_LOOPS_IN_TOPOLOGY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TopoMissingPresentationDescriptor">
            <summary>Constant TopoMissingPresentationDescriptor</summary>
            <unmanaged>MF_E_TOPO_MISSING_PRESENTATION_DESCRIPTOR</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TopoMissingStreamDescriptor">
            <summary>Constant TopoMissingStreamDescriptor</summary>
            <unmanaged>MF_E_TOPO_MISSING_STREAM_DESCRIPTOR</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TopoStreamDescriptorNotSelected">
            <summary>Constant TopoStreamDescriptorNotSelected</summary>
            <unmanaged>MF_E_TOPO_STREAM_DESCRIPTOR_NOT_SELECTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TopoMissingSource">
            <summary>Constant TopoMissingSource</summary>
            <unmanaged>MF_E_TOPO_MISSING_SOURCE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TopoSinkActivatesUnsupported">
            <summary>Constant TopoSinkActivatesUnsupported</summary>
            <unmanaged>MF_E_TOPO_SINK_ACTIVATES_UNSUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.SequencerUnknownSegmentId">
            <summary>Constant SequencerUnknownSegmentId</summary>
            <unmanaged>MF_E_SEQUENCER_UNKNOWN_SEGMENT_ID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NoSourceInCache">
            <summary>Constant NoSourceInCache</summary>
            <unmanaged>MF_E_NO_SOURCE_IN_CACHE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformTypeNotSet">
            <summary>Constant TransformTypeNotSet</summary>
            <unmanaged>MF_E_TRANSFORM_TYPE_NOT_SET</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformStreamChange">
            <summary>Constant TransformStreamChange</summary>
            <unmanaged>MF_E_TRANSFORM_STREAM_CHANGE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformInputRemaining">
            <summary>Constant TransformInputRemaining</summary>
            <unmanaged>MF_E_TRANSFORM_INPUT_REMAINING</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformProfileMissing">
            <summary>Constant TransformProfileMissing</summary>
            <unmanaged>MF_E_TRANSFORM_PROFILE_MISSING</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformProfileInvalidOrCorrupt">
            <summary>Constant TransformProfileInvalidOrCorrupt</summary>
            <unmanaged>MF_E_TRANSFORM_PROFILE_INVALID_OR_CORRUPT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformProfileTruncated">
            <summary>Constant TransformProfileTruncated</summary>
            <unmanaged>MF_E_TRANSFORM_PROFILE_TRUNCATED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformPropertyPidNotRecognized">
            <summary>Constant TransformPropertyPidNotRecognized</summary>
            <unmanaged>MF_E_TRANSFORM_PROPERTY_PID_NOT_RECOGNIZED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformPropertyVariantTypeWrong">
            <summary>Constant TransformPropertyVariantTypeWrong</summary>
            <unmanaged>MF_E_TRANSFORM_PROPERTY_VARIANT_TYPE_WRONG</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformPropertyNotWriteAble">
            <summary>Constant TransformPropertyNotWriteAble</summary>
            <unmanaged>MF_E_TRANSFORM_PROPERTY_NOT_WRITEABLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformPropertyArrayValueWrongNumDim">
            <summary>Constant TransformPropertyArrayValueWrongNumDim</summary>
            <unmanaged>MF_E_TRANSFORM_PROPERTY_ARRAY_VALUE_WRONG_NUM_DIM</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformPropertyValueSizeWrong">
            <summary>Constant TransformPropertyValueSizeWrong</summary>
            <unmanaged>MF_E_TRANSFORM_PROPERTY_VALUE_SIZE_WRONG</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformPropertyValueOutOfRange">
            <summary>Constant TransformPropertyValueOutOfRange</summary>
            <unmanaged>MF_E_TRANSFORM_PROPERTY_VALUE_OUT_OF_RANGE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformPropertyValueIncompatible">
            <summary>Constant TransformPropertyValueIncompatible</summary>
            <unmanaged>MF_E_TRANSFORM_PROPERTY_VALUE_INCOMPATIBLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformNotPossibleForCurrentOutputMediaType">
            <summary>Constant TransformNotPossibleForCurrentOutputMediaType</summary>
            <unmanaged>MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_OUTPUT_MEDIATYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformNotPossibleForCurrentInputMediaType">
            <summary>Constant TransformNotPossibleForCurrentInputMediaType</summary>
            <unmanaged>MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_INPUT_MEDIATYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformNotPossibleForCurrentMediaTypeCombination">
            <summary>Constant TransformNotPossibleForCurrentMediaTypeCombination</summary>
            <unmanaged>MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_MEDIATYPE_COMBINATION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformConflictsWithOtherCurrentlyEnabledFeatures">
            <summary>Constant TransformConflictsWithOtherCurrentlyEnabledFeatures</summary>
            <unmanaged>MF_E_TRANSFORM_CONFLICTS_WITH_OTHER_CURRENTLY_ENABLED_FEATURES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformNeedMoreInput">
            <summary>Constant TransformNeedMoreInput</summary>
            <unmanaged>MF_E_TRANSFORM_NEED_MORE_INPUT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformNotPossibleForCurrentSpkrConfig">
            <summary>Constant TransformNotPossibleForCurrentSpkrConfig</summary>
            <unmanaged>MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_SPKR_CONFIG</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformCannotChangeMediaTypeWhileProcessing">
            <summary>Constant TransformCannotChangeMediaTypeWhileProcessing</summary>
            <unmanaged>MF_E_TRANSFORM_CANNOT_CHANGE_MEDIATYPE_WHILE_PROCESSING</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.UnsupportedD3DType">
            <summary>Constant UnsupportedD3DType</summary>
            <unmanaged>MF_E_UNSUPPORTED_D3D_TYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformAsyncLocked">
            <summary>Constant TransformAsyncLocked</summary>
            <unmanaged>MF_E_TRANSFORM_ASYNC_LOCKED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformCannotInitializeAcmDriver">
            <summary>Constant TransformCannotInitializeAcmDriver</summary>
            <unmanaged>MF_E_TRANSFORM_CANNOT_INITIALIZE_ACM_DRIVER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformStreamInvalidResolution">
            <summary>Constant TransformStreamInvalidResolution</summary>
            <unmanaged>MF_E_TRANSFORM_STREAM_INVALID_RESOLUTION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformAsyncMftNotSupported">
            <summary>Constant TransformAsyncMftNotSupported</summary>
            <unmanaged>MF_E_TRANSFORM_ASYNC_MFT_NOT_SUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TransformExattributeNotSupported">
            <summary>Constant TransformExattributeNotSupported</summary>
            <unmanaged>MF_E_TRANSFORM_EXATTRIBUTE_NOT_SUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.LicenseIncorrectRights">
            <summary>Constant LicenseIncorrectRights</summary>
            <unmanaged>MF_E_LICENSE_INCORRECT_RIGHTS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.LicenseOufOfDate">
            <summary>Constant LicenseOufOfDate</summary>
            <unmanaged>MF_E_LICENSE_OUTOFDATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.LicenseRequired">
            <summary>Constant LicenseRequired</summary>
            <unmanaged>MF_E_LICENSE_REQUIRED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.DrmHardwareInconsistent">
            <summary>Constant DrmHardwareInconsistent</summary>
            <unmanaged>MF_E_DRM_HARDWARE_INCONSISTENT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NoContentProtectionManager">
            <summary>Constant NoContentProtectionManager</summary>
            <unmanaged>MF_E_NO_CONTENT_PROTECTION_MANAGER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.LicenseRestoreNoRights">
            <summary>Constant LicenseRestoreNoRights</summary>
            <unmanaged>MF_E_LICENSE_RESTORE_NO_RIGHTS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.BackupRestrictedLicense">
            <summary>Constant BackupRestrictedLicense</summary>
            <unmanaged>MF_E_BACKUP_RESTRICTED_LICENSE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.LicenseRestoreNeedsIndividualization">
            <summary>Constant LicenseRestoreNeedsIndividualization</summary>
            <unmanaged>MF_E_LICENSE_RESTORE_NEEDS_INDIVIDUALIZATION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.ComponentRevoked">
            <summary>Constant ComponentRevoked</summary>
            <unmanaged>MF_E_COMPONENT_REVOKED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TrustDisabled">
            <summary>Constant TrustDisabled</summary>
            <unmanaged>MF_E_TRUST_DISABLED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.WmdrmotaNoAction">
            <summary>Constant WmdrmotaNoAction</summary>
            <unmanaged>MF_E_WMDRMOTA_NO_ACTION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.WmdrmotaActionAlreadySet">
            <summary>Constant WmdrmotaActionAlreadySet</summary>
            <unmanaged>MF_E_WMDRMOTA_ACTION_ALREADY_SET</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.WmdrmotaDrmHeaderNotAvailable">
            <summary>Constant WmdrmotaDrmHeaderNotAvailable</summary>
            <unmanaged>MF_E_WMDRMOTA_DRM_HEADER_NOT_AVAILABLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.WmdrmotaDrmEncryptionSchemeNotSupported">
            <summary>Constant WmdrmotaDrmEncryptionSchemeNotSupported</summary>
            <unmanaged>MF_E_WMDRMOTA_DRM_ENCRYPTION_SCHEME_NOT_SUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.WmdrmotaActionMismatch">
            <summary>Constant WmdrmotaActionMismatch</summary>
            <unmanaged>MF_E_WMDRMOTA_ACTION_MISMATCH</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.WmdrmotaInvalidPolicy">
            <summary>Constant WmdrmotaInvalidPolicy</summary>
            <unmanaged>MF_E_WMDRMOTA_INVALID_POLICY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.PolicyUnsupported">
            <summary>Constant PolicyUnsupported</summary>
            <unmanaged>MF_E_POLICY_UNSUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.OperationLNotSupported">
            <summary>Constant OperationLNotSupported</summary>
            <unmanaged>MF_E_OPL_NOT_SUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TopologyVerificationFailed">
            <summary>Constant TopologyVerificationFailed</summary>
            <unmanaged>MF_E_TOPOLOGY_VERIFICATION_FAILED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.SignatureVerificationFailed">
            <summary>Constant SignatureVerificationFailed</summary>
            <unmanaged>MF_E_SIGNATURE_VERIFICATION_FAILED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.DebuggingNotAllowEd">
            <summary>Constant DebuggingNotAllowEd</summary>
            <unmanaged>MF_E_DEBUGGING_NOT_ALLOWED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.CodeExpired">
            <summary>Constant CodeExpired</summary>
            <unmanaged>MF_E_CODE_EXPIRED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.GrlVersionTooLow">
            <summary>Constant GrlVersionTooLow</summary>
            <unmanaged>MF_E_GRL_VERSION_TOO_LOW</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.GrlRenewalNotFound">
            <summary>Constant GrlRenewalNotFound</summary>
            <unmanaged>MF_E_GRL_RENEWAL_NOT_FOUND</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.GrlExtensibleEntryNotFound">
            <summary>Constant GrlExtensibleEntryNotFound</summary>
            <unmanaged>MF_E_GRL_EXTENSIBLE_ENTRY_NOT_FOUND</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.KernelUntrusted">
            <summary>Constant KernelUntrusted</summary>
            <unmanaged>MF_E_KERNEL_UNTRUSTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.PeauthUntrusted">
            <summary>Constant PeauthUntrusted</summary>
            <unmanaged>MF_E_PEAUTH_UNTRUSTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NonPeProcess">
            <summary>Constant NonPeProcess</summary>
            <unmanaged>MF_E_NON_PE_PROCESS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.RebootRequired">
            <summary>Constant RebootRequired</summary>
            <unmanaged>MF_E_REBOOT_REQUIRED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.GrlInvalidFormat">
            <summary>Constant GrlInvalidFormat</summary>
            <unmanaged>MF_E_GRL_INVALID_FORMAT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.GrlUnrecognizedFormat">
            <summary>Constant GrlUnrecognizedFormat</summary>
            <unmanaged>MF_E_GRL_UNRECOGNIZED_FORMAT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AllProcessRestartRequired">
            <summary>Constant AllProcessRestartRequired</summary>
            <unmanaged>MF_E_ALL_PROCESS_RESTART_REQUIRED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.ProcessRestartRequired">
            <summary>Constant ProcessRestartRequired</summary>
            <unmanaged>MF_E_PROCESS_RESTART_REQUIRED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.UsermodeUntrusted">
            <summary>Constant UsermodeUntrusted</summary>
            <unmanaged>MF_E_USERMODE_UNTRUSTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.PeauthSessionNotStarted">
            <summary>Constant PeauthSessionNotStarted</summary>
            <unmanaged>MF_E_PEAUTH_SESSION_NOT_STARTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.PeauthPublickeyRevoked">
            <summary>Constant PeauthPublickeyRevoked</summary>
            <unmanaged>MF_E_PEAUTH_PUBLICKEY_REVOKED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.GrlAbsent">
            <summary>Constant GrlAbsent</summary>
            <unmanaged>MF_E_GRL_ABSENT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.PeUntrusted">
            <summary>Constant PeUntrusted</summary>
            <unmanaged>MF_E_PE_UNTRUSTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.PeauthNotStarted">
            <summary>Constant PeauthNotStarted</summary>
            <unmanaged>MF_E_PEAUTH_NOT_STARTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.IncompatibleSampleProtection">
            <summary>Constant IncompatibleSampleProtection</summary>
            <unmanaged>MF_E_INCOMPATIBLE_SAMPLE_PROTECTION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.PeSessionsMaximumEd">
            <summary>Constant PeSessionsMaximumEd</summary>
            <unmanaged>MF_E_PE_SESSIONS_MAXED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.HighSecurityLevelContentNotAllowEd">
            <summary>Constant HighSecurityLevelContentNotAllowEd</summary>
            <unmanaged>MF_E_HIGH_SECURITY_LEVEL_CONTENT_NOT_ALLOWED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TestSignedComponentsNotAllowEd">
            <summary>Constant TestSignedComponentsNotAllowEd</summary>
            <unmanaged>MF_E_TEST_SIGNED_COMPONENTS_NOT_ALLOWED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.ItaUnsupportedAction">
            <summary>Constant ItaUnsupportedAction</summary>
            <unmanaged>MF_E_ITA_UNSUPPORTED_ACTION</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.ItaErrorParsingSapParameters">
            <summary>Constant ItaErrorParsingSapParameters</summary>
            <unmanaged>MF_E_ITA_ERROR_PARSING_SAP_PARAMETERS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.PolicyMgrActionOufOfBounds">
            <summary>Constant PolicyMgrActionOufOfBounds</summary>
            <unmanaged>MF_E_POLICY_MGR_ACTION_OUTOFBOUNDS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.BadOperationLStructureFormat">
            <summary>Constant BadOperationLStructureFormat</summary>
            <unmanaged>MF_E_BAD_OPL_STRUCTURE_FORMAT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.ItaUnrecognizedAnalogVideoProtectionGuid">
            <summary>Constant ItaUnrecognizedAnalogVideoProtectionGuid</summary>
            <unmanaged>MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_PROTECTION_GUID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NoPmpHost">
            <summary>Constant NoPmpHost</summary>
            <unmanaged>MF_E_NO_PMP_HOST</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.ItaOperationLDataNotInitializeD">
            <summary>Constant ItaOperationLDataNotInitializeD</summary>
            <unmanaged>MF_E_ITA_OPL_DATA_NOT_INITIALIZED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.ItaUnrecognizedAnalogVideoOutput">
            <summary>Constant ItaUnrecognizedAnalogVideoOutput</summary>
            <unmanaged>MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_OUTPUT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.ItaUnrecognizedDigitalVideoOutput">
            <summary>Constant ItaUnrecognizedDigitalVideoOutput</summary>
            <unmanaged>MF_E_ITA_UNRECOGNIZED_DIGITAL_VIDEO_OUTPUT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.ResolutionRequiresPmpCreationCallback">
            <summary>Constant ResolutionRequiresPmpCreationCallback</summary>
            <unmanaged>MF_E_RESOLUTION_REQUIRES_PMP_CREATION_CALLBACK</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InvalidAkeChannelParameters">
            <summary>Constant InvalidAkeChannelParameters</summary>
            <unmanaged>MF_E_INVALID_AKE_CHANNEL_PARAMETERS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.ContentProtectionSystemNotEnabled">
            <summary>Constant ContentProtectionSystemNotEnabled</summary>
            <unmanaged>MF_E_CONTENT_PROTECTION_SYSTEM_NOT_ENABLED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.UnsupportedContentProtectionSystem">
            <summary>Constant UnsupportedContentProtectionSystem</summary>
            <unmanaged>MF_E_UNSUPPORTED_CONTENT_PROTECTION_SYSTEM</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.DrmMigrationNotSupported">
            <summary>Constant DrmMigrationNotSupported</summary>
            <unmanaged>MF_E_DRM_MIGRATION_NOT_SUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.HdcpAuthenticationFailure">
            <summary>Constant HdcpAuthenticationFailure</summary>
            <unmanaged>MF_E_HDCP_AUTHENTICATION_FAILURE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.HdcpLinkFailure">
            <summary>Constant HdcpLinkFailure</summary>
            <unmanaged>MF_E_HDCP_LINK_FAILURE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.ClockInvalidContinuityKey">
            <summary>Constant ClockInvalidContinuityKey</summary>
            <unmanaged>MF_E_CLOCK_INVALID_CONTINUITY_KEY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.ClockNoTimeSource">
            <summary>Constant ClockNoTimeSource</summary>
            <unmanaged>MF_E_CLOCK_NO_TIME_SOURCE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.ClockStateAlreadySet">
            <summary>Constant ClockStateAlreadySet</summary>
            <unmanaged>MF_E_CLOCK_STATE_ALREADY_SET</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.ClockNotSimple">
            <summary>Constant ClockNotSimple</summary>
            <unmanaged>MF_E_CLOCK_NOT_SIMPLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NoMoreDropModes">
            <summary>Constant NoMoreDropModes</summary>
            <unmanaged>MF_E_NO_MORE_DROP_MODES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NoMoreQualityLevels">
            <summary>Constant NoMoreQualityLevels</summary>
            <unmanaged>MF_E_NO_MORE_QUALITY_LEVELS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.DroptimeNotSupported">
            <summary>Constant DroptimeNotSupported</summary>
            <unmanaged>MF_E_DROPTIME_NOT_SUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.QualityknobWaitLonger">
            <summary>Constant QualityknobWaitLonger</summary>
            <unmanaged>MF_E_QUALITYKNOB_WAIT_LONGER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.QmInvalidState">
            <summary>Constant QmInvalidState</summary>
            <unmanaged>MF_E_QM_INVALIDSTATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TranscodeNoContainertype">
            <summary>Constant TranscodeNoContainertype</summary>
            <unmanaged>MF_E_TRANSCODE_NO_CONTAINERTYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TranscodeProfileNoMatchingStreams">
            <summary>Constant TranscodeProfileNoMatchingStreams</summary>
            <unmanaged>MF_E_TRANSCODE_PROFILE_NO_MATCHING_STREAMS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TranscodeNoMatchingEncoder">
            <summary>Constant TranscodeNoMatchingEncoder</summary>
            <unmanaged>MF_E_TRANSCODE_NO_MATCHING_ENCODER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TranscodeInvalidProfile">
            <summary>Constant TranscodeInvalidProfile</summary>
            <unmanaged>MF_E_TRANSCODE_INVALID_PROFILE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AllOcatorNotInitializeD">
            <summary>Constant AllOcatorNotInitializeD</summary>
            <unmanaged>MF_E_ALLOCATOR_NOT_INITIALIZED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AllOcatorNotCommited">
            <summary>Constant AllOcatorNotCommited</summary>
            <unmanaged>MF_E_ALLOCATOR_NOT_COMMITED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.AllOcatorAlreadyCommited">
            <summary>Constant AllOcatorAlreadyCommited</summary>
            <unmanaged>MF_E_ALLOCATOR_ALREADY_COMMITED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.StreamError">
            <summary>Constant StreamError</summary>
            <unmanaged>MF_E_STREAM_ERROR</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.InvalidStreamState">
            <summary>Constant InvalidStreamState</summary>
            <unmanaged>MF_E_INVALID_STREAM_STATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.HwStreamNotConnected">
            <summary>Constant HwStreamNotConnected</summary>
            <unmanaged>MF_E_HW_STREAM_NOT_CONNECTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.NoCaptureDevicesAvailable">
            <summary>Constant NoCaptureDevicesAvailable</summary>
            <unmanaged>MF_E_NO_CAPTURE_DEVICES_AVAILABLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.CaptureSinkOutputNotSet">
            <summary>Constant CaptureSinkOutputNotSet</summary>
            <unmanaged>MF_E_CAPTURE_SINK_OUTPUT_NOT_SET</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.CaptureSinkMirrorError">
            <summary>Constant CaptureSinkMirrorError</summary>
            <unmanaged>MF_E_CAPTURE_SINK_MIRROR_ERROR</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.CaptureSinkRotateError">
            <summary>Constant CaptureSinkRotateError</summary>
            <unmanaged>MF_E_CAPTURE_SINK_ROTATE_ERROR</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.CaptureEngineInvalidOperation">
            <summary>Constant CaptureEngineInvalidOperation</summary>
            <unmanaged>MF_E_CAPTURE_ENGINE_INVALID_OP</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.CaptureEngineAllEffectsRemoved">
            <summary>Constant CaptureEngineAllEffectsRemoved</summary>
            <unmanaged>MF_E_CAPTURE_ENGINE_ALL_EFFECTS_REMOVED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.CaptureSourceNoIndependentPhotoStreamPresent">
            <summary>Constant CaptureSourceNoIndependentPhotoStreamPresent</summary>
            <unmanaged>MF_E_CAPTURE_SOURCE_NO_INDEPENDENT_PHOTO_STREAM_PRESENT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.CaptureSourceNoVideoStreamPresent">
            <summary>Constant CaptureSourceNoVideoStreamPresent</summary>
            <unmanaged>MF_E_CAPTURE_SOURCE_NO_VIDEO_STREAM_PRESENT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.CaptureSourceNoAudioStreamPresent">
            <summary>Constant CaptureSourceNoAudioStreamPresent</summary>
            <unmanaged>MF_E_CAPTURE_SOURCE_NO_AUDIO_STREAM_PRESENT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.CaptureSourceDeviceExtendedpropOperationInProgress">
            <summary>Constant CaptureSourceDeviceExtendedpropOperationInProgress</summary>
            <unmanaged>MF_E_CAPTURE_SOURCE_DEVICE_EXTENDEDPROP_OP_IN_PROGRESS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.CapturePropertySetDuringPhoto">
            <summary>Constant CapturePropertySetDuringPhoto</summary>
            <unmanaged>MF_E_CAPTURE_PROPERTY_SET_DURING_PHOTO</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.CaptureNoSamplesInQueue">
            <summary>Constant CaptureNoSamplesInQueue</summary>
            <unmanaged>MF_E_CAPTURE_NO_SAMPLES_IN_QUEUE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.HwAcceleratedThumbnailNotSupported">
            <summary>Constant HwAcceleratedThumbnailNotSupported</summary>
            <unmanaged>MF_E_HW_ACCELERATED_THUMBNAIL_NOT_SUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.UnsupportedCaptureDevicePresent">
            <summary>Constant UnsupportedCaptureDevicePresent</summary>
            <unmanaged>MF_E_UNSUPPORTED_CAPTURE_DEVICE_PRESENT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TimelinecontrollerUnsupportedSourceType">
            <summary>Constant TimelinecontrollerUnsupportedSourceType</summary>
            <unmanaged>MF_E_TIMELINECONTROLLER_UNSUPPORTED_SOURCE_TYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TimelinecontrollerNotAllowEd">
            <summary>Constant TimelinecontrollerNotAllowEd</summary>
            <unmanaged>MF_E_TIMELINECONTROLLER_NOT_ALLOWED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.TimelinecontrollerCannotAttach">
            <summary>Constant TimelinecontrollerCannotAttach</summary>
            <unmanaged>MF_E_TIMELINECONTROLLER_CANNOT_ATTACH</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.MediaExtensionAppserviceConnectionFailed">
            <summary>Constant MediaExtensionAppserviceConnectionFailed</summary>
            <unmanaged>MF_E_MEDIA_EXTENSION_APPSERVICE_CONNECTION_FAILED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.MediaExtensionAppserviceRequestFailed">
            <summary>Constant MediaExtensionAppserviceRequestFailed</summary>
            <unmanaged>MF_E_MEDIA_EXTENSION_APPSERVICE_REQUEST_FAILED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.MediaExtensionPackageIntegrityCheckFailed">
            <summary>Constant MediaExtensionPackageIntegrityCheckFailed</summary>
            <unmanaged>MF_E_MEDIA_EXTENSION_PACKAGE_INTEGRITY_CHECK_FAILED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.ResultCode.MediaExtensionPackageLicenseInvalid">
            <summary>Constant MediaExtensionPackageLicenseInvalid</summary>
            <unmanaged>MF_E_MEDIA_EXTENSION_PACKAGE_LICENSE_INVALID</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.SampleAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.Video3D">
            <summary>Constant Video3D</summary>
            <unmanaged>MFSampleExtension_3DVideo</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.Video3DSampleFormat">
            <summary>Constant Video3DSampleFormat</summary>
            <unmanaged>MFSampleExtension_3DVideo_SampleFormat</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.BottomFieldFirst">
            <summary>Constant BottomFieldFirst</summary>
            <unmanaged>MFSampleExtension_BottomFieldFirst</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.CleanPoint">
            <summary>Constant CleanPoint</summary>
            <unmanaged>MFSampleExtension_CleanPoint</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.DecodeTimestamp">
            <summary>Constant DecodeTimestamp</summary>
            <unmanaged>MFSampleExtension_DecodeTimestamp</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.DerivedFromTopField">
            <summary>Constant DerivedFromTopField</summary>
            <unmanaged>MFSampleExtension_DerivedFromTopField</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.DeviceTimestamp">
            <summary>Constant DeviceTimestamp</summary>
            <unmanaged>MFSampleExtension_DeviceTimestamp</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.Discontinuity">
            <summary>Constant Discontinuity</summary>
            <unmanaged>MFSampleExtension_Discontinuity</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.FrameCorruption">
            <summary>Constant FrameCorruption</summary>
            <unmanaged>MFSampleExtension_FrameCorruption</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.Interlaced">
            <summary>Constant Interlaced</summary>
            <unmanaged>MFSampleExtension_Interlaced</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.PacketCrossOffsets">
            <summary>Constant PacketCrossOffsets</summary>
            <unmanaged>MFSampleExtension_PacketCrossOffsets</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.RepeatFirstField">
            <summary>Constant RepeatFirstField</summary>
            <unmanaged>MFSampleExtension_RepeatFirstField</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.SingleField">
            <summary>Constant SingleField</summary>
            <unmanaged>MFSampleExtension_SingleField</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.Token">
            <summary>Constant Token</summary>
            <unmanaged>MFSampleExtension_Token</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.VideoEncodePictureType">
            <summary>Constant VideoEncodePictureType</summary>
            <unmanaged>MFSampleExtension_VideoEncodePictureType</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.VideoEncodeQP">
            <summary>Constant VideoEncodeQP</summary>
            <unmanaged>MFSampleExtension_VideoEncodeQP</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.DescrambleData">
            <summary>Constant DescrambleData</summary>
            <unmanaged>MFSampleExtension_DescrambleData</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.SampleKeyID">
            <summary>Constant SampleKeyID</summary>
            <unmanaged>MFSampleExtension_SampleKeyID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.GenKeyFunc">
            <summary>Constant GenKeyFunc</summary>
            <unmanaged>MFSampleExtension_GenKeyFunc</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleAttributeKeys.GenKeyCtx">
            <summary>Constant GenKeyCtx</summary>
            <unmanaged>MFSampleExtension_GenKeyCtx</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.SampleGrabberSinkAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleGrabberSinkAttributeKeys.IgnoreClock">
            <summary>Constant IgnoreClock</summary>
            <unmanaged>MF_SAMPLEGRABBERSINK_IGNORE_CLOCK</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SampleGrabberSinkAttributeKeys.SampleTimeOffset">
            <summary>Constant SampleTimeOffset</summary>
            <unmanaged>MF_SAMPLEGRABBERSINK_SAMPLE_TIME_OFFSET</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.SinkWriterAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterAttributeKeys.LowLatency">
            <summary>Constant LowLatency</summary>
            <unmanaged>MF_LOW_LATENCY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterAttributeKeys.ReadwriteD3DOptional">
            <summary>Constant ReadwriteD3DOptional</summary>
            <unmanaged>MF_READWRITE_D3D_OPTIONAL</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterAttributeKeys.ReadwriteDisableConverters">
            <summary>Constant ReadwriteDisableConverters</summary>
            <unmanaged>MF_READWRITE_DISABLE_CONVERTERS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterAttributeKeys.ReadwriteEnableHardwareTransforms">
            <summary>Constant ReadwriteEnableHardwareTransforms</summary>
            <unmanaged>MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterAttributeKeys.ReadwriteMmcssClass">
            <summary>Constant ReadwriteMmcssClass</summary>
            <unmanaged>MF_READWRITE_MMCSS_CLASS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterAttributeKeys.ReadwriteMmcssClassAudio">
            <summary>Constant ReadwriteMmcssClassAudio</summary>
            <unmanaged>MF_READWRITE_MMCSS_CLASS_AUDIO</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterAttributeKeys.ReadwriteMmcssPriority">
            <summary>Constant ReadwriteMmcssPriority</summary>
            <unmanaged>MF_READWRITE_MMCSS_PRIORITY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterAttributeKeys.ReadwriteMmcssPriorityAudio">
            <summary>Constant ReadwriteMmcssPriorityAudio</summary>
            <unmanaged>MF_READWRITE_MMCSS_PRIORITY_AUDIO</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterAttributeKeys.AsyncCallback">
            <summary>Constant AsyncCallback</summary>
            <unmanaged>MF_SINK_WRITER_ASYNC_CALLBACK</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterAttributeKeys.D3DManager">
            <summary>Constant D3DManager</summary>
            <unmanaged>MF_SINK_WRITER_D3D_MANAGER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterAttributeKeys.DisableThrottling">
            <summary>Constant DisableThrottling</summary>
            <unmanaged>MF_SINK_WRITER_DISABLE_THROTTLING</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterAttributeKeys.EncoderConfig">
            <summary>Constant EncoderConfig</summary>
            <unmanaged>MF_SINK_WRITER_ENCODER_CONFIG</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.SourceReaderAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderAttributeKeys.AsyncCallback">
            <summary>Constant AsyncCallback</summary>
            <unmanaged>MF_SOURCE_READER_ASYNC_CALLBACK</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderAttributeKeys.D3DManager">
            <summary>Constant D3DManager</summary>
            <unmanaged>MF_SOURCE_READER_D3D_MANAGER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderAttributeKeys.DisableCameraPlugins">
            <summary>Constant DisableCameraPlugins</summary>
            <unmanaged>MF_SOURCE_READER_DISABLE_CAMERA_PLUGINS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderAttributeKeys.DisableDxva">
            <summary>Constant DisableDxva</summary>
            <unmanaged>MF_SOURCE_READER_DISABLE_DXVA</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderAttributeKeys.DisconnectMediasourceOnShutdown">
            <summary>Constant DisconnectMediasourceOnShutdown</summary>
            <unmanaged>MF_SOURCE_READER_DISCONNECT_MEDIASOURCE_ON_SHUTDOWN</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderAttributeKeys.EnableAdvancedVideoProcessing">
            <summary>Constant EnableAdvancedVideoProcessing</summary>
            <unmanaged>MF_SOURCE_READER_ENABLE_ADVANCED_VIDEO_PROCESSING</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderAttributeKeys.EnableTranscodeOnlyTransforms">
            <summary>Constant EnableTranscodeOnlyTransforms</summary>
            <unmanaged>MF_SOURCE_READER_ENABLE_TRANSCODE_ONLY_TRANSFORMS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderAttributeKeys.EnableVideoProcessing">
            <summary>Constant EnableVideoProcessing</summary>
            <unmanaged>MF_SOURCE_READER_ENABLE_VIDEO_PROCESSING</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderAttributeKeys.MediaSourceCharacteristics">
            <summary>Constant MediaSourceCharacteristics</summary>
            <unmanaged>MF_SOURCE_READER_MEDIASOURCE_CHARACTERISTICS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.SourceReaderAttributeKeys.MediaSourceConfig">
            <summary>Constant MediaSourceConfig</summary>
            <unmanaged>MF_SOURCE_READER_MEDIASOURCE_CONFIG</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.StreamDescriptorAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamDescriptorAttributeKeys.AsfExtstrmpropAvgBuffersize">
            <summary>Constant AsfExtstrmpropAvgBuffersize</summary>
            <unmanaged>MF_SD_ASF_EXTSTRMPROP_AVG_BUFFERSIZE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamDescriptorAttributeKeys.AsfExtstrmpropAvgDataBitrate">
            <summary>Constant AsfExtstrmpropAvgDataBitrate</summary>
            <unmanaged>MF_SD_ASF_EXTSTRMPROP_AVG_DATA_BITRATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamDescriptorAttributeKeys.AsfExtstrmpropLanguageIdIndex">
            <summary>Constant AsfExtstrmpropLanguageIdIndex</summary>
            <unmanaged>MF_SD_ASF_EXTSTRMPROP_LANGUAGE_ID_INDEX</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamDescriptorAttributeKeys.AsfExtstrmpropMaxBuffersize">
            <summary>Constant AsfExtstrmpropMaxBuffersize</summary>
            <unmanaged>MF_SD_ASF_EXTSTRMPROP_MAX_BUFFERSIZE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamDescriptorAttributeKeys.AsfExtstrmpropMaxDataBitrate">
            <summary>Constant AsfExtstrmpropMaxDataBitrate</summary>
            <unmanaged>MF_SD_ASF_EXTSTRMPROP_MAX_DATA_BITRATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamDescriptorAttributeKeys.AsfMetadataDeviceConformanceTemplate">
            <summary>Constant AsfMetadataDeviceConformanceTemplate</summary>
            <unmanaged>MF_SD_ASF_METADATA_DEVICE_CONFORMANCE_TEMPLATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamDescriptorAttributeKeys.AsfStreambitratesBitrate">
            <summary>Constant AsfStreambitratesBitrate</summary>
            <unmanaged>MF_SD_ASF_STREAMBITRATES_BITRATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamDescriptorAttributeKeys.Language">
            <summary>Constant Language</summary>
            <unmanaged>MF_SD_LANGUAGE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamDescriptorAttributeKeys.MutuallyExclusive">
            <summary>Constant MutuallyExclusive</summary>
            <unmanaged>MF_SD_MUTUALLY_EXCLUSIVE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamDescriptorAttributeKeys.Protected">
            <summary>Constant Protected</summary>
            <unmanaged>MF_SD_PROTECTED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamDescriptorAttributeKeys.SamiLanguage">
            <summary>Constant SamiLanguage</summary>
            <unmanaged>MF_SD_SAMI_LANGUAGE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamDescriptorAttributeKeys.StreamName">
            <summary>Constant StreamName</summary>
            <unmanaged>MF_SD_STREAM_NAME</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.TopologyAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyAttributeKeys.DXVAMode">
            <summary>Constant DXVAMode</summary>
            <unmanaged>MF_TOPOLOGY_DXVA_MODE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyAttributeKeys.DynamicChangeNotAllowed">
            <summary>Constant DynamicChangeNotAllowed</summary>
            <unmanaged>MF_TOPOLOGY_DYNAMIC_CHANGE_NOT_ALLOWED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyAttributeKeys.EnumerateSourceTypes">
            <summary>Constant EnumerateSourceTypes</summary>
            <unmanaged>MF_TOPOLOGY_ENUMERATE_SOURCE_TYPES</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyAttributeKeys.HardwareMode">
            <summary>Constant HardwareMode</summary>
            <unmanaged>MF_TOPOLOGY_HARDWARE_MODE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyAttributeKeys.NoMarkinMarkout">
            <summary>Constant NoMarkinMarkout</summary>
            <unmanaged>MF_TOPOLOGY_NO_MARKIN_MARKOUT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyAttributeKeys.PlaybackFramerate">
            <summary>Constant PlaybackFramerate</summary>
            <unmanaged>MF_TOPOLOGY_PLAYBACK_FRAMERATE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyAttributeKeys.PlaybackMaxDimensions">
            <summary>Constant PlaybackMaxDimensions</summary>
            <unmanaged>MF_TOPOLOGY_PLAYBACK_MAX_DIMS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyAttributeKeys.ProjectStart">
            <summary>Constant ProjectStart</summary>
            <unmanaged>MF_TOPOLOGY_PROJECTSTART</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyAttributeKeys.ProjectStop">
            <summary>Constant ProjectStop</summary>
            <unmanaged>MF_TOPOLOGY_PROJECTSTOP</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyAttributeKeys.ResolutionStatus">
            <summary>Constant ResolutionStatus</summary>
            <unmanaged>MF_TOPOLOGY_RESOLUTION_STATUS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyAttributeKeys.StartTimeOnPresentationSwitch">
            <summary>Constant StartTimeOnPresentationSwitch</summary>
            <unmanaged>MF_TOPOLOGY_START_TIME_ON_PRESENTATION_SWITCH</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyAttributeKeys.StaticPlaybackOptimizations">
            <summary>Constant StaticPlaybackOptimizations</summary>
            <unmanaged>MF_TOPOLOGY_STATIC_PLAYBACK_OPTIMIZATIONS</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.TopologyNodeAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.ConnectMethod">
            <summary>Constant ConnectMethod</summary>
            <unmanaged>MF_TOPONODE_CONNECT_METHOD</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.D3DAWARE">
            <summary>Constant D3DAWARE</summary>
            <unmanaged>MF_TOPONODE_D3DAWARE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.Decoder">
            <summary>Constant Decoder</summary>
            <unmanaged>MF_TOPONODE_DECODER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.Decryptor">
            <summary>Constant Decryptor</summary>
            <unmanaged>MF_TOPONODE_DECRYPTOR</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.DisablePreroll">
            <summary>Constant DisablePreroll</summary>
            <unmanaged>MF_TOPONODE_DISABLE_PREROLL</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.Discardable">
            <summary>Constant Discardable</summary>
            <unmanaged>MF_TOPONODE_DISCARDABLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.Drain">
            <summary>Constant Drain</summary>
            <unmanaged>MF_TOPONODE_DRAIN</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.ErrorMajortype">
            <summary>Constant ErrorMajortype</summary>
            <unmanaged>MF_TOPONODE_ERROR_MAJORTYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.ErrorSubtype">
            <summary>Constant ErrorSubtype</summary>
            <unmanaged>MF_TOPONODE_ERROR_SUBTYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.Errorcode">
            <summary>Constant Errorcode</summary>
            <unmanaged>MF_TOPONODE_ERRORCODE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.Flush">
            <summary>Constant Flush</summary>
            <unmanaged>MF_TOPONODE_FLUSH</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.Locked">
            <summary>Constant Locked</summary>
            <unmanaged>MF_TOPONODE_LOCKED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.MarkinHere">
            <summary>Constant MarkinHere</summary>
            <unmanaged>MF_TOPONODE_MARKIN_HERE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.MarkoutHere">
            <summary>Constant MarkoutHere</summary>
            <unmanaged>MF_TOPONODE_MARKOUT_HERE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.Mediastart">
            <summary>Constant Mediastart</summary>
            <unmanaged>MF_TOPONODE_MEDIASTART</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.Mediastop">
            <summary>Constant Mediastop</summary>
            <unmanaged>MF_TOPONODE_MEDIASTOP</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.NoshutdownOnRemove">
            <summary>Constant NoshutdownOnRemove</summary>
            <unmanaged>MF_TOPONODE_NOSHUTDOWN_ON_REMOVE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.PresentationDescriptor">
            <summary>Constant PresentationDescriptor</summary>
            <unmanaged>MF_TOPONODE_PRESENTATION_DESCRIPTOR</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.Primaryoutput">
            <summary>Constant Primaryoutput</summary>
            <unmanaged>MF_TOPONODE_PRIMARYOUTPUT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.Rateless">
            <summary>Constant Rateless</summary>
            <unmanaged>MF_TOPONODE_RATELESS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.SequenceElementid">
            <summary>Constant SequenceElementid</summary>
            <unmanaged>MF_TOPONODE_SEQUENCE_ELEMENTID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.Source">
            <summary>Constant Source</summary>
            <unmanaged>MF_TOPONODE_SOURCE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.StreamDescriptor">
            <summary>Constant StreamDescriptor</summary>
            <unmanaged>MF_TOPONODE_STREAM_DESCRIPTOR</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.Streamid">
            <summary>Constant Streamid</summary>
            <unmanaged>MF_TOPONODE_STREAMID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.TransformObjectid">
            <summary>Constant TransformObjectid</summary>
            <unmanaged>MF_TOPONODE_TRANSFORM_OBJECTID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.WorkqueueId">
            <summary>Constant WorkqueueId</summary>
            <unmanaged>MF_TOPONODE_WORKQUEUE_ID</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.WorkqueueItemPriority">
            <summary>Constant WorkqueueItemPriority</summary>
            <unmanaged>MF_TOPONODE_WORKQUEUE_ITEM_PRIORITY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.WorkqueueMmcssClass">
            <summary>Constant WorkqueueMmcssClass</summary>
            <unmanaged>MF_TOPONODE_WORKQUEUE_MMCSS_CLASS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.WorkqueueMmcssPriority">
            <summary>Constant WorkqueueMmcssPriority</summary>
            <unmanaged>MF_TOPONODE_WORKQUEUE_MMCSS_PRIORITY</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TopologyNodeAttributeKeys.WorkqueueMmcssTaskid">
            <summary>Constant WorkqueueMmcssTaskid</summary>
            <unmanaged>MF_TOPONODE_WORKQUEUE_MMCSS_TASKID</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.TranscodeAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeAdjustProfile">
            <summary>Constant TranscodeAdjustProfile</summary>
            <unmanaged>MF_TRANSCODE_ADJUST_PROFILE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeContainertype">
            <summary>Constant TranscodeContainertype</summary>
            <unmanaged>MF_TRANSCODE_CONTAINERTYPE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeDonotInsertEncoder">
            <summary>Constant TranscodeDonotInsertEncoder</summary>
            <unmanaged>MF_TRANSCODE_DONOT_INSERT_ENCODER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeEncodingprofile">
            <summary>Constant TranscodeEncodingprofile</summary>
            <unmanaged>MF_TRANSCODE_ENCODINGPROFILE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeQualityvsspeed">
            <summary>Constant TranscodeQualityvsspeed</summary>
            <unmanaged>MF_TRANSCODE_QUALITYVSSPEED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeSkipMetadataTransfer">
            <summary>Constant TranscodeSkipMetadataTransfer</summary>
            <unmanaged>MF_TRANSCODE_SKIP_METADATA_TRANSFER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeAttributeKeys.TranscodeTopologymode">
            <summary>Constant TranscodeTopologymode</summary>
            <unmanaged>MF_TRANSCODE_TOPOLOGYMODE</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.TranscodeContainerTypeGuids">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeContainerTypeGuids.Asf">
            <summary>Constant Asf</summary>
            <unmanaged>MFTranscodeContainerType_ASF</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeContainerTypeGuids.Mpeg4">
            <summary>Constant Mpeg4</summary>
            <unmanaged>MFTranscodeContainerType_MPEG4</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeContainerTypeGuids.Mp3">
            <summary>Constant Mp3</summary>
            <unmanaged>MFTranscodeContainerType_MP3</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeContainerTypeGuids.Flac">
            <summary>Constant Flac</summary>
            <unmanaged>MFTranscodeContainerType_FLAC</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeContainerTypeGuids.Ac3">
            <summary>Constant Ac3</summary>
            <unmanaged>MFTranscodeContainerType_AC3</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeContainerTypeGuids.Adts">
            <summary>Constant Adts</summary>
            <unmanaged>MFTranscodeContainerType_ADTS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeContainerTypeGuids.Mpeg2">
            <summary>Constant Mpeg2</summary>
            <unmanaged>MFTranscodeContainerType_MPEG2</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeContainerTypeGuids.Wave">
            <summary>Constant Wave</summary>
            <unmanaged>MFTranscodeContainerType_WAVE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeContainerTypeGuids.Avi">
            <summary>Constant Avi</summary>
            <unmanaged>MFTranscodeContainerType_AVI</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeContainerTypeGuids.Fmpeg4">
            <summary>Constant Fmpeg4</summary>
            <unmanaged>MFTranscodeContainerType_FMPEG4</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeContainerTypeGuids.Amr">
            <summary>Constant Amr</summary>
            <unmanaged>MFTranscodeContainerType_AMR</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeContainerTypeGuids.Mobile3gp">
            <summary>Constant Mobile3gp</summary>
            <unmanaged>MFTranscodeContainerType_3GP</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.TransformAttributeKeys">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.ActivateMftLocked">
            <summary>Constant ActivateMftLocked</summary>
            <unmanaged>MF_ACTIVATE_MFT_LOCKED</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.DisableLocallyRegisteredPlugins">
            <summary>Constant DisableLocallyRegisteredPlugins</summary>
            <unmanaged>MF_DISABLE_LOCALLY_REGISTERED_PLUGINS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.Enable3dvideoOutput">
            <summary>Constant Enable3dvideoOutput</summary>
            <unmanaged>MF_ENABLE_3DVIDEO_OUTPUT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.BuffersPerSample">
            <summary>Constant BuffersPerSample</summary>
            <unmanaged>MF_SA_BUFFERS_PER_SAMPLE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.D3DAware">
            <summary>Constant D3DAware</summary>
            <unmanaged>MF_SA_D3D_AWARE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.D3D11Aware">
            <summary>Constant D3D11Aware</summary>
            <unmanaged>MF_SA_D3D11_AWARE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.D3D11Bindflags">
            <summary>Constant D3D11Bindflags</summary>
            <unmanaged>MF_SA_D3D11_BINDFLAGS</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.D3D11Usage">
            <summary>Constant D3D11Usage</summary>
            <unmanaged>MF_SA_D3D11_USAGE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.TransformAsync">
            <summary>Constant TransformAsync</summary>
            <unmanaged>MF_TRANSFORM_ASYNC</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.TransformAsyncUnlock">
            <summary>Constant TransformAsyncUnlock</summary>
            <unmanaged>MF_TRANSFORM_ASYNC_UNLOCK</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.TransformCategoryAttribute">
            <summary>Constant TransformCategoryAttribute</summary>
            <unmanaged>MF_TRANSFORM_CATEGORY_Attribute</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.TransformFlagsAttribute">
            <summary>Constant TransformFlagsAttribute</summary>
            <unmanaged>MF_TRANSFORM_FLAGS_Attribute</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftCodecMeritAttribute">
            <summary>Constant MftCodecMeritAttribute</summary>
            <unmanaged>MFT_CODEC_MERIT_Attribute</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftConnectedStreamAttribute">
            <summary>Constant MftConnectedStreamAttribute</summary>
            <unmanaged>MFT_CONNECTED_STREAM_ATTRIBUTE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftConnectedToHwStream">
            <summary>Constant MftConnectedToHwStream</summary>
            <unmanaged>MFT_CONNECTED_TO_HW_STREAM</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftDecoderExposeOutputTypesInNativeOrder">
            <summary>Constant MftDecoderExposeOutputTypesInNativeOrder</summary>
            <unmanaged>MFT_DECODER_EXPOSE_OUTPUT_TYPES_IN_NATIVE_ORDER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftDecoderFinalVideoResolutionHint">
            <summary>Constant MftDecoderFinalVideoResolutionHint</summary>
            <unmanaged>MFT_DECODER_FINAL_VIDEO_RESOLUTION_HINT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftEnumHardwareUrlAttribute">
            <summary>Constant MftEnumHardwareUrlAttribute</summary>
            <unmanaged>MFT_ENUM_HARDWARE_URL_Attribute</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftEnumHardwareVendorIdAttribute">
            <summary>Constant MftEnumHardwareVendorIdAttribute</summary>
            <unmanaged>MFT_ENUM_HARDWARE_VENDOR_ID_Attribute</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftEnumTranscodeOnlyAttribute">
            <summary>Constant MftEnumTranscodeOnlyAttribute</summary>
            <unmanaged>MFT_ENUM_TRANSCODE_ONLY_ATTRIBUTE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftFieldofuseUnlockAttribute">
            <summary>Constant MftFieldofuseUnlockAttribute</summary>
            <unmanaged>MFT_FIELDOFUSE_UNLOCK_Attribute</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftFriendlyNameAttribute">
            <summary>Constant MftFriendlyNameAttribute</summary>
            <unmanaged>MFT_FRIENDLY_NAME_Attribute</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftHwTimestampWithQpcAttribute">
            <summary>Constant MftHwTimestampWithQpcAttribute</summary>
            <unmanaged>MFT_HW_TIMESTAMP_WITH_QPC_Attribute</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftInputTypesAttributes">
            <summary>Constant MftInputTypesAttributes</summary>
            <unmanaged>MFT_INPUT_TYPES_Attributes</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftOutputTypesAttributes">
            <summary>Constant MftOutputTypesAttributes</summary>
            <unmanaged>MFT_OUTPUT_TYPES_Attributes</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftPreferredEncoderProfile">
            <summary>Constant MftPreferredEncoderProfile</summary>
            <unmanaged>MFT_PREFERRED_ENCODER_PROFILE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftPreferredOutputtypeAttribute">
            <summary>Constant MftPreferredOutputtypeAttribute</summary>
            <unmanaged>MFT_PREFERRED_OUTPUTTYPE_Attribute</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftProcessLocalAttribute">
            <summary>Constant MftProcessLocalAttribute</summary>
            <unmanaged>MFT_PROCESS_LOCAL_Attribute</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftSupport3dvideo">
            <summary>Constant MftSupport3dvideo</summary>
            <unmanaged>MFT_SUPPORT_3DVIDEO</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftSupportDynamicFormatChange">
            <summary>Constant MftSupportDynamicFormatChange</summary>
            <unmanaged>MFT_SUPPORT_DYNAMIC_FORMAT_CHANGE</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformAttributeKeys.MftTransformClsidAttribute">
            <summary>Constant MftTransformClsidAttribute</summary>
            <unmanaged>MFT_TRANSFORM_CLSID_Attribute</unmanaged>
        </member>
        <member name="T:SharpDX.MediaFoundation.TransformCategoryGuids">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformCategoryGuids.VideoDecoder">
            <summary>Constant VideoDecoder</summary>
            <unmanaged>MFT_CATEGORY_VIDEO_DECODER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformCategoryGuids.VideoEncoder">
            <summary>Constant VideoEncoder</summary>
            <unmanaged>MFT_CATEGORY_VIDEO_ENCODER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformCategoryGuids.VideoEffect">
            <summary>Constant VideoEffect</summary>
            <unmanaged>MFT_CATEGORY_VIDEO_EFFECT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformCategoryGuids.Multiplexer">
            <summary>Constant Multiplexer</summary>
            <unmanaged>MFT_CATEGORY_MULTIPLEXER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformCategoryGuids.Demultiplexer">
            <summary>Constant Demultiplexer</summary>
            <unmanaged>MFT_CATEGORY_DEMULTIPLEXER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformCategoryGuids.AudioDecoder">
            <summary>Constant AudioDecoder</summary>
            <unmanaged>MFT_CATEGORY_AUDIO_DECODER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformCategoryGuids.AudioEncoder">
            <summary>Constant AudioEncoder</summary>
            <unmanaged>MFT_CATEGORY_AUDIO_ENCODER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformCategoryGuids.AudioEffect">
            <summary>Constant AudioEffect</summary>
            <unmanaged>MFT_CATEGORY_AUDIO_EFFECT</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformCategoryGuids.VideoProcessor">
            <summary>Constant VideoProcessor</summary>
            <unmanaged>MFT_CATEGORY_VIDEO_PROCESSOR</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformCategoryGuids.Other">
            <summary>Constant Other</summary>
            <unmanaged>MFT_CATEGORY_OTHER</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformCategoryGuids.Encryptor">
            <summary>Constant Encryptor</summary>
            <unmanaged>MFT_CATEGORY_ENCRYPTOR</unmanaged>
        </member>
        <member name="F:SharpDX.MediaFoundation.TransformCategoryGuids.VideoRendererEffect">
            <summary>Constant VideoRendererEffect</summary>
            <unmanaged>MFT_CATEGORY_VIDEO_RENDERER_EFFECT</unmanaged>
        </member>
        <member name="P:SharpDX.MediaFoundation.ASFContentInfo.Profile">
            <summary>
            <p> </p><p>Retrieves an Advanced Systems Format (ASF) profile that describes the ASF content.</p>
            </summary>
            <remarks>
            <p>The profile is set by calling either <strong>IMFASFContentInfo::SetProfile</strong> or <strong>IMFASFContentInfo::ParseHeader</strong>.</p><p>The ASF profile object returned by this method does not include any of the <strong>MF_PD_ASF_xxx</strong> attributes (see Presentation Descriptor Attributes). To get these attributes, do the following:</p><ol> <li> <p>Call <strong>IMFASFContentInfo::GeneratePresentationDescriptor</strong> to get the ASF presentation descriptor. You can query the presentation descriptor for the <strong>MF_PD_ASF_xxx</strong> attributes.</p> </li> <li> <p>(Optional.) Call <strong>MFCreateASFProfileFromPresentationDescriptor</strong> to convert the presentation descriptor into an ASF profile. The profile object created by this function contains the <strong>MF_PD_ASF_xxx</strong> attributes.</p> </li> </ol><p>An ASF profile is a template for file encoding, and is intended mainly for creating ASF content. If you are reading an existing ASF file, it is recommended that you use the presentation descriptor to get information about the file. One exception is that the profile contains the mutual exclusion and stream prioritization objects, which are not exposed directly from the presentation descriptor.</p>
            </remarks>
            <doc-id>ms698931</doc-id>
            <unmanaged>GetProfile / SetProfile</unmanaged>
            <unmanaged-short>GetProfile</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFContentInfo.GetHeaderSize(SharpDX.MediaFoundation.MediaBuffer,System.Int64)">
            <summary>
            <p> Retrieves the size of the header section of an Advanced Systems Format (ASF) file. </p>
            </summary>
            <param name = "iStartOfContentRef"><dd> <p>The <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of a buffer object containing the beginning of ASF content. The size of the valid data in the buffer must be at least MFASF_MIN_HEADER_BYTES in bytes.</p> </dd></param>
            <param name = "cbHeaderSize"><dd> <p>Receives the size, in bytes, of the header section of the content. The value includes the size of the ASF Header Object plus the size of the header section of the Data Object. Therefore, the resulting value is the offset to the start of the data packets in the ASF Data Object.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:AsfInvalidData"/></strong></dt> </dl> </td><td> <p> The buffer does not contain valid ASF data. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:BufferTooSmall"/></strong></dt> </dl> </td><td> <p> The buffer does not contain enough valid data. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The header of an ASF file or stream can be passed to the <strong>IMFASFContentInfo::ParseHeader</strong> method to populate the ContentInfo object with the header information.</p>
            </remarks>
            <doc-id>ms703043</doc-id>
            <unmanaged>HRESULT IMFASFContentInfo::GetHeaderSize([In] IMFMediaBuffer* pIStartOfContent,[In] unsigned longlong* cbHeaderSize)</unmanaged>
            <unmanaged-short>IMFASFContentInfo::GetHeaderSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFContentInfo.ParseHeader(SharpDX.MediaFoundation.MediaBuffer,System.Int64)">
            <summary>
            <p> </p><p>Parses the information in an ASF header and uses that information to set values in the ContentInfo object. You can pass the entire header in a single buffer or send it in several pieces.</p>
            </summary>
            <param name = "iHeaderBufferRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of a buffer object containing some or all of the header. The buffer must contain at least 30 bytes, which is the size of the Header Object, not including the objects contained in the Header Object (that is, everything up to and including the Reserved2 field in the Header Object).</p> </dd></param>
            <param name = "cbOffsetWithinHeader"><dd> <p>Offset, in bytes, of the first byte in the buffer relative to the beginning of the header.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The header is completely parsed and validated.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:AsfInvalidData"/></strong></dt> </dl> </td><td> <p>The input buffer does not contain valid ASF data.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:BufferTooSmall"/></strong></dt> </dl> </td><td> <p>The input buffer is to small.</p> </td></tr> <tr><td> <dl> <dt><strong>MF_S_ASF_PARSEINPROGRESS</strong></dt> </dl> </td><td> <p>The method succeeded, but the header passed was incomplete. This is the successful return code for all calls but the last one when passing the header in pieces.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If you pass the header in pieces, the ContentInfo object will keep references to the buffer objects until the entire header is parsed. Therefore, do not write over the buffers passed into this method.</p><p>The start of the Header object has the following layout in memory:</p><table> <tr><th>Field Name</th><th>Size in bytes</th></tr> <tr><td>Object ID</td><td>16</td></tr> <tr><td>Object Size</td><td>8</td></tr> <tr><td>Number of Header Objects</td><td>4</td></tr> <tr><td>Reserved1</td><td>1</td></tr> <tr><td>Reserved2</td><td>1</td></tr> </table><p>?</p><p>The first call to <strong>ParseHeader</strong> reads everything up to and including Rerserved2, so it requires a minimum of 30 bytes. (Note that the <strong>IMFASFContentInfo::GetHeaderSize</strong> method reads only the Object ID and Object Size fields, so that method requires a minimum of 24 bytes.)</p>
            </remarks>
            <doc-id>ms694306</doc-id>
            <unmanaged>HRESULT IMFASFContentInfo::ParseHeader([In] IMFMediaBuffer* pIHeaderBuffer,[In] unsigned longlong cbOffsetWithinHeader)</unmanaged>
            <unmanaged-short>IMFASFContentInfo::ParseHeader</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFContentInfo.GenerateHeader(SharpDX.MediaFoundation.MediaBuffer,System.Int32)">
            <summary>
            <p> </p><p>Encodes the data in the <strong>MFASFContentInfo</strong> object into a binary Advanced Systems Format (ASF) header.</p>
            </summary>
            <param name = "iHeaderRef"><dd> <p> A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of the buffer object that will receive the encoded header. Set to <strong><c>null</c></strong> to retrieve the size of the header. </p> </dd></param>
            <param name = "cbHeaderRef"><dd> <p> Size of the encoded ASF header in bytes. If <em>pIHeader</em> is <strong><c>null</c></strong>, this value is set to the buffer size required to hold the encoded header. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p> The ASF Header Objects do not exist for the media that the ContentInfo object holds reference to. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:AsfInvalidData"/></strong></dt> </dl> </td><td> <p> The ASF Header Object size exceeds 10 MB. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:BufferTooSmall"/></strong></dt> </dl> </td><td> <p> The buffer passed in <em>pIHeader</em> is not large enough to hold the ASF Header Object information. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The size received in the <em>pcbHeader</em> parameter includes the padding size. The content information shrinks or expands the padding data depending on the size of the ASF Header Objects.</p><p>During this call, the stream properties are set based on the encoding properties of the profile. These properties are available through the <strong><see cref = "T:SharpDX.MediaFoundation.Metadata"/></strong> interface.</p>
            </remarks>
            <doc-id>ms701575</doc-id>
            <unmanaged>HRESULT IMFASFContentInfo::GenerateHeader([In] IMFMediaBuffer* pIHeader,[In] DWORD* pcbHeader)</unmanaged>
            <unmanaged-short>IMFASFContentInfo::GenerateHeader</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFContentInfo.GetProfile(SharpDX.MediaFoundation.ASFProfile@)">
            <summary>
            <p> </p><p>Retrieves an Advanced Systems Format (ASF) profile that describes the ASF content.</p>
            </summary>
            <param name = "iProfileOut"><dd> <p>Receives an <strong><see cref = "T:SharpDX.MediaFoundation.ASFProfile"/></strong> interface reference. The caller must release the interface. If the object does not have an ASF profile, this parameter receives the value <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The profile is set by calling either <strong>IMFASFContentInfo::SetProfile</strong> or <strong>IMFASFContentInfo::ParseHeader</strong>.</p><p>The ASF profile object returned by this method does not include any of the <strong>MF_PD_ASF_xxx</strong> attributes (see Presentation Descriptor Attributes). To get these attributes, do the following:</p><ol> <li> <p>Call <strong>IMFASFContentInfo::GeneratePresentationDescriptor</strong> to get the ASF presentation descriptor. You can query the presentation descriptor for the <strong>MF_PD_ASF_xxx</strong> attributes.</p> </li> <li> <p>(Optional.) Call <strong>MFCreateASFProfileFromPresentationDescriptor</strong> to convert the presentation descriptor into an ASF profile. The profile object created by this function contains the <strong>MF_PD_ASF_xxx</strong> attributes.</p> </li> </ol><p>An ASF profile is a template for file encoding, and is intended mainly for creating ASF content. If you are reading an existing ASF file, it is recommended that you use the presentation descriptor to get information about the file. One exception is that the profile contains the mutual exclusion and stream prioritization objects, which are not exposed directly from the presentation descriptor.</p>
            </remarks>
            <doc-id>ms698931</doc-id>
            <unmanaged>HRESULT IMFASFContentInfo::GetProfile([In] IMFASFProfile** ppIProfile)</unmanaged>
            <unmanaged-short>IMFASFContentInfo::GetProfile</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFContentInfo.SetProfile(SharpDX.MediaFoundation.ASFProfile)">
            <summary>
            <p> </p><p>Uses profile data from a profile object to configure settings in the ContentInfo object.</p>
            </summary>
            <param name = "iProfileRef"><dd> <p>The <strong><see cref = "T:SharpDX.MediaFoundation.ASFProfile"/></strong> interface of the profile object.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If there is already information in the ContentInfo object when this method is called, it is replaced by the information from the profile object.</p>
            </remarks>
            <doc-id>ms699846</doc-id>
            <unmanaged>HRESULT IMFASFContentInfo::SetProfile([In] IMFASFProfile* pIProfile)</unmanaged>
            <unmanaged-short>IMFASFContentInfo::SetProfile</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFContentInfo.GeneratePresentationDescriptor(SharpDX.MediaFoundation.PresentationDescriptor@)">
            <summary>
            <p> </p><p>Creates a presentation descriptor for ASF content.</p>
            </summary>
            <param name = "iPresentationDescriptorOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms704860</doc-id>
            <unmanaged>HRESULT IMFASFContentInfo::GeneratePresentationDescriptor([In] IMFPresentationDescriptor** ppIPresentationDescriptor)</unmanaged>
            <unmanaged-short>IMFASFContentInfo::GeneratePresentationDescriptor</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFContentInfo.GetEncodingConfigurationPropertyStore(System.Int16,SharpDX.ComObject@)">
            <summary>
            <p> </p><p>Retrieves a property store that can be used to set encoding properties.</p>
            </summary>
            <param name = "wStreamNumber"><dd> <p>Stream number to configure. Set to zero to configure file-level encoding properties.</p> </dd></param>
            <param name = "iStoreOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.ComObject"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms704750</doc-id>
            <unmanaged>HRESULT IMFASFContentInfo::GetEncodingConfigurationPropertyStore([In] unsigned short wStreamNumber,[In] IPropertyStore** ppIStore)</unmanaged>
            <unmanaged-short>IMFASFContentInfo::GetEncodingConfigurationPropertyStore</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFIndexer.SetFlags(System.Int32)">
            <summary>
            <p> </p><p>Sets indexer options.</p>
            </summary>
            <param name = "dwFlags"><dd> <p>Bitwise OR of zero or more flags from the <strong>MFASF_INDEXER_FLAGS</strong> enumeration specifying the indexer options to use.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The indexer object was  initialized before setting flags for it.  For more information, see Remarks.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p><strong>IMFASFIndexer::SetFlags</strong> must be called before <strong>IMFASFIndexer::Initialize</strong>. Attempting to call <strong>SetFlags</strong> after <strong>Initialize</strong> will return <see cref = "!:InvalidRequest"/> as a result.</p>
            </remarks>
            <doc-id>ms699840</doc-id>
            <unmanaged>HRESULT IMFASFIndexer::SetFlags([In] DWORD dwFlags)</unmanaged>
            <unmanaged-short>IMFASFIndexer::SetFlags</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFIndexer.GetFlags(System.Int32)">
            <summary>
            <p> </p><p>Retrieves the flags that indicate the selected indexer options.</p>
            </summary>
            <param name = "dwFlagsRef"><dd> <p>Receives a bitwise OR of zero or more flags from the <strong>MFASF_INDEXER_FLAGS</strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>pdwFlags</em> is <strong><c>null</c></strong>.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>You must call this method before initializing the indexer object with <strong>IMFASFIndexer::Initialize</strong>.</p>
            </remarks>
            <doc-id>ms701578</doc-id>
            <unmanaged>HRESULT IMFASFIndexer::GetFlags([In] DWORD* pdwFlags)</unmanaged>
            <unmanaged-short>IMFASFIndexer::GetFlags</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFIndexer.Initialize(SharpDX.MediaFoundation.ASFContentInfo)">
            <summary>
            <p> </p><p>Initializes the indexer object. This method reads information in a ContentInfo object about the configuration of the content and the properties of the existing index, if present. Use this method before using the indexer for either writing or reading an index. You must make this call before using any of the other methods of the <strong><see cref = "T:SharpDX.MediaFoundation.ASFIndexer"/></strong> interface.</p>
            </summary>
            <param name = "iContentInfoRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:AsfInvalidData"/></strong></dt> </dl> </td><td> <p>Invalid ASF data.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Unexpected"/></strong></dt> </dl> </td><td> <p>Unexpected error.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The indexer needs to examine the data in the ContentInfo object to properly write or read the index for the content. The indexer will not make changes to the content information and will not hold any references to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFContentInfo"/></strong> interface.</p><p>In the ASF header, the maximum data-packet size must equal the minimum data-packet size. Otherwise, the method returns <strong><see cref = "!:Unexpected"/></strong>.</p>
            </remarks>
            <doc-id>ms703030</doc-id>
            <unmanaged>HRESULT IMFASFIndexer::Initialize([In] IMFASFContentInfo* pIContentInfo)</unmanaged>
            <unmanaged-short>IMFASFIndexer::Initialize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFIndexer.GetIndexPosition(SharpDX.MediaFoundation.ASFContentInfo,System.Int64)">
            <summary>
            <p> </p><p>Retrieves the offset of the index object from the start of the content.</p>
            </summary>
            <param name = "iContentInfoRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFContentInfo"/></strong> interface of the ContentInfo object that describes the content.</p> </dd></param>
            <param name = "cbIndexOffsetRef"><dd> <p>Receives the offset of the index relative to the beginning of the content described by the ContentInfo object. This is the position relative to the beginning of the ASF file.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>pIContentInfo</em> is <strong><c>null</c></strong> or <em>pcbIndexOffset</em> is <strong><c>null</c></strong></p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The index continues from the offset retrieved by this method to the end of the file.</p><p>You must call <strong>IMFASFIndexer::Initialize</strong> to set up the indexer before calling this method.</p><p>If the index is retrieved by using more than one call to <strong>IMFASFIndexer::GetCompletedIndex</strong>, the position of individual index portions is equal to the index offset plus the offset of the portion within the index.</p>
            </remarks>
            <doc-id>ms699858</doc-id>
            <unmanaged>HRESULT IMFASFIndexer::GetIndexPosition([In] IMFASFContentInfo* pIContentInfo,[In] unsigned longlong* pcbIndexOffset)</unmanaged>
            <unmanaged-short>IMFASFIndexer::GetIndexPosition</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFIndexer.SetIndexByteStreams(SharpDX.MediaFoundation.IByteStream@,System.Int32)">
            <summary>
            <p> </p><p>Adds byte streams to be indexed.</p>
            </summary>
            <param name = "iByteStreamsOut"><dd> <p>An array of <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface references. To get the byte stream, call <strong>MFCreateASFIndexerByteStream</strong>.</p> </dd></param>
            <param name = "cByteStreams"><dd> <p>The number of references in the <em>ppIByteStreams</em> array.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:AlreadyInitializeD"/></strong></dt> </dl> </td><td> <p>The indexer object has already been initialized and it  has packets which have been indexed.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>For a reading scenario, only one byte stream should be used by the indexer object. For an index generating scenario, it depends how many index objects are needed to be generated. </p>
            </remarks>
            <doc-id>ms704843</doc-id>
            <unmanaged>HRESULT IMFASFIndexer::SetIndexByteStreams([In] IMFByteStream** ppIByteStreams,[In] DWORD cByteStreams)</unmanaged>
            <unmanaged-short>IMFASFIndexer::SetIndexByteStreams</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFIndexer.GetIndexByteStreamCount(System.Int32)">
            <summary>
            <p> </p><p>Retrieves the number of byte streams that are  in use by the  indexer object.</p>
            </summary>
            <param name = "cByteStreamsRef"><dd> <p>Receives the number of byte streams that are  in use by the indexer object.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>pcByteStreams</em> is <strong><c>null</c></strong>.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms701789</doc-id>
            <unmanaged>HRESULT IMFASFIndexer::GetIndexByteStreamCount([In] DWORD* pcByteStreams)</unmanaged>
            <unmanaged-short>IMFASFIndexer::GetIndexByteStreamCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFIndexer.GetIndexStatus(SharpDX.MediaFoundation.AsfIndexIdentifier@,SharpDX.Mathematics.Interop.RawBool,System.Byte,System.Int32)">
            <summary>
            <p> </p><p>Retrieves the index settings for a specified stream and index type.</p>
            </summary>
            <param name = "indexIdentifierRef"><dd> <p>Pointer to an <strong><see cref = "T:SharpDX.MediaFoundation.AsfIndexIdentifier"/></strong> structure that contains the stream number and index type for which to get the status.</p> </dd></param>
            <param name = "fIsIndexedRef"><dd> <p>A variable that retrieves a Boolean value specifying whether the index described by <em>pIndexIdentifier</em> has been created.</p> </dd></param>
            <param name = "bIndexDescriptorRef"><dd> <p>A buffer that receives the index descriptor. The index descriptor consists of an <strong><see cref = "T:SharpDX.MediaFoundation.AsfIndexDescriptor"/></strong> structure, optionally followed by index-specific data.</p> </dd></param>
            <param name = "cbIndexDescriptorRef"><dd> <p>On input, specifies the size, in bytes, of the buffer that <em>pbIndexDescriptor</em> points to. The value can be zero if <em>pbIndexDescriptor</em> is <strong><c>null</c></strong>. On output, receives the size of the index descriptor, in bytes.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:BufferTooSmall"/></strong></dt> </dl> </td><td> <p>The buffer size specified in <em>pcbIndexDescriptor</em> is too small.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To read an existing ASF index, call <strong>IMFASFIndexer::SetIndexByteStreams</strong> before calling this method.</p><p>If an index exists for the stream and the value passed into <em>pcbIndexDescriptor</em> is smaller than the required size of the <em>pbIndexDescriptor</em> buffer, the method returns <see cref = "!:BufferTooSmall"/>. The required buffer size is returned in the <em>pcbIndexDescriptor</em> parameter.</p><p>If there is no index for the specified stream, the method returns <strong><see cref = "F:SharpDX.Result.False"/></strong> in the <em>pfIsIndexed</em> parameter.</p>
            </remarks>
            <doc-id>ms704012</doc-id>
            <unmanaged>HRESULT IMFASFIndexer::GetIndexStatus([In] ASF_INDEX_IDENTIFIER* pIndexIdentifier,[In] BOOL* pfIsIndexed,[In] unsigned char* pbIndexDescriptor,[In] DWORD* pcbIndexDescriptor)</unmanaged>
            <unmanaged-short>IMFASFIndexer::GetIndexStatus</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFIndexer.SetIndexStatus(System.Byte,System.Int32,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p> </p><p>Configures the index for a stream.</p>
            </summary>
            <param name = "bIndexDescriptorRef"><dd> <p>The index descriptor to set. The index descriptor is an <strong><see cref = "T:SharpDX.MediaFoundation.AsfIndexDescriptor"/></strong> structure, optionally followed by index-specific data.</p> </dd></param>
            <param name = "cbIndexDescriptor"><dd> <p>The size, in bytes, of the index descriptor.</p> </dd></param>
            <param name = "fGenerateIndex"><dd> <p>A Boolean value. Set to <strong>TRUE</strong> to have the indexer create an index of the type specified for the stream specified in the index descriptor.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>At attempt was made to change the index status in a seek-only scenario. For more information, see Remarks.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>You must make all calls to <strong>SetIndexStatus</strong> before making any calls to <strong>IMFASFIndexer::GenerateIndexEntries</strong>.</p><p>The indexer object is configured to create temporal indexes for each stream by default. Call this method only if you want to override the default settings.</p><p>You cannot use this method in an index reading scenario.  You can only use this method when writing indexes.</p>
            </remarks>
            <doc-id>ms702981</doc-id>
            <unmanaged>HRESULT IMFASFIndexer::SetIndexStatus([In] unsigned char* pbIndexDescriptor,[In] DWORD cbIndexDescriptor,[In] BOOL fGenerateIndex)</unmanaged>
            <unmanaged-short>IMFASFIndexer::SetIndexStatus</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFIndexer.GetSeekPositionForValue(System.IntPtr,SharpDX.MediaFoundation.AsfIndexIdentifier@,System.Int64,System.Int64,System.Int32)">
            <summary>
            <p> Given a desired seek time, gets the offset from which the client should start reading data. </p>
            </summary>
            <param name = "varValueRef"><dd> <p> The value of the index entry for which to get the position. The format of this value varies depending on the type of index, which is specified in the index identifier. For time-based indexing, the variant type is <strong>VT_I8</strong> and the value is the desired seek time, in 100-nanosecond units. </p> </dd></param>
            <param name = "indexIdentifierRef"><dd> <p> Pointer to an <strong><see cref = "T:SharpDX.MediaFoundation.AsfIndexIdentifier"/></strong> structure that identifies the stream number and index type. </p> </dd></param>
            <param name = "cbOffsetWithinDataRef"><dd> <p> Receives the offset within the data segment of the ASF Data Object. The offset is in bytes, and is relative to the start of packet 0. The offset gives the starting location from which the client should begin reading from the stream. This location might not correspond exactly to the requested seek time. </p> <p> For reverse playback, if no key frame exists after the desired seek position, this parameter receives the value <strong>MFASFINDEXER_READ_FOR_REVERSEPLAYBACK_OUTOFDATASEGMENT</strong>. In that case, the seek position should be 1 byte pass the end of the data segment. </p> </dd></param>
            <param name = "hnsApproxTimeRef"><dd> <p> Receives the approximate time stamp of the data that is located at the offset returned in the <em>pcbOffsetWithinData</em> parameter. The accuracy of this value is equal to the indexing interval of the ASF index, typically about 1 second. </p> <ul> <li> If the index type specified in <em>pIndexIdentifier</em> is <strong>GUID_NULL</strong> (time indexing), this parameter can be <strong><c>null</c></strong>. </li> <li> For all other index types, this parameter must be <strong><c>null</c></strong>. </li> </ul> <p> If the approximate time stamp cannot be determined, this parameter receives the value <strong>MFASFINDEXER_APPROX_SEEK_TIME_UNKNOWN</strong>. </p> </dd></param>
            <param name = "dwPayloadNumberOfStreamWithinPacketRef"><dd> <p> Receives the payload number of the payload that contains the information for the specified stream. Packets can contain multiple payloads, each containing data for a different stream. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:AsfOufOfRange"/></strong></dt> </dl> </td><td> <p> The requested seek time is out of range. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NoIndex"/></strong></dt> </dl> </td><td> <p> No index exists of the specified type for the specified stream. </p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms703125</doc-id>
            <unmanaged>HRESULT IMFASFIndexer::GetSeekPositionForValue([In] const PROPVARIANT* pvarValue,[In] ASF_INDEX_IDENTIFIER* pIndexIdentifier,[In] unsigned longlong* pcbOffsetWithinData,[In] longlong* phnsApproxTime,[In] DWORD* pdwPayloadNumberOfStreamWithinPacket)</unmanaged>
            <unmanaged-short>IMFASFIndexer::GetSeekPositionForValue</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFIndexer.GenerateIndexEntries(SharpDX.MediaFoundation.Sample)">
            <summary>
            <p> Accepts an ASF packet for the file and creates index entries for them.</p>
            </summary>
            <param name = "iASFPacketSampleRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface of a media sample that contains the ASF packet. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The argument passed in is <strong><c>null</c></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotInitializeD"/></strong></dt> </dl> </td><td> <p>The indexer is not initialized.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The ASF indexer creates indexes for a file internally. You can get the completed index for all data packets sent to the indexer by committing the index with <strong>IMFASFIndexer::CommitIndex</strong> and then calling <strong>IMFASFIndexer::GetCompletedIndex</strong> to write the index entries into a media buffer. To determine the size of the index so you can allocate a buffer large enough to hold the index, call <strong>IMFASFIndexer::GetIndexWriteSpace</strong>.</p><p> When this method creates index entries, they are immediately available for use by <strong>IMFASFIndexer::GetSeekPositionForValue</strong>. </p><p> The media sample specified in   <em>pIASFPacketSample</em> must hold a buffer that contains a single ASF packet. Get the sample from the  ASF multiplexer by calling the <strong>IMFASFMultiplexer::GetNextPacket</strong> method. </p><p>You cannot use this method while reading an index, only when writing an index.</p>
            </remarks>
            <doc-id>ms705660</doc-id>
            <unmanaged>HRESULT IMFASFIndexer::GenerateIndexEntries([In] IMFSample* pIASFPacketSample)</unmanaged>
            <unmanaged-short>IMFASFIndexer::GenerateIndexEntries</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFIndexer.CommitIndex(SharpDX.MediaFoundation.ASFContentInfo)">
            <summary>
            <p> </p><p>Adds information about a new index to the ContentInfo object associated with ASF content. You must call this method before copying the index to the content so that the index will be readable by the indexer later.</p>
            </summary>
            <param name = "iContentInfoRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFContentInfo"/></strong> interface of the ContentInfo object that describes the content.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The caller made an invalid request. For more information, see Remarks.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>For the index to function properly, you must call this method after all ASF packets in the file have been passed to the indexer by using the <strong>IMFASFIndexer::GenerateIndexEntries</strong> method. After you call this method, you must retrieve the indexes by calling <strong>GetCompletedIndex</strong> and write them to the appropriate location in the file. Finally, you must generate a new ASF header by calling the <strong>IMFASFContentInfo::GenerateHeader</strong> method of the ASF ContentInfo object.</p><p> An application must use the <strong>CommitIndex</strong> method only when writing a new index otherwise <strong>CommitIndex</strong> may return <see cref = "!:InvalidRequest"/> as a result. For example, <see cref = "!:InvalidRequest"/> is returned if the application has flags other than MFASF_INDEXER_WRITE_NEW_INDEX  set on the indexer object. <strong>CommitIndex</strong> can also return MFASF_INDEXER_WRITE_NEW_INDEX if the index entries have already been committed through an earlier <strong>CommitIndex</strong> call.</p><p>You cannot use this method in an index reading scenario.  You can only use this method when writing indexes.</p>
            </remarks>
            <doc-id>ms696994</doc-id>
            <unmanaged>HRESULT IMFASFIndexer::CommitIndex([In] IMFASFContentInfo* pIContentInfo)</unmanaged>
            <unmanaged-short>IMFASFIndexer::CommitIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFIndexer.GetIndexWriteSpace(System.Int64)">
            <summary>
            <p> </p><p>Retrieves the size, in bytes, of the buffer required to store the completed index.</p>
            </summary>
            <param name = "cbIndexWriteSpaceRef"><dd> <p>Receives the size of the index, in bytes</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:IndexNotCommitted"/></strong></dt> </dl> </td><td> <p>The index has not been committed. For more information; see Remarks.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Use this method to get the size of the index and then allocate a buffer big enough to hold it. </p><p>The index must be committed with a call to<strong>IMFASFIndexer::CommitIndex</strong> before calling <strong>IMFASFIndexer::GetIndexWriteSpace</strong>.  If the index is not committed before <strong>GetIndexWriteSpace</strong> is called, then <see cref = "!:IndexNotCommitted"/> will be returned as a result. </p><p>Call <strong>IMFASFIndexer::GetCompletedIndex</strong> to write the completed index into a media buffer.</p><p>You cannot use this method in a reading scenario.  You can only use this method when writing indexes.</p>
            </remarks>
            <doc-id>ms700198</doc-id>
            <unmanaged>HRESULT IMFASFIndexer::GetIndexWriteSpace([In] unsigned longlong* pcbIndexWriteSpace)</unmanaged>
            <unmanaged-short>IMFASFIndexer::GetIndexWriteSpace</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFIndexer.GetCompletedIndex(SharpDX.MediaFoundation.MediaBuffer,System.Int64)">
            <summary>
            <p> </p><p>Retrieves the completed index from the ASF indexer object.</p>
            </summary>
            <param name = "iIndexBufferRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of a media buffer that receives the index data.</p> </dd></param>
            <param name = "cbOffsetWithinIndex"><dd> <p>The offset of the data to be retrieved, in bytes from the start of the index data. Set to 0 for the first call. If subsequent calls are needed (the buffer is not large enough to hold the entire index), set to the byte following the last one retrieved.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:IndexNotCommitted"/></strong></dt> </dl> </td><td> <p>The index was not committed before attempting to get the completed index. For more information, see Remarks.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method uses as much of the buffer as possible, and updates the length of the buffer appropriately.</p><p>If <em>pIIndexBuffer</em> is large enough to contain the entire buffer, <em>cbOffsetWithinIndex</em> should be 0, and the call needs to be made only once. Otherwise, there should be no gaps between successive buffers.</p><p>The user must write this data to the content at <em>cbOffsetFromIndexStart</em> bytes after the end of the ASF data object. You can call <strong>IMFASFIndexer::GetIndexPosition</strong> to determine the start position of the ASF index.</p><p>This call will not succeed unless <strong>IMFASFIndexer::CommitIndex</strong> has been called. After calling <strong>GetCompletedIndex</strong>, the caller must call <strong>IMFASFContentInfo::GenerateHeader</strong> and overwrite the existing ASF header with the new header; otherwise, the ASF header will not match the content, and the file is not guaranteed to play correctly.</p><p>You cannot use this method in an index reading scenario.  You can only use this method when writing indexes.</p>
            </remarks>
            <doc-id>ms702077</doc-id>
            <unmanaged>HRESULT IMFASFIndexer::GetCompletedIndex([In] IMFMediaBuffer* pIIndexBuffer,[In] unsigned longlong cbOffsetWithinIndex)</unmanaged>
            <unmanaged-short>IMFASFIndexer::GetCompletedIndex</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.ASFMultiplexer.SyncTolerance">
            <summary>
            <p> </p><p>Sets the maximum time by which samples from various streams can be out of synchronization. The multiplexer will not accept a sample with a time stamp that is out of synchronization with the latest samples from any other stream by an amount that exceeds the synchronization tolerance.</p>
            </summary>
            <remarks>
            <p>The synchronization tolerance is the maximum difference in presentation times at any given point between samples of different streams that the ASF multiplexer can accommodate. That is, if the synchronization tolerance is 3 seconds, no stream can be more than 3 seconds behind any other stream in the time stamps passed to the multiplexer. The multiplexer determines a default synchronization tolerance to use, but this method overrides it (usually to increase it). More tolerance means the potential for greater latency in the multiplexer. If the time stamps are synchronized among the streams, actual latency will be much lower than <em>msSyncTolerance</em>.</p>
            </remarks>
            <doc-id>ms697206</doc-id>
            <unmanaged>SetSyncTolerance</unmanaged>
            <unmanaged-short>SetSyncTolerance</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFMultiplexer.Initialize(SharpDX.MediaFoundation.ASFContentInfo)">
            <summary>
            <p> </p><p>Initializes the multiplexer with the data from an ASF ContentInfo object.</p>
            </summary>
            <param name = "iContentInfoRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFContentInfo"/></strong> interface of the <strong>MFASFContentInfo</strong> object that contains the header information of the new ASF file. The multiplexer will generate data packets for this file.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This call must be made once at the beginning of encoding, with <em>pIContentInfo</em> pointing to the ASF ContentInfo object that describes the content to be encoded. This enables the ASF multiplexer to see, among other things, which streams will be present in the encoding session. This call typically does not affect the data in the ASF ContentInfo object.</p>
            </remarks>
            <doc-id>ms697469</doc-id>
            <unmanaged>HRESULT IMFASFMultiplexer::Initialize([In] IMFASFContentInfo* pIContentInfo)</unmanaged>
            <unmanaged-short>IMFASFMultiplexer::Initialize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFMultiplexer.SetFlags(System.Int32)">
            <summary>
            <p> </p><p>Sets multiplexer options.</p>
            </summary>
            <param name = "dwFlags"><dd> <p>Bitwise <strong>OR</strong> of zero or more members of the <strong><see cref = "T:SharpDX.MediaFoundation.AsfMultiplexerflags"/></strong> enumeration. These flags specify which multiplexer options to use. For more information, see "Multiplexer Initialization and Leaky Bucket Settings" in Creating the Multiplexer Object.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms703986</doc-id>
            <unmanaged>HRESULT IMFASFMultiplexer::SetFlags([In] DWORD dwFlags)</unmanaged>
            <unmanaged-short>IMFASFMultiplexer::SetFlags</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFMultiplexer.GetFlags(System.Int32)">
            <summary>
            <p> </p><p>Retrieves flags indicating the configured multiplexer options.</p>
            </summary>
            <param name = "dwFlagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more values from the <strong><see cref = "T:SharpDX.MediaFoundation.AsfMultiplexerflags"/></strong> enumeration. To set these flags, call <strong>IMFASFMultiplexer::SetFlags</strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms702166</doc-id>
            <unmanaged>HRESULT IMFASFMultiplexer::GetFlags([In] DWORD* pdwFlags)</unmanaged>
            <unmanaged-short>IMFASFMultiplexer::GetFlags</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFMultiplexer.ProcessSample(System.Int16,SharpDX.MediaFoundation.Sample,System.Int64)">
            <summary>
            <p> Delivers input samples to the multiplexer. </p>
            </summary>
            <param name = "wStreamNumber"><dd> <p> The stream number of the stream to which the sample belongs. </p> </dd></param>
            <param name = "iSampleRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface of the input sample. The input sample contains the media data to be converted to ASF data packets. When possible, the time stamp of this sample should be accurate. </p> </dd></param>
            <param name = "hnsTimestampAdjust"><dd> <p> The adjustment to apply to the time stamp of the sample. This parameter is used if the caller wants to shift the sample time on <em>pISample</em>. This value should be positive if the time stamp should be pushed ahead and negative if the time stamp should be pushed back. This time stamp is added to sample time on <em>pISample</em>, and the resulting time is used by the multiplexer instead of the original sample time. If no adjustment is needed, set this value to 0. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotAccepting"/></strong></dt> </dl> </td><td> <p> There are too many packets waiting to be retrieved from the multiplexer. Call <strong>IMFASFMultiplexer::GetNextPacket</strong> to get the packets.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:BandwidthOverrun"/></strong></dt> </dl> </td><td> <p> The sample that was processed violates the bandwidth limitations specified for the stream in the ASF ContentInfo object. When this error is generated, the sample is dropped. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> The value passed in <em>wStreamNumber</em> is invalid. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:LateSample"/></strong></dt> </dl> </td><td> <p> The presentation time of the input media sample is earlier than the send time. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> The application passes samples to <strong>ProcessSample</strong>, and the ASF multiplexer queues them internally until they are ready to be placed into ASF packets. Call <strong>IMFASFMultiplexer::GetNextPacket</strong> to get the ASF data packet. </p><p>After each call to <strong>ProcessSample</strong>, call <strong>GetNextPacket</strong> in a loop to get all of the available data packets. For a code example, see Generating New ASF Data Packets.</p>
            </remarks>
            <doc-id>ms696206</doc-id>
            <unmanaged>HRESULT IMFASFMultiplexer::ProcessSample([In] unsigned short wStreamNumber,[In] IMFSample* pISample,[In] longlong hnsTimestampAdjust)</unmanaged>
            <unmanaged-short>IMFASFMultiplexer::ProcessSample</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFMultiplexer.GetNextPacket(SharpDX.MediaFoundation.AsfStatusflags@,SharpDX.MediaFoundation.Sample@)">
            <summary>
            <p> </p><p>Retrieves the next output ASF packet from the multiplexer.</p>
            </summary>
            <param name = "dwStatusFlagsRef"><dd> <p> Receives zero or more status flags. If more than one packet is waiting, the method sets the <strong>ASF_STATUSFLAGS_INCOMPLETE</strong> flag. </p> </dd></param>
            <param name = "iPacketOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface of the first output sample of the data packet. The caller must release the interface. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> The client needs to call this method, ideally after every call to <strong>IMFASFMultiplexer::ProcessSample</strong>, to get the output ASF packets. Call this method in a loop as long as the <strong>ASF_STATUSFLAGS_INCOMPLETE</strong> flag is received. </p><p>If no packets are ready, the method returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong> but does not return a sample in <em>ppIPacket</em>.</p>
            </remarks>
            <doc-id>ms696243</doc-id>
            <unmanaged>HRESULT IMFASFMultiplexer::GetNextPacket([Out] DWORD* pdwStatusFlags,[In] IMFSample** ppIPacket)</unmanaged>
            <unmanaged-short>IMFASFMultiplexer::GetNextPacket</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFMultiplexer.Flush">
            <summary>
            <p> </p><p>Signals the multiplexer to process all queued output media samples. Call this method after passing the last sample to the multiplexer.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>You must call <strong>Flush</strong> after the last sample has been passed into the ASF multiplexer and before you call <strong>IMFASFMultiplexer::End</strong>. This causes all output media samples in progress to be completed. After calling <strong>Flush</strong>, call <strong>IMFASFMultiplexer::GetNextPacket</strong> in a loop until all the pending media samples have been packetized.</p>
            </remarks>
            <doc-id>ms696991</doc-id>
            <unmanaged>HRESULT IMFASFMultiplexer::Flush()</unmanaged>
            <unmanaged-short>IMFASFMultiplexer::Flush</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFMultiplexer.End(SharpDX.MediaFoundation.ASFContentInfo)">
            <summary>
            <p> </p><p>Collects data from the multiplexer and updates the ASF ContentInfo object to include that information in the ASF Header Object.</p>
            </summary>
            <param name = "iContentInfoRef"><dd> <p>Pointer to the  <strong><see cref = "T:SharpDX.MediaFoundation.ASFContentInfo"/></strong> interface of the ContentInfo object. This must be the same object that was used to initialize the multiplexer. The ContentInfo object represents the ASF Header Object of the file for which the multiplexer generated data packets.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:FlushNeeded"/></strong></dt> </dl> </td><td> <p>There are pending output media samples waiting in the multiplexer. Call <strong>IMFASFMultiplexer::Flush</strong> to force the media samples to be packetized.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>For non-live encoding scenarios (such as encoding to a file), the user should call <strong>End</strong> to update the specified ContentInfo object, adding data that the multiplexer has collected during the packet generation process. The user should then call <strong>IMFASFContentInfo::GenerateHeader</strong> and write the output header at the beginning of the ASF file (overwriting the header obtained at the beginning of the encoding session). For more information, see Writing an ASF Header Object for a New File.</p><p>During live encoding, it is usually not possible to rewrite the header, so this call is not required for live encoding. (The header in those cases will simply lack some of the information that was not available until the end of the encoding session.)</p>
            </remarks>
            <doc-id>ms696172</doc-id>
            <unmanaged>HRESULT IMFASFMultiplexer::End([In] IMFASFContentInfo* pIContentInfo)</unmanaged>
            <unmanaged-short>IMFASFMultiplexer::End</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFMultiplexer.GetStatistics(System.Int16,SharpDX.MediaFoundation.AsfMuxStatistics)">
            <summary>
            <p> </p><p>Retrieves multiplexer statistics.</p>
            </summary>
            <param name = "wStreamNumber"><dd> <p>The stream number for which to obtain statistics.</p> </dd></param>
            <param name = "muxStatsRef"><dd> <p>Pointer to an <strong><see cref = "T:SharpDX.MediaFoundation.AsfMuxStatistics"/></strong> structure that receives the statistics.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms697232</doc-id>
            <unmanaged>HRESULT IMFASFMultiplexer::GetStatistics([In] unsigned short wStreamNumber,[In] ASF_MUX_STATISTICS* pMuxStats)</unmanaged>
            <unmanaged-short>IMFASFMultiplexer::GetStatistics</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFMultiplexer.SetSyncTolerance(System.Int32)">
            <summary>
            <p> </p><p>Sets the maximum time by which samples from various streams can be out of synchronization. The multiplexer will not accept a sample with a time stamp that is out of synchronization with the latest samples from any other stream by an amount that exceeds the synchronization tolerance.</p>
            </summary>
            <param name = "msSyncTolerance"><dd> <p>Synchronization tolerance in milliseconds.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The synchronization tolerance is the maximum difference in presentation times at any given point between samples of different streams that the ASF multiplexer can accommodate. That is, if the synchronization tolerance is 3 seconds, no stream can be more than 3 seconds behind any other stream in the time stamps passed to the multiplexer. The multiplexer determines a default synchronization tolerance to use, but this method overrides it (usually to increase it). More tolerance means the potential for greater latency in the multiplexer. If the time stamps are synchronized among the streams, actual latency will be much lower than <em>msSyncTolerance</em>.</p>
            </remarks>
            <doc-id>ms697206</doc-id>
            <unmanaged>HRESULT IMFASFMultiplexer::SetSyncTolerance([In] DWORD msSyncTolerance)</unmanaged>
            <unmanaged-short>IMFASFMultiplexer::SetSyncTolerance</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.ASFMutualExclusion.Type">
            <summary>
            <p> </p><p>Sets the type of mutual exclusion that is represented by the Advanced Systems Format (ASF) mutual exclusion object.</p>
            </summary>
            <remarks>
            <p>Sometimes, content must be made mutually exclusive in more than one way. For example, a video file might contain audio streams in several bit rates for each of several languages. To handle this type of complex mutual exclusion, you must configure more than one ASF mutual exclusion object. For more information, see <strong>IMFASFMutualExclusion::AddRecord</strong>.</p>
            </remarks>
            <doc-id>ms697261</doc-id>
            <unmanaged>SetType</unmanaged>
            <unmanaged-short>SetType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFMutualExclusion.GetTypeInfo(System.Guid)">
            <summary>
            <p> </p><p>Retrieves the type of mutual exclusion represented by the Advanced Systems Format (ASF) mutual exclusion object.</p>
            </summary>
            <param name = "guidTypeRef"><dd> <p>A variable that receives the type identifier. For a list of predefined mutual exclusion type constants, see ASF Mutual Exclusion Type GUIDs.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Sometimes, content must be made mutually exclusive in more than one way. For example, a video file might contain audio streams of several bit rates for each of several languages. To handle this type of complex mutual exclusion, you must configure more than one ASF mutual exclusion object. For more information, see <strong>IMFASFMutualExclusion::AddRecord</strong>.</p>
            </remarks>
            <doc-id>ms703095</doc-id>
            <unmanaged>HRESULT IMFASFMutualExclusion::GetType([In] GUID* pguidType)</unmanaged>
            <unmanaged-short>IMFASFMutualExclusion::GetType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFMutualExclusion.SetType(System.Guid)">
            <summary>
            <p> </p><p>Sets the type of mutual exclusion that is represented by the Advanced Systems Format (ASF) mutual exclusion object.</p>
            </summary>
            <param name = "guidType"><dd> <p>The type of mutual exclusion that is represented by the ASF mutual exclusion object. For a list of predefined mutual exclusion type constants, see ASF Mutual Exclusion Type GUIDs.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Sometimes, content must be made mutually exclusive in more than one way. For example, a video file might contain audio streams in several bit rates for each of several languages. To handle this type of complex mutual exclusion, you must configure more than one ASF mutual exclusion object. For more information, see <strong>IMFASFMutualExclusion::AddRecord</strong>.</p>
            </remarks>
            <doc-id>ms697261</doc-id>
            <unmanaged>HRESULT IMFASFMutualExclusion::SetType([In] const GUID&amp; guidType)</unmanaged>
            <unmanaged-short>IMFASFMutualExclusion::SetType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFMutualExclusion.GetRecordCount(System.Int32)">
            <summary>
            <p> </p><p>Retrieves the number of records in the Advanced Systems Format mutual exclusion object.</p>
            </summary>
            <param name = "dwRecordCountRef"><dd> <p>Receives the count of records.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Each record includes one or more streams. Every stream in a record is mutually exclusive of streams in every other record.</p><p>Use this method in conjunction with <strong>IMFASFMutualExclusion::GetStreamsForRecord</strong> to retrieve the streams that are included in each record.</p>
            </remarks>
            <doc-id>ms700201</doc-id>
            <unmanaged>HRESULT IMFASFMutualExclusion::GetRecordCount([In] DWORD* pdwRecordCount)</unmanaged>
            <unmanaged-short>IMFASFMutualExclusion::GetRecordCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFMutualExclusion.GetStreamsForRecord(System.Int32,System.Int16,System.Int32)">
            <summary>
            <p> </p><p>Retrieves the stream numbers contained in a record in the Advanced Systems Format mutual exclusion object.</p>
            </summary>
            <param name = "dwRecordNumber"><dd> <p>The number of the record for which to retrieve the stream numbers.</p> </dd></param>
            <param name = "wStreamNumArrayRef"><dd> <p>An array that receives the stream numbers. Set to <strong><c>null</c></strong> to get the number of elements required, which is indicated by the value of <em>pcStreams</em> on return. If this parameter is not <strong><c>null</c></strong>, the method will copy as many stream numbers to the array as there are elements indicated by the value of <em>pcStreams</em>.</p> </dd></param>
            <param name = "cStreamsRef"><dd> <p>On input, the number of elements in the array referenced by <em>pwStreamNumArray</em>. On output, the method sets this value to the count of stream numbers in the record. You can call <strong>GetStreamsForRecord</strong> with <em>pwStreamNumArray</em> set to <strong><c>null</c></strong> to retrieve the number of elements required to hold all of the stream numbers.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms703200</doc-id>
            <unmanaged>HRESULT IMFASFMutualExclusion::GetStreamsForRecord([In] DWORD dwRecordNumber,[In] unsigned short* pwStreamNumArray,[In] DWORD* pcStreams)</unmanaged>
            <unmanaged-short>IMFASFMutualExclusion::GetStreamsForRecord</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFMutualExclusion.AddStreamForRecord(System.Int32,System.Int16)">
            <summary>
            <p> </p><p>Adds a stream number to a record in the Advanced Systems Format mutual exclusion object.</p>
            </summary>
            <param name = "dwRecordNumber"><dd> <p>The record number to which the stream is added. A record number is set by the <strong>IMFASFMutualExclusion::AddRecord</strong> method.</p> </dd></param>
            <param name = "wStreamNumber"><dd> <p>The stream number to add to the record.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The specified stream number is already associated with the record.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Each record includes one or more streams. Every stream in a record is mutually exclusive of all streams in every other record.</p>
            </remarks>
            <doc-id>ms703794</doc-id>
            <unmanaged>HRESULT IMFASFMutualExclusion::AddStreamForRecord([In] DWORD dwRecordNumber,[In] unsigned short wStreamNumber)</unmanaged>
            <unmanaged-short>IMFASFMutualExclusion::AddStreamForRecord</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFMutualExclusion.RemoveStreamFromRecord(System.Int32,System.Int16)">
            <summary>
            <p> </p><p>Removes a stream number from a record in the Advanced Systems Format mutual exclusion object.</p>
            </summary>
            <param name = "dwRecordNumber"><dd> <p>The record number from which to remove the stream number.</p> </dd></param>
            <param name = "wStreamNumber"><dd> <p>The stream number to remove from the record.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The stream number is not listed for the specified record.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms703971</doc-id>
            <unmanaged>HRESULT IMFASFMutualExclusion::RemoveStreamFromRecord([In] DWORD dwRecordNumber,[In] unsigned short wStreamNumber)</unmanaged>
            <unmanaged-short>IMFASFMutualExclusion::RemoveStreamFromRecord</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFMutualExclusion.RemoveRecord(System.Int32)">
            <summary>
            <p> </p><p>Removes a record from the Advanced Systems Format (ASF) mutual exclusion object.</p>
            </summary>
            <param name = "dwRecordNumber"><dd> <p>The index of the record to remove.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>When a record is removed, the ASF mutual exclusion object indexes the remaining records so that they are sequential starting with zero. You should enumerate the records to ensure that you have the correct index for each record. If the record removed is the one with the highest index, removing it has no effect on the other indexes.</p>
            </remarks>
            <doc-id>ms704808</doc-id>
            <unmanaged>HRESULT IMFASFMutualExclusion::RemoveRecord([In] DWORD dwRecordNumber)</unmanaged>
            <unmanaged-short>IMFASFMutualExclusion::RemoveRecord</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFMutualExclusion.AddRecord(System.Int32)">
            <summary>
            <p> </p><p>Adds a record to the mutual exclusion object. A record specifies streams that are mutually exclusive with the streams in all other records.</p>
            </summary>
            <param name = "dwRecordNumberRef"><dd> <p>Receives the index assigned to the new record. Record indexes are zero-based and sequential.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>A record can include one or more stream numbers. All of the streams in a record are mutually exclusive with all the streams in all other records in the ASF mutual exclusion object.</p><p>You can use records to create complex mutual exclusion scenarios by using multiple ASF mutual exclusion objects.</p>
            </remarks>
            <doc-id>ms705615</doc-id>
            <unmanaged>HRESULT IMFASFMutualExclusion::AddRecord([In] DWORD* pdwRecordNumber)</unmanaged>
            <unmanaged-short>IMFASFMutualExclusion::AddRecord</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFMutualExclusion.Clone(SharpDX.MediaFoundation.ASFMutualExclusion@)">
            <summary>
            <p> </p><p>Creates a copy of the Advanced Systems Format mutual exclusion object.</p>
            </summary>
            <param name = "iMutexOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFMutualExclusion"/></strong> interface of the new object. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The cloned object is a new object, completely independent of the object from which it was cloned.</p>
            </remarks>
            <doc-id>ms696217</doc-id>
            <unmanaged>HRESULT IMFASFMutualExclusion::Clone([In] IMFASFMutualExclusion** ppIMutex)</unmanaged>
            <unmanaged-short>IMFASFMutualExclusion::Clone</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.ASFProfile.StreamPrioritization">
            <summary>
            <strong>Note</strong>??This method is not supported.?
            </summary>
            <doc-id>ms695410</doc-id>
            <unmanaged>GetStreamPrioritization</unmanaged>
            <unmanaged-short>GetStreamPrioritization</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFProfile.GetStreamCount(System.Int32)">
            <summary>
            <p> </p><p>Retrieves the number of streams in the profile.</p>
            </summary>
            <param name = "cStreamsRef"><dd> <p>Receives the number of streams in the profile.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms703024</doc-id>
            <unmanaged>HRESULT IMFASFProfile::GetStreamCount([In] DWORD* pcStreams)</unmanaged>
            <unmanaged-short>IMFASFProfile::GetStreamCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFProfile.GetStream(System.Int32,System.Int16,SharpDX.MediaFoundation.ASFStreamConfig@)">
            <summary>
            <p> </p><p>Retrieves a stream from the profile by stream index, and/or retrieves the stream number for a stream index.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The index of the stream to retrieve. Stream indexes are sequential and zero-based. You can get the number of streams that are in the profile by calling the <strong>IMFASFProfile::GetStreamCount</strong> method.</p> </dd></param>
            <param name = "wStreamNumberRef"><dd> <p>Receives the stream number of the requested stream. Stream numbers are one-based and are not necessarily sequential. This parameter can be set to <strong><c>null</c></strong> if the stream number is not required.</p> </dd></param>
            <param name = "iStreamOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFStreamConfig"/></strong> interface of the ASF stream configuration object. The caller must release the interface. This parameter can be <strong><c>null</c></strong> if you want to retrieve the stream number without accessing the stream configuration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method does not create a copy of the stream configuration object. The reference that is retrieved points to the object within the profile object. You must not make any changes to the stream configuration object using this reference, because doing so can affect the profile object in unexpected ways.</p><p>To change the configuration of the stream configuration object in the profile, you must first clone the stream configuration object by calling <strong>IMFASFStreamConfig::Clone</strong>. Make whatever changes are required to the clone of the object and then add the updated object by calling the <strong>IMFASFProfile::SetStream</strong> method.</p>
            </remarks>
            <doc-id>ms700799</doc-id>
            <unmanaged>HRESULT IMFASFProfile::GetStream([In] DWORD dwStreamIndex,[In] unsigned short* pwStreamNumber,[In] IMFASFStreamConfig** ppIStream)</unmanaged>
            <unmanaged-short>IMFASFProfile::GetStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFProfile.GetStreamByNumber(System.Int16,SharpDX.MediaFoundation.ASFStreamConfig@)">
            <summary>
            <p> </p><p>Retrieves an Advanced Systems Format (ASF) stream configuration object for a stream in the profile. This method references the stream by stream number instead of stream index.</p>
            </summary>
            <param name = "wStreamNumber"><dd> <p>The stream number for which to obtain the interface reference.</p> </dd></param>
            <param name = "iStreamOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFStreamConfig"/></strong> interface of the ASF stream configuration object. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method does not create a copy of the stream configuration object. The reference that is retrieved points to the object within the profile object. You must not make any changes to the stream configuration object using this reference, because doing so can affect the profile object in unexpected ways.</p><p>To change the configuration of the stream configuration object in the profile, you must first clone the stream configuration object by calling <strong>IMFASFStreamConfig::Clone</strong>. Make whatever changes are required to the clone of the object and then add the updated object by calling the <strong>IMFASFProfile::SetStream</strong> method.</p>
            </remarks>
            <doc-id>ms694981</doc-id>
            <unmanaged>HRESULT IMFASFProfile::GetStreamByNumber([In] unsigned short wStreamNumber,[In] IMFASFStreamConfig** ppIStream)</unmanaged>
            <unmanaged-short>IMFASFProfile::GetStreamByNumber</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFProfile.SetStream(SharpDX.MediaFoundation.ASFStreamConfig)">
            <summary>
            <p> </p><p>Adds a stream to the profile or reconfigures an existing stream.</p>
            </summary>
            <param name = "iStreamRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFStreamConfig"/></strong> interface of a configured ASF stream configuration object.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the stream number in the ASF stream configuration object is already included in the profile, the information in the new object replaces the old one. If the profile does not contain a stream for the stream number, the ASF stream configuration object is added as a new stream.</p>
            </remarks>
            <doc-id>ms703051</doc-id>
            <unmanaged>HRESULT IMFASFProfile::SetStream([In] IMFASFStreamConfig* pIStream)</unmanaged>
            <unmanaged-short>IMFASFProfile::SetStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFProfile.RemoveStream(System.Int16)">
            <summary>
            <p> </p><p>Removes a stream from the Advanced Systems Format (ASF) profile object.</p>
            </summary>
            <param name = "wStreamNumber"><dd> <p>Stream number of the stream to remove.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>After a stream is removed, the ASF profile object reassigns stream indexes so that the index values are sequential starting from zero. Any previously stored stream index numbers are no longer valid after deleting a stream.</p>
            </remarks>
            <doc-id>ms704569</doc-id>
            <unmanaged>HRESULT IMFASFProfile::RemoveStream([In] unsigned short wStreamNumber)</unmanaged>
            <unmanaged-short>IMFASFProfile::RemoveStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFProfile.CreateStream(SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.ASFStreamConfig@)">
            <summary>
            <p> </p><p>Creates an Advanced Systems Format (ASF) stream configuration object.</p>
            </summary>
            <param name = "iMediaTypeRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of a configured media type.</p> </dd></param>
            <param name = "iStreamOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFStreamConfig"/></strong> interface of the new ASF stream configuration object. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>ppIStream</em> is <strong><c>null</c></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong>E_OUTOFMEMORY</strong></dt> </dl> </td><td> <p>stream configuration object could not be created due to insufficient memory.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The ASF stream configuration object created by this method is not included in the profile. To include the stream, you must first configure the stream configuration and then call <strong>IMFASFProfile::SetStream</strong>.</p>
            </remarks>
            <doc-id>ms696264</doc-id>
            <unmanaged>HRESULT IMFASFProfile::CreateStream([In] IMFMediaType* pIMediaType,[In] IMFASFStreamConfig** ppIStream)</unmanaged>
            <unmanaged-short>IMFASFProfile::CreateStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFProfile.GetMutualExclusionCount(System.Int32)">
            <summary>
            <p> </p><p>Retrieves the number of Advanced Systems Format (ASF) mutual exclusion objects that are associated with the profile.</p>
            </summary>
            <param name = "cMutexsRef"><dd> <p>Receives the number of mutual exclusion objects.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Multiple mutual exclusion objects may be required for streams that are mutually exclusive in more than one way. For more information, see <strong>IMFASFMutualExclusion::AddRecord</strong>.</p>
            </remarks>
            <doc-id>ms697361</doc-id>
            <unmanaged>HRESULT IMFASFProfile::GetMutualExclusionCount([In] DWORD* pcMutexs)</unmanaged>
            <unmanaged-short>IMFASFProfile::GetMutualExclusionCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFProfile.GetMutualExclusion(System.Int32,SharpDX.MediaFoundation.ASFMutualExclusion@)">
            <summary>
            <p> </p><p>Retrieves an Advanced Systems Format (ASF) mutual exclusion object from the profile.</p>
            </summary>
            <param name = "dwMutexIndex"><dd> <p>Index of the mutual exclusion object in the profile.</p> </dd></param>
            <param name = "iMutexOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFMutualExclusion"/></strong> interface of the ASF mutual exclusion object. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method does not create a copy of the mutual exclusion object. The returned reference refers to the mutual exclusion contained in the profile object. You must not make any changes to the mutual exclusion object using this reference, because doing so can affect the profile object in unexpected ways.</p><p>To change the configuration of the mutual exclusion object in the profile, you must first clone the mutual exclusion object by calling <strong>IMFASFMutualExclusion::Clone</strong>. Make whatever changes are required to the clone of the object, remove the old mutual exclusion object from the profile by calling the <strong>IMFASFProfile::RemoveMutualExclusion</strong> method, and then add the updated object by calling the <strong>IMFASFProfile::AddMutualExclusion</strong> method.</p>
            </remarks>
            <doc-id>ms701598</doc-id>
            <unmanaged>HRESULT IMFASFProfile::GetMutualExclusion([In] DWORD dwMutexIndex,[In] IMFASFMutualExclusion** ppIMutex)</unmanaged>
            <unmanaged-short>IMFASFProfile::GetMutualExclusion</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFProfile.AddMutualExclusion(SharpDX.MediaFoundation.ASFMutualExclusion)">
            <summary>
            <p> </p><p>Adds a configured Advanced Systems Format (ASF) mutual exclusion object to the profile.</p>
            </summary>
            <param name = "iMutexRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFMutualExclusion"/></strong> interface of a configured ASF mutual exclusion object.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>You can create a mutual exclusion object by calling the <strong>IMFASFProfile::CreateMutualExclusion</strong> method.</p>
            </remarks>
            <doc-id>ms703965</doc-id>
            <unmanaged>HRESULT IMFASFProfile::AddMutualExclusion([In] IMFASFMutualExclusion* pIMutex)</unmanaged>
            <unmanaged-short>IMFASFProfile::AddMutualExclusion</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFProfile.RemoveMutualExclusion(System.Int32)">
            <summary>
            <p> </p><p>Removes an Advanced Systems Format (ASF) mutual exclusion object from the profile.</p>
            </summary>
            <param name = "dwMutexIndex"><dd> <p>The index of the mutual exclusion object to remove from the profile.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>When a mutual exclusion object is removed from the profile, the ASF profile object reassigns the mutual exclusion indexes so that they are sequential starting with zero. Any previously stored indexes are no longer valid after calling this method.</p>
            </remarks>
            <doc-id>ms704007</doc-id>
            <unmanaged>HRESULT IMFASFProfile::RemoveMutualExclusion([In] DWORD dwMutexIndex)</unmanaged>
            <unmanaged-short>IMFASFProfile::RemoveMutualExclusion</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFProfile.CreateMutualExclusion(SharpDX.MediaFoundation.ASFMutualExclusion@)">
            <summary>
            <p> </p><p>Creates a new Advanced Systems Format (ASF) mutual exclusion object. Mutual exclusion objects can be added to a profile by calling the <strong>AddMutualExclusion</strong> method.</p>
            </summary>
            <param name = "iMutexOut">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The ASF mutual exclusion object created by this method is not associated with the profile. Call <strong>IMFASFProfile::AddMutualExclusion</strong> after configuring the object to make this association.</p>
            </remarks>
            <doc-id>ms697002</doc-id>
            <unmanaged>HRESULT IMFASFProfile::CreateMutualExclusion([In] IMFASFMutualExclusion** ppIMutex)</unmanaged>
            <unmanaged-short>IMFASFProfile::CreateMutualExclusion</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFProfile.GetStreamPrioritization(SharpDX.MediaFoundation.ASFStreamPrioritization@)">
            <summary>
            <strong>Note</strong>??This method is not supported.?
            </summary>
            <param name = "iStreamPrioritizationOut"><dd> <p>Reserved.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ms695410</doc-id>
            <unmanaged>HRESULT IMFASFProfile::GetStreamPrioritization([In] IMFASFStreamPrioritization** ppIStreamPrioritization)</unmanaged>
            <unmanaged-short>IMFASFProfile::GetStreamPrioritization</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFProfile.AddStreamPrioritization(SharpDX.MediaFoundation.ASFStreamPrioritization)">
            <summary>
            <strong>Note</strong>??This method is not supported.?
            </summary>
            <param name = "iStreamPrioritizationRef"><dd> <p>Reserved. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ms697516</doc-id>
            <unmanaged>HRESULT IMFASFProfile::AddStreamPrioritization([In] IMFASFStreamPrioritization* pIStreamPrioritization)</unmanaged>
            <unmanaged-short>IMFASFProfile::AddStreamPrioritization</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFProfile.RemoveStreamPrioritization">
            <summary>
            <strong>Note</strong>??This method is not supported.?
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ms701838</doc-id>
            <unmanaged>HRESULT IMFASFProfile::RemoveStreamPrioritization()</unmanaged>
            <unmanaged-short>IMFASFProfile::RemoveStreamPrioritization</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFProfile.CreateStreamPrioritization(SharpDX.MediaFoundation.ASFStreamPrioritization@)">
            <summary>
            <strong>Note</strong>??This method is not implemented.?
            </summary>
            <param name = "iStreamPrioritizationOut"><dd> <p>Reserved. </p> </dd></param>
            <returns><p> Returns <strong>E_NOTIMPL</strong>. </p></returns>
            <doc-id>ms694914</doc-id>
            <unmanaged>HRESULT IMFASFProfile::CreateStreamPrioritization([In] IMFASFStreamPrioritization** ppIStreamPrioritization)</unmanaged>
            <unmanaged-short>IMFASFProfile::CreateStreamPrioritization</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFProfile.Clone(SharpDX.MediaFoundation.ASFProfile@)">
            <summary>
            <p> </p><p>Creates a copy of the Advanced Systems Format profile object.</p>
            </summary>
            <param name = "iProfileOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFProfile"/></strong> interface of the new object. The caller must release the interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The cloned object is completely independent of the original.</p>
            </remarks>
            <doc-id>ms704773</doc-id>
            <unmanaged>HRESULT IMFASFProfile::Clone([In] IMFASFProfile** ppIProfile)</unmanaged>
            <unmanaged-short>IMFASFProfile::Clone</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFSplitter.Initialize(SharpDX.MediaFoundation.ASFContentInfo)">
            <summary>
            <p> </p><p>Resets the Advanced Systems Format (ASF) splitter and configures it to parse data from an ASF data section.</p>
            </summary>
            <param name = "iContentInfoRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFContentInfo"/></strong> interface of a ContentInfo object that describes the data to be parsed.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The <em>pIContentInfo</em> parameter is <strong><c>null</c></strong>.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms704048</doc-id>
            <unmanaged>HRESULT IMFASFSplitter::Initialize([In] IMFASFContentInfo* pIContentInfo)</unmanaged>
            <unmanaged-short>IMFASFSplitter::Initialize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFSplitter.SetFlags(System.Int32)">
            <summary>
            <p> </p><p>Sets option flags on the Advanced Systems Format (ASF) splitter.</p>
            </summary>
            <param name = "dwFlags"><dd> <p>A bitwise combination of zero or more members of the <strong><see cref = "T:SharpDX.MediaFoundation.AsfSplitterflags"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotInitializeD"/></strong></dt> </dl> </td><td> <p>The splitter is not initialized.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The <em>dwFlags</em> parameter does not contain a valid flag.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The MFASF_SPLITTER_REVERSE flag is set, but the content cannot be parsed in reverse.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method can only be called after the splitter is initialized.</p>
            </remarks>
            <doc-id>ms697337</doc-id>
            <unmanaged>HRESULT IMFASFSplitter::SetFlags([In] DWORD dwFlags)</unmanaged>
            <unmanaged-short>IMFASFSplitter::SetFlags</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFSplitter.GetFlags(System.Int32)">
            <summary>
            <p> </p><p>Retrieves the option flags that are set on the ASF splitter.</p>
            </summary>
            <param name = "dwFlagsRef"><dd> <p>Receives the option flags. This value is a bitwise <strong>OR</strong> of zero or more members of the <strong><see cref = "T:SharpDX.MediaFoundation.AsfSplitterflags"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>pdwFlags</em> is <strong><c>null</c></strong>.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms702288</doc-id>
            <unmanaged>HRESULT IMFASFSplitter::GetFlags([In] DWORD* pdwFlags)</unmanaged>
            <unmanaged-short>IMFASFSplitter::GetFlags</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFSplitter.SelectStreams(System.Int16,System.Int16)">
            <summary>
            <p> </p><p>Sets the streams to be parsed by the Advanced Systems Format (ASF) splitter.</p>
            </summary>
            <param name = "wStreamNumbersRef"><dd> <p>An array of variables containing the list of stream numbers to select.</p> </dd></param>
            <param name = "wNumStreams"><dd> <p>The number of valid elements in the stream number array.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>pwStreamNumbers</em> is <strong><c>null</c></strong> and <em>wNumStreams</em> contains a value greater than zero.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>Invalid stream number was passed in the array.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Calling this method supersedes any previous stream selections; only the streams specified in the <em>pwStreamNumbers</em> array will be selected.</p><p>By default, no streams are selected by the splitter.</p><p>You can obtain a list of the currently selected streams by calling the <strong>IMFASFSplitter::GetSelectedStreams</strong> method.</p>
            </remarks>
            <doc-id>ms701631</doc-id>
            <unmanaged>HRESULT IMFASFSplitter::SelectStreams([In] unsigned short* pwStreamNumbers,[In] unsigned short wNumStreams)</unmanaged>
            <unmanaged-short>IMFASFSplitter::SelectStreams</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFSplitter.GetSelectedStreams(System.Int16,System.Int16)">
            <summary>
            <p> Gets a list of currently selected streams. </p>
            </summary>
            <param name = "wStreamNumbersRef"><dd> <p> The address of an array of <strong>WORDs</strong>. This array receives the stream numbers of the selected streams. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "wNumStreamsRef"><dd> <p>On input, points to a variable that contains the number of elements in the <em>pwStreamNumbers</em> array. Set the variable to zero if <em>pwStreamNumbers</em> is <strong><c>null</c></strong>. </p> <p>On output, receives the number of elements that were copied into <em>pwStreamNumbers</em>. Each element is the identifier of a selected stream.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> Invalid argument. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:BufferTooSmall"/></strong></dt> </dl> </td><td> <p> The <em>pwStreamNumbers</em> array is smaller than the number of selected streams. See Remarks.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To get the number of selected streams, set <em>pwStreamNumbers</em> to <strong><c>null</c></strong>. The method will return <strong>MF_E_BUFFERTOSMALL</strong> but will also set the value of <code>*pwNumStreams</code> equal  to the number of selected streams. Then allocate an array of that size and call the method again, passing the array in the <em>pwStreamNumbers</em> parameter.</p><p>The following code shows these steps:</p><pre><see cref = "T:SharpDX.Result"/> DisplaySelectedStreams(<see cref = "T:SharpDX.MediaFoundation.ASFSplitter"/> *pSplitter)
            { WORD count = 0; <see cref = "T:SharpDX.Result"/> hr = pSplitter-&gt;GetSelectedStreams(<c>null</c>, &amp;count); if (hr == <see cref = "!:BufferTooSmall"/>) { WORD *pStreamIds = new (std::nothrow) WORD[count]; if (pStreamIds) { hr = pSplitter-&gt;GetSelectedStreams(pStreamIds, &amp;count); if (SUCCEEDED(hr)) { for (WORD i = 0; i &lt; count; i++) { printf("Selected stream ID: %d\n", pStreamIds[i]); } } delete [] pStreamIds; } else { hr = E_OUTOFMEMORY; } } return hr;
            }
            </pre><p>Alternatively, you can allocate an array that is equal to the total number of streams and pass that to <em>pwStreamNumbers</em>.</p><p>Before calling this method, initialize <code>*pwNumStreams</code> to the number of elements in <em>pwStreamNumbers</em>. If <em>pwStreamNumbers</em> is <strong><c>null</c></strong>, set <code>*pwNumStreams</code> to zero.</p><p> By default, no streams are selected by the splitter. Select streams by calling the <strong>IMFASFSplitter::SelectStreams</strong> method. </p>
            </remarks>
            <doc-id>ms705602</doc-id>
            <unmanaged>HRESULT IMFASFSplitter::GetSelectedStreams([In] unsigned short* pwStreamNumbers,[In] unsigned short* pwNumStreams)</unmanaged>
            <unmanaged-short>IMFASFSplitter::GetSelectedStreams</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFSplitter.ParseData(SharpDX.MediaFoundation.MediaBuffer,System.Int32,System.Int32)">
            <summary>
            <p> </p><p>Sends packetized Advanced Systems Format (ASF) data to the ASF splitter for processing.</p>
            </summary>
            <param name = "iBufferRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of a buffer object containing data to be parsed.</p> </dd></param>
            <param name = "cbBufferOffset"><dd> <p>The offset into the data buffer where the splitter should begin parsing. This value is typically set to 0.</p> </dd></param>
            <param name = "cbLength"><dd> <p>The length, in bytes, of the data to parse. This value is measured from the offset specified by <em>cbBufferOffset</em>. Set to 0 to process to the end of the buffer.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The <em>pIBuffer</em> parameter is <strong><c>null</c></strong>.</p> <p>The specified offset value in <em>cbBufferOffset</em> is greater than the length of the buffer.</p> <p>The total value of <em>cbBufferOffset</em> and <em>cbLength</em> is greater than the length of the buffer.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotInitializeD"/></strong></dt> </dl> </td><td> <p>The <strong>IMFASFSplitter::Initialize</strong> method was not called or the call failed.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotAccepting"/></strong></dt> </dl> </td><td> <p>The splitter cannot process more input at this time.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>After using this method to parse data, you must call <strong>IMFASFSplitter::GetNextSample</strong> to retrieve parsed media samples.</p><p>If your ASF data contains variable-sized packets, you must set the <strong><see cref = "!:PacketBoundary"/></strong> attribute on the buffers to indicate the sample boundaries, and the buffers cannot span multiple packets.</p><p>If the method returns ME_E_NOTACCEPTING, call <strong>GetNextSample</strong> to get the output samples, or call <strong>IMFASFSplitter::Flush</strong> to clear the splitter.</p><p>The splitter might hold a reference count on the input buffer. Therefore, do not write over the valid data in the buffer after calling this method.</p>
            </remarks>
            <doc-id>ms694299</doc-id>
            <unmanaged>HRESULT IMFASFSplitter::ParseData([In] IMFMediaBuffer* pIBuffer,[In] DWORD cbBufferOffset,[In] DWORD cbLength)</unmanaged>
            <unmanaged-short>IMFASFSplitter::ParseData</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFSplitter.GetNextSample(System.Int32,System.Int16,SharpDX.MediaFoundation.Sample@)">
            <summary>
            <p> </p><p>Retrieves a sample from the Advanced Systems Format (ASF) splitter after the data has been parsed.</p>
            </summary>
            <param name = "dwStatusFlagsRef"><dd> <p>Receives one of the following values.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>ASF_STATUSFLAGS_INCOMPLETE</strong></dt> </dl> </td><td> <p>More samples are ready to be retrieved. Call <strong>GetNextSample</strong> in a loop until the <em>pdwStatusFlags</em> parameter receives the value zero.</p> </td></tr> <tr><td><dl> <dt><strong>Zero</strong></dt> </dl> </td><td> <p>No additional samples are ready. Call <strong>IMFASFSplitter::ParseData</strong> to give more input data to the splitter.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "wStreamNumberRef"><dd> <p>If the method returns a sample in the <em>ppISample</em> parameter, this parameter receives the number of the stream to which the sample belongs.</p> </dd></param>
            <param name = "iSampleOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface of the parsed sample. The caller must release the interface. If no samples are ready, this parameter receives the value <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:AsfInvalidData"/></strong></dt> </dl> </td><td> <p>The ASF data in the buffer is invalid.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:AsfMissingData"/></strong></dt> </dl> </td><td> <p>There is a gap in the ASF data.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Before calling this method, call <strong>IMFASFSplitter::ParseData</strong> to give input data to the splitter. If the input does not contain enough data for a complete sample, the <strong>GetNextSample</strong> method succeeds but returns <strong><c>null</c></strong> in the <em>ppISample</em> parameter.</p><p>The ASF splitter skips samples for unselected streams. To select streams, call <strong>IMFASFSplitter::SelectStreams</strong>.</p>
            </remarks>
            <doc-id>ms700167</doc-id>
            <unmanaged>HRESULT IMFASFSplitter::GetNextSample([In] DWORD* pdwStatusFlags,[In] unsigned short* pwStreamNumber,[In] IMFSample** ppISample)</unmanaged>
            <unmanaged-short>IMFASFSplitter::GetNextSample</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFSplitter.Flush">
            <summary>
            <p> </p><p>Resets the Advanced Systems Format (ASF) splitter and releases all pending samples.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Any samples waiting to be retrieved when <strong>Flush</strong> is called are lost.</p>
            </remarks>
            <doc-id>ms703013</doc-id>
            <unmanaged>HRESULT IMFASFSplitter::Flush()</unmanaged>
            <unmanaged-short>IMFASFSplitter::Flush</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFSplitter.GetLastSendTime(System.Int32)">
            <summary>
            <p> </p><p>Retrieves the send time of the last sample received.</p>
            </summary>
            <param name = "dwLastSendTimeRef"><dd> <p>Receives the send time of the last sample received.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>pdwLastSendTime</em> is <strong><c>null</c></strong>.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms697272</doc-id>
            <unmanaged>HRESULT IMFASFSplitter::GetLastSendTime([In] DWORD* pdwLastSendTime)</unmanaged>
            <unmanaged-short>IMFASFSplitter::GetLastSendTime</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.ASFStreamConfig.StreamNumber">
            <summary>
            <p> </p><p>Retrieves the stream number of the stream.</p>
            </summary>
            <doc-id>ms703172</doc-id>
            <unmanaged>GetStreamNumber / SetStreamNumber</unmanaged>
            <unmanaged-short>GetStreamNumber</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.ASFStreamConfig.MediaType">
            <summary>
            <p> </p><p>Retrieves the media type of the stream.</p>
            </summary>
            <remarks>
            <p>To reduce unnecessary copying, the method returns a reference to the media type  that is stored internally by the object. Do not modify the returned media type,  as the results are not defined.</p>
            </remarks>
            <doc-id>ms697489</doc-id>
            <unmanaged>GetMediaType / SetMediaType</unmanaged>
            <unmanaged-short>GetMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamConfig.GetStreamType(System.Guid)">
            <summary>
            <p>Gets the major media type of the stream. </p>
            </summary>
            <param name = "guidStreamTypeRef"><dd> <p>Receives the major media type for the stream. For a list of possible values, see Major Media Types. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ms697390</doc-id>
            <unmanaged>HRESULT IMFASFStreamConfig::GetStreamType([In] GUID* pguidStreamType)</unmanaged>
            <unmanaged-short>IMFASFStreamConfig::GetStreamType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamConfig.GetStreamNumber">
            <summary>
            <p> </p><p>Retrieves the stream number of the stream.</p>
            </summary>
            <returns><p>The method returns the  stream number.</p></returns>
            <doc-id>ms703172</doc-id>
            <unmanaged>unsigned short IMFASFStreamConfig::GetStreamNumber()</unmanaged>
            <unmanaged-short>IMFASFStreamConfig::GetStreamNumber</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamConfig.SetStreamNumber(System.Int16)">
            <summary>
            <p> </p><p>Assigns a stream number to the stream.</p>
            </summary>
            <param name = "wStreamNum"><dd> <p>The number to assign to the stream.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Stream numbers start from 1 and do not need to be sequential.</p>
            </remarks>
            <doc-id>ms697298</doc-id>
            <unmanaged>HRESULT IMFASFStreamConfig::SetStreamNumber([In] unsigned short wStreamNum)</unmanaged>
            <unmanaged-short>IMFASFStreamConfig::SetStreamNumber</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamConfig.GetMediaType(SharpDX.MediaFoundation.MediaType@)">
            <summary>
            <p> </p><p>Retrieves the media type of the stream.</p>
            </summary>
            <param name = "iMediaTypeOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type object associated with the stream. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To reduce unnecessary copying, the method returns a reference to the media type  that is stored internally by the object. Do not modify the returned media type,  as the results are not defined.</p>
            </remarks>
            <doc-id>ms697489</doc-id>
            <unmanaged>HRESULT IMFASFStreamConfig::GetMediaType([In] IMFMediaType** ppIMediaType)</unmanaged>
            <unmanaged-short>IMFASFStreamConfig::GetMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamConfig.SetMediaType(SharpDX.MediaFoundation.MediaType)">
            <summary>
            <p> </p><p>Sets the media type for the Advanced Systems Format (ASF) stream configuration object.</p>
            </summary>
            <param name = "iMediaTypeRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of a configured media type object.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Some validation of the media type is performed by this method. However, a media type can be successfully set, but cause an error when the stream is added to the profile.</p>
            </remarks>
            <doc-id>ms697185</doc-id>
            <unmanaged>HRESULT IMFASFStreamConfig::SetMediaType([In] IMFMediaType* pIMediaType)</unmanaged>
            <unmanaged-short>IMFASFStreamConfig::SetMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamConfig.GetPayloadExtensionCount(System.Int16)">
            <summary>
            <p> </p><p>Retrieves the number of payload extensions that are configured for the stream.</p>
            </summary>
            <param name = "cPayloadExtensionsRef"><dd> <p>Receives the number of payload extensions.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms696251</doc-id>
            <unmanaged>HRESULT IMFASFStreamConfig::GetPayloadExtensionCount([In] unsigned short* pcPayloadExtensions)</unmanaged>
            <unmanaged-short>IMFASFStreamConfig::GetPayloadExtensionCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamConfig.GetPayloadExtension(System.Int16,System.Guid,System.Int16,System.Byte,System.Int32)">
            <summary>
            <p> </p><p>Retrieves information about an existing payload extension.</p>
            </summary>
            <param name = "wPayloadExtensionNumber"><dd> <p>The payload extension index. Valid indexes range from 0, to one less than the number of extensions obtained by calling <strong>IMFASFStreamConfig::GetPayloadExtensionCount</strong>.</p> </dd></param>
            <param name = "guidExtensionSystemIDRef"><dd> <p>Receives a <see cref = "T:System.Guid"/> that identifies the payload extension. For a list of predefined payload extensions, see ASF Payload Extension GUIDs. Applications can also define custom payload extensions.</p> </dd></param>
            <param name = "cbExtensionDataSizeRef"><dd> <p>Receives the number of bytes added to each sample for the extension.</p> </dd></param>
            <param name = "bExtensionSystemInfoRef"><dd> <p>Pointer to a buffer that receives information about this extension system. This information is the same for all samples and is stored in the content header (not in each sample). This parameter can be <strong><c>null</c></strong>. To find the required size of the buffer, set this parameter to <strong><c>null</c></strong>; the size is returned in <em>pcbExtensionSystemInfo</em>.</p> </dd></param>
            <param name = "cbExtensionSystemInfoRef"><dd> <p>On input, specifies the size of the buffer pointed to by <em>pbExtensionSystemInfo</em>. On output, receives the required size of the <em>pbExtensionSystemInfo</em> buffer in bytes.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:BufferTooSmall"/></strong></dt> </dl> </td><td> <p>The buffer specified in <em>pbExtensionSystemInfo</em> is too small.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidIndex"/></strong></dt> </dl> </td><td> <p>The <em>wPayloadExtensionNumber</em> parameter is out of range.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms697305</doc-id>
            <unmanaged>HRESULT IMFASFStreamConfig::GetPayloadExtension([In] unsigned short wPayloadExtensionNumber,[In] GUID* pguidExtensionSystemID,[In] unsigned short* pcbExtensionDataSize,[In] unsigned char* pbExtensionSystemInfo,[In] DWORD* pcbExtensionSystemInfo)</unmanaged>
            <unmanaged-short>IMFASFStreamConfig::GetPayloadExtension</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamConfig.AddPayloadExtension(System.Guid,System.Int16,System.Byte,System.Int32)">
            <summary>
            <p> </p><p>Configures a payload extension for the stream.</p>
            </summary>
            <param name = "guidExtensionSystemID"><dd> <p>Pointer to a <see cref = "T:System.Guid"/> that identifies the payload extension. For a list of predefined payload extensions, see ASF Payload Extension GUIDs. Applications can also define custom payload extensions.</p> </dd></param>
            <param name = "cbExtensionDataSize"><dd> <p>Number of bytes added to each sample for the extension.</p> </dd></param>
            <param name = "bExtensionSystemInfoRef"><dd> <p>A reference to a buffer that contains information about this extension system. This information is the same for all samples and is stored in the content header (not with each sample). This parameter can be <strong><c>null</c></strong> if <em>cbExtensionSystemInfo</em> is 0.</p> </dd></param>
            <param name = "cbExtensionSystemInfo"><dd> <p>Amount of data, in bytes, that describes this extension system. If this value is 0, then <em>pbExtensionSystemInfo</em> can be <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms697229</doc-id>
            <unmanaged>HRESULT IMFASFStreamConfig::AddPayloadExtension([In] GUID guidExtensionSystemID,[In] unsigned short cbExtensionDataSize,[In] unsigned char* pbExtensionSystemInfo,[In] DWORD cbExtensionSystemInfo)</unmanaged>
            <unmanaged-short>IMFASFStreamConfig::AddPayloadExtension</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamConfig.RemoveAllPayloadExtensions">
            <summary>
            <p> </p><p>Removes all payload extensions that are configured for the stream.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>None.</p>
            </remarks>
            <doc-id>ms699009</doc-id>
            <unmanaged>HRESULT IMFASFStreamConfig::RemoveAllPayloadExtensions()</unmanaged>
            <unmanaged-short>IMFASFStreamConfig::RemoveAllPayloadExtensions</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamConfig.Clone(SharpDX.MediaFoundation.ASFStreamConfig@)">
            <summary>
            <p> </p><p>Creates a copy of the Advanced Systems Format (ASF) stream configuration object.</p>
            </summary>
            <param name = "iStreamConfigOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFStreamConfig"/></strong> interface of the new object. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The cloned object is completely independent of the original.</p>
            </remarks>
            <doc-id>ms703117</doc-id>
            <unmanaged>HRESULT IMFASFStreamConfig::Clone([In] IMFASFStreamConfig** ppIStreamConfig)</unmanaged>
            <unmanaged-short>IMFASFStreamConfig::Clone</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamPrioritization.GetStreamCount(System.Int32)">
            <summary>
            <p> </p><strong>Note</strong>??This interface is not implemented in this version of Media Foundation.?<p>Retrieves the number of entries in the stream priority list.</p>
            </summary>
            <param name = "dwStreamCountRef"><dd> <p>Receives the number of streams in the stream priority list.</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970449</doc-id>
            <unmanaged>HRESULT IMFASFStreamPrioritization::GetStreamCount([In] DWORD* pdwStreamCount)</unmanaged>
            <unmanaged-short>IMFASFStreamPrioritization::GetStreamCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamPrioritization.GetStream(System.Int32,System.Int16,System.Int16)">
            <summary>
            <p> </p><strong>Note</strong>??This interface is not implemented in this version of Media Foundation.?<p>Retrieves the stream number of a stream in the stream priority list.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>Zero-based index of the entry to retrieve from the stream priority list. To get the number of entries in the priority list, call <strong>IMFASFStreamPrioritization::GetStreamCount</strong>.</p> </dd></param>
            <param name = "wStreamNumberRef"><dd> <p>Receives the stream number of the stream priority entry.</p> </dd></param>
            <param name = "wStreamFlagsRef"><dd> <p>Receives a Boolean value. If <strong>TRUE</strong>, the stream is mandatory.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><strong><c>null</c></strong> reference argument or the <em>dwStreamIndex</em> parameter is out of range.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms697005</doc-id>
            <unmanaged>HRESULT IMFASFStreamPrioritization::GetStream([In] DWORD dwStreamIndex,[In] unsigned short* pwStreamNumber,[In] unsigned short* pwStreamFlags)</unmanaged>
            <unmanaged-short>IMFASFStreamPrioritization::GetStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamPrioritization.AddStream(System.Int16,System.Int16)">
            <summary>
            <p> </p><strong>Note</strong>??This interface is not implemented in this version of Media Foundation.?<p>Adds a stream to the stream priority list.</p>
            </summary>
            <param name = "wStreamNumber"><dd> <p>Stream number of the stream to add.</p> </dd></param>
            <param name = "wStreamFlags"><dd> <p>If <strong>TRUE</strong>, the stream is mandatory.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid stream number.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The stream priority list is built by appending entries to the list with each call to <strong>AddStream</strong>. The list is evaluated in descending order of importance. The most important stream should be added first, and the least important should be added last.</p>
            </remarks>
            <doc-id>ms696987</doc-id>
            <unmanaged>HRESULT IMFASFStreamPrioritization::AddStream([In] unsigned short wStreamNumber,[In] unsigned short wStreamFlags)</unmanaged>
            <unmanaged-short>IMFASFStreamPrioritization::AddStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamPrioritization.RemoveStream(System.Int32)">
            <summary>
            <p> </p><strong>Note</strong>??This interface is not implemented in this version of Media Foundation.?<p>Removes a stream from the stream priority list.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>Index of the entry in the stream priority list to remove. Values range from zero, to one less than the stream count retrieved by calling <strong>IMFASFStreamPrioritization::GetStreamCount</strong>.</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>When a stream is removed from the stream priority list, the index values of all streams that follow it in the list are decremented.</p>
            </remarks>
            <doc-id>bb970482</doc-id>
            <unmanaged>HRESULT IMFASFStreamPrioritization::RemoveStream([In] DWORD dwStreamIndex)</unmanaged>
            <unmanaged-short>IMFASFStreamPrioritization::RemoveStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamPrioritization.Clone(SharpDX.MediaFoundation.ASFStreamPrioritization@)">
            <summary>
            <p> </p><strong>Note</strong>??This interface is not implemented in this version of Media Foundation.?<p>Creates a copy of the ASF stream prioritization object.</p>
            </summary>
            <param name = "iStreamPrioritizationOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.ASFStreamPrioritization"/></strong> interface of the new object. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The new object is completely independent of the original.</p>
            </remarks>
            <doc-id>ms704679</doc-id>
            <unmanaged>HRESULT IMFASFStreamPrioritization::Clone([In] IMFASFStreamPrioritization** ppIStreamPrioritization)</unmanaged>
            <unmanaged-short>IMFASFStreamPrioritization::Clone</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.ASFStreamSelector.StreamSelectorFlags">
            <summary>
            <p> </p><p>Sets options for the stream selector.</p>
            </summary>
            <doc-id>ms701635</doc-id>
            <unmanaged>SetStreamSelectorFlags</unmanaged>
            <unmanaged-short>SetStreamSelectorFlags</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamSelector.GetStreamCount(System.Int32)">
            <summary>
            <p> </p><p>Retrieves the number of streams that are in the Advanced Systems Format (ASF) content.</p>
            </summary>
            <param name = "cStreamsRef"><dd> <p>Receives the number of streams in the content.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms704621</doc-id>
            <unmanaged>HRESULT IMFASFStreamSelector::GetStreamCount([In] DWORD* pcStreams)</unmanaged>
            <unmanaged-short>IMFASFStreamSelector::GetStreamCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamSelector.GetOutputCount(System.Int32)">
            <summary>
            <p> </p><p>Retrieves the number of outputs for the Advanced Systems Format (ASF) content.</p>
            </summary>
            <param name = "cOutputsRef"><dd> <p>Receives the number of outputs.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Outputs are streams in the ASF data section that will be parsed.</p>
            </remarks>
            <doc-id>ms694076</doc-id>
            <unmanaged>HRESULT IMFASFStreamSelector::GetOutputCount([In] DWORD* pcOutputs)</unmanaged>
            <unmanaged-short>IMFASFStreamSelector::GetOutputCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamSelector.GetOutputStreamCount(System.Int32,System.Int32)">
            <summary>
            <p> </p><p>Retrieves the number of streams associated with an output.</p>
            </summary>
            <param name = "dwOutputNum"><dd> <p>The output number for which to retrieve the stream count.</p> </dd></param>
            <param name = "cStreamsRef"><dd> <p>Receives the number of streams associated with the output.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid output number.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>An output is a stream in an ASF data section that will be parsed. If mutual exclusion is used, mutually exclusive streams share the same output.</p>
            </remarks>
            <doc-id>ms700815</doc-id>
            <unmanaged>HRESULT IMFASFStreamSelector::GetOutputStreamCount([In] DWORD dwOutputNum,[In] DWORD* pcStreams)</unmanaged>
            <unmanaged-short>IMFASFStreamSelector::GetOutputStreamCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamSelector.GetOutputStreamNumbers(System.Int32,System.Int16)">
            <summary>
            <p> </p><p>Retrieves the stream numbers for all of the streams that are associated with an output.</p>
            </summary>
            <param name = "dwOutputNum"><dd> <p>The output number for which to retrieve stream numbers.</p> </dd></param>
            <param name = "rgwStreamNumbers"><dd> <p>Address of an array that receives the stream numbers associated with the output. The caller allocates the array. The array size must be at least as large as the value returned by the <strong>IMFASFStreamSelector::GetOutputStreamCount</strong> method.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid output number.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>An output is a stream in an ASF data section that will be parsed. If mutual exclusion is used, mutually exclusive streams share the same output.</p>
            </remarks>
            <doc-id>ms697025</doc-id>
            <unmanaged>HRESULT IMFASFStreamSelector::GetOutputStreamNumbers([In] DWORD dwOutputNum,[In] unsigned short* rgwStreamNumbers)</unmanaged>
            <unmanaged-short>IMFASFStreamSelector::GetOutputStreamNumbers</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamSelector.GetOutputFromStream(System.Int16,System.Int32)">
            <summary>
            <p> </p><p>Retrieves the output number associated with a stream.</p>
            </summary>
            <param name = "wStreamNum"><dd> <p>The stream number for which to retrieve an output number.</p> </dd></param>
            <param name = "dwOutputRef"><dd> <p>Receives the output number.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid stream number.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Outputs are streams in the ASF data section that will be parsed.</p>
            </remarks>
            <doc-id>ms701979</doc-id>
            <unmanaged>HRESULT IMFASFStreamSelector::GetOutputFromStream([In] unsigned short wStreamNum,[In] DWORD* pdwOutput)</unmanaged>
            <unmanaged-short>IMFASFStreamSelector::GetOutputFromStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamSelector.GetOutputOverride(System.Int32,SharpDX.MediaFoundation.AsfSelectionStatus)">
            <summary>
            <p> </p><p>Retrieves the manual output override selection that is set for a stream.</p>
            </summary>
            <param name = "dwOutputNum"><dd> <p>Stream number for which to retrieve the output override selection.</p> </dd></param>
            <param name = "selectionRef"><dd> <p>Receives the output override selection. The value is a member of the <strong><see cref = "T:SharpDX.MediaFoundation.AsfSelectionStatus"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms697510</doc-id>
            <unmanaged>HRESULT IMFASFStreamSelector::GetOutputOverride([In] DWORD dwOutputNum,[In] ASF_SELECTION_STATUS* pSelection)</unmanaged>
            <unmanaged-short>IMFASFStreamSelector::GetOutputOverride</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamSelector.SetOutputOverride(System.Int32,SharpDX.MediaFoundation.AsfSelectionStatus)">
            <summary>
            <p> </p><p>Sets the selection status of an output, overriding other selection criteria.</p>
            </summary>
            <param name = "dwOutputNum"><dd> <p>Output number for which to set selection.</p> </dd></param>
            <param name = "selection"><dd> <p>Member of the <strong><see cref = "T:SharpDX.MediaFoundation.AsfSelectionStatus"/></strong> enumeration specifying the level of selection for the output.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms703122</doc-id>
            <unmanaged>HRESULT IMFASFStreamSelector::SetOutputOverride([In] DWORD dwOutputNum,[In] ASF_SELECTION_STATUS Selection)</unmanaged>
            <unmanaged-short>IMFASFStreamSelector::SetOutputOverride</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamSelector.GetOutputMutexCount(System.Int32,System.Int32)">
            <summary>
            <p> </p><p>Retrieves the number of mutual exclusion objects associated with an output.</p>
            </summary>
            <param name = "dwOutputNum"><dd> <p>Output number for which to retrieve the count of mutually exclusive relationships.</p> </dd></param>
            <param name = "cMutexesRef"><dd> <p>Receives the number of mutual exclusions.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms703918</doc-id>
            <unmanaged>HRESULT IMFASFStreamSelector::GetOutputMutexCount([In] DWORD dwOutputNum,[In] DWORD* pcMutexes)</unmanaged>
            <unmanaged-short>IMFASFStreamSelector::GetOutputMutexCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamSelector.GetOutputMutex(System.Int32,System.Int32,SharpDX.IUnknown@)">
            <summary>
            <p> </p><p>Retrieves a mutual exclusion object for an output.</p>
            </summary>
            <param name = "dwOutputNum"><dd> <p>Output number for which to retrieve a mutual exclusion object.</p> </dd></param>
            <param name = "dwMutexNum"><dd> <p>Mutual exclusion number. This is an index of mutually exclusive relationships associated with the output. Set to a number between 0, and 1 less than the number of mutual exclusion objects retrieved by calling <strong>IMFASFStreamSelector::GetOutputMutexCount</strong>.</p> </dd></param>
            <param name = "mutexOut"><dd> <p>Receives a reference to the mutual exclusion object's <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Outputs are streams in the ASF data section that will be parsed.</p>
            </remarks>
            <doc-id>ms703819</doc-id>
            <unmanaged>HRESULT IMFASFStreamSelector::GetOutputMutex([In] DWORD dwOutputNum,[In] DWORD dwMutexNum,[In] IUnknown** ppMutex)</unmanaged>
            <unmanaged-short>IMFASFStreamSelector::GetOutputMutex</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamSelector.SetOutputMutexSelection(System.Int32,System.Int32,System.Int16)">
            <summary>
            <p> </p><p>Selects a mutual exclusion record to use for a mutual exclusion object associated with an output.</p>
            </summary>
            <param name = "dwOutputNum"><dd> <p>The output number for which to set a stream.</p> </dd></param>
            <param name = "dwMutexNum"><dd> <p>Index of the mutual exclusion for which to select.</p> </dd></param>
            <param name = "wSelectedRecord"><dd> <p>Record of the specified mutual exclusion to select.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>An output is a stream in an Advanced Systems Format (ASF) data section that will be parsed. If mutual exclusion is used, mutually exclusive streams share the same output.</p><p>An ASF file can contain multiple mutually exclusive relationships, such as a file with both language based and bit-rate based mutual exclusion. If an output is involved in multiple mutually exclusive relationships, a record from each must be selected.</p>
            </remarks>
            <doc-id>ms704822</doc-id>
            <unmanaged>HRESULT IMFASFStreamSelector::SetOutputMutexSelection([In] DWORD dwOutputNum,[In] DWORD dwMutexNum,[In] unsigned short wSelectedRecord)</unmanaged>
            <unmanaged-short>IMFASFStreamSelector::SetOutputMutexSelection</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamSelector.GetBandwidthStepCount(System.Int32)">
            <summary>
            <p> </p><p>Retrieves the number of bandwidth steps that exist for the content. This method is used for multiple bit rate (MBR) content.</p>
            </summary>
            <param name = "cStepCountRef"><dd> <p>Receives the number of bandwidth steps.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Bandwidth steps are bandwidth levels used for multiple bit rate (MBR) content. If you stream MBR content, you can choose the bandwidth step that matches the network conditions to avoid interruptions during playback.</p>
            </remarks>
            <doc-id>ms698868</doc-id>
            <unmanaged>HRESULT IMFASFStreamSelector::GetBandwidthStepCount([In] DWORD* pcStepCount)</unmanaged>
            <unmanaged-short>IMFASFStreamSelector::GetBandwidthStepCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamSelector.GetBandwidthStep(System.Int32,System.Int32,System.Int16,SharpDX.MediaFoundation.AsfSelectionStatus)">
            <summary>
            <p> </p><p>Retrieves the stream numbers that apply to a bandwidth step. This method is used for multiple bit rate (MBR) content.</p>
            </summary>
            <param name = "dwStepNum"><dd> <p>Bandwidth step number for which to retrieve information. Set this value to a number between 0, and 1 less than the number of bandwidth steps returned by <strong>IMFASFStreamSelector::GetBandwidthStepCount</strong>.</p> </dd></param>
            <param name = "dwBitrateRef"><dd> <p>Receives the bit rate associated with the bandwidth step.</p> </dd></param>
            <param name = "rgwStreamNumbers"><dd> <p>Address of an array that receives the stream numbers. The caller allocates the array. The array size must be at least as large as the value returned by the <strong>IMFASFStreamSelector::GetStreamCount</strong> method.</p> </dd></param>
            <param name = "rgSelections"><dd> <p>Address of an array that receives the selection status of each stream, as an <strong><see cref = "T:SharpDX.MediaFoundation.AsfSelectionStatus"/></strong> value. The members of this array correspond to the members of the <em>rgwStreamNumbers</em> array by index. The caller allocates the array. The array size must be at least as large as the value returned by the <strong>IMFASFStreamSelector::GetStreamCount</strong> method.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Bandwidth steps are bandwidth levels used for MBR content. If you stream MBR content, you can choose the bandwidth step that matches the network conditions to avoid interruptions during playback.</p>
            </remarks>
            <doc-id>ms700131</doc-id>
            <unmanaged>HRESULT IMFASFStreamSelector::GetBandwidthStep([In] DWORD dwStepNum,[In] DWORD* pdwBitrate,[In] unsigned short* rgwStreamNumbers,[In] ASF_SELECTION_STATUS* rgSelections)</unmanaged>
            <unmanaged-short>IMFASFStreamSelector::GetBandwidthStep</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamSelector.BitrateToStepNumber(System.Int32,System.Int32)">
            <summary>
            <p> </p><p>Retrieves the index of a bandwidth step that is appropriate for a specified bit rate. This method is used for multiple bit rate (MBR) content.</p>
            </summary>
            <param name = "dwBitrate"><dd> <p>The bit rate to find a bandwidth step for.</p> </dd></param>
            <param name = "dwStepNumRef"><dd> <p>Receives the step number. Use this number to retrieve information about the step by calling <strong>IMFASFStreamSelector::GetBandwidthStep</strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>In a streaming multiple bit rate (MBR) scenario, call this method with the current data rate of the network connection to determine the correct step to use. You can also call this method periodically throughout streaming to ensure that the best step is used.</p>
            </remarks>
            <doc-id>ms704645</doc-id>
            <unmanaged>HRESULT IMFASFStreamSelector::BitrateToStepNumber([In] DWORD dwBitrate,[In] DWORD* pdwStepNum)</unmanaged>
            <unmanaged-short>IMFASFStreamSelector::BitrateToStepNumber</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ASFStreamSelector.SetStreamSelectorFlags(System.Int32)">
            <summary>
            <p> </p><p>Sets options for the stream selector.</p>
            </summary>
            <param name = "dwStreamSelectorFlags"><dd> <p>Bitwise <strong>OR</strong> of zero or more members of the <strong>MFASF_STREAMSELECTOR_FLAGS</strong> enumeration specifying the options to use.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms701635</doc-id>
            <unmanaged>HRESULT IMFASFStreamSelector::SetStreamSelectorFlags([In] DWORD dwStreamSelectorFlags)</unmanaged>
            <unmanaged-short>IMFASFStreamSelector::SetStreamSelectorFlags</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.AudioMediaType.AudioFormat">
            <summary>
            <p>[<strong>GetAudioFormat</strong> is no longer available for use as of Windows?7. Instead, use the media type attributes to get the properties of the audio format.]</p><p> Returns a reference to a <strong><see cref = "T:SharpDX.Multimedia.WaveFormat"/></strong> structure that describes the audio format.</p>
            </summary>
            <remarks>
            <p>If you need to convert the media type into a <strong><see cref = "T:SharpDX.Multimedia.WaveFormat"/></strong> structure, call <strong>MFCreateWaveFormatExFromMFMediaType</strong>.</p><p> There are no guarantees about how long the returned reference is valid.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>aa473803</doc-id>
            <unmanaged>GetAudioFormat</unmanaged>
            <unmanaged-short>GetAudioFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.AudioMediaType.GetAudioFormat">
            <summary>
            <p>[<strong>GetAudioFormat</strong> is no longer available for use as of Windows?7. Instead, use the media type attributes to get the properties of the audio format.]</p><p> Returns a reference to a <strong><see cref = "T:SharpDX.Multimedia.WaveFormat"/></strong> structure that describes the audio format.</p>
            </summary>
            <returns><p> This method returns a reference to a <strong><see cref = "T:SharpDX.Multimedia.WaveFormat"/></strong> structure.</p></returns>
            <remarks>
            <p>If you need to convert the media type into a <strong><see cref = "T:SharpDX.Multimedia.WaveFormat"/></strong> structure, call <strong>MFCreateWaveFormatExFromMFMediaType</strong>.</p><p> There are no guarantees about how long the returned reference is valid.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>aa473803</doc-id>
            <unmanaged>const WAVEFORMATEX* IMFAudioMediaType::GetAudioFormat()</unmanaged>
            <unmanaged-short>IMFAudioMediaType::GetAudioFormat</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.AudioPolicy.GroupingParam">
            <summary>
            <p> </p><p>Retrieves the group of sessions to which this audio session belongs.</p>
            </summary>
            <remarks>
            <p>If two or more audio sessions share the same group, the Windows volume control displays one slider control for the entire group. Otherwise, it displays a slider for each session. For more information, see <strong>IAudioSessionControl::SetGroupingParam</strong> in the core audio API documentation.</p>
            </remarks>
            <doc-id>ms698967</doc-id>
            <unmanaged>GetGroupingParam / SetGroupingParam</unmanaged>
            <unmanaged-short>GetGroupingParam</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.AudioPolicy.SetGroupingParam(System.Guid)">
            <summary>
            <p> </p><p>Assigns the audio session to a group of sessions.</p>
            </summary>
            <param name = "rguidClass"><dd> <p>A <strong><see cref = "T:System.Guid"/></strong> that identifies the session group. Groups are application-defined. To create a new session group, assign a new <see cref = "T:System.Guid"/>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If two or more audio sessions share the same group, the Windows volume control displays one slider control for the entire group. Otherwise, it displays a slider for each session. For more information, see <strong>IAudioSessionControl::SetGroupingParam</strong> in the core audio API documentation.</p>
            </remarks>
            <doc-id>ms696185</doc-id>
            <unmanaged>HRESULT IMFAudioPolicy::SetGroupingParam([In] const GUID&amp; rguidClass)</unmanaged>
            <unmanaged-short>IMFAudioPolicy::SetGroupingParam</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.AudioPolicy.GetGroupingParam(System.Guid@)">
            <summary>
            <p> </p><p>Retrieves the group of sessions to which this audio session belongs.</p>
            </summary>
            <param name = "guidClassRef"><dd> <p>Receives a <see cref = "T:System.Guid"/> that identifies the session group.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If two or more audio sessions share the same group, the Windows volume control displays one slider control for the entire group. Otherwise, it displays a slider for each session. For more information, see <strong>IAudioSessionControl::SetGroupingParam</strong> in the core audio API documentation.</p>
            </remarks>
            <doc-id>ms698967</doc-id>
            <unmanaged>HRESULT IMFAudioPolicy::GetGroupingParam([Out] GUID* pguidClass)</unmanaged>
            <unmanaged-short>IMFAudioPolicy::GetGroupingParam</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.AudioPolicy.SetDisplayName(System.String)">
            <summary>
            <p> </p><p>Sets the display name of the audio session. The Windows volume control displays this name.</p>
            </summary>
            <param name = "szNameRef"><dd> <p>A null-terminated wide-character string that contains the display name.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the application does not set a display name, Windows creates one.</p>
            </remarks>
            <doc-id>ms697038</doc-id>
            <unmanaged>HRESULT IMFAudioPolicy::SetDisplayName([In] const wchar_t* pszName)</unmanaged>
            <unmanaged-short>IMFAudioPolicy::SetDisplayName</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.AudioPolicy.GetDisplayName(System.IntPtr)">
            <summary>
            <p> </p><p>Retrieves the display name of the audio session. The Windows volume control displays this name.</p>
            </summary>
            <param name = "szNameRef"><dd> <p>Receives a reference to the display name string. The caller must free the memory allocated for the string by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the application does not set a display name, Windows creates one.</p>
            </remarks>
            <doc-id>ms698992</doc-id>
            <unmanaged>HRESULT IMFAudioPolicy::GetDisplayName([Out] wchar_t** pszName)</unmanaged>
            <unmanaged-short>IMFAudioPolicy::GetDisplayName</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.AudioPolicy.SetIconPath(System.String)">
            <summary>
            <p> Sets the icon resource for the audio session. The Windows volume control displays this icon. </p>
            </summary>
            <param name = "szPathRef"><dd> <p>A wide-character string that specifies the icon. See Remarks.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The icon path has the format "path,index" or "path,-id", where <em>path</em> is the fully qualified path to a DLL, executable file, or icon file; <em>index</em> is the zero-based index of the icon within the file; and <em>id</em> is a resource identifier. Note that resource identifiers are preceded by a minus sign (-) to distinguish them from indexes. The path can contain environment variables, such as "%windir%". For more information, see <strong>IAudioSessionControl::SetIconPath</strong> in the Windows SDK.</p>
            </remarks>
            <doc-id>ms694065</doc-id>
            <unmanaged>HRESULT IMFAudioPolicy::SetIconPath([In] const wchar_t* pszPath)</unmanaged>
            <unmanaged-short>IMFAudioPolicy::SetIconPath</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.AudioPolicy.GetIconPath(System.IntPtr)">
            <summary>
            <p> </p><p>Retrieves the icon resource for the audio session. The Windows volume control displays this icon.</p>
            </summary>
            <param name = "szPathRef"><dd> <p>Receives a reference to a wide-character string that specifies a shell resource. The format of the string is described in the topic <strong>IMFAudioPolicy::SetIconPath</strong>. The caller must free the memory allocated for the string by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the application did not set an icon path, the method returns an empty string ("").</p><p>For more information, see <strong>IAudioSessionControl::GetIconPath</strong> in the core audio API documentation.</p>
            </remarks>
            <doc-id>ms704858</doc-id>
            <unmanaged>HRESULT IMFAudioPolicy::GetIconPath([Out] wchar_t** pszPath)</unmanaged>
            <unmanaged-short>IMFAudioPolicy::GetIconPath</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.AudioStreamVolume.ChannelCount">
            <summary>
            <p> </p><p>Retrieves the number of channels in the audio stream.</p>
            </summary>
            <doc-id>aa373760</doc-id>
            <unmanaged>GetChannelCount</unmanaged>
            <unmanaged-short>GetChannelCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.AudioStreamVolume.GetChannelCount(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the number of channels in the audio stream.</p>
            </summary>
            <param name = "dwCountRef"><dd> <p>Receives the number of channels in the audio stream.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>aa373760</doc-id>
            <unmanaged>HRESULT IMFAudioStreamVolume::GetChannelCount([Out] unsigned int* pdwCount)</unmanaged>
            <unmanaged-short>IMFAudioStreamVolume::GetChannelCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.AudioStreamVolume.SetChannelVolume(System.Int32,System.Single)">
            <summary>
            <p> </p><p>Sets the volume level for a specified channel in the audio stream.</p>
            </summary>
            <param name = "dwIndex"><dd> <p>Zero-based index of the audio channel. To get the number of channels, call <strong>IMFAudioStreamVolume::GetChannelCount</strong>.</p> </dd></param>
            <param name = "fLevel"><dd> <p>Volume level for the channel.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>aa370771</doc-id>
            <unmanaged>HRESULT IMFAudioStreamVolume::SetChannelVolume([In] unsigned int dwIndex,[In] const float fLevel)</unmanaged>
            <unmanaged-short>IMFAudioStreamVolume::SetChannelVolume</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.AudioStreamVolume.GetChannelVolume(System.Int32,System.Single@)">
            <summary>
            <p> </p><p>Retrieves the volume level for a specified channel in the audio stream.</p>
            </summary>
            <param name = "dwIndex"><dd> <p>Zero-based index of the audio channel. To get the number of channels, call <strong>IMFAudioStreamVolume::GetChannelCount</strong>.</p> </dd></param>
            <param name = "fLevelRef"><dd> <p>Receives the volume level for the channel.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>aa369737</doc-id>
            <unmanaged>HRESULT IMFAudioStreamVolume::GetChannelVolume([In] unsigned int dwIndex,[Out] float* pfLevel)</unmanaged>
            <unmanaged-short>IMFAudioStreamVolume::GetChannelVolume</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.AudioStreamVolume.SetAllVolumes(System.Int32,System.Single[])">
            <summary>
            <p> </p><p>Sets the individual volume levels for all of the channels in the audio stream.</p>
            </summary>
            <param name = "dwCount"><dd> <p>Number of elements in the <em>pfVolumes</em> array. The value must equal the number of channels. To get the number of channels, call <strong>IMFAudioStreamVolume::GetChannelCount</strong>.</p> </dd></param>
            <param name = "fVolumesRef"><dd> <p>Address of an array of size <em>dwCount</em>, allocated by the caller. The array specifies the volume levels for all of the channels. Before calling the method, set each element of the array to the desired volume level for the channel.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>aa370454</doc-id>
            <unmanaged>HRESULT IMFAudioStreamVolume::SetAllVolumes([In] unsigned int dwCount,[In, Buffer] const float* pfVolumes)</unmanaged>
            <unmanaged-short>IMFAudioStreamVolume::SetAllVolumes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.AudioStreamVolume.GetAllVolumes(System.Int32,System.Single[])">
            <summary>
            <p> </p><p>Retrieves the volume levels for all of the channels in the audio stream.</p>
            </summary>
            <param name = "dwCount"><dd> <p>Number of elements in the <em>pfVolumes</em> array. The value must equal the number of channels. To get the number of channels, call <strong>IMFAudioStreamVolume::GetChannelCount</strong>.</p> </dd></param>
            <param name = "fVolumesRef"><dd> <p>Address of an array of size <em>dwCount</em>, allocated by the caller. The method fills the array with the volume level for each channel in the stream.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>aa373642</doc-id>
            <unmanaged>HRESULT IMFAudioStreamVolume::GetAllVolumes([In] unsigned int dwCount,[Out, Buffer] float* pfVolumes)</unmanaged>
            <unmanaged-short>IMFAudioStreamVolume::GetAllVolumes</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.Buffer2D.IsContiguousFormat">
            <summary>
            <p> </p><p>Queries whether the buffer is contiguous in its native format.</p>
            </summary>
            <remarks>
            <p>For a definition of contiguous as it applies to 2-D buffers, see the Remarks section in <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2D"/></strong> interface. For non-contiguous buffers, the <strong>IMFMediaBuffer::Lock</strong> method must perform an internal copy.</p>
            </remarks>
            <doc-id>ms701629</doc-id>
            <unmanaged>IsContiguousFormat</unmanaged>
            <unmanaged-short>IsContiguousFormat</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.Buffer2D.ContiguousLength">
            <summary>
            <p> </p><p>Retrieves the number of bytes needed to store the contents of the buffer in contiguous format.</p>
            </summary>
            <remarks>
            <p>For a definition of contiguous as it applies to 2-D buffers, see the Remarks section in <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2D"/></strong> interface.</p>
            </remarks>
            <doc-id>ms696971</doc-id>
            <unmanaged>GetContiguousLength</unmanaged>
            <unmanaged-short>GetContiguousLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Buffer2D.Lock2D(System.Byte[],System.Int32@)">
            <summary>
            <p> </p><p>Gives the caller access to the memory in the buffer.</p>
            </summary>
            <param name = "bScanline0Out"><dd> <p>Receives a reference to the first byte of the top row of pixels in the image. The top row is defined as the top row when the image is presented to the viewer, and might not be the first row in memory.</p> </dd></param>
            <param name = "lPitchRef"><dd> <p>Receives the surface stride, in bytes. The stride might be negative, indicating that the image is oriented from the bottom up in memory.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>D3DERR_INVALIDCALL</strong></dt> </dl> </td><td> <p>Cannot lock the Direct3D surface.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The buffer cannot be locked at this time.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If <em>p</em> is a reference to the first byte in a row of pixels, <em>p</em> + (*<em>plPitch</em>) points to the first byte in the next row of pixels. A buffer might contain padding after each row of pixels, so the stride might be wider than the width of the image in bytes. Do not access the memory that is reserved for padding bytes, because it might not be read-accessible or write-accessible. For more information, see Image Stride.</p><p>The reference returned in <em>pbScanline0</em> remains valid as long as the caller holds the lock. When you are done accessing the memory, call <strong>IMF2DBuffer::Unlock2D</strong> to unlock the buffer. You must call <strong>Unlock2D</strong> once for each call to <strong>Lock2D</strong>. After you unlock the buffer, the reference returned in <em>pbScanline0</em> is no longer valid and should not be used. Generally, it is best to call <strong>Lock2D</strong> only when you need to access the buffer memory, and not earlier.</p><p>The values returned by the <strong>IMFMediaBuffer::GetCurrentLength</strong> and <strong>IMFMediaBuffer::GetMaxLength</strong> methods do not apply to the buffer that is returned by the <strong>Lock2D</strong> method. For the same reason, you do not need to call <strong>IMFMediaBuffer::SetCurrentLength</strong> after manipulating the data in the buffer returned by the <strong>Lock2D</strong> method.</p><p>The <strong>IMFMediaBuffer::Lock</strong> method fails while the <strong>Lock2D</strong> lock is held, and vice-versa. Applications should use only one of these methods at a time.</p><p>When the underlying buffer is a Direct3D surface, the method fails if the surface is not lockable.</p>
            </remarks>
            <doc-id>ms700182</doc-id>
            <unmanaged>HRESULT IMF2DBuffer::Lock2D([Out, Buffer] unsigned char** ppbScanline0,[Out] LONG* plPitch)</unmanaged>
            <unmanaged-short>IMF2DBuffer::Lock2D</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Buffer2D.Unlock2D">
            <summary>
            <p> </p><p>Unlocks a buffer that was previously locked. Call this method once for each call to <strong>IMF2DBuffer::Lock2D</strong>.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms697066</doc-id>
            <unmanaged>HRESULT IMF2DBuffer::Unlock2D()</unmanaged>
            <unmanaged-short>IMF2DBuffer::Unlock2D</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Buffer2D.GetScanline0AndPitch(System.Byte@,System.Int32@)">
            <summary>
            <p> </p><p>Retrieves a reference to the buffer memory and the surface stride.</p>
            </summary>
            <param name = "bScanline0Ref"><dd> <p>Receives a reference to the first byte of the top row of pixels in the image.</p> </dd></param>
            <param name = "lPitchRef"><dd> <p>Receives the stride, in bytes. For more information, see Image Stride.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>ERROR_INVALID_FUNCTION</strong></dt> </dl> </td><td> <p>You must lock the buffer before calling this method.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Before calling this method, you must lock the buffer by calling <strong>IMF2DBuffer::Lock2D</strong>. The reference returned in <em>plPitch</em> is valid only while the buffer remains locked.</p>
            </remarks>
            <doc-id>ms694042</doc-id>
            <unmanaged>HRESULT IMF2DBuffer::GetScanline0AndPitch([Out] unsigned char** pbScanline0,[Out] LONG* plPitch)</unmanaged>
            <unmanaged-short>IMF2DBuffer::GetScanline0AndPitch</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Buffer2D.IsContiguousFormat_(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p> </p><p>Queries whether the buffer is contiguous in its native format.</p>
            </summary>
            <param name = "fIsContiguousRef"><dd> <p>Receives a Boolean value. The value is <strong>TRUE</strong> if the buffer is contiguous, and <strong><see cref = "F:SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>For a definition of contiguous as it applies to 2-D buffers, see the Remarks section in <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2D"/></strong> interface. For non-contiguous buffers, the <strong>IMFMediaBuffer::Lock</strong> method must perform an internal copy.</p>
            </remarks>
            <doc-id>ms701629</doc-id>
            <unmanaged>HRESULT IMF2DBuffer::IsContiguousFormat([Out] BOOL* pfIsContiguous)</unmanaged>
            <unmanaged-short>IMF2DBuffer::IsContiguousFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Buffer2D.GetContiguousLength(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the number of bytes needed to store the contents of the buffer in contiguous format.</p>
            </summary>
            <param name = "cbLengthRef"><dd> <p>Receives the number of bytes needed to store the contents of the buffer in contiguous format.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>For a definition of contiguous as it applies to 2-D buffers, see the Remarks section in <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2D"/></strong> interface.</p>
            </remarks>
            <doc-id>ms696971</doc-id>
            <unmanaged>HRESULT IMF2DBuffer::GetContiguousLength([Out] DWORD* pcbLength)</unmanaged>
            <unmanaged-short>IMF2DBuffer::GetContiguousLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Buffer2D.ContiguousCopyTo(System.Byte[],System.Int32)">
            <summary>
            <p> </p><p>Copies this buffer into the caller's buffer, converting the data to contiguous format.</p>
            </summary>
            <param name = "bDestBufferRef"><dd> <p>Pointer to the destination buffer where the data will be copied. The caller allocates the buffer.</p> </dd></param>
            <param name = "cbDestBuffer"><dd> <p>Size of the destination buffer, in bytes. To get the required size, call <strong>IMF2DBuffer::GetContiguousLength</strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid size specified in <em>pbDestBuffer</em>.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the original buffer is not contiguous, this method converts the contents into contiguous format during the copy. For a definition of contiguous as it applies to 2-D buffers, see the Remarks section in <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2D"/></strong> interface.</p>
            </remarks>
            <doc-id>ms696215</doc-id>
            <unmanaged>HRESULT IMF2DBuffer::ContiguousCopyTo([Out, Buffer] unsigned char* pbDestBuffer,[In] DWORD cbDestBuffer)</unmanaged>
            <unmanaged-short>IMF2DBuffer::ContiguousCopyTo</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Buffer2D.ContiguousCopyFrom(System.Byte[],System.Int32)">
            <summary>
            <p> </p><p>Copies data to this buffer from a buffer that has a contiguous format.</p>
            </summary>
            <param name = "bSrcBufferRef"><dd> <p>Pointer to the source buffer. The caller allocates the buffer.</p> </dd></param>
            <param name = "cbSrcBuffer"><dd> <p>Size of the source buffer, in bytes. To get the maximum size of the buffer, call <strong>IMF2DBuffer::GetContiguousLength</strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method copies the contents of the source buffer into the buffer that is managed by this <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2D"/></strong> object. The source buffer must be in contiguous format. While copying, the method converts the contents into the destination buffer's native format, correcting for the buffer's pitch if necessary.</p><p>For a definition of contiguous as it applies to 2-D buffers, see the Remarks section in the <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2D"/></strong> interface topic.</p>
            </remarks>
            <doc-id>ms700162</doc-id>
            <unmanaged>HRESULT IMF2DBuffer::ContiguousCopyFrom([In, Buffer] const unsigned char* pbSrcBuffer,[In] DWORD cbSrcBuffer)</unmanaged>
            <unmanaged-short>IMF2DBuffer::ContiguousCopyFrom</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Buffer2D2.Lock2DSize(SharpDX.MediaFoundation.Buffer2DLockFlags,System.Byte[],System.Int32@,System.Byte[],System.Int32@)">
            <summary>
            <p>Gives the caller access to the memory in the buffer.</p>
            </summary>
            <param name = "lockFlags"><dd> <p>A member of the <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2DLockFlags"/></strong> enumeration that specifies whether to lock the buffer for reading, writing, or both.</p> </dd></param>
            <param name = "bScanline0Out"><dd> <p>Receives a reference to the first byte of the top row of pixels in the image. The top row is defined as the top row when the image is presented to the viewer, and might not be the first row in memory. </p> </dd></param>
            <param name = "lPitchRef"><dd> <p>Receives the surface stride, in bytes. The stride might be negative, indicating that the image is oriented from the bottom up in memory. </p> </dd></param>
            <param name = "bBufferStartOut"><dd> <p>Receives a reference to the start of the accessible buffer in memory.</p> </dd></param>
            <param name = "cbBufferLengthRef"><dd> <p>Receives the length of the buffer, in bytes.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid request. The buffer might already be locked with an incompatible locking flag. See Remarks.</p> </td></tr> <tr><td> <dl> <dt><strong> E_OUTOFMEMORY</strong></dt> </dl> </td><td> <p>There is insufficient memory to complete the operation. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>When you are done accessing the memory, call <strong>IMF2DBuffer::Unlock2D</strong> to unlock the buffer. You must call <strong>Unlock2D</strong> once for each call to <strong>Lock2DSize</strong>.</p><p>This method is equivalent to the <strong>IMF2DBuffer::Lock2D</strong> method. However, <strong>Lock2DSize</strong> is preferred because it enables the caller to validate memory references, and because it supports read-only locks. A buffer is not guaranteed to support the <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2D2"/></strong> interface. To access a buffer, you should try the following methods in the order listed:</p><ol> <li><strong>IMF2DBuffer2::Lock2DSize</strong></li> <li> <strong>IMF2DBuffer::Lock2D</strong> </li> <li> <strong>IMFMediaBuffer::Lock</strong> </li> </ol><p>The <em>ppbBufferStart</em> and <em>pcbBufferLength</em> parameters receive the bounds of the buffer memory. Use these values to guard against buffer overruns. Use the values of <em>ppbScanline0</em> and <em>plPitch</em> to access the image data. If the image is bottom-up in memory, <em>ppbScanline0</em> will point to the last scan line in memory and <em>plPitch</em> will be negative. For more information, see Image Stride.</p><p>The <em>lockFlags</em> parameter specifies whether the buffer is locked for read-only access, write-only access,  or read/write access. </p><ul> <li>If the buffer is already locked for read-only access, it cannot be locked for write access.</li> <li>If the buffer is already locked for write-only access, it cannot be locked for read access.</li> <li>If the buffer is already locked for read/write acess, it can be locked for read or write acess.</li> </ul><p>When possible, use a read-only or write-only lock, and avoid locking the buffer for read/write access. If the buffer represents a DirectX Graphics Infrastructure (DXGI) surface, a read/write lock can cause an extra copy between CPU memory and GPU memory.</p>
            </remarks>
            <doc-id>hh447829</doc-id>
            <unmanaged>HRESULT IMF2DBuffer2::Lock2DSize([In] MF2DBuffer_LockFlags lockFlags,[Out, Buffer] unsigned char** ppbScanline0,[Out] LONG* plPitch,[Out, Buffer] unsigned char** ppbBufferStart,[Out] DWORD* pcbBufferLength)</unmanaged>
            <unmanaged-short>IMF2DBuffer2::Lock2DSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Buffer2D2.Copy2DTo(SharpDX.MediaFoundation.Buffer2D2)">
            <summary>
            <p>Copies the buffer to another 2D buffer object.</p>
            </summary>
            <param name = "destBufferRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2D2"/></strong> interface of the destination buffer.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The destination buffer must be at least as large as the source buffer.</p>
            </remarks>
            <doc-id>hh447828</doc-id>
            <unmanaged>HRESULT IMF2DBuffer2::Copy2DTo([In] IMF2DBuffer2* pDestBuffer)</unmanaged>
            <unmanaged-short>IMF2DBuffer2::Copy2DTo</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.BufferListNotify.OnAddSourceBuffer">
            <summary>
            <p>Indicates that a <strong><see cref = "T:SharpDX.MediaFoundation.SourceBuffer"/></strong> has been added.</p>
            </summary>
            <doc-id>dn280675</doc-id>
            <unmanaged>void IMFBufferListNotify::OnAddSourceBuffer()</unmanaged>
            <unmanaged-short>IMFBufferListNotify::OnAddSourceBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.BufferListNotify.OnRemoveSourceBuffer">
            <summary>
            <p>Indicates that a <strong><see cref = "T:SharpDX.MediaFoundation.SourceBuffer"/></strong> has been removed.</p>
            </summary>
            <doc-id>dn280676</doc-id>
            <unmanaged>void IMFBufferListNotify::OnRemoveSourceBuffer()</unmanaged>
            <unmanaged-short>IMFBufferListNotify::OnRemoveSourceBuffer</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.ByteStreamBuffering.BufferingParams">
            <summary>
            <p> </p><p>Sets the buffering parameters.</p>
            </summary>
            <doc-id>aa366520</doc-id>
            <unmanaged>SetBufferingParams</unmanaged>
            <unmanaged-short>SetBufferingParams</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStreamBuffering.SetBufferingParams(SharpDX.MediaFoundation.ByteStreamBufferingParameters@)">
            <summary>
            <p> </p><p>Sets the buffering parameters.</p>
            </summary>
            <param name = "paramsRef"><dd> <p>Pointer to an <strong><see cref = "T:SharpDX.MediaFoundation.ByteStreamBufferingParameters"/></strong> structure that contains the buffering parameters. The byte stream uses this information to calculate how much data to buffer from the network.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>aa366520</doc-id>
            <unmanaged>HRESULT IMFByteStreamBuffering::SetBufferingParams([In] MFBYTESTREAM_BUFFERING_PARAMS* pParams)</unmanaged>
            <unmanaged-short>IMFByteStreamBuffering::SetBufferingParams</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStreamBuffering.EnableBuffering(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p> </p><p>Enables or disables buffering.</p>
            </summary>
            <param name = "fEnable"><dd> <p>Specifies whether the byte stream buffers data. If <strong>TRUE</strong>, buffering is enabled. If <strong><see cref = "F:SharpDX.Result.False"/></strong>, buffering is disabled.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Before calling this method, call <strong>IMFByteStreamBuffering::SetBufferingParams</strong> to set the buffering parameters on the byte stream.</p>
            </remarks>
            <doc-id>aa369933</doc-id>
            <unmanaged>HRESULT IMFByteStreamBuffering::EnableBuffering([In] BOOL fEnable)</unmanaged>
            <unmanaged-short>IMFByteStreamBuffering::EnableBuffering</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStreamBuffering.StopBuffering">
            <summary>
            <p> </p><p>Stops any buffering that is in progress.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The byte stream successfully stopped buffering.</p> </td></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p>No buffering was in progress.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the byte stream is currently buffering data, it stops and sends an MEBufferingStopped event. If the byte stream is not currently buffering, this method has no effect.</p>
            </remarks>
            <doc-id>aa375256</doc-id>
            <unmanaged>HRESULT IMFByteStreamBuffering::StopBuffering()</unmanaged>
            <unmanaged-short>IMFByteStreamBuffering::StopBuffering</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStreamCacheControl.StopBackgroundTransfer">
            <summary>
            <p>Stops the background transfer of data to the local cache.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The byte stream resumes transferring data to the cache if the application does one of the following:</p><ul> <li>Reads data from the byte stream.</li> <li>Calls the byte stream's <strong>IMFByteStreamBuffering::EnableBuffering</strong> method.</li> </ul>
            </remarks>
            <doc-id>dd368786</doc-id>
            <unmanaged>HRESULT IMFByteStreamCacheControl::StopBackgroundTransfer()</unmanaged>
            <unmanaged-short>IMFByteStreamCacheControl::StopBackgroundTransfer</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.ByteStreamCacheControl2.CacheLimit">
            <summary>
            <p>Limits the cache size.</p>
            </summary>
            <doc-id>hh447833</doc-id>
            <unmanaged>SetCacheLimit</unmanaged>
            <unmanaged-short>SetCacheLimit</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.ByteStreamCacheControl2.IsBackgroundTransferActive">
            <summary>
            <p>Queries whether background transfer is active.</p>
            </summary>
            <remarks>
            <p>Background transfer might stop because the cache limit was reached (see <strong>IMFByteStreamCacheControl2::SetCacheLimit</strong>) or because the <strong>IMFByteStreamCacheControl::StopBackgroundTransfer</strong> method was called.</p>
            </remarks>
            <doc-id>hh447832</doc-id>
            <unmanaged>IsBackgroundTransferActive</unmanaged>
            <unmanaged-short>IsBackgroundTransferActive</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStreamCacheControl2.GetByteRanges(System.Int32@,SharpDX.MediaFoundation.ByteStreamCacheRange[])">
            <summary>
            <p>Gets the ranges of bytes that are currently stored in the cache.</p>
            </summary>
            <param name = "cRangesRef"><dd> <p>Receives the number of ranges returned in the <em>ppRanges</em> array.</p> </dd></param>
            <param name = "rangesOut"><dd> <p>Receives an array of <strong><see cref = "T:SharpDX.MediaFoundation.ByteStreamCacheRange"/></strong> structures. Each structure specifies a range of bytes stored in the cache. The caller must free the array by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447831</doc-id>
            <unmanaged>HRESULT IMFByteStreamCacheControl2::GetByteRanges([Out] DWORD* pcRanges,[Buffer, Optional] MF_BYTE_STREAM_CACHE_RANGE** ppRanges)</unmanaged>
            <unmanaged-short>IMFByteStreamCacheControl2::GetByteRanges</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStreamCacheControl2.SetCacheLimit(System.Int64)">
            <summary>
            <p>Limits the cache size.</p>
            </summary>
            <param name = "qwBytes"><dd> <p>The maximum number of bytes to store in the cache, or <strong>ULONGLONG_MAX </strong> for no limit.  The default value is no limit.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447833</doc-id>
            <unmanaged>HRESULT IMFByteStreamCacheControl2::SetCacheLimit([In] unsigned longlong qwBytes)</unmanaged>
            <unmanaged-short>IMFByteStreamCacheControl2::SetCacheLimit</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStreamCacheControl2.IsBackgroundTransferActive_(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Queries whether background transfer is active.</p>
            </summary>
            <param name = "fActiveRef"><dd> <p>Receives the value <strong>TRUE</strong> if background transfer is currently active, or <strong><see cref = "F:SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Background transfer might stop because the cache limit was reached (see <strong>IMFByteStreamCacheControl2::SetCacheLimit</strong>) or because the <strong>IMFByteStreamCacheControl::StopBackgroundTransfer</strong> method was called.</p>
            </remarks>
            <doc-id>hh447832</doc-id>
            <unmanaged>HRESULT IMFByteStreamCacheControl2::IsBackgroundTransferActive([Out] BOOL* pfActive)</unmanaged>
            <unmanaged-short>IMFByteStreamCacheControl2::IsBackgroundTransferActive</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.ByteStreamHandler.MaxNumberOfBytesRequiredForResolution">
            <summary>
            <p> </p><p>Retrieves the maximum number of bytes needed to create the media source or determine that the byte stream handler cannot parse this stream.</p>
            </summary>
            <doc-id>ms704770</doc-id>
            <unmanaged>GetMaxNumberOfBytesRequiredForResolution</unmanaged>
            <unmanaged-short>GetMaxNumberOfBytesRequiredForResolution</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStreamHandler.BeginCreateObject(SharpDX.MediaFoundation.IByteStream,System.String,System.Int32,SharpDX.ComObject,SharpDX.IUnknown@,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Begins an asynchronous request to create a media source from a byte stream.</p>
            </summary>
            <param name = "byteStreamRef"><dd> <p>Pointer to the byte stream's <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface.</p> </dd></param>
            <param name = "wszURLRef"><dd> <p>String that contains the original URL of the byte stream. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "dwFlags"><dd> <p>Bitwise OR of zero or more flags. See <strong>Source Resolver Flags</strong>.</p> </dd></param>
            <param name = "propsRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.ComObject"/></strong> interface of a property store. The byte-stream handler can use this property store to configure the object. This parameter can be <strong><c>null</c></strong>. For more information, see Configuring a Media Source.</p> </dd></param>
            <param name = "iUnknownCancelCookieOut"><dd> <p>Receives an <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference or the value <strong><c>null</c></strong>. If the value is not <strong><c>null</c></strong>, you can cancel the asynchronous operation by passing this reference to the <strong>IMFByteStreamHandler::CancelObjectCreation</strong> method. The caller must release the interface. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "callbackRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>
            <param name = "unkStateRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:CannotParseByteStream"/></strong></dt> </dl> </td><td> <p>Unable to parse the byte stream.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The <em>dwFlags</em> parameter must contain the MF_RESOLUTION_MEDIASOURCE flag and should not contain the MF_RESOLUTION_BYTESTREAM flag.</p><p>The byte-stream handler is responsible for parsing the stream and validating the contents. If the stream is not valid or the byte stream handler cannot parse the stream, the handler should return a failure code. The byte stream is not guaranteed to match the type of stream that the byte handler is designed to parse.</p><p>If the <em>pwszURL</em> parameter is not <strong><c>null</c></strong>, the byte-stream handler might use the URL during the resolution process. (For example, it might use the file name extension, if present.) Also, the byte stream might contain the <strong><see cref = "!:ContentType"/></strong> attribute, specifying the MIME type.</p><p>When the operation completes, the byte-stream handler calls the <strong>IMFAsyncCallback::Invoke</strong> method. The <strong>Invoke</strong> method should call <strong>IMFByteStreamHandler::EndCreateObject</strong> to get a reference to the media source.</p>
            </remarks>
            <doc-id>ms696214</doc-id>
            <unmanaged>HRESULT IMFByteStreamHandler::BeginCreateObject([In] IMFByteStream* pByteStream,[In] const wchar_t* pwszURL,[In] DWORD dwFlags,[In] IPropertyStore* pProps,[Out, Optional] IUnknown** ppIUnknownCancelCookie,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>
            <unmanaged-short>IMFByteStreamHandler::BeginCreateObject</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStreamHandler.EndCreateObject(SharpDX.MediaFoundation.AsyncResult,SharpDX.MediaFoundation.ObjectType@,SharpDX.IUnknown@)">
            <summary>
            <p> </p><p>Completes an asynchronous request to create a media source.</p>
            </summary>
            <param name = "resultRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>Invoke</strong> method.</p> </dd></param>
            <param name = "objectTypeRef"><dd> <p>Receives a member of the <strong><see cref = "T:SharpDX.MediaFoundation.ObjectType"/></strong> enumeration, specifying the type of object that was created.</p> </dd></param>
            <param name = "objectOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of the media source. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_ABORT</strong></dt> </dl> </td><td> <p>The operation was canceled. See <strong>IMFByteStreamHandler::CancelObjectCreation</strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:CannotParseByteStream"/></strong></dt> </dl> </td><td> <p>Unable to parse the byte stream.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this method from inside the <strong>IMFAsyncCallback::Invoke</strong> method.</p>
            </remarks>
            <doc-id>ms700217</doc-id>
            <unmanaged>HRESULT IMFByteStreamHandler::EndCreateObject([In] IMFAsyncResult* pResult,[Out] MF_OBJECT_TYPE* pObjectType,[Out] IUnknown** ppObject)</unmanaged>
            <unmanaged-short>IMFByteStreamHandler::EndCreateObject</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStreamHandler.CancelObjectCreation(SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Cancels the current request to create a media source.</p>
            </summary>
            <param name = "iUnknownCancelCookieRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface that was returned in the <em>ppIUnknownCancelCookie</em> parameter of the <strong>IMFByteStreamHandler::BeginCreateObject</strong> method.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>You can use this method to cancel a previous call to <strong>BeginCreateObject</strong>. Because that method is asynchronous, however, it might be completed before the operation can be canceled. Therefore, your callback might still be invoked after you call this method.</p>
            </remarks>
            <doc-id>ms701576</doc-id>
            <unmanaged>HRESULT IMFByteStreamHandler::CancelObjectCreation([In] IUnknown* pIUnknownCancelCookie)</unmanaged>
            <unmanaged-short>IMFByteStreamHandler::CancelObjectCreation</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStreamHandler.GetMaxNumberOfBytesRequiredForResolution(System.Int64@)">
            <summary>
            <p> </p><p>Retrieves the maximum number of bytes needed to create the media source or determine that the byte stream handler cannot parse this stream.</p>
            </summary>
            <param name = "qwBytesRef"><dd> <p>Receives the maximum number of bytes that are required.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms704770</doc-id>
            <unmanaged>HRESULT IMFByteStreamHandler::GetMaxNumberOfBytesRequiredForResolution([Out] unsigned longlong* pqwBytes)</unmanaged>
            <unmanaged-short>IMFByteStreamHandler::GetMaxNumberOfBytesRequiredForResolution</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStreamProxyClassFactory.CreateByteStreamProxy(SharpDX.MediaFoundation.IByteStream,SharpDX.MediaFoundation.MediaAttributes,System.Guid,System.IntPtr@)">
            <summary>
            <p>Creates a proxy to a byte stream. The proxy enables a media source to read from a byte stream in another process.</p>
            </summary>
            <param name = "byteStreamRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of the byte stream to proxy.</p> </dd></param>
            <param name = "attributesRef"><dd> <p>Reserved. Set to <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "riid"><dd> <p>The interface identifer (IID) of the interface being requested.</p> </dd></param>
            <param name = "vObjectOut"><dd> <p>Receives a reference to the interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447835</doc-id>
            <unmanaged>HRESULT IMFByteStreamProxyClassFactory::CreateByteStreamProxy([In, Optional] IMFByteStream* pByteStream,[In, Optional] IMFAttributes* pAttributes,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>
            <unmanaged-short>IMFByteStreamProxyClassFactory::CreateByteStreamProxy</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.ByteStreamTimeSeek.IsTimeSeekSupported">
            <summary>
            <p>Queries whether the byte stream supports time-based seeking.</p>
            </summary>
            <doc-id>hh447838</doc-id>
            <unmanaged>IsTimeSeekSupported</unmanaged>
            <unmanaged-short>IsTimeSeekSupported</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStreamTimeSeek.IsTimeSeekSupported_(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Queries whether the byte stream supports time-based seeking.</p>
            </summary>
            <param name = "fTimeSeekIsSupportedRef"><dd> <p>Receives the value <strong>TRUE</strong> if the byte stream supports time-based seeking, or <strong><see cref = "F:SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447838</doc-id>
            <unmanaged>HRESULT IMFByteStreamTimeSeek::IsTimeSeekSupported([Out] BOOL* pfTimeSeekIsSupported)</unmanaged>
            <unmanaged-short>IMFByteStreamTimeSeek::IsTimeSeekSupported</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStreamTimeSeek.TimeSeek(System.Int64)">
            <summary>
            <p>Seeks to a new position in the byte stream.</p>
            </summary>
            <param name = "qwTimePosition"><dd> <p>The new position, in 100-nanosecond units.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If the byte stream reads from a server, it might cache the seek request until the next read request. Therefore, the byte stream might not send a request to the server immediately.</p>
            </remarks>
            <doc-id>hh447839</doc-id>
            <unmanaged>HRESULT IMFByteStreamTimeSeek::TimeSeek([In] unsigned longlong qwTimePosition)</unmanaged>
            <unmanaged-short>IMFByteStreamTimeSeek::TimeSeek</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ByteStreamTimeSeek.GetTimeSeekResult(System.Int64@,System.Int64@,System.Int64@)">
            <summary>
            <p>Gets the result of a time-based seek.</p>
            </summary>
            <param name = "qwStartTimeRef"><dd> <p>Receives the new position after the seek, in 100-nanosecond units.</p> </dd></param>
            <param name = "qwStopTimeRef"><dd> <p>Receives the stop time, in 100-nanosecond units. If the stop time is unknown, the value is zero.</p> </dd></param>
            <param name = "qwDurationRef"><dd> <p>Receives the total duration of the file, in 100-nanosecond units. If the duration is unknown, the value is ?1.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The byte stream does not support time-based seeking, or no data is available.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method returns the server response from a previous time-based seek. </p><strong>Note</strong>??This method normally cannot be invoked until some data is read from the byte stream, because the <strong>IMFByteStreamTimeSeek::TimeSeek</strong> method does not send a server request immediately.?
            </remarks>
            <doc-id>hh447837</doc-id>
            <unmanaged>HRESULT IMFByteStreamTimeSeek::GetTimeSeekResult([Out] unsigned longlong* pqwStartTime,[Out] unsigned longlong* pqwStopTime,[Out] unsigned longlong* pqwDuration)</unmanaged>
            <unmanaged-short>IMFByteStreamTimeSeek::GetTimeSeekResult</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngine.ClsidMFCaptureEngine">
            <summary>Constant ClsidMFCaptureEngine</summary>
            <unmanaged>CLSID_MFCaptureEngine</unmanaged>
        </member>
        <member name="P:SharpDX.MediaFoundation.CaptureEngine.Source">
            <summary>
            <p>Gets a reference to the capture source object. Use the capture source to configure the capture devices.</p>
            </summary>
            <doc-id>hh447854</doc-id>
            <unmanaged>GetSource</unmanaged>
            <unmanaged-short>GetSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureEngine.Initialize(SharpDX.MediaFoundation.CaptureEngineOnEventCallback,SharpDX.MediaFoundation.MediaAttributes,SharpDX.IUnknown,SharpDX.IUnknown)">
            <summary>
            <p>Initializes the capture engine.</p>
            </summary>
            <param name = "eventCallbackRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.CaptureEngineOnEventCallback"/></strong> interface. The caller must implement this interface. The capture engine uses this interface to send asynchronous events to the caller.</p> </dd></param>
            <param name = "attributesRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. This parameter can be <strong><c>null</c></strong>. </p> <p>You can use this parameter to configure the capture engine. Call <strong>MFCreateAttributes</strong> to create an attribute store, and then set any of the following attributes.</p> <ul> <li> <see cref = "!:D3DManager"/> </li> <li> <see cref = "!:DisableDXVA"/> </li> <li> <see cref = "!:DisableHardwareTransforms"/> </li> <li> <see cref = "!:EncoderTransformFieldOfUseUnlockAttribute"/> </li> <li> <see cref = "!:EventGeneratorGuid"/> </li> <li> <see cref = "!:EventStreamIndex"/> </li> <li> <see cref = "!:MediaSourceConfig"/> </li> <li> <see cref = "!:RecordSinkAudioMaxProcessedSamples"/> </li> <li> <see cref = "!:RecordSinkAudioMaxUnprocessedSamples"/> </li> <li> <see cref = "!:RecordSinkVideoMaxProcessedSamples"/> </li> <li> <see cref = "!:RecordSinkVideoMaxUnprocessedSamples"/> </li> <li> <see cref = "!:UseAudioDeviceOnly"/> </li> <li> <see cref = "!:UseVideoDeviceOnly"/> </li> </ul> </dd></param>
            <param name = "audioSourceRef"><dd> <p>An <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference that specifies an audio-capture device. This parameter can be <strong><c>null</c></strong>.</p> <p>If you set the <see cref = "!:UseVideoDeviceOnly"/> attribute to <strong>TRUE</strong> in <em>pAttributes</em>, the capture engine does not use an audio device, and the <em>pAudioSource</em> parameter is ignored.</p> <p>Otherwise, if <em>pAudioSource</em> is <strong><c>null</c></strong>, the capture engine selects the microphone that is built into the video camera specified by <em>pVideoSource</em>. If the video camera does not have a microphone, the capture engine enumerates the audio-capture devices on the system and selects the first one.</p> <p>To override the default audio device, set <em>pAudioSource</em> to an <strong><see cref = "T:SharpDX.MediaFoundation.MediaSource"/></strong> or <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> reference for the device. For more information, see Audio/Video Capture in Media Foundation.</p> </dd></param>
            <param name = "videoSourceRef"><dd> <p>An <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference that specifies a video-capture device. This parameter can be <strong><c>null</c></strong>.</p> <p>If you set the <see cref = "!:UseAudioDeviceOnly"/> attribute to <strong>TRUE</strong> in <em>pAttributes</em>, the capture engine does not use a video device, and the <em>pVideoSource</em> parameter is ignored.</p> <p>Otherwise, if <em>pVideoSource</em> is <strong><c>null</c></strong>, the capture engine enumerates the video-capture devices on the system and selects the first one.</p> <p>To override the default video device, set <em>pVideoSource</em> to an <strong><see cref = "T:SharpDX.MediaFoundation.MediaSource"/></strong> or <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> reference for the device. For more information, see Enumerating Video Capture Devices.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The <strong>Initialize</strong> method was already called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NoCaptureDevicesAvailable"/></strong></dt> </dl> </td><td> <p>No capture devices are available.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>You must call this method once before using the capture engine. Calling the method a second time returns <strong><see cref = "!:InvalidRequest"/></strong>.</p><p>This method is asynchronous. If the method returns a success code, the caller will receive an <strong>MF_CAPTURE_ENGINE_INITIALIZED</strong> event through the <strong>IMFCaptureEngineOnEventCallback::OnEvent</strong> method. The operation can fail asynchronously after the method succeeds. If so, the error code is conveyed through the <strong>OnEvent</strong> method.</p>
            </remarks>
            <doc-id>hh447855</doc-id>
            <unmanaged>HRESULT IMFCaptureEngine::Initialize([In] IMFCaptureEngineOnEventCallback* pEventCallback,[In, Optional] IMFAttributes* pAttributes,[In, Optional] IUnknown* pAudioSource,[In, Optional] IUnknown* pVideoSource)</unmanaged>
            <unmanaged-short>IMFCaptureEngine::Initialize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureEngine.StartPreview">
            <summary>
            <p>Starts preview.</p>
            </summary>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The preview sink was not initialized.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Before calling this method, configure the preview sink by calling <strong>IMFCaptureSink::AddStream</strong>. To get a reference to the preview sink, call <strong>IMFCaptureEngine::GetSink</strong>. </p><p>This method is asynchronous. If the method returns a success code, the caller will receive an <strong>MF_CAPTURE_ENGINE_PREVIEW_STARTED</strong> event through the <strong>IMFCaptureEngineOnEventCallback::OnEvent</strong> method. The operation can fail asynchronously after the method succeeds. If so, the error code is conveyed through the <strong>OnEvent</strong> method.</p><p>After the preview sink is configured, you can stop and start preview by calling <strong>IMFCaptureEngine::StopPreview</strong> and <strong>IMFCaptureEngine::StartPreview</strong>.</p>
            </remarks>
            <doc-id>hh447856</doc-id>
            <unmanaged>HRESULT IMFCaptureEngine::StartPreview()</unmanaged>
            <unmanaged-short>IMFCaptureEngine::StartPreview</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureEngine.StopPreview">
            <summary>
            <p>Stops preview.</p>
            </summary>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The capture engine is not currently previewing.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is asynchronous. If the method returns a success code, the caller will receive an <strong>MF_CAPTURE_ENGINE_PREVIEW_STOPPED</strong> event through the <strong>IMFCaptureEngineOnEventCallback::OnEvent</strong> method. The operation can fail asynchronously after the method succeeds. If so, the error code is conveyed through the <strong>OnEvent</strong> method.</p>
            </remarks>
            <doc-id>hh447858</doc-id>
            <unmanaged>HRESULT IMFCaptureEngine::StopPreview()</unmanaged>
            <unmanaged-short>IMFCaptureEngine::StopPreview</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureEngine.StartRecord">
            <summary>
            <p>Starts recording audio and/or video to a file.</p>
            </summary>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The recording sink was not initialized.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Before calling this method, configure the recording sink by calling <strong>IMFCaptureSink::AddStream</strong>. To get a reference to the recording sink, call <strong>IMFCaptureEngine::GetSink</strong>.</p><p>This method is asynchronous. If the method returns a success code, the caller will receive an <strong>MF_CAPTURE_ENGINE_RECORD_STARTED</strong> event through the <strong>IMFCaptureEngineOnEventCallback::OnEvent</strong> method. The operation can fail asynchronously after the method succeeds. If so, the error code is conveyed through the <strong>OnEvent</strong> method.</p><p>To stop recording, call <strong>IMFCaptureEngine::StopRecord</strong>.</p>
            </remarks>
            <doc-id>hh447857</doc-id>
            <unmanaged>HRESULT IMFCaptureEngine::StartRecord()</unmanaged>
            <unmanaged-short>IMFCaptureEngine::StartRecord</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureEngine.StopRecord(SharpDX.Mathematics.Interop.RawBool,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Stops recording.</p>
            </summary>
            <param name = "bFinalize"><dd> <p>A Boolean value that specifies whether to finalize the output file. To create a valid output file, specify <strong>TRUE</strong>. Specify <strong><see cref = "F:SharpDX.Result.False"/></strong> only if you want to interrupt the recording and discard the output file. If the value is <strong><see cref = "F:SharpDX.Result.False"/></strong>, the operation completes more quickly, but the file will not be playable. </p> </dd></param>
            <param name = "bFlushUnprocessedSamples"><dd> <p>A Boolean value that specifies if the unprocessed samples waiting to be encoded should be flushed.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method is asynchronous. If the method returns a success code, the caller will receive an <strong>MF_CAPTURE_ENGINE_RECORD_STOPPED</strong> event through the <strong>IMFCaptureEngineOnEventCallback::OnEvent</strong> method. The operation can fail asynchronously after the method succeeds. If so, the error code is conveyed through the <strong>OnEvent</strong> method.</p>
            </remarks>
            <doc-id>hh447859</doc-id>
            <unmanaged>HRESULT IMFCaptureEngine::StopRecord([In] BOOL bFinalize,[In] BOOL bFlushUnprocessedSamples)</unmanaged>
            <unmanaged-short>IMFCaptureEngine::StopRecord</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureEngine.TakePhoto">
            <summary>
            <p>Captures a still image from the video stream.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Before calling this method, configure the photo sink by calling <strong>IMFCaptureSink::AddStream</strong>. To get a reference to the photo sink, call <strong>IMFCaptureEngine::GetSink</strong>. </p><p>This method is asynchronous. If the method returns a success code, the caller will receive an <strong>MF_CAPTURE_ENGINE_PHOTO_TAKEN</strong> event through the <strong>IMFCaptureEngineOnEventCallback::OnEvent</strong> method. The operation can fail asynchronously after the method succeeds. If so, the error code is conveyed through the <strong>OnEvent</strong> method.</p>
            </remarks>
            <doc-id>hh447860</doc-id>
            <unmanaged>HRESULT IMFCaptureEngine::TakePhoto()</unmanaged>
            <unmanaged-short>IMFCaptureEngine::TakePhoto</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureEngine.GetSink(SharpDX.MediaFoundation.CaptureEngineSinkType,SharpDX.MediaFoundation.CaptureSink@)">
            <summary>
            <p>Gets a reference to one of the capture sink objects. You can use the capture sinks to configure preview, recording, or still-image capture.</p>
            </summary>
            <param name = "mfCaptureEngineSinkType"><dd> <p>An <strong><see cref = "T:SharpDX.MediaFoundation.CaptureEngineSinkType"/></strong> value that specifies the capture sink to retrieve.</p> </dd></param>
            <param name = "sinkOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.CaptureSink"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>hh447853</doc-id>
            <unmanaged>HRESULT IMFCaptureEngine::GetSink([In] MF_CAPTURE_ENGINE_SINK_TYPE mfCaptureEngineSinkType,[Out] IMFCaptureSink** ppSink)</unmanaged>
            <unmanaged-short>IMFCaptureEngine::GetSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureEngine.GetSource(SharpDX.MediaFoundation.CaptureSource@)">
            <summary>
            <p>Gets a reference to the capture source object. Use the capture source to configure the capture devices.</p>
            </summary>
            <param name = "sourceOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.CaptureSource"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447854</doc-id>
            <unmanaged>HRESULT IMFCaptureEngine::GetSource([Out] IMFCaptureSource** ppSource)</unmanaged>
            <unmanaged-short>IMFCaptureEngine::GetSource</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CaptureEngineClassFactory.ClsidMFCaptureEngineClassFactory">
            <summary>Constant ClsidMFCaptureEngineClassFactory</summary>
            <unmanaged>CLSID_MFCaptureEngineClassFactory</unmanaged>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureEngineClassFactory.CreateInstance(System.Guid,System.Guid,System.IntPtr@)">
            <summary>
            <p>Creates an instance of the capture engine.</p>
            </summary>
            <param name = "clsid"><dd> <p>The CLSID of the object to create. Currently, this parameter must equal <strong><see cref = "!:ClsidMFCaptureEngine"/></strong>.</p> </dd></param>
            <param name = "riid"><dd> <p>The IID of the requested interface. The capture engine supports the <strong><see cref = "T:SharpDX.MediaFoundation.CaptureEngine"/></strong> interface.</p> </dd></param>
            <param name = "vObjectOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Before calling this method, call the <strong>MFStartup</strong> function.</p>
            </remarks>
            <doc-id>hh447848</doc-id>
            <unmanaged>HRESULT IMFCaptureEngineClassFactory::CreateInstance([In] const GUID&amp; clsid,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>
            <unmanaged-short>IMFCaptureEngineClassFactory::CreateInstance</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.CapturePhotoConfirmation.PixelFormat">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetPixelFormat / SetPixelFormat</unmanaged>
            <unmanaged-short>GetPixelFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CapturePhotoConfirmation.SetPhotoConfirmationCallback(SharpDX.MediaFoundation.IAsyncCallback)">
            <summary>
            No documentation.
            </summary>
            <param name = "notificationCallbackRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFCapturePhotoConfirmation::SetPhotoConfirmationCallback([In] IMFAsyncCallback* pNotificationCallback)</unmanaged>
            <unmanaged-short>IMFCapturePhotoConfirmation::SetPhotoConfirmationCallback</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CapturePhotoConfirmation.SetPixelFormat(System.Guid)">
            <summary>
            No documentation.
            </summary>
            <param name = "subtype">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFCapturePhotoConfirmation::SetPixelFormat([In] GUID subtype)</unmanaged>
            <unmanaged-short>IMFCapturePhotoConfirmation::SetPixelFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CapturePhotoConfirmation.GetPixelFormat(System.Guid@)">
            <summary>
            No documentation.
            </summary>
            <param name = "subtype">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFCapturePhotoConfirmation::GetPixelFormat([Out] GUID* subtype)</unmanaged>
            <unmanaged-short>IMFCapturePhotoConfirmation::GetPixelFormat</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.CapturePhotoSink.OutputFileName">
            <summary>
            <p>Specifies the name of the output file for the still image.</p>
            </summary>
            <remarks>
            <p>Calling this method overrides any previous call to <strong>IMFCapturePhotoSink::SetOutputByteStream</strong> or <strong>IMFCapturePhotoSink::SetSampleCallback</strong>.</p>
            </remarks>
            <doc-id>hh447863</doc-id>
            <unmanaged>SetOutputFileName</unmanaged>
            <unmanaged-short>SetOutputFileName</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CapturePhotoSink.SetOutputFileName(System.String)">
            <summary>
            <p>Specifies the name of the output file for the still image.</p>
            </summary>
            <param name = "fileName"><dd> <p>A null-terminated string that contains the URL of the output file. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Calling this method overrides any previous call to <strong>IMFCapturePhotoSink::SetOutputByteStream</strong> or <strong>IMFCapturePhotoSink::SetSampleCallback</strong>.</p>
            </remarks>
            <doc-id>hh447863</doc-id>
            <unmanaged>HRESULT IMFCapturePhotoSink::SetOutputFileName([In] const wchar_t* fileName)</unmanaged>
            <unmanaged-short>IMFCapturePhotoSink::SetOutputFileName</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CapturePhotoSink.SetSampleCallback(SharpDX.MediaFoundation.CaptureEngineOnSampleCallback)">
            <summary>
            <p>Sets a callback to receive the still-image data.</p>
            </summary>
            <param name = "callbackRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.CaptureEngineOnSampleCallback"/></strong> interface. The caller must implement this interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Calling this method overrides any previous call to <strong>IMFCapturePhotoSink::SetOutputByteStream</strong> or  <strong>IMFCapturePhotoSink::SetOutputFileName</strong>.</p>
            </remarks>
            <doc-id>hh447864</doc-id>
            <unmanaged>HRESULT IMFCapturePhotoSink::SetSampleCallback([In] IMFCaptureEngineOnSampleCallback* pCallback)</unmanaged>
            <unmanaged-short>IMFCapturePhotoSink::SetSampleCallback</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CapturePhotoSink.SetOutputByteStream(SharpDX.MediaFoundation.IByteStream)">
            <summary>
            <p>Specifies a byte stream that will receive the still image data.</p>
            </summary>
            <param name = "byteStreamRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream. The byte stream must be writable.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Calling this method overrides any previous call to <strong>IMFCapturePhotoSink::SetOutputFileName</strong> or <strong>IMFCapturePhotoSink::SetSampleCallback</strong>.</p>
            </remarks>
            <doc-id>hh447862</doc-id>
            <unmanaged>HRESULT IMFCapturePhotoSink::SetOutputByteStream([In] IMFByteStream* pByteStream)</unmanaged>
            <unmanaged-short>IMFCapturePhotoSink::SetOutputByteStream</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.CapturePreviewSink.RenderHandle">
            <summary>
            <p>Specifies a window for preview.</p>
            </summary>
            <remarks>
            <p>Calling this method overrides any previous call to <strong>IMFCapturePreviewSink::SetSampleCallback</strong>.</p>
            </remarks>
            <doc-id>hh447870</doc-id>
            <unmanaged>SetRenderHandle</unmanaged>
            <unmanaged-short>SetRenderHandle</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.CapturePreviewSink.RenderSurface">
            <summary>
            <p>Specifies a Microsoft DirectComposition visual for preview.</p>
            </summary>
            <doc-id>hh447871</doc-id>
            <unmanaged>SetRenderSurface</unmanaged>
            <unmanaged-short>SetRenderSurface</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.CapturePreviewSink.MirrorState">
            <summary>
            <p>Gets or sets the current mirroring state of the video preview stream.</p>
            </summary>
            <doc-id>hh447866</doc-id>
            <unmanaged>GetMirrorState / SetMirrorState</unmanaged>
            <unmanaged-short>GetMirrorState</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.CapturePreviewSink.CustomSink">
            <summary>
            <p>Sets a custom media sink for preview.</p>
            </summary>
            <remarks>
            <p>This method overrides the default selection of the media sink for preview.</p>
            </remarks>
            <doc-id>hh447868</doc-id>
            <unmanaged>SetCustomSink</unmanaged>
            <unmanaged-short>SetCustomSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CapturePreviewSink.SetRenderHandle(System.IntPtr)">
            <summary>
            <p>Specifies a window for preview.</p>
            </summary>
            <param name = "handle"><dd> <p>A handle to the window. The preview sink draws the video frames inside this window.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Calling this method overrides any previous call to <strong>IMFCapturePreviewSink::SetSampleCallback</strong>.</p>
            </remarks>
            <doc-id>hh447870</doc-id>
            <unmanaged>HRESULT IMFCapturePreviewSink::SetRenderHandle([In] void* handle)</unmanaged>
            <unmanaged-short>IMFCapturePreviewSink::SetRenderHandle</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CapturePreviewSink.SetRenderSurface(SharpDX.IUnknown)">
            <summary>
            <p>Specifies a Microsoft DirectComposition visual for preview.</p>
            </summary>
            <param name = "surfaceRef"><dd> <p>A reference to a DirectComposition visual that implements the <strong><see cref = "!:SharpDX.DirectComposition.Visual"/></strong> interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447871</doc-id>
            <unmanaged>HRESULT IMFCapturePreviewSink::SetRenderSurface([In] IUnknown* pSurface)</unmanaged>
            <unmanaged-short>IMFCapturePreviewSink::SetRenderSurface</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CapturePreviewSink.UpdateVideo(System.Nullable{SharpDX.MediaFoundation.VideoNormalizedRect},System.Nullable{SharpDX.Mathematics.Interop.RawRectangle},System.Nullable{System.Int32})">
            <summary>
            <p>Updates the video frame.  Call this method when the preview window receives a <strong>WM_PAINT</strong> or <strong>WM_SIZE</strong> message.</p>
            </summary>
            <param name = "srcRef">No documentation.</param>
            <param name = "dstRef">No documentation.</param>
            <param name = "borderClrRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447874</doc-id>
            <unmanaged>HRESULT IMFCapturePreviewSink::UpdateVideo([In, Optional] const MFVideoNormalizedRect* pSrc,[In, Optional] const RECT* pDst,[In, Optional] const COLORREF* pBorderClr)</unmanaged>
            <unmanaged-short>IMFCapturePreviewSink::UpdateVideo</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CapturePreviewSink.SetSampleCallback(System.Int32,SharpDX.MediaFoundation.CaptureEngineOnSampleCallback)">
            <summary>
            <p>Sets a callback to receive the preview data for one stream.</p>
            </summary>
            <param name = "dwStreamSinkIndex"><dd> <p>The zero-based index of the stream. The index is returned in the <em>pdwSinkStreamIndex</em> parameter of the <strong>IMFCaptureSink::AddStream</strong> method.</p> </dd></param>
            <param name = "callbackRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.CaptureEngineOnSampleCallback"/></strong> interface. The caller must implement this interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Calling this method overrides any previous call to <strong>IMFCapturePreviewSink::SetRenderHandle</strong>.</p>
            </remarks>
            <doc-id>hh447873</doc-id>
            <unmanaged>HRESULT IMFCapturePreviewSink::SetSampleCallback([In] DWORD dwStreamSinkIndex,[In] IMFCaptureEngineOnSampleCallback* pCallback)</unmanaged>
            <unmanaged-short>IMFCapturePreviewSink::SetSampleCallback</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CapturePreviewSink.GetMirrorState(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Gets the current mirroring state of the video preview stream.</p>
            </summary>
            <param name = "fMirrorStateRef"><dd> <p>Receives the value <strong>TRUE</strong> if mirroring is enabled, or <strong><see cref = "F:SharpDX.Result.False"/></strong> if mirroring is disabled.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447866</doc-id>
            <unmanaged>HRESULT IMFCapturePreviewSink::GetMirrorState([Out] BOOL* pfMirrorState)</unmanaged>
            <unmanaged-short>IMFCapturePreviewSink::GetMirrorState</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CapturePreviewSink.SetMirrorState(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Enables or disables mirroring of the video preview stream.</p>
            </summary>
            <param name = "fMirrorState"><dd> <p>If   <strong>TRUE</strong>, mirroring is enabled. If <strong><see cref = "F:SharpDX.Result.False"/></strong>, mirror is disabled.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447869</doc-id>
            <unmanaged>HRESULT IMFCapturePreviewSink::SetMirrorState([In] BOOL fMirrorState)</unmanaged>
            <unmanaged-short>IMFCapturePreviewSink::SetMirrorState</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CapturePreviewSink.GetRotation(System.Int32,System.Int32@)">
            <summary>
            <p>Gets the rotation of the video preview stream.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The zero-based index of the stream. You must specify a video stream.</p> </dd></param>
            <param name = "dwRotationValueRef"><dd> <p>Receives the image rotation, in degrees.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447867</doc-id>
            <unmanaged>HRESULT IMFCapturePreviewSink::GetRotation([In] DWORD dwStreamIndex,[Out] DWORD* pdwRotationValue)</unmanaged>
            <unmanaged-short>IMFCapturePreviewSink::GetRotation</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CapturePreviewSink.SetRotation(System.Int32,System.Int32)">
            <summary>
            <p>Rotates the video preview stream.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The zero-based index of the stream to rotate. You must specify a video stream.</p> </dd></param>
            <param name = "dwRotationValue"><dd> <p>The amount to rotate the video, in degrees. Valid values are 0, 90, 180, and 270. The value zero restores the video to its original orientation.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447872</doc-id>
            <unmanaged>HRESULT IMFCapturePreviewSink::SetRotation([In] DWORD dwStreamIndex,[In] DWORD dwRotationValue)</unmanaged>
            <unmanaged-short>IMFCapturePreviewSink::SetRotation</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CapturePreviewSink.SetCustomSink(SharpDX.MediaFoundation.MediaSink)">
            <summary>
            <p>Sets a custom media sink for preview.</p>
            </summary>
            <param name = "mediaSinkRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSink"/></strong> interface of the media sink.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method overrides the default selection of the media sink for preview.</p>
            </remarks>
            <doc-id>hh447868</doc-id>
            <unmanaged>HRESULT IMFCapturePreviewSink::SetCustomSink([In] IMFMediaSink* pMediaSink)</unmanaged>
            <unmanaged-short>IMFCapturePreviewSink::SetCustomSink</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.CaptureRecordSink.OutputFileName">
            <summary>
            <p>Specifies the name of the output file for the recording.</p>
            </summary>
            <remarks>
            <p>The capture engine uses the file name extension to select the container type for the output file. For example, if the file name extension is ."mp4", the capture engine creates an MP4 file.</p><p>Calling this method overrides any previous call to <strong>IMFCaptureRecordSink::SetOutputByteStream</strong> or <strong>IMFCaptureRecordSink::SetSampleCallback</strong>.</p>
            </remarks>
            <doc-id>hh447879</doc-id>
            <unmanaged>SetOutputFileName</unmanaged>
            <unmanaged-short>SetOutputFileName</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.CaptureRecordSink.CustomSink">
            <summary>
            <p>Sets a custom media sink for recording.</p>
            </summary>
            <remarks>
            <p>This method overrides the default selection of the media sink for recording.</p>
            </remarks>
            <doc-id>hh447877</doc-id>
            <unmanaged>SetCustomSink</unmanaged>
            <unmanaged-short>SetCustomSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureRecordSink.SetOutputByteStream(SharpDX.MediaFoundation.IByteStream,System.Guid)">
            <summary>
            <p>Specifies a byte stream that will receive the data for the recording.</p>
            </summary>
            <param name = "byteStreamRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of a byte stream. The byte stream must be writable.</p> </dd></param>
            <param name = "guidContainerType"><dd> <p>A <see cref = "T:System.Guid"/> that specifies the file container type. Possible values are documented in the <see cref = "!:TranscodeContainertype"/> attribute.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Calling this method overrides any previous call to <strong>IMFCaptureRecordSink::SetOutputFileName</strong> or <strong>IMFCaptureRecordSink::SetSampleCallback</strong>.</p>
            </remarks>
            <doc-id>hh447878</doc-id>
            <unmanaged>HRESULT IMFCaptureRecordSink::SetOutputByteStream([In] IMFByteStream* pByteStream,[In] const GUID&amp; guidContainerType)</unmanaged>
            <unmanaged-short>IMFCaptureRecordSink::SetOutputByteStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureRecordSink.SetOutputFileName(System.String)">
            <summary>
            <p>Specifies the name of the output file for the recording.</p>
            </summary>
            <param name = "fileName"><dd> <p>A null-terminated string that contains the URL of the output file. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The capture engine uses the file name extension to select the container type for the output file. For example, if the file name extension is ."mp4", the capture engine creates an MP4 file.</p><p>Calling this method overrides any previous call to <strong>IMFCaptureRecordSink::SetOutputByteStream</strong> or <strong>IMFCaptureRecordSink::SetSampleCallback</strong>.</p>
            </remarks>
            <doc-id>hh447879</doc-id>
            <unmanaged>HRESULT IMFCaptureRecordSink::SetOutputFileName([In] const wchar_t* fileName)</unmanaged>
            <unmanaged-short>IMFCaptureRecordSink::SetOutputFileName</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureRecordSink.SetSampleCallback(System.Int32,SharpDX.MediaFoundation.CaptureEngineOnSampleCallback)">
            <summary>
            <p>Sets a callback to receive the recording data for one stream.</p>
            </summary>
            <param name = "dwStreamSinkIndex"><dd> <p>The zero-based index of the stream. The index is returned in the <em>pdwSinkStreamIndex</em> parameter of the <strong>IMFCaptureSink::AddStream</strong> method.</p> </dd></param>
            <param name = "callbackRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.CaptureEngineOnSampleCallback"/></strong> interface. The caller must implement this interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Calling this method overrides any previous call to <strong>IMFCaptureRecordSink::SetOutputByteStream</strong> or  <strong>IMFCaptureRecordSink::SetOutputFileName</strong>.</p>
            </remarks>
            <doc-id>hh447881</doc-id>
            <unmanaged>HRESULT IMFCaptureRecordSink::SetSampleCallback([In] DWORD dwStreamSinkIndex,[In] IMFCaptureEngineOnSampleCallback* pCallback)</unmanaged>
            <unmanaged-short>IMFCaptureRecordSink::SetSampleCallback</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureRecordSink.SetCustomSink(SharpDX.MediaFoundation.MediaSink)">
            <summary>
            <p>Sets a custom media sink for recording.</p>
            </summary>
            <param name = "mediaSinkRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSink"/></strong> interface of the media sink.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method overrides the default selection of the media sink for recording.</p>
            </remarks>
            <doc-id>hh447877</doc-id>
            <unmanaged>HRESULT IMFCaptureRecordSink::SetCustomSink([In] IMFMediaSink* pMediaSink)</unmanaged>
            <unmanaged-short>IMFCaptureRecordSink::SetCustomSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureRecordSink.GetRotation(System.Int32,System.Int32@)">
            <summary>
            <p>Gets the rotation that is currently being applied to the recorded video stream.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The zero-based index of the stream. You must specify a video stream.</p> </dd></param>
            <param name = "dwRotationValueRef"><dd> <p>Receives the image rotation, in degrees.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447876</doc-id>
            <unmanaged>HRESULT IMFCaptureRecordSink::GetRotation([In] DWORD dwStreamIndex,[Out] DWORD* pdwRotationValue)</unmanaged>
            <unmanaged-short>IMFCaptureRecordSink::GetRotation</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureRecordSink.SetRotation(System.Int32,System.Int32)">
            <summary>
            <p>Rotates the recorded video stream.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The zero-based index of the stream to rotate. You must specify a video stream.</p> </dd></param>
            <param name = "dwRotationValue"><dd> <p>The amount to rotate the video, in degrees. Valid values are 0, 90, 180, and 270. The value zero restores the video to its original orientation.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447880</doc-id>
            <unmanaged>HRESULT IMFCaptureRecordSink::SetRotation([In] DWORD dwStreamIndex,[In] DWORD dwRotationValue)</unmanaged>
            <unmanaged-short>IMFCaptureRecordSink::SetRotation</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSink.GetOutputMediaType(System.Int32,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            <p>Gets the output format for a stream on this capture sink.</p>
            </summary>
            <param name = "dwSinkStreamIndex"><dd> <p>The zero-based index of the stream to query. The index is returned in the <em>pdwSinkStreamIndex</em> parameter of the <strong>IMFCaptureSink::AddStream</strong> method.</p> </dd></param>
            <param name = "mediaTypeOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the reference.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The <em>dwSinkStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>hh447884</doc-id>
            <unmanaged>HRESULT IMFCaptureSink::GetOutputMediaType([In] DWORD dwSinkStreamIndex,[Out, Optional] IMFMediaType** ppMediaType)</unmanaged>
            <unmanaged-short>IMFCaptureSink::GetOutputMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSink.GetService(System.Int32,System.Guid,System.Guid)">
            <summary>
            <p>Queries the underlying Sink Writer object for an interface.</p>
            </summary>
            <param name = "dwSinkStreamIndex">No documentation.</param>
            <param name = "rguidService">No documentation.</param>
            <param name = "riid">No documentation.</param>
            <returns>No documentation.</returns>
            <doc-id>hh447885</doc-id>
            <unmanaged>HRESULT IMFCaptureSink::GetService([In] DWORD dwSinkStreamIndex,[In] const GUID&amp; rguidService,[In] const GUID&amp; riid,[Out, Optional] IUnknown** ppUnknown)</unmanaged>
            <unmanaged-short>IMFCaptureSink::GetService</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSink.AddStream(System.Int32,SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.MediaAttributes,System.Int32@)">
            <summary>
            <p>Connects a stream from the capture source to this capture sink.</p>
            </summary>
            <param name = "dwSourceStreamIndex"><dd> <p>The source stream to connect. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream. To get the number of streams, call <strong>IMFCaptureSource::GetDeviceStreamCount</strong>.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</strong></strong></dt> <dt>0xFFFFFFFB</dt> </dl> </td><td> <p>The first image stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "mediaTypeRef"><dd> <p>An <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> reference that specifies the desired format of the output stream. The details of the format will depend on the capture sink.</p> <ul> <li>Photo sink: A still image format compatible with Windows Imaging Component (WIC).</li> <li>Preview sink: An uncompressed audio or video format.</li> <li>Record sink: The audio or video format that will be written to the output file.</li> </ul> </dd></param>
            <param name = "attributesRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. For compressed streams, you can use this parameter to configure the encoder. This parameter can also be <strong><c>null</c></strong>. For the preview sink, set this parameter to <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "dwSinkStreamIndexRef"><dd> <p>Receives the index of the new stream on the capture sink. Note that this index will not necessarily match the value of <em>dwSourceStreamIndex</em>. </p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidMediaType"/></strong></dt> </dl> </td><td> <p>The format specified in <em>pMediaType</em> is not valid for this capture sink.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The <em>dwSourceStreamIndex</em> parameter is invalid, or the specified source stream was already connected to this sink.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>hh447883</doc-id>
            <unmanaged>HRESULT IMFCaptureSink::AddStream([In] DWORD dwSourceStreamIndex,[In] IMFMediaType* pMediaType,[In, Optional] IMFAttributes* pAttributes,[Out, Optional] DWORD* pdwSinkStreamIndex)</unmanaged>
            <unmanaged-short>IMFCaptureSink::AddStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSink.Prepare">
            <summary>
            <p>Prepares the capture sink by loading any required pipeline components, such as encoders, video processors, and media sinks.</p>
            </summary>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid request.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Calling this method is optional. This method gives the application an opportunity to configure the pipeline components before they are used. The method is asynchronous. If the method returns a success code, the caller will receive an <strong>MF_CAPTURE_SINK_PREPARED</strong> event through the <strong>IMFCaptureEngineOnEventCallback::OnEvent</strong> method.  After this event is received, call <strong>IMFCaptureSink::GetService</strong> to configure individual components.</p><p>Before calling this method, configure the capture sink by adding at least one stream. To add a stream, call <strong>IMFCaptureSink::AddStream</strong>.</p><p>The <strong>Prepare</strong> method fails if the capture sink is currently in use. For example, calling <strong>Prepare</strong> on the preview sink fails if the capture engine is currently previewing.</p>
            </remarks>
            <doc-id>hh447886</doc-id>
            <unmanaged>HRESULT IMFCaptureSink::Prepare()</unmanaged>
            <unmanaged-short>IMFCaptureSink::Prepare</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSink.RemoveAllStreams">
            <summary>
            <p>Removes all streams from the capture sink.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>You can use this method to reconfigure the sink.</p>
            </remarks>
            <doc-id>hh447887</doc-id>
            <unmanaged>HRESULT IMFCaptureSink::RemoveAllStreams()</unmanaged>
            <unmanaged-short>IMFCaptureSink::RemoveAllStreams</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSink2.SetOutputMediaType(System.Int32,SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.MediaAttributes)">
            <summary>
            <p>Dynamically sets the output media type of the record sink or preview sink.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The stream index to change the output media type on.</p> </dd></param>
            <param name = "mediaTypeRef"><dd> <p>The new output media type.</p> </dd></param>
            <param name = "encodingAttributesRef"><dd> <p>The new encoder attributes. This can be  <strong>null</strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded</p> </td></tr> <tr><td> <dl> <dt><strong>MF_E_INVALID_MEDIATYPE</strong></dt> </dl> </td><td> <p>The sink does not support the media type.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This is an asynchronous call.  Listen to the MF_CAPTURE_ENGINE_OUTPUT_MEDIA_TYPE_SET event
            to be notified when the output media type has been set.</p>
            </remarks>
            <doc-id>dn280680</doc-id>
            <unmanaged>HRESULT IMFCaptureSink2::SetOutputMediaType([In] DWORD dwStreamIndex,[In] IMFMediaType* pMediaType,[In, Optional] IMFAttributes* pEncodingAttributes)</unmanaged>
            <unmanaged-short>IMFCaptureSink2::SetOutputMediaType</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.CaptureSource.DeviceStreamCount">
            <summary>
            <p>Gets the number of device streams.</p>
            </summary>
            <doc-id>hh447894</doc-id>
            <unmanaged>GetDeviceStreamCount</unmanaged>
            <unmanaged-short>GetDeviceStreamCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSource.GetCaptureDeviceSource(SharpDX.MediaFoundation.CaptureEngineDeviceType,SharpDX.MediaFoundation.MediaSource@)">
            <summary>
            <p>Gets the current capture device's <strong><see cref = "T:SharpDX.MediaFoundation.MediaSource"/></strong> object reference.</p>
            </summary>
            <param name = "mfCaptureEngineDeviceType">No documentation.</param>
            <param name = "mediaSourceOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>jj159896</doc-id>
            <unmanaged>HRESULT IMFCaptureSource::GetCaptureDeviceSource([In] MF_CAPTURE_ENGINE_DEVICE_TYPE mfCaptureEngineDeviceType,[Out, Optional] IMFMediaSource** ppMediaSource)</unmanaged>
            <unmanaged-short>IMFCaptureSource::GetCaptureDeviceSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSource.GetCaptureDeviceActivate(SharpDX.MediaFoundation.CaptureEngineDeviceType,SharpDX.MediaFoundation.Activate@)">
            <summary>
            <p> Gets the current capture device's <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> object reference.</p>
            </summary>
            <param name = "mfCaptureEngineDeviceType">No documentation.</param>
            <param name = "activateOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>jj159895</doc-id>
            <unmanaged>HRESULT IMFCaptureSource::GetCaptureDeviceActivate([In] MF_CAPTURE_ENGINE_DEVICE_TYPE mfCaptureEngineDeviceType,[Out, Optional] IMFActivate** ppActivate)</unmanaged>
            <unmanaged-short>IMFCaptureSource::GetCaptureDeviceActivate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSource.GetService(System.Guid,System.Guid,SharpDX.IUnknown@)">
            <summary>
            <p>Gets a reference to the underlying Source Reader object.</p>
            </summary>
            <param name = "rguidService">No documentation.</param>
            <param name = "riid">No documentation.</param>
            <param name = "unknownOut">No documentation.</param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The capture source was not initialized. Possibly there is no capture device on the system.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>hh447896</doc-id>
            <unmanaged>HRESULT IMFCaptureSource::GetService([In] const GUID&amp; rguidService,[In] const GUID&amp; riid,[Out, Optional] IUnknown** ppUnknown)</unmanaged>
            <unmanaged-short>IMFCaptureSource::GetService</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSource.AddEffect(System.Int32,SharpDX.IUnknown)">
            <summary>
            <p>Adds an effect to a capture stream.</p>
            </summary>
            <param name = "dwSourceStreamIndex"><dd> <p>The capture stream. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.  To get the number of streams, call <strong>IMFCaptureSource::GetDeviceStreamCount</strong>.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</strong></strong></dt> <dt>0xFFFFFFFB</dt> </dl> </td><td> <p>The first image stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "unknownRef"><dd> <p>A reference to one of the following: </p> <ul> <li>A Media Foundation transform (MFT) that exposes the <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> interface.</li> <li>An MFT activation object that exposes the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface.</li> </ul> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidMediaType"/></strong></dt> </dl> </td><td> <p>No compatible media type could be found.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The <em>dwSourceStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The effect must be implemented as a Media Foundation Transform (MFT). The <em>pUnknown</em> parameter can point to an instance of the MFT, or to an activation object for the MFT. For more information, see Activation Objects.</p><p>The effect is applied to the stream before the data reaches the capture sinks. </p>
            </remarks>
            <doc-id>hh447890</doc-id>
            <unmanaged>HRESULT IMFCaptureSource::AddEffect([In] DWORD dwSourceStreamIndex,[In] IUnknown* pUnknown)</unmanaged>
            <unmanaged-short>IMFCaptureSource::AddEffect</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSource.RemoveEffect(System.Int32,SharpDX.IUnknown)">
            <summary>
            <p>Removes an effect from a capture stream.</p>
            </summary>
            <param name = "dwSourceStreamIndex"><dd> <p>The capture stream. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.  To get the number of streams, call <strong>IMFCaptureSource::GetDeviceStreamCount</strong>.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</strong></strong></dt> <dt>0xFFFFFFFB</dt> </dl> </td><td> <p>The first image stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "unknownRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of the effect object. </p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid request. Possibly the specified effect could not be found.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The <em>dwSourceStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method removes an effect that was previously added using the <strong>IMFCaptureSource::AddEffect</strong> method.</p>
            </remarks>
            <doc-id>hh447898</doc-id>
            <unmanaged>HRESULT IMFCaptureSource::RemoveEffect([In] DWORD dwSourceStreamIndex,[In] IUnknown* pUnknown)</unmanaged>
            <unmanaged-short>IMFCaptureSource::RemoveEffect</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSource.RemoveAllEffects(System.Int32)">
            <summary>
            <p>Removes all effects from a capture stream.</p>
            </summary>
            <param name = "dwSourceStreamIndex"><dd> <p>The capture stream. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream. To get the number of streams, call <strong>IMFCaptureSource::GetDeviceStreamCount</strong>.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</strong></strong></dt> <dt>0xFFFFFFFB</dt> </dl> </td><td> <p>The first image stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The <em>dwSourceStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>hh447897</doc-id>
            <unmanaged>HRESULT IMFCaptureSource::RemoveAllEffects([In] DWORD dwSourceStreamIndex)</unmanaged>
            <unmanaged-short>IMFCaptureSource::RemoveAllEffects</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSource.GetAvailableDeviceMediaType(System.Int32,System.Int32,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            <p>Gets a format that is supported by one of the capture streams.</p>
            </summary>
            <param name = "dwSourceStreamIndex"><dd> <p>The stream to query. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream. To get the number of streams, call <strong>IMFCaptureSource::GetDeviceStreamCount</strong>.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</strong></strong></dt> <dt>0xFFFFFFFB</dt> </dl> </td><td> <p>The first image stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "dwMediaTypeIndex"><dd> <p>The zero-based index of the media type to retrieve.</p> </dd></param>
            <param name = "mediaTypeOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The <em>dwSourceStreamIndex</em> parameter is invalid.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NoMoreTypes"/></strong></dt> </dl> </td><td> <p>The <em>dwMediaTypeIndex</em> parameter is out of range. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To enumerate all of the available formats on a stream, call this method in a loop while incrementing <em>dwMediaTypeIndex</em>, until the method returns <strong><see cref = "!:NoMoreTypes"/></strong>.</p><p>Some cameras might support a range of frame rates. The minimum and maximum frame rates are stored in the <see cref = "!:FrameRateRangeMin"/> and <see cref = "!:FrameRateRangeMax"/> attributes on the media type.</p>
            </remarks>
            <doc-id>hh447891</doc-id>
            <unmanaged>HRESULT IMFCaptureSource::GetAvailableDeviceMediaType([In] DWORD dwSourceStreamIndex,[In] DWORD dwMediaTypeIndex,[Out, Optional] IMFMediaType** ppMediaType)</unmanaged>
            <unmanaged-short>IMFCaptureSource::GetAvailableDeviceMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSource.SetCurrentDeviceMediaType(System.Int32,SharpDX.MediaFoundation.MediaType)">
            <summary>
            <p>Sets the output format for a capture stream.</p>
            </summary>
            <param name = "dwSourceStreamIndex"><dd> <p>The capture stream to set. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream. To get the number of streams, call <strong>IMFCaptureSource::GetDeviceStreamCount</strong>.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</strong></strong></dt> <dt>0xFFFFFFFB</dt> </dl> </td><td> <p>The first image stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "mediaTypeRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The <em>dwSourceStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method sets the native output type on the capture device. The device must support the specified format. To get the list of available formats, call <strong>IMFCaptureSource::GetAvailableDeviceMediaType</strong>.</p>
            </remarks>
            <doc-id>hh447899</doc-id>
            <unmanaged>HRESULT IMFCaptureSource::SetCurrentDeviceMediaType([In] DWORD dwSourceStreamIndex,[In] IMFMediaType* pMediaType)</unmanaged>
            <unmanaged-short>IMFCaptureSource::SetCurrentDeviceMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSource.GetCurrentDeviceMediaType(System.Int32,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            <p>Gets the current media type for a capture stream.</p>
            </summary>
            <param name = "dwSourceStreamIndex"><dd> <p>Specifies which stream to query. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.  To get the number of streams, call <strong>IMFCaptureSource::GetDeviceStreamCount</strong>.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</strong></strong></dt> <dt>0xFFFFFFFB</dt> </dl> </td><td> <p>The first image stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "mediaTypeOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The <em>dwSourceStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>hh447893</doc-id>
            <unmanaged>HRESULT IMFCaptureSource::GetCurrentDeviceMediaType([In] DWORD dwSourceStreamIndex,[Out] IMFMediaType** ppMediaType)</unmanaged>
            <unmanaged-short>IMFCaptureSource::GetCurrentDeviceMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSource.GetDeviceStreamCount(System.Int32@)">
            <summary>
            <p>Gets the number of device streams.</p>
            </summary>
            <param name = "dwStreamCountRef"><dd> <p>Receives the number of device streams.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447894</doc-id>
            <unmanaged>HRESULT IMFCaptureSource::GetDeviceStreamCount([Out] DWORD* pdwStreamCount)</unmanaged>
            <unmanaged-short>IMFCaptureSource::GetDeviceStreamCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSource.GetDeviceStreamCategory(System.Int32,SharpDX.MediaFoundation.CaptureEngineStreamCategory@)">
            <summary>
            <p>Gets the stream category for the specified source stream index.</p>
            </summary>
            <param name = "dwSourceStreamIndex"><dd> <p>The index of the source stream.</p> </dd></param>
            <param name = "streamCategoryRef"><dd> <p>Receives the <see cref = "T:SharpDX.MediaFoundation.CaptureEngineStreamCategory"/> of the specified source stream.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>jj159897</doc-id>
            <unmanaged>HRESULT IMFCaptureSource::GetDeviceStreamCategory([In] DWORD dwSourceStreamIndex,[Out] MF_CAPTURE_ENGINE_STREAM_CATEGORY* pStreamCategory)</unmanaged>
            <unmanaged-short>IMFCaptureSource::GetDeviceStreamCategory</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSource.GetMirrorState(System.Int32,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Gets the current mirroring state of the video preview stream.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The zero-based index of the stream.</p> </dd></param>
            <param name = "fMirrorStateRef"><dd> <p>Receives the value <strong>TRUE</strong> if mirroring is enabled, or <strong><see cref = "F:SharpDX.Result.False"/></strong> if mirroring is disabled.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447895</doc-id>
            <unmanaged>HRESULT IMFCaptureSource::GetMirrorState([In] DWORD dwStreamIndex,[Out] BOOL* pfMirrorState)</unmanaged>
            <unmanaged-short>IMFCaptureSource::GetMirrorState</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSource.SetMirrorState(System.Int32,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Enables or disables mirroring of the video preview stream.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The zero-based index of the stream.</p> </dd></param>
            <param name = "fMirrorState"><dd> <p>If   <strong>TRUE</strong>,    mirroring is enabled; if  <strong><see cref = "F:SharpDX.Result.False"/></strong>, mirroring is  disabled.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>The device stream does not have mirroring capability.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The source is not initialized.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>hh447900</doc-id>
            <unmanaged>HRESULT IMFCaptureSource::SetMirrorState([In] DWORD dwStreamIndex,[In] BOOL fMirrorState)</unmanaged>
            <unmanaged-short>IMFCaptureSource::SetMirrorState</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CaptureSource.GetStreamIndexFromFriendlyName(System.Int32,System.Int32@)">
            <summary>
            <p>Gets the actual device stream index translated from a friendly stream name.</p>
            </summary>
            <param name = "uifriendlyName"><dd> <p>The friendly name.  Can be one of the following:</p> <ul> <li>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</li> <li>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</li> <li>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</li> <li>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_VIDEO_STREAM_FOR_RECORD</li> <li>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_VIDEO_STREAM_FOR_PREVIEW</li> <li>MF_CAPTURE_ENGINE_FIRST_SOURCE_INDEPENDENT_PHOTO_STREAM</li> </ul> </dd></param>
            <param name = "dwActualStreamIndexRef"><dd> <p>Receives the value of the stream index that corresponds to the friendly name.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>jj128307</doc-id>
            <unmanaged>HRESULT IMFCaptureSource::GetStreamIndexFromFriendlyName([In] unsigned int uifriendlyName,[Out] DWORD* pdwActualStreamIndex)</unmanaged>
            <unmanaged-short>IMFCaptureSource::GetStreamIndexFromFriendlyName</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CdmSuspendNotify.Begin">
            <summary>
            <p>Indicates that the suspend process is starting and  resources should be brought into a consistent state.  </p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280682</doc-id>
            <unmanaged>HRESULT IMFCdmSuspendNotify::Begin()</unmanaged>
            <unmanaged-short>IMFCdmSuspendNotify::Begin</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.CdmSuspendNotify.End">
            <summary>
            <p>The actual suspend is about to occur and no more calls will be made into the Content Decryption Module (CDM).</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280683</doc-id>
            <unmanaged>HRESULT IMFCdmSuspendNotify::End()</unmanaged>
            <unmanaged-short>IMFCdmSuspendNotify::End</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.Clock.ClockCharacteristics">
            <summary>
            <p> </p><p>Retrieves the characteristics of the clock.</p>
            </summary>
            <doc-id>ms697050</doc-id>
            <unmanaged>GetClockCharacteristics</unmanaged>
            <unmanaged-short>GetClockCharacteristics</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.Clock.ContinuityKey">
            <summary>
            <p> </p><p>Retrieves the clock's continuity key. (Not supported.)</p>
            </summary>
            <remarks>
            <p>Continuity keys are currently not supported in Media Foundation. Clocks must return the value zero in the <em>pdwContinuityKey</em> parameter.</p>
            </remarks>
            <doc-id>ms700188</doc-id>
            <unmanaged>GetContinuityKey</unmanaged>
            <unmanaged-short>GetContinuityKey</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.Clock.Properties">
            <summary>
            <p> </p><p>Retrieves the properties of the clock.</p>
            </summary>
            <doc-id>ms701613</doc-id>
            <unmanaged>GetProperties</unmanaged>
            <unmanaged-short>GetProperties</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Clock.GetClockCharacteristics(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the characteristics of the clock.</p>
            </summary>
            <param name = "dwCharacteristicsRef"><dd> <p>Receives a bitwise OR of values from the <strong><see cref = "T:SharpDX.MediaFoundation.ClockCharacteristicsFlags"/></strong> enumeration indicating the characteristics of the clock.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms697050</doc-id>
            <unmanaged>HRESULT IMFClock::GetClockCharacteristics([Out] DWORD* pdwCharacteristics)</unmanaged>
            <unmanaged-short>IMFClock::GetClockCharacteristics</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Clock.GetCorrelatedTime(System.Int32,System.Int64@,System.Int64@)">
            <summary>
            <p> Retrieves the last clock time that was correlated with system time. </p>
            </summary>
            <param name = "dwReserved"><dd> <p> Reserved, must be zero. </p> </dd></param>
            <param name = "llClockTimeRef"><dd> <p> Receives the last known clock time, in units of the clock's frequency. </p> </dd></param>
            <param name = "hnsSystemTimeRef"><dd> <p> Receives the system time that corresponds to the clock time returned in <em>pllClockTime</em>, in 100-nanosecond units. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ClockNoTimeSource"/></strong></dt> </dl> </td><td> <p> The clock does not have a time source. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>At some fixed interval, a clock correlates its internal clock ticks with the system time. (The system time is the time returned by the high-resolution performance counter.) This method returns:</p><ul> <li> The most recent clock time that was correlated with system time. </li> <li> The system time when the correlation was performed. </li> </ul><p> The clock time is returned in the <em>pllClockTime</em> parameter and is expressed in units of the clock's frequency. If the clock's <strong>IMFClock::GetClockCharacteristics</strong> method returns the <strong>MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ</strong> flag, the clock's frequency is 10 MHz (each clock tick is 100 nanoseconds). Otherwise, you can get the clock's frequency by calling <strong>IMFClock::GetProperties</strong>. The frequency is given in the <strong>qwClockFrequency</strong> member of the <strong><see cref = "T:SharpDX.MediaFoundation.ClockProperties"/></strong> structure returned by that method. </p><p> The system time is returned in the <em>phnsSystemTime</em> parameter, and is always expressed in 100-nanosecond units. </p><p> To find out how often the clock correlates its clock time with the system time, call <strong>GetProperties</strong>. The correlation interval is given in the <strong>qwCorrelationRate</strong> member of the <strong><see cref = "T:SharpDX.MediaFoundation.ClockProperties"/></strong> structure. If <strong>qwCorrelationRate</strong> is zero, it means the clock performs the correlation whenever <strong>GetCorrelatedTime</strong> is called. Otherwise, you can calculate the current clock time by extrapolating from the last correlated time. </p><p> Some clocks support rate changes through the <strong><see cref = "T:SharpDX.MediaFoundation.RateControl"/></strong> interface. If so, the clock time advances at a speed of frequency ? current rate. If a clock does not expose the <strong><see cref = "T:SharpDX.MediaFoundation.RateControl"/></strong> interface, the rate is always 1.0. </p><p>For the presentation clock, the clock time is the presentation time, and is always relative to the starting time specified in <strong>IMFPresentationClock::Start</strong>. You can also get the presentation time by calling <strong>IMFPresentationClock::GetTime</strong>.</p>
            </remarks>
            <doc-id>ms694122</doc-id>
            <unmanaged>HRESULT IMFClock::GetCorrelatedTime([In] DWORD dwReserved,[Out] longlong* pllClockTime,[Out] longlong* phnsSystemTime)</unmanaged>
            <unmanaged-short>IMFClock::GetCorrelatedTime</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Clock.GetContinuityKey(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the clock's continuity key. (Not supported.)</p>
            </summary>
            <param name = "dwContinuityKeyRef"><dd> <p>Receives the continuity key.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Continuity keys are currently not supported in Media Foundation. Clocks must return the value zero in the <em>pdwContinuityKey</em> parameter.</p>
            </remarks>
            <doc-id>ms700188</doc-id>
            <unmanaged>HRESULT IMFClock::GetContinuityKey([Out] DWORD* pdwContinuityKey)</unmanaged>
            <unmanaged-short>IMFClock::GetContinuityKey</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Clock.GetState(System.Int32,SharpDX.MediaFoundation.ClockState@)">
            <summary>
            <p> </p><p>Retrieves the current state of the clock.</p>
            </summary>
            <param name = "dwReserved"><dd> <p>Reserved, must be zero.</p> </dd></param>
            <param name = "eClockStateRef"><dd> <p>Receives the clock state, as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.ClockState"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms700206</doc-id>
            <unmanaged>HRESULT IMFClock::GetState([In] DWORD dwReserved,[Out] MFCLOCK_STATE* peClockState)</unmanaged>
            <unmanaged-short>IMFClock::GetState</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Clock.GetProperties(SharpDX.MediaFoundation.ClockProperties@)">
            <summary>
            <p> </p><p>Retrieves the properties of the clock.</p>
            </summary>
            <param name = "clockPropertiesRef"><dd> <p>Pointer to an <strong><see cref = "T:SharpDX.MediaFoundation.ClockProperties"/></strong> structure that receives the properties.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms701613</doc-id>
            <unmanaged>HRESULT IMFClock::GetProperties([Out] MFCLOCK_PROPERTIES* pClockProperties)</unmanaged>
            <unmanaged-short>IMFClock::GetProperties</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.ClockConsumer.PresentationClock">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetPresentationClock / SetPresentationClock</unmanaged>
            <unmanaged-short>GetPresentationClock</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ClockConsumer.SetPresentationClock(SharpDX.MediaFoundation.PresentationClock)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called by the media pipeline to provide the app with an instance of <strong><see cref = "T:SharpDX.MediaFoundation.PresentationClock"/></strong>.</p>
            </summary>
            <param name = "presentationClockRef">No documentation.</param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> </table><p>?</p></returns>
            <doc-id>mt797926</doc-id>
            <unmanaged>HRESULT IMFClockConsumer::SetPresentationClock([In, Optional] IMFPresentationClock* pPresentationClock)</unmanaged>
            <unmanaged-short>IMFClockConsumer::SetPresentationClock</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ClockConsumer.GetPresentationClock(SharpDX.MediaFoundation.PresentationClock@)">
            <summary>
            No documentation.
            </summary>
            <param name = "presentationClockOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFClockConsumer::GetPresentationClock([Out] IMFPresentationClock** ppPresentationClock)</unmanaged>
            <unmanaged-short>IMFClockConsumer::GetPresentationClock</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.Collection.ElementCount">
            <summary>
            <p> </p><p>Retrieves the number of objects in the collection.</p>
            </summary>
            <doc-id>ms697034</doc-id>
            <unmanaged>GetElementCount</unmanaged>
            <unmanaged-short>GetElementCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Collection.GetElementCount(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the number of objects in the collection.</p>
            </summary>
            <param name = "cElementsRef"><dd> <p>Receives the number of objects in the collection.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms697034</doc-id>
            <unmanaged>HRESULT IMFCollection::GetElementCount([Out] DWORD* pcElements)</unmanaged>
            <unmanaged-short>IMFCollection::GetElementCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Collection.GetElement(System.Int32)">
            <summary>
            <p> </p><p>Retrieves an object in the collection.</p>
            </summary>
            <param name = "dwElementIndex"><dd> <p> Zero-based index of the object to retrieve. Objects are indexed in the order in which they were added to the collection. </p> </dd></param>
            <returns><dd> <p> Receives a reference to the object's <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface. The caller must release the interface. The retrieved reference value might be <strong><c>null</c></strong>. </p> </dd></returns>
            <remarks>
            <p> This method does not remove the object from the collection. To remove an object, call <strong>IMFCollection::RemoveElement</strong>. </p>
            </remarks>
            <doc-id>ms701793</doc-id>
            <unmanaged>HRESULT IMFCollection::GetElement([In] DWORD dwElementIndex,[Out] IUnknown** ppUnkElement)</unmanaged>
            <unmanaged-short>IMFCollection::GetElement</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Collection.AddElement(SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Adds an object to the collection.</p>
            </summary>
            <param name = "unkElementRef"><dd> <p>Pointer to the object's <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If <em>pUnkElement</em> is <strong><c>null</c></strong>, a <strong><c>null</c></strong> reference is added to the collection.</p>
            </remarks>
            <doc-id>ms695202</doc-id>
            <unmanaged>HRESULT IMFCollection::AddElement([In, Optional] IUnknown* pUnkElement)</unmanaged>
            <unmanaged-short>IMFCollection::AddElement</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Collection.RemoveElement(System.Int32,SharpDX.IUnknown@)">
            <summary>
            <p> </p><p>Removes an object from the collection.</p>
            </summary>
            <param name = "dwElementIndex"><dd> <p>Zero-based index of the object to remove. Objects are indexed in the order in which they were added to the collection.</p> </dd></param>
            <param name = "unkElementOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of the object. The caller must release the interface. This parameter cannot be <strong><c>null</c></strong>, but the retrieved reference value might be <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms697010</doc-id>
            <unmanaged>HRESULT IMFCollection::RemoveElement([In] DWORD dwElementIndex,[Out] IUnknown** ppUnkElement)</unmanaged>
            <unmanaged-short>IMFCollection::RemoveElement</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Collection.InsertElementAt(System.Int32,SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Adds an object at the specified index in the collection.</p>
            </summary>
            <param name = "dwIndex"><dd> <p>The zero-based index where the object will be added to the collection.</p> </dd></param>
            <param name = "unknownRef"><dd> <p>The object to insert.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms703963</doc-id>
            <unmanaged>HRESULT IMFCollection::InsertElementAt([In] DWORD dwIndex,[In, Optional] IUnknown* pUnknown)</unmanaged>
            <unmanaged-short>IMFCollection::InsertElementAt</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Collection.RemoveAllElements">
            <summary>
            <p> </p><p>Removes all items from the collection.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms700194</doc-id>
            <unmanaged>HRESULT IMFCollection::RemoveAllElements()</unmanaged>
            <unmanaged-short>IMFCollection::RemoveAllElements</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ContentDecryptorContext.InitializeHardwareKey(System.Int32,System.IntPtr,System.Int64@)">
            <summary>
            <p> Allows the display driver to return IHV-specific information used when initializing a new hardware key. </p>
            </summary>
            <param name = "inputPrivateDataByteCount"><dd> <p>The number of bytes in the buffer that <em>InputPrivateData</em> specifies.</p> </dd></param>
            <param name = "inputPrivateData"><dd> <p>The contents of this parameter are defined by the implementation of    the protection system that runs in the security processor. The contents may contain data about license or stream properties.</p> </dd></param>
            <param name = "outputPrivateData"><dd> <p>The return data is also defined by the implementation of the protection system implementation    that runs in the security processor.  The contents may contain data associated with the underlying hardware key.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>mt219183</doc-id>
            <unmanaged>HRESULT IMFContentDecryptorContext::InitializeHardwareKey([In] unsigned int InputPrivateDataByteCount,[In, Buffer, Optional] const void* InputPrivateData,[Out] unsigned longlong* OutputPrivateData)</unmanaged>
            <unmanaged-short>IMFContentDecryptorContext::InitializeHardwareKey</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.ContentEnabler.EnableType">
            <summary>
            <p> </p><p>Retrieves the type of operation that this content enabler performs.</p>
            </summary>
            <remarks>
            <p>The following GUIDs are defined for the <em>pType</em> parameter.</p><table> <tr><th>Value</th><th>Description</th></tr> <tr><td>MFENABLETYPE_MF_RebootRequired</td><td>The user must reboot his or her computer.</td></tr> <tr><td>MFENABLETYPE_MF_UpdateRevocationInformation</td><td>Update revocation information.</td></tr> <tr><td>MFENABLETYPE_MF_UpdateUntrustedComponent</td><td>Update untrusted components.</td></tr> <tr><td>MFENABLETYPE_WMDRMV1_LicenseAcquisition</td><td>License acquisition for Windows Media Digital Rights Management (DRM) version 1.</td></tr> <tr><td>MFENABLETYPE_WMDRMV7_Individualization</td><td>Individualization.</td></tr> <tr><td>MFENABLETYPE_WMDRMV7_LicenseAcquisition</td><td>License acquisition for Windows Media DRM version 7 or later.</td></tr> </table><p>?</p>
            </remarks>
            <doc-id>bb970471</doc-id>
            <unmanaged>GetEnableType</unmanaged>
            <unmanaged-short>GetEnableType</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.ContentEnabler.IsAutomaticSupported">
            <summary>
            <p> </p><p>Queries whether the content enabler can perform all of its actions automatically.</p>
            </summary>
            <remarks>
            <p>If this method returns <strong>TRUE</strong> in the <em>pfAutomatic</em> parameter, call the <strong>IMFContentEnabler::AutomaticEnable</strong> method to perform the enabling action.</p><p>If this method returns <strong><see cref = "F:SharpDX.Result.False"/></strong> in the <em>pfAutomatic</em> parameter, the application must use manual enabling. To do so, call <strong>IMFContentEnabler::GetEnableURL</strong> and <strong>IMFContentEnabler::GetEnableData</strong> to get the URL and data needed for manual enabling.</p>
            </remarks>
            <doc-id>bb970334</doc-id>
            <unmanaged>IsAutomaticSupported</unmanaged>
            <unmanaged-short>IsAutomaticSupported</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ContentEnabler.GetEnableType(System.Guid@)">
            <summary>
            <p> </p><p>Retrieves the type of operation that this content enabler performs.</p>
            </summary>
            <param name = "typeRef"><dd> <p>Receives a <see cref = "T:System.Guid"/> that identifies the type of operation. An application can tailor its user interface (UI) strings for known operation types. See Remarks.</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The following GUIDs are defined for the <em>pType</em> parameter.</p><table> <tr><th>Value</th><th>Description</th></tr> <tr><td>MFENABLETYPE_MF_RebootRequired</td><td>The user must reboot his or her computer.</td></tr> <tr><td>MFENABLETYPE_MF_UpdateRevocationInformation</td><td>Update revocation information.</td></tr> <tr><td>MFENABLETYPE_MF_UpdateUntrustedComponent</td><td>Update untrusted components.</td></tr> <tr><td>MFENABLETYPE_WMDRMV1_LicenseAcquisition</td><td>License acquisition for Windows Media Digital Rights Management (DRM) version 1.</td></tr> <tr><td>MFENABLETYPE_WMDRMV7_Individualization</td><td>Individualization.</td></tr> <tr><td>MFENABLETYPE_WMDRMV7_LicenseAcquisition</td><td>License acquisition for Windows Media DRM version 7 or later.</td></tr> </table><p>?</p>
            </remarks>
            <doc-id>bb970471</doc-id>
            <unmanaged>HRESULT IMFContentEnabler::GetEnableType([Out] GUID* pType)</unmanaged>
            <unmanaged-short>IMFContentEnabler::GetEnableType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ContentEnabler.GetEnableURL(System.String,System.Int32@,System.IntPtr)">
            <summary>
            <p> </p><p>Retrieves a URL for performing a manual content enabling action.</p>
            </summary>
            <param name = "wszURLOut"><dd> <p>Receives a reference to a buffer that contains the URL. The caller must release the memory for the buffer by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>
            <param name = "cchURLRef"><dd> <p>Receives the number of characters returned in <em>ppwszURL</em>, including the terminating <c>null</c> character.</p> </dd></param>
            <param name = "trustStatusRef"><dd> <p>Receives a member of the <strong><see cref = "T:SharpDX.MediaFoundation.UrlTrustStatus"/></strong> enumeration indicating whether the URL is trusted.</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotAvailable"/></strong></dt> </dl> </td><td> <p>No URL is available.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the enabling action can be performed by navigating to a URL, this method returns the URL. If no such URL exists, the method returns a failure code.</p><p>The purpose of the URL depends on the content enabler type, which is obtained by calling <strong>IMFContentEnabler::GetEnableType</strong>.</p><table> <tr><th>Enable type</th><th>Purpose of URL</th></tr> <tr><td>Individualization</td><td>Not applicable.</td></tr> <tr><td>License acquisition</td><td>URL to obtain the license. Call <strong>IMFContentEnabler::GetEnableData</strong> and submit the data to the URL as an HTTP POST request. To receive notification when the license is acquired, call <strong>IMFContentEnabler::MonitorEnable</strong>.</td></tr> <tr><td>Revocation</td><td>URL to a webpage where the user can download and install an updated component.</td></tr> </table><p>?</p>
            </remarks>
            <doc-id>bb970345</doc-id>
            <unmanaged>HRESULT IMFContentEnabler::GetEnableURL([Buffer, Optional] wchar_t** ppwszURL,[Out] DWORD* pcchURL,[InOut, Optional] MF_URL_TRUST_STATUS* pTrustStatus)</unmanaged>
            <unmanaged-short>IMFContentEnabler::GetEnableURL</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ContentEnabler.GetEnableData(System.Byte[],System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the data for a manual content enabling action.</p>
            </summary>
            <param name = "bDataOut"><dd> <p>Receives a reference to a buffer that contains the data. The caller must free the buffer by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>
            <param name = "cbDataRef"><dd> <p>Receives the size of the <em>ppbData</em> buffer.</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotAvailable"/></strong></dt> </dl> </td><td> <p>No data is available.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The purpose of the data depends on the content enabler type, which is obtained by calling <strong>IMFContentEnabler::GetEnableType</strong>.</p><table> <tr><th>Enable type</th><th>Purpose of data</th></tr> <tr><td>Individualization</td><td>Not applicable.</td></tr> <tr><td>License acquisition</td><td>HTTP POST data.</td></tr> <tr><td>Revocation</td><td> <strong><see cref = "T:SharpDX.MediaFoundation.RrComponents"/></strong> structure.</td></tr> </table><p>?</p>
            </remarks>
            <doc-id>bb970525</doc-id>
            <unmanaged>HRESULT IMFContentEnabler::GetEnableData([Buffer, Optional] unsigned char** ppbData,[Out] DWORD* pcbData)</unmanaged>
            <unmanaged-short>IMFContentEnabler::GetEnableData</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ContentEnabler.IsAutomaticSupported_(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p> </p><p>Queries whether the content enabler can perform all of its actions automatically.</p>
            </summary>
            <param name = "fAutomaticRef"><dd> <p>Receives a Boolean value. If <strong>TRUE</strong>, the content enabler can perform the enabing action automatically.</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If this method returns <strong>TRUE</strong> in the <em>pfAutomatic</em> parameter, call the <strong>IMFContentEnabler::AutomaticEnable</strong> method to perform the enabling action.</p><p>If this method returns <strong><see cref = "F:SharpDX.Result.False"/></strong> in the <em>pfAutomatic</em> parameter, the application must use manual enabling. To do so, call <strong>IMFContentEnabler::GetEnableURL</strong> and <strong>IMFContentEnabler::GetEnableData</strong> to get the URL and data needed for manual enabling.</p>
            </remarks>
            <doc-id>bb970334</doc-id>
            <unmanaged>HRESULT IMFContentEnabler::IsAutomaticSupported([Out] BOOL* pfAutomatic)</unmanaged>
            <unmanaged-short>IMFContentEnabler::IsAutomaticSupported</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ContentEnabler.AutomaticEnable">
            <summary>
            <p> </p><p>Performs a content enabling action without any user interaction.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is asynchronous. When the operation is complete, the content enabler sends an MEEnablerCompleted event. While the operation is in progress, the content enabler might send MEEnablerProgress events.</p><p>To find out whether the content enabler supports this method, call <strong>IMFContentEnabler::IsAutomaticSupported</strong>.</p>
            </remarks>
            <doc-id>ms699012</doc-id>
            <unmanaged>HRESULT IMFContentEnabler::AutomaticEnable()</unmanaged>
            <unmanaged-short>IMFContentEnabler::AutomaticEnable</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ContentEnabler.MonitorEnable">
            <summary>
            <p> </p><p>Requests notification when the enabling action is completed.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p>The method succeeded and no action was required.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If you use a manual enabling action, call this method to be notified when the operation completes. If this method returns <see cref = "F:SharpDX.Result.Ok"/>, the content enabler will send an MEEnablerCompleted event when the operation is completed. If the application cancels the operatation before completing it, call <strong>IMFContentEnabler::Cancel</strong>.</p><p>You do not have to call <strong>MonitorEnable</strong> when you use automatic enabling by calling <strong>IMFContentEnabler::AutomaticEnable</strong>.</p>
            </remarks>
            <doc-id>ms698997</doc-id>
            <unmanaged>HRESULT IMFContentEnabler::MonitorEnable()</unmanaged>
            <unmanaged-short>IMFContentEnabler::MonitorEnable</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ContentEnabler.Cancel">
            <summary>
            <p> </p><p>Cancels a pending content enabling action.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The content enabler sends an MEEnablerCompleted event with a status code of E_CANCEL.</p>
            </remarks>
            <doc-id>ms704633</doc-id>
            <unmanaged>HRESULT IMFContentEnabler::Cancel()</unmanaged>
            <unmanaged-short>IMFContentEnabler::Cancel</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ContentProtectionDevice.InvokeFunction(System.Int32,System.Int32,System.Byte[],System.Int32@,System.Byte[])">
            <summary>
            <p>Calls into the implementation of the protection system in the security processor. </p>
            </summary>
            <param name = "functionId"><dd> <p>The identifier of the function that you want to run. This identifier is defined by the implementation of the protection system.</p> </dd></param>
            <param name = "inputBufferByteCount"><dd> <p>The number of bytes of in the buffer that <em>InputBuffer</em> specifies, including private data.</p> </dd></param>
            <param name = "inputBuffer"><dd> <p>A reference to the data that you want to provide as input.</p> </dd></param>
            <param name = "outputBufferByteCount"><dd> <p>Pointer to a value that specifies the length in bytes of the data that the function wrote to the buffer that <em>OutputBuffer</em> specifies, including the private data.    </p> </dd></param>
            <param name = "outputBuffer"><dd> <p>Pointer to the buffer where you want the function to write its output.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>mt219186</doc-id>
            <unmanaged>HRESULT IMFContentProtectionDevice::InvokeFunction([In] DWORD FunctionId,[In] DWORD InputBufferByteCount,[In, Buffer] const unsigned char* InputBuffer,[InOut] DWORD* OutputBufferByteCount,[Out, Buffer] unsigned char* OutputBuffer)</unmanaged>
            <unmanaged-short>IMFContentProtectionDevice::InvokeFunction</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ContentProtectionDevice.GetPrivateDataByteCount(System.Int32@,System.Int32@)">
            <summary>
            <p> Gets the required number of bytes that need to be prepended to    the  input and output buffers when you call the security processor through the <strong>InvokeFunction</strong> method.   When you specify this number of bytes, the Media Foundation transform (MFT) decryptor can allocate the total amount of bytes and can avoid making copies of the data when the decrytor moves the data to the security processor.  </p>
            </summary>
            <param name = "privateInputByteCount">No documentation.</param>
            <param name = "privateOutputByteCount">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>mt219185</doc-id>
            <unmanaged>HRESULT IMFContentProtectionDevice::GetPrivateDataByteCount([Out] DWORD* PrivateInputByteCount,[Out] DWORD* PrivateOutputByteCount)</unmanaged>
            <unmanaged-short>IMFContentProtectionDevice::GetPrivateDataByteCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ContentProtectionManager.BeginEnableContent(SharpDX.MediaFoundation.Activate,SharpDX.MediaFoundation.Topology,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p>Begins an asynchronous request to perform a content enabling action.</p><p>This method requests the application to perform a specific step needed to acquire rights to the content, using a content enabler object.</p>
            </summary>
            <param name = "enablerActivateRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface of a content enabler object. To create the content enabler, call <strong>IMFActivate::ActivateObject</strong> and request the <strong><see cref = "T:SharpDX.MediaFoundation.ContentEnabler"/></strong> interface. The application should use the methods in <strong><see cref = "T:SharpDX.MediaFoundation.ContentEnabler"/></strong> to complete the content enabling action. </p> </dd></param>
            <param name = "topoRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.Topology"/></strong> interface of the pending topology. </p> </dd></param>
            <param name = "callbackRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. When the operation is complete, the application should call <strong>IMFAsyncCallback::Invoke</strong> on the callback. </p> </dd></param>
            <param name = "unkStateRef"><dd> <p> Reserved. Currently this parameter is always <strong><c>null</c></strong>. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Do not block within this callback method. Instead, perform the content enabling action asynchronously on another thread. When the operation is finished, notify the protected media path (PMP) through the <em>pCallback</em> parameter.</p><p>If you return a success code from this method, you must call <strong>Invoke</strong> on the callback. Conversely, if you return an error code from this method, you must not call <strong>Invoke</strong>. If the operation fails after the method returns a success code, use status code on the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> object to report the error.</p><p>After the callback is invoked, the PMP will call the application's <strong>IMFContentProtectionManager::EndEnableContent</strong> method to complete the asynchronous call.</p><p>This method is not necessarily called every time the application plays protected content. Generally, the method will not be called if the user has a valid, up-to-date license for the content. Internally, the input trust authority (ITA) determines whether <strong>BeginEnableContent</strong> is called, based on the content provider's DRM policy. For more information, see Protected Media Path.</p>
            </remarks>
            <doc-id>ms696203</doc-id>
            <unmanaged>HRESULT IMFContentProtectionManager::BeginEnableContent([In] IMFActivate* pEnablerActivate,[In] IMFTopology* pTopo,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>
            <unmanaged-short>IMFContentProtectionManager::BeginEnableContent</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ContentProtectionManager.EndEnableContent(SharpDX.MediaFoundation.AsyncResult)">
            <summary>
            <p> </p><p>Ends an asynchronous request to perform a content enabling action. This method is called by the protected media path (PMP) to complete an asynchronous call to <strong>IMFContentProtectionManager::BeginEnableContent</strong>.</p>
            </summary>
            <param name = "resultRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>When the <strong>BeginEnableContent</strong> method completes asynchronously, the application notifies the PMP by invoking the asynchronous callback. The PMP calls <strong>EndEnableContent</strong> on the application to get the result code. This method is called on the application's thread from inside the callback method. Therefore, it must not block the thread that invoked the callback.</p><p>The application must return the success or failure code of the asynchronous processing that followed the call to <strong>BeginEnableContent</strong>.</p>
            </remarks>
            <doc-id>ms694267</doc-id>
            <unmanaged>HRESULT IMFContentProtectionManager::EndEnableContent([In] IMFAsyncResult* pResult)</unmanaged>
            <unmanaged-short>IMFContentProtectionManager::EndEnableContent</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DesiredSample.GetDesiredSampleTimeAndDuration(System.Int64@,System.Int64@)">
            <summary>
            <p> </p><p>Called by the mixer to get the time and duration of the sample requested by the presenter.</p>
            </summary>
            <param name = "hnsSampleTimeRef"><dd> <p>Receives the desired sample time that should be mixed.</p> </dd></param>
            <param name = "hnsSampleDurationRef"><dd> <p>Receives the sample duration that should be mixed.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotAvailable"/></strong></dt> </dl> </td><td> <p>No time stamp was set for this sample. See <strong>IMFDesiredSample::Clear</strong>.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms694058</doc-id>
            <unmanaged>HRESULT IMFDesiredSample::GetDesiredSampleTimeAndDuration([Out] longlong* phnsSampleTime,[Out] longlong* phnsSampleDuration)</unmanaged>
            <unmanaged-short>IMFDesiredSample::GetDesiredSampleTimeAndDuration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DesiredSample.SetDesiredSampleTimeAndDuration(System.Int64,System.Int64)">
            <summary>
            <p> </p><p>Called by the presenter to set the time and duration of the sample that it requests from the mixer.</p>
            </summary>
            <param name = "hnsSampleTime"><dd> <p>The time of the requested sample.</p> </dd></param>
            <param name = "hnsSampleDuration"><dd> <p>The duration of the requested sample.</p> </dd></param>
            <remarks>
            <p>This value should be set prior to passing the buffer to the mixer for a Mix operation. The mixer sets the actual start and duration times on the sample before sending it back.</p>
            </remarks>
            <doc-id>ms694296</doc-id>
            <unmanaged>void IMFDesiredSample::SetDesiredSampleTimeAndDuration([In] longlong hnsSampleTime,[In] longlong hnsSampleDuration)</unmanaged>
            <unmanaged-short>IMFDesiredSample::SetDesiredSampleTimeAndDuration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DesiredSample.Clear">
            <summary>
            <p> </p><p>Clears the time stamps previously set by a call to <strong>IMFDesiredSample::SetDesiredSampleTimeAndDuration</strong>.</p>
            </summary>
            <remarks>
            <p>After this method is called, the <strong>IMFDesiredSample::GetDesiredSampleTimeAndDuration</strong> method returns <see cref = "!:NotAvailable"/>.</p><p>This method also clears the time stamp and duration and removes all attributes from the sample.</p>
            </remarks>
            <doc-id>ms703903</doc-id>
            <unmanaged>void IMFDesiredSample::Clear()</unmanaged>
            <unmanaged-short>IMFDesiredSample::Clear</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.InitializeTransform(SharpDX.MediaFoundation.MediaAttributes)">
            <summary>
            No documentation.
            </summary>
            <param name = "attributesRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFDeviceTransform::InitializeTransform([In] IMFAttributes* pAttributes)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::InitializeTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.GetInputAvailableType(System.Int32,System.Int32,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwInputStreamID">No documentation.</param>
            <param name = "dwTypeIndex">No documentation.</param>
            <param name = "mediaTypeRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFDeviceTransform::GetInputAvailableType([In] DWORD dwInputStreamID,[In] DWORD dwTypeIndex,[Out] IMFMediaType** pMediaType)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::GetInputAvailableType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.GetInputCurrentType(System.Int32,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwInputStreamID">No documentation.</param>
            <param name = "mediaTypeRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFDeviceTransform::GetInputCurrentType([In] DWORD dwInputStreamID,[Out] IMFMediaType** pMediaType)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::GetInputCurrentType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.GetInputStreamAttributes(System.Int32,SharpDX.MediaFoundation.MediaAttributes@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwInputStreamID">No documentation.</param>
            <param name = "attributesOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFDeviceTransform::GetInputStreamAttributes([In] DWORD dwInputStreamID,[Out] IMFAttributes** ppAttributes)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::GetInputStreamAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.GetOutputAvailableType(System.Int32,System.Int32,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwOutputStreamID">No documentation.</param>
            <param name = "dwTypeIndex">No documentation.</param>
            <param name = "mediaTypeRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFDeviceTransform::GetOutputAvailableType([In] DWORD dwOutputStreamID,[In] DWORD dwTypeIndex,[Out] IMFMediaType** pMediaType)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::GetOutputAvailableType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.GetOutputCurrentType(System.Int32,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwOutputStreamID">No documentation.</param>
            <param name = "mediaTypeRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFDeviceTransform::GetOutputCurrentType([In] DWORD dwOutputStreamID,[Out] IMFMediaType** pMediaType)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::GetOutputCurrentType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.GetOutputStreamAttributes(System.Int32,SharpDX.MediaFoundation.MediaAttributes@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwOutputStreamID">No documentation.</param>
            <param name = "attributesOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFDeviceTransform::GetOutputStreamAttributes([In] DWORD dwOutputStreamID,[Out] IMFAttributes** ppAttributes)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::GetOutputStreamAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.GetStreamCount(System.Int32@,System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "cInputStreamsRef">No documentation.</param>
            <param name = "cOutputStreamsRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFDeviceTransform::GetStreamCount([Out] DWORD* pcInputStreams,[Out] DWORD* pcOutputStreams)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::GetStreamCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.GetStreamIDs(System.Int32,System.Int32@,System.Int32,System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwInputIDArraySize">No documentation.</param>
            <param name = "dwInputStreamIdsRef">No documentation.</param>
            <param name = "dwOutputIDArraySize">No documentation.</param>
            <param name = "dwOutputStreamIdsRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFDeviceTransform::GetStreamIDs([In] DWORD dwInputIDArraySize,[Out] DWORD* pdwInputStreamIds,[In] DWORD dwOutputIDArraySize,[Out] DWORD* pdwOutputStreamIds)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::GetStreamIDs</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.ProcessEvent(System.Int32,SharpDX.MediaFoundation.MediaEvent)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwInputStreamID">No documentation.</param>
            <param name = "eventRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFDeviceTransform::ProcessEvent([In] DWORD dwInputStreamID,[In] IMFMediaEvent* pEvent)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::ProcessEvent</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.ProcessInput(System.Int32,SharpDX.MediaFoundation.Sample,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwInputStreamID">No documentation.</param>
            <param name = "sampleRef">No documentation.</param>
            <param name = "dwFlags">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFDeviceTransform::ProcessInput([In] DWORD dwInputStreamID,[In] IMFSample* pSample,[In] DWORD dwFlags)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::ProcessInput</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.ProcessMessage(SharpDX.MediaFoundation.TMessageType,System.IntPtr)">
            <summary>
            No documentation.
            </summary>
            <param name = "eMessage">No documentation.</param>
            <param name = "ulParam">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFDeviceTransform::ProcessMessage([In] MFT_MESSAGE_TYPE eMessage,[In] ULONG_PTR ulParam)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::ProcessMessage</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.ProcessOutput(System.Int32,System.Int32,SharpDX.MediaFoundation.TOutputDataBuffer@,System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwFlags">No documentation.</param>
            <param name = "cOutputBufferCount">No documentation.</param>
            <param name = "outputSampleRef">No documentation.</param>
            <param name = "dwStatusRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFDeviceTransform::ProcessOutput([In] DWORD dwFlags,[In] DWORD cOutputBufferCount,[InOut] MFT_OUTPUT_DATA_BUFFER* pOutputSample,[Out] DWORD* pdwStatus)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::ProcessOutput</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.SetInputStreamState(System.Int32,SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.DeviceStreamState,System.Int32)">
            <summary>
            <p>The <strong>SetInputStreamState</strong> method sets the Device MFT input stream state and media type.</p>
            </summary>
            <param name = "dwStreamID"><dd> <p>Stream ID of the input stream where the state and media type needs to be changed.</p> </dd></param>
            <param name = "mediaTypeRef"><dd> <p>Preferred media type for the input stream is passed in through this parameter. Device MFT should change the media type only if the incoming media type is different from the current media type.</p> </dd></param>
            <param name = "value"><dd> <p>Specifies the  <strong>DeviceStreamState</strong> which the input stream should transition to.</p> </dd></param>
            <param name = "dwFlags"><dd> <p>When  <strong><see cref = "F:SharpDX.Result.Ok"/></strong> is returned, perform the state change operation. Otherwise, this contains an error that occurred while setting the media type on the devproxy  output pin. In this case, propagate the error appropriately.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include but not limited to values given in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Initialization succeeded</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>Device MFT could not  support the request at this time.</p> </td></tr> <tr><td> <dl> <dt><strong>MF_E_INVAILIDSTREAMNUMBER</strong></dt> </dl> </td><td> <p>An invalid stream ID was passed.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamState"/></strong></dt> </dl> </td><td> <p>The requested stream transition is not possible.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface function helps to transition the input stream to a specified state with a specified media type set on the input stream. This will be used by device transform  manager (DTM) when the Device MFT requests a specific input stream?s state and media type to be changed. Device MFT would need to request such a change when one of the Device MFT's output changes.</p><p>As an  example, consider a Device MFT that has two input streams and three output streams. Let  Output 1 and Output 2 source from Input 1 and  stream at 720p. Now, if   Output 2?s media type changes to 1080p, Device MFT has to change Input 1's media type to 1080p. To achieve this, Device MFT should request DTM to call this method using the METransformInputStreamStateChanged message.
            </p>
            </remarks>
            <doc-id>mt797683</doc-id>
            <unmanaged>HRESULT IMFDeviceTransform::SetInputStreamState([In] DWORD dwStreamID,[In] IMFMediaType* pMediaType,[In] DeviceStreamState value,[In] DWORD dwFlags)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::SetInputStreamState</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.GetInputStreamState(System.Int32,SharpDX.MediaFoundation.DeviceStreamState@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwStreamID">No documentation.</param>
            <param name = "value">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFDeviceTransform::GetInputStreamState([In] DWORD dwStreamID,[Out] DeviceStreamState* value)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::GetInputStreamState</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.SetOutputStreamState(System.Int32,SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.DeviceStreamState,System.Int32)">
            <summary>
            <p>The <strong>SetOutputStreamState</strong> method sets the Device MFT output stream state and media type.</p>
            </summary>
            <param name = "dwStreamID"><dd> <p>Stream ID of the input stream where the state and media type needs to be changed.</p> </dd></param>
            <param name = "mediaTypeRef"><dd> <p>Preferred media type for the input stream is passed in through this parameter. Device MFT should change the media type only if the incoming media type is different from the current media type.</p> </dd></param>
            <param name = "value"><dd> <p>Specifies the  <strong>DeviceStreamState</strong> which the input stream should transition to.</p> </dd></param>
            <param name = "dwFlags"><dd> <p>Must be zero.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include but not limited to values given in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Transitioning the stream state succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>Device MFT could not  support the request at this time.</p> </td></tr> <tr><td> <dl> <dt><strong>MF_E_INVAILIDSTREAMNUMBER</strong></dt> </dl> </td><td> <p>An invalid stream ID was passed.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamState"/></strong></dt> </dl> </td><td> <p>The requested stream transition is not possible.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface method helps to transition the output stream to a specified state with specified media type set on the output stream. This will be used by the DTM when the Device Source requests a specific output stream?s state and media type to be changed. Device MFT should change the specified output stream?s media type and state to the requested media type.</p><p>If the incoming media type and stream state are same as the current media type and stream state the method return <strong><see cref = "F:SharpDX.Result.Ok"/></strong>.</p><p>If the incoming media type and current media type of the stream are the same, Device MFT must change the stream?s state to the requested value and return the appropriate <strong><see cref = "T:SharpDX.Result"/></strong>.</p><p>When a change in the output stream?s media type requires a corresponding change in the input then Device MFT must post the METransformInputStreamStateChanged event  to DTM to change the relevant input stream. The call must return only after changing the input stream?s media type and the appropriate <strong><see cref = "T:SharpDX.Result"/></strong>.</p><p>As an  example, consider a Device MFT that has two input streams and three output streams. Let  Output 1 and Output 2 source from Input 1 and  stream at 720p. Now, let us say Output 2?s media type changes to 1080p. To satisfy this request, Device MFT must  change the Input 1 media type to 1080p, by posting METransformInputStreamStateChanged event to the DTM. DTM would call <strong>SetInputStreamState</strong> to change the input stream? media type and state. After this call, the <strong>SetOutputStreamState</strong> must return.</p>
            </remarks>
            <doc-id>mt797684</doc-id>
            <unmanaged>HRESULT IMFDeviceTransform::SetOutputStreamState([In] DWORD dwStreamID,[In] IMFMediaType* pMediaType,[In] DeviceStreamState value,[In] DWORD dwFlags)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::SetOutputStreamState</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.GetOutputStreamState(System.Int32,SharpDX.MediaFoundation.DeviceStreamState@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwStreamID">No documentation.</param>
            <param name = "value">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFDeviceTransform::GetOutputStreamState([In] DWORD dwStreamID,[Out] DeviceStreamState* value)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::GetOutputStreamState</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.GetInputStreamPreferredState(System.Int32,SharpDX.MediaFoundation.DeviceStreamState@,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwStreamID">No documentation.</param>
            <param name = "value">No documentation.</param>
            <param name = "mediaTypeOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFDeviceTransform::GetInputStreamPreferredState([In] DWORD dwStreamID,[Out] DeviceStreamState* value,[Out] IMFMediaType** ppMediaType)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::GetInputStreamPreferredState</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.FlushInputStream(System.Int32,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwStreamIndex">No documentation.</param>
            <param name = "dwFlags">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFDeviceTransform::FlushInputStream([In] DWORD dwStreamIndex,[In] DWORD dwFlags)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::FlushInputStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DeviceTransform.FlushOutputStream(System.Int32,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwStreamIndex">No documentation.</param>
            <param name = "dwFlags">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFDeviceTransform::FlushOutputStream([In] DWORD dwStreamIndex,[In] DWORD dwFlags)</unmanaged>
            <unmanaged-short>IMFDeviceTransform::FlushOutputStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DLNASinkInit.Initialize(SharpDX.MediaFoundation.IByteStream,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Initializes the Digital Living Network Alliance (DLNA) media sink.</p>
            </summary>
            <param name = "byteStreamRef"><dd> <p>Pointer to a byte stream. The DLNA media sink writes data to this byte stream. The byte stream must be writable.</p> </dd></param>
            <param name = "fPal"><dd> <p>If <strong>TRUE</strong>, the DLNA media sink accepts PAL video formats. Otherwise, it accepts NTSC video  formats.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:AlreadyInitializeD"/></strong></strong></dt> </dl> </td><td> <p>The method was already called.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The media sink's <strong>IMFMediaSink::Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dd368788</doc-id>
            <unmanaged>HRESULT IMFDLNASinkInit::Initialize([In] IMFByteStream* pByteStream,[In] BOOL fPal)</unmanaged>
            <unmanaged-short>IMFDLNASinkInit::Initialize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DRMNetHelper.ProcessLicenseRequest(System.Byte[],System.Int32,System.Byte[],System.Int32@,System.IntPtr)">
            <summary>
            <p>Gets the license response for the specified request.</p>
            </summary>
            <param name = "licenseRequestRef"><dd> <p>Pointer to a byte array that contains the license request.</p> </dd></param>
            <param name = "cbLicenseRequest"><dd> <p>Size, in bytes, of the license request.</p> </dd></param>
            <param name = "licenseResponseOut"><dd> <p>Receives a reference to a byte array that contains the license response. The caller must free the array by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>
            <param name = "cbLicenseResponseRef"><dd> <p>Receives the size, in bytes, of the license response.</p> </dd></param>
            <param name = "bstrKIDRef"><dd> <p>Receives the key identifier. The caller must release the string by calling <strong>SysFreeString</strong>.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink was shut down.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dd368791</doc-id>
            <unmanaged>HRESULT IMFDRMNetHelper::ProcessLicenseRequest([In, Buffer] unsigned char* pLicenseRequest,[In] DWORD cbLicenseRequest,[Buffer, Optional] unsigned char** ppLicenseResponse,[Out] DWORD* pcbLicenseResponse,[Out] wchar_t** pbstrKID)</unmanaged>
            <unmanaged-short>IMFDRMNetHelper::ProcessLicenseRequest</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DRMNetHelper.GetChainedLicenseResponse(System.Byte[],System.Int32@)">
            <summary>
            <p>Not implemented in this release.</p>
            </summary>
            <param name = "licenseResponseOut"><dd> <p>Receives a reference to a byte array that contains the license response. The caller must free the array by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>
            <param name = "cbLicenseResponseRef"><dd> <p>Receives the size, in bytes, of the license response.</p> </dd></param>
            <returns><p>The method returns <strong>E_NOTIMPL</strong>.</p></returns>
            <doc-id>dd368790</doc-id>
            <unmanaged>HRESULT IMFDRMNetHelper::GetChainedLicenseResponse([Buffer, Optional] unsigned char** ppLicenseResponse,[Out] DWORD* pcbLicenseResponse)</unmanaged>
            <unmanaged-short>IMFDRMNetHelper::GetChainedLicenseResponse</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.DXGIBuffer.SubresourceIndex">
            <summary>
            <p>Gets the index of the subresource that is associated with this media buffer.</p>
            </summary>
            <remarks>
            <p>The subresource index is specified when you create the media buffer object. See <strong>MFCreateDXGISurfaceBuffer</strong>.</p><p>For more information about texture subresources, see <strong>ID3D11Device::CreateTexture2D</strong>.</p>
            </remarks>
            <doc-id>hh447903</doc-id>
            <unmanaged>GetSubresourceIndex</unmanaged>
            <unmanaged-short>GetSubresourceIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DXGIBuffer.GetResource(System.Guid,System.IntPtr@)">
            <summary>
            <p>Queries the Microsoft DirectX Graphics Infrastructure (DXGI) surface for an interface.</p>
            </summary>
            <param name = "riid"><dd> <p>The interface identifer (IID) of the interface being requested.</p> </dd></param>
            <param name = "vObjectOut"><dd> <p>Receives a reference to the interface. The caller must release the interface.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong> E_NOINTERFACE</strong></dt> </dl> </td><td> <p>The object does not support the specified interface.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid request.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>You can use this method to get a reference to the <strong><see cref = "!:SharpDX.Direct3D11.Texture2D"/></strong> interface of the surface. If the buffer is locked, the method returns <strong><see cref = "!:InvalidRequest"/></strong>.</p>
            </remarks>
            <doc-id>hh447902</doc-id>
            <unmanaged>HRESULT IMFDXGIBuffer::GetResource([In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>
            <unmanaged-short>IMFDXGIBuffer::GetResource</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DXGIBuffer.GetSubresourceIndex(System.Int32@)">
            <summary>
            <p>Gets the index of the subresource that is associated with this media buffer.</p>
            </summary>
            <param name = "uSubresourceRef"><dd> <p>Receives the zero-based index of the subresource.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The subresource index is specified when you create the media buffer object. See <strong>MFCreateDXGISurfaceBuffer</strong>.</p><p>For more information about texture subresources, see <strong>ID3D11Device::CreateTexture2D</strong>.</p>
            </remarks>
            <doc-id>hh447903</doc-id>
            <unmanaged>HRESULT IMFDXGIBuffer::GetSubresourceIndex([Out] unsigned int* puSubresource)</unmanaged>
            <unmanaged-short>IMFDXGIBuffer::GetSubresourceIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DXGIBuffer.GetUnknown(System.Guid,System.Guid,System.IntPtr@)">
            <summary>
            <p>Gets an <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference that was previously stored in the media buffer object.</p>
            </summary>
            <param name = "guid">No documentation.</param>
            <param name = "riid">No documentation.</param>
            <param name = "vObjectOut">No documentation.</param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong> E_NOINTERFACE</strong></dt> </dl> </td><td> <p>The object does not support the specified interface.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotFound"/></strong></dt> </dl> </td><td> <p>The specified key was not found.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>hh447904</doc-id>
            <unmanaged>HRESULT IMFDXGIBuffer::GetUnknown([In] const GUID&amp; guid,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>
            <unmanaged-short>IMFDXGIBuffer::GetUnknown</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DXGIBuffer.SetUnknown(System.Guid,SharpDX.IUnknown)">
            <summary>
            <p>Stores an arbitrary <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference in the media buffer object.</p>
            </summary>
            <param name = "guid">No documentation.</param>
            <param name = "unkDataRef">No documentation.</param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong>ERROR_OBJECT_ALREADY_EXISTS</strong></dt> </dl> </td><td> <p>An item already exists with this key.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To retrieve the reference from the object, call <strong>IMFDXGIBuffer::GetUnknown</strong>.</p>
            </remarks>
            <doc-id>hh447905</doc-id>
            <unmanaged>HRESULT IMFDXGIBuffer::SetUnknown([In] const GUID&amp; guid,[In, Optional] IUnknown* pUnkData)</unmanaged>
            <unmanaged-short>IMFDXGIBuffer::SetUnknown</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.DXGIDeviceManagerSource.Manager">
            <summary>
            <p>Gets the <strong><see cref = "T:SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> from the Microsoft Media Foundation video rendering sink.</p>
            </summary>
            <doc-id>dn280688</doc-id>
            <unmanaged>GetManager</unmanaged>
            <unmanaged-short>GetManager</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.DXGIDeviceManagerSource.GetManager(SharpDX.MediaFoundation.DXGIDeviceManager@)">
            <summary>
            <p>Gets the <strong><see cref = "T:SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> from the Microsoft Media Foundation video rendering sink.</p>
            </summary>
            <param name = "managerOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280688</doc-id>
            <unmanaged>HRESULT IMFDXGIDeviceManagerSource::GetManager([Out] IMFDXGIDeviceManager** ppManager)</unmanaged>
            <unmanaged-short>IMFDXGIDeviceManagerSource::GetManager</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ExtendedDRMTypeSupport.IsTypeSupportedEx(System.String,System.String,SharpDX.MediaFoundation.MediaEngineCanPlay@)">
            <summary>
            No documentation.
            </summary>
            <param name = "type">No documentation.</param>
            <param name = "keySystem">No documentation.</param>
            <param name = "answerRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFExtendedDRMTypeSupport::IsTypeSupportedEx([In, Optional] wchar_t* type,[In] wchar_t* keySystem,[Out] MF_MEDIA_ENGINE_CANPLAY* pAnswer)</unmanaged>
            <unmanaged-short>IMFExtendedDRMTypeSupport::IsTypeSupportedEx</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.FieldOfUseMFTUnlock.Unlock(SharpDX.IUnknown)">
            <summary>
            <p>Unlocks a Media Foundation transform (MFT) so that the application can use it.</p>
            </summary>
            <param name = "unkMFTRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of the MFT.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method authenticates the caller, using a private communication channel between the MFT and the object that implements the <strong><see cref = "T:SharpDX.MediaFoundation.FieldOfUseMFTUnlock"/></strong> interface. The details of the communication depend entirely on the implementation.</p>
            </remarks>
            <doc-id>dd368793</doc-id>
            <unmanaged>HRESULT IMFFieldOfUseMFTUnlock::Unlock([In, Optional] IUnknown* pUnkMFT)</unmanaged>
            <unmanaged-short>IMFFieldOfUseMFTUnlock::Unlock</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.FilterConfig.NumberOfStreams">
            <summary>
            <p> </p><p>Retrieves the number of input pins on the EVR filter. The EVR filter always has at least one input pin, which corresponds to the reference stream.</p>
            </summary>
            <doc-id>ms701550</doc-id>
            <unmanaged>GetNumberOfStreams / SetNumberOfStreams</unmanaged>
            <unmanaged-short>GetNumberOfStreams</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.FilterConfig.SetNumberOfStreams(System.Int32)">
            <summary>
            <p> </p><p>Sets the number of input pins on the EVR filter.</p>
            </summary>
            <param name = "dwMaxStreams"><dd> <p>Specifies the total number of input pins on the EVR filter. This value includes the input pin for the reference stream, which is created by default. For example, to mix one substream plus the reference stream, set this parameter to 2.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid number of streams. The minimum is one, and the maximum is 16.</p> </td></tr> <tr><td> <dl> <dt><strong>VFW_E_WRONG_STATE</strong></dt> </dl> </td><td> <p>This method has already been called, or at least one pin is already connected.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>After this method has been called, it cannot be called a second time on the same instance of the EVR filter. Also, the method fails if any input pins are connected.</p>
            </remarks>
            <doc-id>ms698968</doc-id>
            <unmanaged>HRESULT IEVRFilterConfig::SetNumberOfStreams([In] DWORD dwMaxStreams)</unmanaged>
            <unmanaged-short>IEVRFilterConfig::SetNumberOfStreams</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.FilterConfig.GetNumberOfStreams(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the number of input pins on the EVR filter. The EVR filter always has at least one input pin, which corresponds to the reference stream.</p>
            </summary>
            <param name = "dwMaxStreamsRef"><dd> <p>Receives the number of streams.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms701550</doc-id>
            <unmanaged>HRESULT IEVRFilterConfig::GetNumberOfStreams([Out] DWORD* pdwMaxStreams)</unmanaged>
            <unmanaged-short>IEVRFilterConfig::GetNumberOfStreams</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.FilterConfigEx.ConfigPrefs">
            <summary>
            <p>Gets or sets the configuration parameters for the Microsoft DirectShow <strong>Enhanced Video Renderer Filter</strong> filter.</p>
            </summary>
            <doc-id>dd373925</doc-id>
            <unmanaged>GetConfigPrefs / SetConfigPrefs</unmanaged>
            <unmanaged-short>GetConfigPrefs</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.FilterConfigEx.SetConfigPrefs(System.Int32)">
            <summary>
            <p>Sets the configuration parameters for the Microsoft DirectShow <strong>Enhanced Video Renderer Filter</strong> (EVR).</p>
            </summary>
            <param name = "dwConfigFlags">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dd373926</doc-id>
            <unmanaged>HRESULT IEVRFilterConfigEx::SetConfigPrefs([In] DWORD dwConfigFlags)</unmanaged>
            <unmanaged-short>IEVRFilterConfigEx::SetConfigPrefs</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.FilterConfigEx.GetConfigPrefs(System.Int32@)">
            <summary>
            <p>Gets the configuration parameters for the Microsoft DirectShow <strong>Enhanced Video Renderer Filter</strong> filter.</p>
            </summary>
            <param name = "dwConfigFlagsRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd373925</doc-id>
            <unmanaged>HRESULT IEVRFilterConfigEx::GetConfigPrefs([Out] DWORD* pdwConfigFlags)</unmanaged>
            <unmanaged-short>IEVRFilterConfigEx::GetConfigPrefs</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.FinalizableMediaSink.BeginFinalize(SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Notifies the media sink to asynchronously take any steps it needs to finish its tasks.</p>
            </summary>
            <param name = "callbackRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of an asynchronous object. The caller must implement this interface.</p> </dd></param>
            <param name = "unkStateRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Many archive media sinks have steps they need to do at the end of archiving to complete their file operations, such as updating the header (for some formats) or flushing all pending writes to disk. In some cases, this may include expensive operations such as indexing the content. <strong>BeginFinalize</strong> is an asynchronous way to initiate final tasks.</p><p>When the finalize operation is complete, the callback object's <strong>IMFAsyncCallback::Invoke</strong> method is called. At that point, the application should call <strong>IMFFinalizableMediaSink::EndFinalize</strong> to complete the asynchronous request.</p>
            </remarks>
            <doc-id>ms705643</doc-id>
            <unmanaged>HRESULT IMFFinalizableMediaSink::BeginFinalize([In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>
            <unmanaged-short>IMFFinalizableMediaSink::BeginFinalize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.FinalizableMediaSink.EndFinalize(SharpDX.MediaFoundation.AsyncResult)">
            <summary>
            <p> </p><p>Completes an asynchronous finalize operation.</p>
            </summary>
            <param name = "resultRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>IMFAsyncCallback::Invoke</strong> method.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this method after the <strong>IMFFinalizableMediaSink::BeginFinalize</strong> method completes asynchronously.</p>
            </remarks>
            <doc-id>ms694891</doc-id>
            <unmanaged>HRESULT IMFFinalizableMediaSink::EndFinalize([In] IMFAsyncResult* pResult)</unmanaged>
            <unmanaged-short>IMFFinalizableMediaSink::EndFinalize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HDCPStatus.Query(SharpDX.MediaFoundation.HdcpStatus@,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            No documentation.
            </summary>
            <param name = "statusRef">No documentation.</param>
            <param name = "fStatusRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHDCPStatus::Query([InOut] MF_HDCP_STATUS* pStatus,[InOut] BOOL* pfStatus)</unmanaged>
            <unmanaged-short>IMFHDCPStatus::Query</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HDCPStatus.Set(SharpDX.MediaFoundation.HdcpStatus)">
            <summary>
            No documentation.
            </summary>
            <param name = "status">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHDCPStatus::Set([In] MF_HDCP_STATUS status)</unmanaged>
            <unmanaged-short>IMFHDCPStatus::Set</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.HttpDownloadRequest.HttpStatus">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetHttpStatus</unmanaged>
            <unmanaged-short>GetHttpStatus</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.HttpDownloadRequest.AtEndOfPayload">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetAtEndOfPayload</unmanaged>
            <unmanaged-short>GetAtEndOfPayload</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.HttpDownloadRequest.TotalLength">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetTotalLength</unmanaged>
            <unmanaged-short>GetTotalLength</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.HttpDownloadRequest.RangeEndOffset">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetRangeEndOffset</unmanaged>
            <unmanaged-short>GetRangeEndOffset</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadRequest.AddHeader(System.String)">
            <summary>
            No documentation.
            </summary>
            <param name = "szHeader">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHttpDownloadRequest::AddHeader([In] const wchar_t* szHeader)</unmanaged>
            <unmanaged-short>IMFHttpDownloadRequest::AddHeader</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadRequest.BeginSendRequest(System.Byte[],System.Int32,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            No documentation.
            </summary>
            <param name = "bPayloadRef">No documentation.</param>
            <param name = "cbPayload">No documentation.</param>
            <param name = "callbackRef">No documentation.</param>
            <param name = "unkStateRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHttpDownloadRequest::BeginSendRequest([In, Buffer, Optional] const unsigned char* pbPayload,[In] ULONG cbPayload,[In] IMFAsyncCallback* pCallback,[In, Optional] IUnknown* punkState)</unmanaged>
            <unmanaged-short>IMFHttpDownloadRequest::BeginSendRequest</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadRequest.EndSendRequest(SharpDX.MediaFoundation.AsyncResult)">
            <summary>
            No documentation.
            </summary>
            <param name = "resultRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHttpDownloadRequest::EndSendRequest([In] IMFAsyncResult* pResult)</unmanaged>
            <unmanaged-short>IMFHttpDownloadRequest::EndSendRequest</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadRequest.BeginReceiveResponse(SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            No documentation.
            </summary>
            <param name = "callbackRef">No documentation.</param>
            <param name = "unkStateRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHttpDownloadRequest::BeginReceiveResponse([In] IMFAsyncCallback* pCallback,[In, Optional] IUnknown* punkState)</unmanaged>
            <unmanaged-short>IMFHttpDownloadRequest::BeginReceiveResponse</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadRequest.EndReceiveResponse(SharpDX.MediaFoundation.AsyncResult)">
            <summary>
            No documentation.
            </summary>
            <param name = "resultRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHttpDownloadRequest::EndReceiveResponse([In] IMFAsyncResult* pResult)</unmanaged>
            <unmanaged-short>IMFHttpDownloadRequest::EndReceiveResponse</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadRequest.BeginReadPayload(System.Byte[],System.Int32,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            No documentation.
            </summary>
            <param name = "bRef">No documentation.</param>
            <param name = "cb">No documentation.</param>
            <param name = "callbackRef">No documentation.</param>
            <param name = "unkStateRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHttpDownloadRequest::BeginReadPayload([Out, Buffer] unsigned char* pb,[In] ULONG cb,[In] IMFAsyncCallback* pCallback,[In, Optional] IUnknown* punkState)</unmanaged>
            <unmanaged-short>IMFHttpDownloadRequest::BeginReadPayload</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadRequest.EndReadPayload(SharpDX.MediaFoundation.AsyncResult,System.Int64@,System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "resultRef">No documentation.</param>
            <param name = "qwOffsetRef">No documentation.</param>
            <param name = "cbReadRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHttpDownloadRequest::EndReadPayload([In] IMFAsyncResult* pResult,[Out] unsigned longlong* pqwOffset,[Out] ULONG* pcbRead)</unmanaged>
            <unmanaged-short>IMFHttpDownloadRequest::EndReadPayload</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadRequest.QueryHeader(System.String,System.Int32,System.IntPtr)">
            <summary>
            No documentation.
            </summary>
            <param name = "szHeaderName">No documentation.</param>
            <param name = "dwIndex">No documentation.</param>
            <param name = "szHeaderValueOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHttpDownloadRequest::QueryHeader([In] const wchar_t* szHeaderName,[In] DWORD dwIndex,[Out] wchar_t** ppszHeaderValue)</unmanaged>
            <unmanaged-short>IMFHttpDownloadRequest::QueryHeader</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadRequest.GetURL(System.IntPtr)">
            <summary>
            No documentation.
            </summary>
            <param name = "szURLOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHttpDownloadRequest::GetURL([Out] wchar_t** ppszURL)</unmanaged>
            <unmanaged-short>IMFHttpDownloadRequest::GetURL</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadRequest.HasNullSourceOrigin(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            No documentation.
            </summary>
            <param name = "fNullSourceOriginRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHttpDownloadRequest::HasNullSourceOrigin([Out] BOOL* pfNullSourceOrigin)</unmanaged>
            <unmanaged-short>IMFHttpDownloadRequest::HasNullSourceOrigin</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadRequest.GetTimeSeekResult(System.Int64@,System.Int64@,System.Int64@)">
            <summary>
            No documentation.
            </summary>
            <param name = "qwStartTimeRef">No documentation.</param>
            <param name = "qwStopTimeRef">No documentation.</param>
            <param name = "qwDurationRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHttpDownloadRequest::GetTimeSeekResult([Out] unsigned longlong* pqwStartTime,[Out] unsigned longlong* pqwStopTime,[Out] unsigned longlong* pqwDuration)</unmanaged>
            <unmanaged-short>IMFHttpDownloadRequest::GetTimeSeekResult</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadRequest.GetHttpStatus(System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwHttpStatusRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHttpDownloadRequest::GetHttpStatus([Out] DWORD* pdwHttpStatus)</unmanaged>
            <unmanaged-short>IMFHttpDownloadRequest::GetHttpStatus</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadRequest.GetAtEndOfPayload(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            No documentation.
            </summary>
            <param name = "fAtEndOfPayloadRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHttpDownloadRequest::GetAtEndOfPayload([Out] BOOL* pfAtEndOfPayload)</unmanaged>
            <unmanaged-short>IMFHttpDownloadRequest::GetAtEndOfPayload</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadRequest.GetTotalLength(System.Int64@)">
            <summary>
            No documentation.
            </summary>
            <param name = "qwTotalLengthRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHttpDownloadRequest::GetTotalLength([Out] unsigned longlong* pqwTotalLength)</unmanaged>
            <unmanaged-short>IMFHttpDownloadRequest::GetTotalLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadRequest.GetRangeEndOffset(System.Int64@)">
            <summary>
            No documentation.
            </summary>
            <param name = "qwRangeEndRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHttpDownloadRequest::GetRangeEndOffset([Out] unsigned longlong* pqwRangeEnd)</unmanaged>
            <unmanaged-short>IMFHttpDownloadRequest::GetRangeEndOffset</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadRequest.Close">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHttpDownloadRequest::Close()</unmanaged>
            <unmanaged-short>IMFHttpDownloadRequest::Close</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadSession.SetServer(System.String,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "szServerName">No documentation.</param>
            <param name = "nPort">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHttpDownloadSession::SetServer([In] const wchar_t* szServerName,[In] DWORD nPort)</unmanaged>
            <unmanaged-short>IMFHttpDownloadSession::SetServer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadSession.CreateRequest(System.String,SharpDX.Mathematics.Interop.RawBool,SharpDX.Mathematics.Interop.RawBool,System.String,System.String,SharpDX.MediaFoundation.HttpDownloadRequest@)">
            <summary>
            No documentation.
            </summary>
            <param name = "szObjectName">No documentation.</param>
            <param name = "fBypassProxyCache">No documentation.</param>
            <param name = "fSecure">No documentation.</param>
            <param name = "szVerb">No documentation.</param>
            <param name = "szReferrer">No documentation.</param>
            <param name = "requestOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHttpDownloadSession::CreateRequest([In] const wchar_t* szObjectName,[In] BOOL fBypassProxyCache,[In] BOOL fSecure,[In, Optional] const wchar_t* szVerb,[In, Optional] const wchar_t* szReferrer,[Out] IMFHttpDownloadRequest** ppRequest)</unmanaged>
            <unmanaged-short>IMFHttpDownloadSession::CreateRequest</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadSession.Close">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFHttpDownloadSession::Close()</unmanaged>
            <unmanaged-short>IMFHttpDownloadSession::Close</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.HttpDownloadSessionProvider.CreateHttpDownloadSession(System.String,SharpDX.MediaFoundation.HttpDownloadSession@)">
            <summary>
            <p>Applications implement this interface in order to provide custom a custom HTTP or HTTPS download implementation. Use the <strong><see cref = "T:SharpDX.MediaFoundation.SourceResolver"/></strong> interface to register the provider. For more information, see Using the Source Resolver. Once registered, the Microsoft Media Foundation will invoke the <strong>CreateHttpDownloadSession</strong> method of the provider  implementation to open HTTP or HTTPS URLs instead of using the default implementation.</p>
            </summary>
            <param name = "wszScheme">No documentation.</param>
            <param name = "downloadSessionOut">No documentation.</param>
            <returns>No documentation.</returns>
            <doc-id>mt781238</doc-id>
            <unmanaged>HRESULT IMFHttpDownloadSessionProvider::CreateHttpDownloadSession([In] const wchar_t* wszScheme,[Out] IMFHttpDownloadSession** ppDownloadSession)</unmanaged>
            <unmanaged-short>IMFHttpDownloadSessionProvider::CreateHttpDownloadSession</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IAudioSourceProvider.ProvideInput(System.Int32,System.Int32@,System.Single[])">
            <summary>
            No documentation.
            </summary>
            <param name = "dwSampleCount">No documentation.</param>
            <param name = "dwChannelCountRef">No documentation.</param>
            <param name = "interleavedAudioDataRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IAudioSourceProvider::ProvideInput([In] DWORD dwSampleCount,[InOut] DWORD* pdwChannelCount,[Out, Buffer, Optional] float* pInterleavedAudioData)</unmanaged>
            <unmanaged-short>IAudioSourceProvider::ProvideInput</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.IDMOQualityControl.Now">
            <summary>
            No documentation.
            </summary>
            <unmanaged>SetNow</unmanaged>
            <unmanaged-short>SetNow</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.IDMOQualityControl.Status">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetStatus / SetStatus</unmanaged>
            <unmanaged-short>GetStatus</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IDMOQualityControl.SetNow(System.Int64)">
            <summary>
            No documentation.
            </summary>
            <param name = "rtNow">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IDMOQualityControl::SetNow([In] longlong rtNow)</unmanaged>
            <unmanaged-short>IDMOQualityControl::SetNow</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IDMOQualityControl.SetStatus(System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwFlags">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IDMOQualityControl::SetStatus([In] DWORD dwFlags)</unmanaged>
            <unmanaged-short>IDMOQualityControl::SetStatus</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IDMOQualityControl.GetStatus(System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwFlagsRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IDMOQualityControl::GetStatus([Out] DWORD* pdwFlags)</unmanaged>
            <unmanaged-short>IDMOQualityControl::GetStatus</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IDMOVideoOutputOptimizations.QueryOperationModePreferences(System.Int32,System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "ulOutputStreamIndex">No documentation.</param>
            <param name = "dwRequestedCapabilitiesRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IDMOVideoOutputOptimizations::QueryOperationModePreferences([In] ULONG ulOutputStreamIndex,[Out] DWORD* pdwRequestedCapabilities)</unmanaged>
            <unmanaged-short>IDMOVideoOutputOptimizations::QueryOperationModePreferences</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IDMOVideoOutputOptimizations.SetOperationMode(System.Int32,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "ulOutputStreamIndex">No documentation.</param>
            <param name = "dwEnabledFeatures">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IDMOVideoOutputOptimizations::SetOperationMode([In] ULONG ulOutputStreamIndex,[In] DWORD dwEnabledFeatures)</unmanaged>
            <unmanaged-short>IDMOVideoOutputOptimizations::SetOperationMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IDMOVideoOutputOptimizations.GetCurrentOperationMode(System.Int32,System.Int32@)">
            <summary>
            <p> </p><p>The <code>GetCurrentOperationMode</code> method retrieves the optimization features in effect.</p>
            </summary>
            <param name = "ulOutputStreamIndex"><dd> <p>Zero-based index of an output stream on the DMO.</p> </dd></param>
            <param name = "dwEnabledFeaturesRef"><dd> <p>Pointer to a variable that receives the current features. The returned value is a bitwise combination of zero or more flags from the <strong>DMO_VIDEO_OUTPUT_STREAM_FLAGS</strong> enumeration.</p> </dd></param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>DMO_E_INVALIDSTREAMINDEX</strong></dt> </dl> </td><td> <p>Invalid stream index</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p><strong><c>null</c></strong> reference argument</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dd406844</doc-id>
            <unmanaged>HRESULT IDMOVideoOutputOptimizations::GetCurrentOperationMode([In] ULONG ulOutputStreamIndex,[Out] DWORD* pdwEnabledFeatures)</unmanaged>
            <unmanaged-short>IDMOVideoOutputOptimizations::GetCurrentOperationMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IDMOVideoOutputOptimizations.GetCurrentSampleRequirements(System.Int32,System.Int32@)">
            <summary>
            <p> </p><p>The <code>GetCurrentSampleRequirements</code> method retrieves the optimization features required to process the next sample, given the features already agreed to by the application.</p>
            </summary>
            <param name = "ulOutputStreamIndex"><dd> <p>Zero-based index of an output stream on the DMO.</p> </dd></param>
            <param name = "dwRequestedFeaturesRef"><dd> <p>Pointer to a variable that receives the required features. The returned value is a bitwise combination of zero or more flags from the <strong>DMO_VIDEO_OUTPUT_STREAM_FLAGS</strong> enumeration.</p> </dd></param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>DMO_E_INVALIDSTREAMINDEX</strong></dt> </dl> </td><td> <p>Invalid stream index</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p><strong><c>null</c></strong> reference argument</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>After an application calls the <strong>IDMOVideoOutputOptimizations::SetOperationMode</strong> method, it must provide all the features it has agreed to. However, the DMO might not require every feature on every sample. This method enables the DMO to waive an agreed-upon feature for one sample.</p><p>Before processing a sample, the application can call this method. If the DMO does not require a given feature in order to process the next sample, it omits the corresponding flag from the <em>pdwRequestedFeatures</em> parameter. For the next sample only, the application can ignore the feature. The results of this method are valid only for the next call to the <strong>IMediaObject::ProcessOutput</strong> method.</p><p>The DMO will return only the flags that were agreed to in the <strong>SetOperationMode</strong> method. In other words, you cannot dynamically enable new features with this method.</p>
            </remarks>
            <doc-id>dd406845</doc-id>
            <unmanaged>HRESULT IDMOVideoOutputOptimizations::GetCurrentSampleRequirements([In] ULONG ulOutputStreamIndex,[Out] DWORD* pdwRequestedFeatures)</unmanaged>
            <unmanaged-short>IDMOVideoOutputOptimizations::GetCurrentSampleRequirements</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IEnumDMO.Next(System.Int32,System.Guid[],System.IntPtr,System.Int32@)">
            <summary>
            <p> </p><p>The <code>Next</code> method retrieves a specified number of items in the enumeration sequence.</p>
            </summary>
            <param name = "cItemsToFetch"><dd> <p>Number of items to retrieve.</p> </dd></param>
            <param name = "cLSIDRef"><dd> <p>Array of size <em>cItemsToFetch</em> that is filled with the CLSIDs of the enumerated DMOs.</p> </dd></param>
            <param name = "names"><dd> <p>Array of size <em>cItemsToFetch</em> that is filled with the friendly names of the enumerated DMOs.</p> </dd></param>
            <param name = "cItemsFetchedRef"><dd> <p>Pointer to a variable that receives the actual number of items retrieved. Can be <strong><c>null</c></strong> if <em>cItemsToFetch</em> equals 1.</p> </dd></param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong>E_OUTOFMEMORY</strong></dt> </dl> </td><td> <p>Insufficient memory.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p><strong><c>null</c></strong> reference argument.</p> </td></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p>Retrieved fewer items than requested.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Retrieved the requested number of items.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the method succeeds, the arrays given by the <em>pCLSID</em> and <em>Names</em> parameters are filled with CLSIDs and wide-character strings. The value of *<em>pcItemsFetched</em> specifies the number of items returned in these arrays.</p><p>The method returns <see cref = "F:SharpDX.Result.Ok"/> if it retrieves the requested number of items (in other words, if *<em>pcItemsFetched</em> equals <em>cItemsToFetch</em>). Otherwise, it returns S_FALSE or an error code.</p><p>The caller must free the memory allocated for each string returned in the <em>Names</em> parameter, using the <strong>CoTaskMemFree</strong> function.</p>
            </remarks>
            <doc-id>dd376587</doc-id>
            <unmanaged>HRESULT IEnumDMO::Next([In] DWORD cItemsToFetch,[Out, Buffer] GUID* pCLSID,[Out, Buffer] wchar_t** Names,[Out] DWORD* pcItemsFetched)</unmanaged>
            <unmanaged-short>IEnumDMO::Next</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IEnumDMO.Skip(System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "cItemsToSkip">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IEnumDMO::Skip([In] DWORD cItemsToSkip)</unmanaged>
            <unmanaged-short>IEnumDMO::Skip</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IEnumDMO.Reset">
            <summary>
            <p> </p><p>The <code>Reset</code> method resets the enumeration sequence to the beginning.</p>
            </summary>
            <returns><p>Returns <see cref = "F:SharpDX.Result.Ok"/>.</p></returns>
            <doc-id>dd376588</doc-id>
            <unmanaged>HRESULT IEnumDMO::Reset()</unmanaged>
            <unmanaged-short>IEnumDMO::Reset</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IEnumDMO.Clone(SharpDX.MediaFoundation.IEnumDMO@)">
            <summary>
            No documentation.
            </summary>
            <param name = "enumOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IEnumDMO::Clone([Out] IEnumDMO** ppEnum)</unmanaged>
            <unmanaged-short>IEnumDMO::Clone</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.IMediaBuffer.Length">
            <summary>
            No documentation.
            </summary>
            <unmanaged>SetLength</unmanaged>
            <unmanaged-short>SetLength</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.IMediaBuffer.MaxLength">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetMaxLength</unmanaged>
            <unmanaged-short>GetMaxLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaBuffer.SetLength(System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "cbLength">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMediaBuffer::SetLength([In] DWORD cbLength)</unmanaged>
            <unmanaged-short>IMediaBuffer::SetLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaBuffer.GetMaxLength(System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "cbMaxLengthRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMediaBuffer::GetMaxLength([Out] DWORD* pcbMaxLength)</unmanaged>
            <unmanaged-short>IMediaBuffer::GetMaxLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaBuffer.GetBufferAndLength(System.Byte[],System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "bufferOut">No documentation.</param>
            <param name = "cbLengthRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMediaBuffer::GetBufferAndLength([Out, Buffer, Optional] unsigned char** ppBuffer,[Out, Optional] DWORD* pcbLength)</unmanaged>
            <unmanaged-short>IMediaBuffer::GetBufferAndLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.GetStreamCount(System.Int32@,System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "cInputStreamsRef">No documentation.</param>
            <param name = "cOutputStreamsRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMediaObject::GetStreamCount([Out] DWORD* pcInputStreams,[Out] DWORD* pcOutputStreams)</unmanaged>
            <unmanaged-short>IMediaObject::GetStreamCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.GetInputStreamInfo(System.Int32,System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwInputStreamIndex">No documentation.</param>
            <param name = "dwFlagsRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMediaObject::GetInputStreamInfo([In] DWORD dwInputStreamIndex,[Out] DWORD* pdwFlags)</unmanaged>
            <unmanaged-short>IMediaObject::GetInputStreamInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.GetOutputStreamInfo(System.Int32,System.Int32@)">
            <summary>
            <p> </p><p>The <code>GetOutputStreamInfo</code> method retrieves information about an output stream; for example, whether the stream is discardable, and whether it uses a fixed sample size. This information never changes.</p>
            </summary>
            <param name = "dwOutputStreamIndex"><dd> <p>Zero-based index of an output stream on the DMO.</p> </dd></param>
            <param name = "dwFlagsRef"><dd> <p>Pointer to a variable that receives a bitwise combination of zero or more <strong>DMO_OUTPUT_STREAM_INFO_FLAGS</strong> flags.</p> </dd></param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>DMO_E_INVALIDSTREAMINDEX</strong></dt> </dl> </td><td> <p>Invalid stream index</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p><strong><c>null</c></strong> reference argument</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dd406955</doc-id>
            <unmanaged>HRESULT IMediaObject::GetOutputStreamInfo([In] DWORD dwOutputStreamIndex,[Out] DWORD* pdwFlags)</unmanaged>
            <unmanaged-short>IMediaObject::GetOutputStreamInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.GetInputType(System.Int32,System.Int32,SharpDX.MediaFoundation.DmoMediaType@)">
            <summary>
            <p> </p><p>The <code>GetInputType</code> method retrieves a preferred media type for a specified input stream.</p>
            </summary>
            <param name = "dwInputStreamIndex"><dd> <p>Zero-based index of an input stream on the DMO.</p> </dd></param>
            <param name = "dwTypeIndex"><dd> <p>Zero-based index on the set of acceptable media types.</p> </dd></param>
            <param name = "mtRef"><dd> <p>Pointer to a <strong><see cref = "T:SharpDX.MediaFoundation.DmoMediaType"/></strong> structure allocated by the caller, or <strong><c>null</c></strong>. If this parameter is non-<strong><c>null</c></strong>, the method fills the structure with the media type. You can use the value <strong><c>null</c></strong> to test whether the type index is in range, by checking the return code.</p> </dd></param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>DMO_E_INVALIDSTREAMINDEX</strong></dt> </dl> </td><td> <p>Invalid stream index.</p> </td></tr> <tr><td> <dl> <dt><strong>DMO_E_NO_MORE_ITEMS</strong></dt> </dl> </td><td> <p>Type index is out of range.</p> </td></tr> <tr><td> <dl> <dt><strong>E_OUTOFMEMORY</strong></dt> </dl> </td><td> <p>Insufficient memory.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p><strong><c>null</c></strong> reference argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this method to enumerate an input stream's preferred media types. The DMO assigns each media type an index value in order of preference. The most preferred type has an index of zero. To enumerate all the types, make successive calls while incrementing the type index until the method returns DMO_E_NO_MORE_ITEMS. The DMO is not guaranteed to enumerate every media type that it supports.</p><p>The format block in the returned type might be <strong><c>null</c></strong>. If so, the format type is GUID_NULL. Check the format type before dereferencing the format block.</p><p>If the method succeeds, call <strong>MoFreeMediaType</strong> to free the format block. (This function is also safe to call when the format block is <strong><c>null</c></strong>.)</p><p>To set the media type, call the <strong>IMediaObject::SetInputType</strong> method. Setting the media type on one stream can change another stream's preferred types. In fact, a stream might not have a preferred type until the type is set on another stream. For example, a decoder might not have a preferred output type until the input type is set. However, the DMO is not required to update its preferred types dynamically in this fashion. Thus, the types returned by this method are not guaranteed to be valid; they might fail when used in the <strong>SetInputType</strong> method.</p><p>To test whether a particular media type is acceptable, call <strong>SetInputType</strong> with the DMO_SET_TYPEF_TEST_ONLY flag.</p><p>To test whether the <em>dwTypeIndex</em> parameter is in range, set <em>pmt</em> to <strong><c>null</c></strong>. The method returns <see cref = "F:SharpDX.Result.Ok"/> if the index is in range, or DMO_E_NO_MORE_ITEMS if the index is out of range.</p>
            </remarks>
            <doc-id>dd406952</doc-id>
            <unmanaged>HRESULT IMediaObject::GetInputType([In] DWORD dwInputStreamIndex,[In] DWORD dwTypeIndex,[Out, Optional] DMO_MEDIA_TYPE* pmt)</unmanaged>
            <unmanaged-short>IMediaObject::GetInputType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.GetOutputType(System.Int32,System.Int32,SharpDX.MediaFoundation.DmoMediaType@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwOutputStreamIndex">No documentation.</param>
            <param name = "dwTypeIndex">No documentation.</param>
            <param name = "mtRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMediaObject::GetOutputType([In] DWORD dwOutputStreamIndex,[In] DWORD dwTypeIndex,[Out, Optional] DMO_MEDIA_TYPE* pmt)</unmanaged>
            <unmanaged-short>IMediaObject::GetOutputType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.SetInputType(System.Int32,System.Nullable{SharpDX.MediaFoundation.DmoMediaType},System.Int32)">
            <summary>
            <p> </p><p>The <code>SetInputType</code> method sets the media type on an input stream, or tests whether a media type is acceptable.</p>
            </summary>
            <param name = "dwInputStreamIndex"><dd> <p>Zero-based index of an input stream on the DMO.</p> </dd></param>
            <param name = "mtRef"><dd> <p>Pointer to a <strong><see cref = "T:SharpDX.MediaFoundation.DmoMediaType"/></strong> structure that specifies the media type.</p> </dd></param>
            <param name = "dwFlags"><dd> <p>Bitwise combination of zero or more flags from the <strong>DMO_SET_TYPE_FLAGS</strong> enumeration.</p> </dd></param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>DMO_E_INVALIDSTREAMINDEX</strong></dt> </dl> </td><td> <p>Invalid stream index</p> </td></tr> <tr><td> <dl> <dt><strong>DMO_E_TYPE_NOT_ACCEPTED</strong></dt> </dl> </td><td> <p>Media type was not accepted</p> </td></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p>Media type is not acceptable</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Media type was set successfully, or is acceptable</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this method to test, set, or clear the media type on an input stream:</p><ul> <li>To test the media type without setting it, use the DMO_SET_TYPEF_TEST_ONLY flag. If the media type is not acceptable, the method returns S_FALSE.</li> <li>To set the media type, set <em>dwFlags</em> to zero. If the media type is not acceptable, the method returns DMO_E_TYPE_NOT_ACCEPTED.</li> <li>To clear the current media type (if any), use the DMO_SET_TYPEF_CLEAR flag and set <em>pmt</em> to <strong><c>null</c></strong>. When the method returns, the stream no longer has a media type. The DMO cannot process samples until the application sets a new media type.</li> </ul><p>The media types that are currently set on other streams can affect whether the media type is acceptable.</p>
            </remarks>
            <doc-id>dd406962</doc-id>
            <unmanaged>HRESULT IMediaObject::SetInputType([In] DWORD dwInputStreamIndex,[In, Optional] const DMO_MEDIA_TYPE* pmt,[In] DWORD dwFlags)</unmanaged>
            <unmanaged-short>IMediaObject::SetInputType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.SetOutputType(System.Int32,System.Nullable{SharpDX.MediaFoundation.DmoMediaType},System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwOutputStreamIndex">No documentation.</param>
            <param name = "mtRef">No documentation.</param>
            <param name = "dwFlags">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMediaObject::SetOutputType([In] DWORD dwOutputStreamIndex,[In, Optional] const DMO_MEDIA_TYPE* pmt,[In] DWORD dwFlags)</unmanaged>
            <unmanaged-short>IMediaObject::SetOutputType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.GetInputCurrentType(System.Int32,SharpDX.MediaFoundation.DmoMediaType@)">
            <summary>
            <p> </p><p>The <code>GetInputCurrentType</code> method retrieves the media type that was set for an input stream, if any.</p>
            </summary>
            <param name = "dwInputStreamIndex"><dd> <p>Zero-based index of an input stream on the DMO.</p> </dd></param>
            <param name = "mtRef"><dd> <p>Pointer to a <strong><see cref = "T:SharpDX.MediaFoundation.DmoMediaType"/></strong> structure allocated by the caller. The method fills the structure with the media type.</p> </dd></param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>DMO_E_INVALIDSTREAMINDEX</strong></dt> </dl> </td><td> <p>Invalid stream index.</p> </td></tr> <tr><td> <dl> <dt><strong>DMO_E_TYPE_NOT_SET</strong></dt> </dl> </td><td> <p>Media type was not set.</p> </td></tr> <tr><td> <dl> <dt><strong>E_OUTOFMEMORY</strong></dt> </dl> </td><td> <p>Insufficient memory.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The caller must set the media type for the stream before calling this method. To set the media type, call the <strong>IMediaObject::SetInputType</strong> method.</p><p>If the method succeeds, call <strong>MoFreeMediaType</strong> to free the format block.</p>
            </remarks>
            <doc-id>dd406947</doc-id>
            <unmanaged>HRESULT IMediaObject::GetInputCurrentType([In] DWORD dwInputStreamIndex,[Out] DMO_MEDIA_TYPE* pmt)</unmanaged>
            <unmanaged-short>IMediaObject::GetInputCurrentType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.GetOutputCurrentType(System.Int32,SharpDX.MediaFoundation.DmoMediaType@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwOutputStreamIndex">No documentation.</param>
            <param name = "mtRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMediaObject::GetOutputCurrentType([In] DWORD dwOutputStreamIndex,[Out] DMO_MEDIA_TYPE* pmt)</unmanaged>
            <unmanaged-short>IMediaObject::GetOutputCurrentType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.GetInputSizeInfo(System.Int32,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            <p> </p><p>The <code>GetInputSizeInfo</code> method retrieves the buffer requirements for a specified input stream.</p>
            </summary>
            <param name = "dwInputStreamIndex"><dd> <p>Zero-based index of an input stream on the DMO.</p> </dd></param>
            <param name = "cbSizeRef"><dd> <p>Pointer to a variable that receives the minimum size of an input buffer for this stream, in bytes.</p> </dd></param>
            <param name = "cbMaxLookaheadRef"><dd> <p>Pointer to a variable that receives the maximum amount of data that the DMO will hold for lookahead, in bytes. If the DMO does not perform lookahead on the stream, the value is zero.</p> </dd></param>
            <param name = "cbAlignmentRef"><dd> <p>Pointer to a variable that receives the required buffer alignment, in bytes. If the input stream has no alignment requirement, the value is 1.</p> </dd></param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>DMO_E_INVALIDSTREAMINDEX</strong></dt> </dl> </td><td> <p>Invalid stream index.</p> </td></tr> <tr><td> <dl> <dt><strong>DMO_E_TYPE_NOT_SET</strong></dt> </dl> </td><td> <p>Media type was not set.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The buffer requirements may depend on the media types of the various streams. Before calling this method, set the media type of each stream by calling the <strong>IMediaObject::SetInputType</strong> and <strong>IMediaObject::SetOutputType</strong> methods. If the media types have not been set, this method might return an error.</p><p>If the DMO performs lookahead on the input stream, it returns the DMO_INPUT_STREAMF_HOLDS_BUFFERS flag in the <strong>IMediaObject::GetInputStreamInfo</strong> method. During processing, the DMO holds up to the number of bytes indicated by the <em>pcbMaxLookahead</em> parameter. The application must allocate enough buffers for the DMO to hold this much data.</p><p>A buffer is <em>aligned</em> if the buffer's start address is a multiple of <em>*pcbAlignment</em>. The alignment must be a power of two. Depending on the microprocessor, reads and writes to an aligned buffer might be faster than to an unaligned buffer. Also, some microprocessors do not support unaligned reads and writes.</p>
            </remarks>
            <doc-id>dd406949</doc-id>
            <unmanaged>HRESULT IMediaObject::GetInputSizeInfo([In] DWORD dwInputStreamIndex,[Out] DWORD* pcbSize,[Out] DWORD* pcbMaxLookahead,[Out] DWORD* pcbAlignment)</unmanaged>
            <unmanaged-short>IMediaObject::GetInputSizeInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.GetOutputSizeInfo(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwOutputStreamIndex">No documentation.</param>
            <param name = "cbSizeRef">No documentation.</param>
            <param name = "cbAlignmentRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMediaObject::GetOutputSizeInfo([In] DWORD dwOutputStreamIndex,[Out] DWORD* pcbSize,[Out] DWORD* pcbAlignment)</unmanaged>
            <unmanaged-short>IMediaObject::GetOutputSizeInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.GetInputMaxLatency(System.Int32,System.Int64@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwInputStreamIndex">No documentation.</param>
            <param name = "rtMaxLatencyRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMediaObject::GetInputMaxLatency([In] DWORD dwInputStreamIndex,[Out] longlong* prtMaxLatency)</unmanaged>
            <unmanaged-short>IMediaObject::GetInputMaxLatency</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.SetInputMaxLatency(System.Int32,System.Int64)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwInputStreamIndex">No documentation.</param>
            <param name = "rtMaxLatency">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMediaObject::SetInputMaxLatency([In] DWORD dwInputStreamIndex,[In] longlong rtMaxLatency)</unmanaged>
            <unmanaged-short>IMediaObject::SetInputMaxLatency</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.Flush">
            <summary>
            <p> </p><p>The <code>Flush</code> method flushes all internally buffered data.</p>
            </summary>
            <returns><p>Returns <see cref = "F:SharpDX.Result.Ok"/> if successful. Otherwise, returns an <strong><see cref = "T:SharpDX.Result"/></strong> value indicating the cause of the error.</p></returns>
            <remarks>
            <p>The DMO performs the following actions when this method is called:</p><ul> <li>Releases any <strong><see cref = "T:SharpDX.MediaFoundation.IMediaBuffer"/></strong> references it holds.</li> <li>Discards any values that specify the time stamp or sample length for a media buffer.</li> <li>Reinitializes any internal states that depend on the contents of a media sample.</li> </ul><p>Media types, maximum latency, and locked state do not change.</p><p>When the method returns, every input stream accepts data. Output streams cannot produce any data until the application calls the <strong>IMediaObject::ProcessInput</strong> method on at least one input stream.</p>
            </remarks>
            <doc-id>dd406945</doc-id>
            <unmanaged>HRESULT IMediaObject::Flush()</unmanaged>
            <unmanaged-short>IMediaObject::Flush</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.Discontinuity(System.Int32)">
            <summary>
            <p> </p><p>The <code>Discontinuity</code> method signals a discontinuity on the specified input stream.</p>
            </summary>
            <param name = "dwInputStreamIndex"><dd> <p>Zero-based index of an input stream on the DMO.</p> </dd></param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>DMO_E_INVALIDSTREAMINDEX</strong></dt> </dl> </td><td> <p>Invalid stream index</p> </td></tr> <tr><td> <dl> <dt><strong>DMO_E_NOTACCEPTING</strong></dt> </dl> </td><td> <p>The DMO is not accepting input.</p> </td></tr> <tr><td> <dl> <dt><strong>DMO_E_TYPE_NOT_SET</strong></dt> </dl> </td><td> <p>The input and output types have not been set.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>A discontinuity represents a break in the input. A discontinuity might occur because no more data is expected, the format is changing, or there is a gap in the data. After a discontinuity, the DMO does not accept further input on that stream until all pending data has been processed. The application should call the <strong>IMediaObject::ProcessOutput</strong> method until none of the streams returns the DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE flag.</p><p>This method might fail if it is called before the client sets the input and output types on the DMO.</p>
            </remarks>
            <doc-id>dd406944</doc-id>
            <unmanaged>HRESULT IMediaObject::Discontinuity([In] DWORD dwInputStreamIndex)</unmanaged>
            <unmanaged-short>IMediaObject::Discontinuity</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.AllocateStreamingResources">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMediaObject::AllocateStreamingResources()</unmanaged>
            <unmanaged-short>IMediaObject::AllocateStreamingResources</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.FreeStreamingResources">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMediaObject::FreeStreamingResources()</unmanaged>
            <unmanaged-short>IMediaObject::FreeStreamingResources</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.GetInputStatus(System.Int32,System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwInputStreamIndex">No documentation.</param>
            <param name = "dwFlags">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMediaObject::GetInputStatus([In] DWORD dwInputStreamIndex,[Out] DWORD* dwFlags)</unmanaged>
            <unmanaged-short>IMediaObject::GetInputStatus</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.ProcessInput(System.Int32,SharpDX.MediaFoundation.IMediaBuffer,System.Int32,System.Int64,System.Int64)">
            <summary>
            <p> </p><p>The <code>ProcessInput</code> method delivers a buffer to the specified input stream.</p>
            </summary>
            <param name = "dwInputStreamIndex"><dd> <p>Zero-based index of an input stream on the DMO.</p> </dd></param>
            <param name = "bufferRef"><dd> <p>Pointer to the buffer's <strong><see cref = "T:SharpDX.MediaFoundation.IMediaBuffer"/></strong> interface.</p> </dd></param>
            <param name = "dwFlags"><dd> <p>Bitwise combination of zero or more flags from the <strong>DMO_INPUT_DATA_BUFFER_FLAGS</strong> enumeration.</p> </dd></param>
            <param name = "rtTimestamp"><dd> <p>Time stamp that specifies the start time of the data in the buffer. If the buffer has a valid time stamp, set the DMO_INPUT_DATA_BUFFERF_TIME flag in the <em>dwFlags</em> parameter. Otherwise, the DMO ignores this value.</p> </dd></param>
            <param name = "rtTimelength"><dd> <p>Reference time specifying the duration of the data in the buffer. If this value is valid, set the DMO_INPUT_DATA_BUFFERF_TIMELENGTH flag in the <em>dwFlags</em> parameter. Otherwise, the DMO ignores this value.</p> </dd></param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>DMO_E_INVALIDSTREAMINDEX</strong></dt> </dl> </td><td> <p>Invalid stream index.</p> </td></tr> <tr><td> <dl> <dt><strong>DMO_E_NOTACCEPTING</strong></dt> </dl> </td><td> <p>Data cannot be accepted.</p> </td></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p>No output to process.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The input buffer specified in the <em>pBuffer</em> parameter is read-only. The DMO will not modify the data in this buffer. All write operations occur on the output buffers, which are given in a separate call to the <strong>IMediaObject::ProcessOutput</strong> method.</p><p>If the DMO does not process all the data in the buffer, it keeps a reference count on the buffer. It releases the buffer once it has generated all the output, unless it needs to perform lookahead on the data. (To determine whether a DMO performs lookahead, call the <strong>IMediaObject::GetInputStreamInfo</strong> method.)</p><p>If this method returns DMO_E_NOTACCEPTING, call <strong>ProcessOutput</strong> until the input stream can accept more data. To determine whether the stream can accept more data, call the <strong>IMediaObject::GetInputStatus</strong> method.</p><p>If the method returns S_FALSE, no output was generated from this input and the application does not need to call <strong>ProcessOutput</strong>. However, a DMO is not required to return S_FALSE in this situation; it might return <see cref = "F:SharpDX.Result.Ok"/>.</p>
            </remarks>
            <doc-id>dd406959</doc-id>
            <unmanaged>HRESULT IMediaObject::ProcessInput([In] DWORD dwInputStreamIndex,[In] IMediaBuffer* pBuffer,[In] DWORD dwFlags,[In] longlong rtTimestamp,[In] longlong rtTimelength)</unmanaged>
            <unmanaged-short>IMediaObject::ProcessInput</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.ProcessOutput(System.Int32,System.Int32,SharpDX.MediaFoundation.DmoOutputDataBuffer[],System.Int32@)">
            <summary>
            <p> </p><p>The <code>ProcessOutput</code> method generates output from the current input data.</p>
            </summary>
            <param name = "dwFlags"><dd> <p>Bitwise combination of zero or more flags from the <strong>DMO_PROCESS_OUTPUT_FLAGS</strong> enumeration.</p> </dd></param>
            <param name = "cOutputBufferCount"><dd> <p>Number of output buffers.</p> </dd></param>
            <param name = "outputBuffersRef"><dd> <p>Pointer to an array of <strong><see cref = "T:SharpDX.MediaFoundation.DmoOutputDataBuffer"/></strong> structures containing the output buffers. Specify the size of the array in the <em>cOutputBufferCount</em> parameter.</p> </dd></param>
            <param name = "dwStatusRef"><dd> <p>Pointer to a variable that receives a reserved value (zero). The application should ignore this value.</p> </dd></param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p>Failure</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p><strong><c>null</c></strong> reference argument</p> </td></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p>No output was generated</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The <em>pOutputBuffers</em> parameter points to an array of <strong><see cref = "T:SharpDX.MediaFoundation.DmoOutputDataBuffer"/></strong> structures. The application must allocate one structure for each output stream. To determine the number of output streams, call the <strong>IMediaObject::GetStreamCount</strong> method. Set the <em>cOutputBufferCount</em> parameter to this number.</p><p>Each <strong><see cref = "T:SharpDX.MediaFoundation.DmoOutputDataBuffer"/></strong> structure contains a reference to a buffer's <strong><see cref = "T:SharpDX.MediaFoundation.IMediaBuffer"/></strong> interface. The application allocates these buffers. The other members of the structure are status fields. The DMO sets these fields if the method succeeds. If the method fails, their values are undefined.</p><p>When the application calls <code>ProcessOutput</code>, the DMO processes as much input data as possible. It writes the output data to the output buffers, starting from the end of the data in each buffer. (To find the end of the data, call the <strong>IMediaBuffer::GetBufferAndLength</strong> method.) The DMO never holds a reference count on an output buffer.</p><p>If the DMO fills an entire output buffer and still has input data to process, the DMO returns the DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE flag in the <strong><see cref = "T:SharpDX.MediaFoundation.DmoOutputDataBuffer"/></strong> structure. The application should check for this flag by testing the <strong>dwStatus</strong> member of each structure.</p><p>If the method returns S_FALSE, no output was generated. However, a DMO is not required to return S_FALSE in this situation; it might return <see cref = "F:SharpDX.Result.Ok"/>.</p><p><strong>Discarding data:</strong></p><p>You can discard data from a stream by setting the DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER flag in the <em>dwFlags</em> parameter. For each stream that you want to discard, set the <strong>pBuffer</strong> member of the <strong><see cref = "T:SharpDX.MediaFoundation.DmoOutputDataBuffer"/></strong> structure to <strong><c>null</c></strong>.</p><p>For each stream in which <strong>pBuffer</strong> is <strong><c>null</c></strong>:</p><ul> <li>If the DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER flag is set, and the stream is discardable or optional, the DMO discards the data.</li> <li>If the flag is set but the stream is neither discardable nor optional, the DMO discards the data if possible. It is not guaranteed to discard the data.</li> <li>If the flag is not set, the DMO does not produce output data for that stream, but does not discard the data.</li> </ul><p>To check whether a stream is discardable or optional, call the <strong>IMediaObject::GetOutputStreamInfo</strong> method.</p>
            </remarks>
            <doc-id>dd406960</doc-id>
            <unmanaged>HRESULT IMediaObject::ProcessOutput([In] DWORD dwFlags,[In] DWORD cOutputBufferCount,[Out, Buffer] DMO_OUTPUT_DATA_BUFFER* pOutputBuffers,[Out] DWORD* pdwStatus)</unmanaged>
            <unmanaged-short>IMediaObject::ProcessOutput</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObject.Lock(System.Int32)">
            <summary>
            <p> </p><p>The <code>Lock</code> method acquires or releases a lock on the DMO. Call this method to keep the DMO serialized when performing multiple operations.</p>
            </summary>
            <param name = "bLock"><dd> <p>Value that specifies whether to acquire or release the lock. If the value is non-zero, a lock is acquired. If the value is zero, the lock is released.</p> </dd></param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Possible values include those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p>Failure</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method prevents other threads from calling methods on the DMO. If another thread calls a method on the DMO, the thread blocks until the lock is released.</p><p>If you are using the Active Template Library (ATL) to implement a DMO, the name of the Lock method conflicts with the <strong>CComObjectRootEx::Lock</strong> method. To work around this problem, define the preprocessor symbol FIX_LOCK_NAME before including the header file Dmo.h:</p><pre> #define FIX_LOCK_NAME
            #include &lt;dmo.h&gt;
            </pre><p>This directive causes the preprocessor to rename the <strong><see cref = "T:SharpDX.MediaFoundation.IMediaObject"/></strong> method to <em>DMOLock</em>. In your DMO, implement the method as <em>DMOLock</em>. In your implementation, call the ATL <strong>Lock</strong> or <strong>Unlock</strong> method, depending on the value of <em>bLock</em>. Applications can still invoke the method using the name <em>Lock</em> because the vtable order does not change.</p>
            </remarks>
            <doc-id>dd406958</doc-id>
            <unmanaged>HRESULT IMediaObject::Lock([In] LONG bLock)</unmanaged>
            <unmanaged-short>IMediaObject::Lock</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.IMediaObjectInPlace.Latency">
            <summary>
            <p> </p><p>The <code>GetLatency</code> method retrieves the latency introduced by this DMO.</p>
            </summary>
            <remarks>
            <p>This method returns the average time required to process each buffer. This value usually depends on factors in the run-time environment, such as the processor speed and the CPU load. One possible way to implement this method is for the DMO to keep a running average based on historical data.</p>
            </remarks>
            <doc-id>dd406941</doc-id>
            <unmanaged>GetLatency</unmanaged>
            <unmanaged-short>GetLatency</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObjectInPlace.Process(System.Int32,System.Byte[],System.Int64,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "ulSize">No documentation.</param>
            <param name = "dataRef">No documentation.</param>
            <param name = "refTimeStart">No documentation.</param>
            <param name = "dwFlags">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMediaObjectInPlace::Process([In] ULONG ulSize,[Out, Buffer] unsigned char* pData,[In] longlong refTimeStart,[In] DWORD dwFlags)</unmanaged>
            <unmanaged-short>IMediaObjectInPlace::Process</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObjectInPlace.Clone(SharpDX.MediaFoundation.IMediaObjectInPlace@)">
            <summary>
            <p> </p><p>The <code>Clone</code> method creates a copy of the DMO in its current state.</p>
            </summary>
            <param name = "mediaObjectOut"><dd> <p>Address of a reference to receive the new DMO's <strong><see cref = "T:SharpDX.MediaFoundation.IMediaObjectInPlace"/></strong> interface.</p> </dd></param>
            <returns><p>Returns <see cref = "F:SharpDX.Result.Ok"/> if successful. Otherwise, returns an <strong><see cref = "T:SharpDX.Result"/></strong> value indicating the cause of the error.</p></returns>
            <remarks>
            <p>If the method succeeds, the <strong><see cref = "T:SharpDX.MediaFoundation.IMediaObjectInPlace"/></strong> interface that it returns has an outstanding reference count. Be sure to release the interface when you are finished using it.</p>
            </remarks>
            <doc-id>dd406940</doc-id>
            <unmanaged>HRESULT IMediaObjectInPlace::Clone([Out] IMediaObjectInPlace** ppMediaObject)</unmanaged>
            <unmanaged-short>IMediaObjectInPlace::Clone</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.IMediaObjectInPlace.GetLatency(System.Int64@)">
            <summary>
            <p> </p><p>The <code>GetLatency</code> method retrieves the latency introduced by this DMO.</p>
            </summary>
            <param name = "latencyTimeRef"><dd> <p>Pointer to a variable that receives the latency, in 100-nanosecond units.</p> </dd></param>
            <returns><p>Returns <see cref = "F:SharpDX.Result.Ok"/> if successful. Otherwise, returns an <strong><see cref = "T:SharpDX.Result"/></strong> value indicating the cause of the error.</p></returns>
            <remarks>
            <p>This method returns the average time required to process each buffer. This value usually depends on factors in the run-time environment, such as the processor speed and the CPU load. One possible way to implement this method is for the DMO to keep a running average based on historical data.</p>
            </remarks>
            <doc-id>dd406941</doc-id>
            <unmanaged>HRESULT IMediaObjectInPlace::GetLatency([Out] longlong* pLatencyTime)</unmanaged>
            <unmanaged-short>IMediaObjectInPlace::GetLatency</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.InputTrustAuthority.GetDecrypter(System.Guid,System.IntPtr@)">
            <summary>
            <p> </p><p>Retrieves a decrypter transform.</p>
            </summary>
            <param name = "riid"><dd> <p>Interface identifier (IID) of the interface being requested. Currently this value must be IID_IMFTransform, which requests the <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> interface.</p> </dd></param>
            <param name = "vOut"><dd> <p>Receives a reference to the interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOINTERFACE</strong></dt> </dl> </td><td> <p>The decrypter does not support the requested interface.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotProtected"/></strong></dt> </dl> </td><td> <p>This input trust authority (ITA) does not provide a decrypter.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The decrypter should be created in a disabled state, where any calls to <strong>IMFTransform::ProcessOutput</strong> automatically fail. After the input trust authority (ITA) has verified that it is running inside the protected media path (PMP), the ITA should enable the decrypter.</p><p>An ITA is not required to provide a decrypter. If the source content is not encrypted, the method should return <see cref = "!:NotProtected"/>. The PMP will then proceed without using a decrypter for that stream.</p><p>The ITA must create a new instance of its decrypter for each call to <strong>GetDecrypter</strong>. Do not return multiple references to the same decrypter. They must be separate instances because the Media Session might place them in two different branches of the topology.</p>
            </remarks>
            <doc-id>bb970385</doc-id>
            <unmanaged>HRESULT IMFInputTrustAuthority::GetDecrypter([In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>
            <unmanaged-short>IMFInputTrustAuthority::GetDecrypter</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.InputTrustAuthority.RequestAccess(SharpDX.MediaFoundation.PolicymanagerAction,SharpDX.MediaFoundation.Activate@)">
            <summary>
            <p> </p><p>Requests permission to perform a specified action on the stream.</p>
            </summary>
            <param name = "action"><dd> <p>The requested action, specified as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.PolicymanagerAction"/></strong> enumeration.</p> </dd></param>
            <param name = "contentEnablerActivateOut"><dd> <p>Receives the value <strong><c>null</c></strong> or a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface. The <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface is used to create a content enabler object. The caller must release the interface. For more information, see Remarks.</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The user has permission to perform this action.</p> </td></tr> <tr><td> <dl> <dt><strong>NS_E_DRM_NEEDS_INDIVIDUALIZATION</strong></dt> </dl> </td><td> <p>The user must individualize the application.</p> </td></tr> <tr><td> <dl> <dt><strong>NS_E_LICENSE_REQUIRED</strong></dt> </dl> </td><td> <p>The user must obtain a license.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method verifies whether the user has permission to perform a specified action on the stream. The ITA does any work needed to verify the user's right to perform the action, such as checking licenses.</p><p>To verify the user's rights, the ITA might need to perform additional steps that require interaction with the user or consent from the user. For example, it might need to acquire a new license or individualize a DRM component. In that case, the ITA creates an activation object for a content enabler and returns the activation object's <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface in the <em>ppContentEnablerActivate</em> parameter. The activation object is responsible for creating a content enabler that exposes the <strong><see cref = "T:SharpDX.MediaFoundation.ContentEnabler"/></strong> interface. The content enabler is used as follows:</p><ol> <li> <p>The Media Session returns the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> reference to the application.</p> </li> <li> <p>The application calls <strong>IMFActivate::ActivateObject</strong> to activate the content enabler.</p> </li> <li> <p>The application calls <strong><see cref = "T:SharpDX.MediaFoundation.ContentEnabler"/></strong> methods to perform whatever actions are needed, such as individualization or obtaining a license. The content enabler object must encapsulate this functionality through the <strong><see cref = "T:SharpDX.MediaFoundation.ContentEnabler"/></strong> interface.</p> </li> <li> <p>The Media Session calls <strong>RequestAccess</strong> again.</p> </li> </ol><p>The return value signals whether the user has permission to perform the action:</p><ul> <li> <p>If the user already has permission to perform the action, the method returns <see cref = "F:SharpDX.Result.Ok"/> and sets *<em>ppContentEnablerActivate</em> to <strong><c>null</c></strong>.</p> </li> <li> <p>If the user does not have permission, the method returns a failure code and sets *<em>ppContentEnablerActivate</em> to <strong><c>null</c></strong>.</p> </li> <li> <p>If the ITA must perform additional steps that require interaction with the user, the method returns a failure code and returns the content enabler's <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> reference in <em>ppContentEnablerActivate</em>.</p> </li> </ul><p>The Media Session will not allow the action unless this method returns <see cref = "F:SharpDX.Result.Ok"/>. However, a return value of <see cref = "F:SharpDX.Result.Ok"/> does not guarantee that the action will be performed, because some other failure might occur after this method is called. When the action is definitely about to happen, the Media Session calls <strong>IMFInputTrustAuthority::BindAccess</strong>.</p><p>A stream can go to multiple outputs, so this method might be called multiple times with different actions, once for every output.</p>
            </remarks>
            <doc-id>bb970453</doc-id>
            <unmanaged>HRESULT IMFInputTrustAuthority::RequestAccess([In] MFPOLICYMANAGER_ACTION Action,[Out] IMFActivate** ppContentEnablerActivate)</unmanaged>
            <unmanaged-short>IMFInputTrustAuthority::RequestAccess</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.InputTrustAuthority.GetPolicy(SharpDX.MediaFoundation.PolicymanagerAction,SharpDX.MediaFoundation.OutputPolicy@)">
            <summary>
            <p> </p><p>Retrieves the policy that defines which output protection systems are allowed for this stream, and the configuration data for each protection system.</p>
            </summary>
            <param name = "action"><dd> <p>The action that will be performed on this stream, specified as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.PolicymanagerAction"/></strong> enumeration.</p> </dd></param>
            <param name = "policyOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.OutputPolicy"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970400</doc-id>
            <unmanaged>HRESULT IMFInputTrustAuthority::GetPolicy([In] MFPOLICYMANAGER_ACTION Action,[Out] IMFOutputPolicy** ppPolicy)</unmanaged>
            <unmanaged-short>IMFInputTrustAuthority::GetPolicy</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.InputTrustAuthority.BindAccess(SharpDX.MediaFoundation.InputTrustauthorityAccessParameters@)">
            <summary>
            <p> </p><p>Notifies the input trust authority (ITA) that a requested action is about to be performed.</p>
            </summary>
            <param name = "paramRef"><dd> <p>Pointer to an <strong><see cref = "T:SharpDX.MediaFoundation.InputTrustauthorityAccessParameters"/></strong> structure that contains parameters for the <strong>BindAccess</strong> action.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Before calling this method, the Media Session calls <strong>IMFInputTrustAuthority::RequestAccess</strong> to request an action. The <strong>BindAccess</strong> method notifies the ITA that the action is definitely about to occur, so that the ITA can update its internal state as needed. If the method returns a failure code, the Media Session cancels the action.</p>
            </remarks>
            <doc-id>ms701551</doc-id>
            <unmanaged>HRESULT IMFInputTrustAuthority::BindAccess([In] MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS* pParam)</unmanaged>
            <unmanaged-short>IMFInputTrustAuthority::BindAccess</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.InputTrustAuthority.UpdateAccess(SharpDX.MediaFoundation.InputTrustauthorityAccessParameters@)">
            <summary>
            <p> </p><p>Notifies the input trust authority (ITA) when the number of output trust authorities (OTAs) that will perform a specified action has changed.</p>
            </summary>
            <param name = "paramRef"><dd> <p>Pointer to an <strong><see cref = "T:SharpDX.MediaFoundation.InputTrustauthorityAccessParameters"/></strong> structure that contains parameters for the <strong>UpdateAccess</strong> action.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The ITA can update its internal state if needed. If the method returns a failure code, the Media Session cancels the action.</p>
            </remarks>
            <doc-id>ms697037</doc-id>
            <unmanaged>HRESULT IMFInputTrustAuthority::UpdateAccess([In] MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS* pParam)</unmanaged>
            <unmanaged-short>IMFInputTrustAuthority::UpdateAccess</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.InputTrustAuthority.Reset">
            <summary>
            <p> </p><p>Resets the input trust authority (ITA) to its initial state.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>When this method is called, the ITA should disable any decrypter that was returned in the <strong>IMFInputTrustAuthority::GetDecrypter</strong> method.</p>
            </remarks>
            <doc-id>ms703015</doc-id>
            <unmanaged>HRESULT IMFInputTrustAuthority::Reset()</unmanaged>
            <unmanaged-short>IMFInputTrustAuthority::Reset</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.LocalMFTRegistration.RegisterMFTs(SharpDX.MediaFoundation.TRegistrationInformation[],System.Int32)">
            <summary>
            <p>Registers one or more Media Foundation transforms (MFTs) in the caller's process.</p>
            </summary>
            <param name = "mFTsRef"><dd> <p>A reference to an array of <strong><see cref = "T:SharpDX.MediaFoundation.TRegistrationInformation"/></strong> structures.</p> </dd></param>
            <param name = "cMFTs"><dd> <p>The number of elements in the <em>pMFTs</em> array.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method is similar to the <strong>MFTRegisterLocalByCLSID</strong> function. It registers one or more MFTs in the caller's process. These MFTs can be enumerated by calling the <strong>MFTEnumEx</strong> function with the <strong>MFT_ENUM_FLAG_LOCALMFT</strong> flag.</p><p>Unlike <strong>MFTRegisterLocalByCLSID</strong>, however, this method also makes the MFT available in the Protected Media Path (PMP) process, and is therefore useful if you are using the Media Session inside the PMP. For more information, see the following topics:</p><ul> <li> <strong>MFCreatePMPMediaSession</strong> </li> <li> Protected Media Path </li> </ul>
            </remarks>
            <doc-id>dd374223</doc-id>
            <unmanaged>HRESULT IMFLocalMFTRegistration::RegisterMFTs([In, Buffer] MFT_REGISTRATION_INFO* pMFTs,[In] DWORD cMFTs)</unmanaged>
            <unmanaged-short>IMFLocalMFTRegistration::RegisterMFTs</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaBuffer.CurrentLength">
            <summary>
            <p> </p><p>Retrieves the length of the valid data in the buffer.</p>
            </summary>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms698987</doc-id>
            <unmanaged>GetCurrentLength / SetCurrentLength</unmanaged>
            <unmanaged-short>GetCurrentLength</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaBuffer.MaxLength">
            <summary>
            <p> </p><p>Retrieves the allocated size of the buffer.</p>
            </summary>
            <remarks>
            <p>The buffer might or might not contain any valid data, and if there is valid data in the buffer, it might be smaller than the buffer's allocated size. To get the length of the valid data, call <strong>IMFMediaBuffer::GetCurrentLength</strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms704840</doc-id>
            <unmanaged>GetMaxLength</unmanaged>
            <unmanaged-short>GetMaxLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaBuffer.Lock(System.Int32@,System.Int32@)">
            <summary>
            <p> </p><p>Gives the caller access to the memory in the buffer, for reading or writing</p>
            </summary>
            <param name = "cbMaxLengthRef"><dd> <p>Receives the maximum amount of data that can be written to the buffer. This parameter can be <strong><c>null</c></strong>. The same value is returned by the <strong>IMFMediaBuffer::GetMaxLength</strong> method.</p> </dd></param>
            <param name = "cbCurrentLengthRef"><dd> <p>Receives the length of the valid data in the buffer, in bytes. This parameter can be <strong><c>null</c></strong>. The same value is returned by the <strong>IMFMediaBuffer::GetCurrentLength</strong> method.</p> </dd></param>
            <returns><dd> <p>Receives a reference to the start of the buffer.</p> </dd></returns>
            <remarks>
            <p>This method gives the caller access to the entire buffer, up to the maximum size returned in the <em>pcbMaxLength</em> parameter. The value returned in <em>pcbCurrentLength</em> is the size of any valid data already in the buffer, which might be less than the total buffer size.</p><p>The reference returned in <em>ppbBuffer</em> is guaranteed to be valid, and can safely be accessed across the entire buffer for as long as the lock is held. When you are done accessing the buffer, call <strong>IMFMediaBuffer::Unlock</strong> to unlock the buffer. You must call <strong>Unlock</strong> once for each call to <strong>Lock</strong>. After you unlock the buffer, the reference returned in <em>ppbBuffer</em> is no longer valid, and should not be used. Generally, it is best to call <strong>Lock</strong> only when you need to access the buffer memory, and not earlier.</p><p>Locking the buffer does not prevent other threads from calling <strong>Lock</strong>, so you should not rely on this method to synchronize threads.</p><p>This method does not allocate any memory, or transfer ownership of the memory to the caller. Do not release or free the memory; the media buffer will free the memory when the media buffer is destroyed.</p><p>If you modify the contents of the buffer, update the current length by calling <strong>IMFMediaBuffer::SetCurrentLength</strong>.</p><p>If the buffer supports the <strong><see cref = "T:SharpDX.MediaFoundation.Buffer2D"/></strong> interface, you should use the <strong>IMF2DBuffer::Lock2D</strong> method to lock the buffer. For 2-D buffers, the <strong>Lock2D</strong> method is more efficient than the <strong>Lock</strong> method. If the buffer is locked using <strong>Lock2D</strong>, the Lock method might return <strong><see cref = "!:InvalidRequest"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>bb970366</doc-id>
            <unmanaged>HRESULT IMFMediaBuffer::Lock([Out] unsigned char** ppbBuffer,[Out, Optional] DWORD* pcbMaxLength,[Out, Optional] DWORD* pcbCurrentLength)</unmanaged>
            <unmanaged-short>IMFMediaBuffer::Lock</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaBuffer.Unlock">
            <summary>
            <p> </p><p>Unlocks a buffer that was previously locked. Call this method once for every call to <strong>IMFMediaBuffer::Lock</strong>.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>D3DERR_INVALIDCALL</strong></dt> </dl> </td><td> <p>For Direct3D surface buffers, an error occurred when unlocking the surface.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>It is an error to call <strong>Unlock</strong> if you did not call <strong>Lock</strong> previously.</p><p>After calling this method, do not use the reference returned by the <strong>Lock</strong> method. It is no longer guaranteed to be valid.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms696259</doc-id>
            <unmanaged>HRESULT IMFMediaBuffer::Unlock()</unmanaged>
            <unmanaged-short>IMFMediaBuffer::Unlock</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaBuffer.GetCurrentLength(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the length of the valid data in the buffer.</p>
            </summary>
            <param name = "cbCurrentLengthRef"><dd> <p>Receives the length of the valid data, in bytes. If the buffer does not contain any valid data, the value is zero.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms698987</doc-id>
            <unmanaged>HRESULT IMFMediaBuffer::GetCurrentLength([Out] DWORD* pcbCurrentLength)</unmanaged>
            <unmanaged-short>IMFMediaBuffer::GetCurrentLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaBuffer.SetCurrentLength(System.Int32)">
            <summary>
            <p> </p><p>Sets the length of the valid data in the buffer.</p>
            </summary>
            <param name = "cbCurrentLength"><dd> <p>Length of the valid data, in bytes. This value cannot be greater than the allocated size of the buffer, which is returned by the <strong>IMFMediaBuffer::GetMaxLength</strong> method.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The specified length is greater than the maximum size of the buffer.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this method if you write data into the buffer.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms703202</doc-id>
            <unmanaged>HRESULT IMFMediaBuffer::SetCurrentLength([In] DWORD cbCurrentLength)</unmanaged>
            <unmanaged-short>IMFMediaBuffer::SetCurrentLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaBuffer.GetMaxLength(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the allocated size of the buffer.</p>
            </summary>
            <param name = "cbMaxLengthRef"><dd> <p>Receives the allocated size of the buffer, in bytes.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The buffer might or might not contain any valid data, and if there is valid data in the buffer, it might be smaller than the buffer's allocated size. To get the length of the valid data, call <strong>IMFMediaBuffer::GetCurrentLength</strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms704840</doc-id>
            <unmanaged>HRESULT IMFMediaBuffer::GetMaxLength([Out] DWORD* pcbMaxLength)</unmanaged>
            <unmanaged-short>IMFMediaBuffer::GetMaxLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineClassFactory2.CreateMediaKeys2(System.String,System.String,System.String,SharpDX.MediaFoundation.MediaKeys@)">
            <summary>
            <p>Creates a media keys object based on the specified key system.</p>
            </summary>
            <param name = "keySystem"><dd> <p>The media key system.</p> </dd></param>
            <param name = "defaultCdmStorePath"><dd> <p>Points to the default file location for the  store Content Decryption Module (CDM) data.</p> </dd></param>
            <param name = "inprivateCdmStorePath"><dd> <p>Points to a the inprivate location for the  store Content Decryption Module (CDM) data. Specifying this path allows the CDM to comply with the application?s privacy policy by putting personal information in the file location indicated by this path.</p> </dd></param>
            <param name = "keysOut"><dd> <p>Receives the media keys.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn449732</doc-id>
            <unmanaged>HRESULT IMFMediaEngineClassFactory2::CreateMediaKeys2([In] wchar_t* keySystem,[In] wchar_t* defaultCdmStorePath,[In, Optional] wchar_t* inprivateCdmStorePath,[Out] IMFMediaKeys** ppKeys)</unmanaged>
            <unmanaged-short>IMFMediaEngineClassFactory2::CreateMediaKeys2</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineClassFactory3.CreateMediaKeySystemAccess(System.String,SharpDX.ComObject[],System.Int32,SharpDX.MediaFoundation.MediaKeySystemAccess@)">
            <summary>
            No documentation.
            </summary>
            <param name = "keySystem">No documentation.</param>
            <param name = "supportedConfigurationsArrayOut">No documentation.</param>
            <param name = "uSize">No documentation.</param>
            <param name = "keyAccessOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaEngineClassFactory3::CreateMediaKeySystemAccess([In] wchar_t* keySystem,[In, Buffer] IPropertyStore** ppSupportedConfigurationsArray,[In] unsigned int uSize,[Out] IMFMediaKeySystemAccess** ppKeyAccess)</unmanaged>
            <unmanaged-short>IMFMediaEngineClassFactory3::CreateMediaKeySystemAccess</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineClassFactory3.CreateMediaKeySystemAccess(System.String,SharpDX.ComArray{SharpDX.ComObject},System.Int32,SharpDX.MediaFoundation.MediaKeySystemAccess@)">
            <summary>
            No documentation.
            </summary>
            <param name = "keySystem">No documentation.</param>
            <param name = "supportedConfigurationsArrayOut">No documentation.</param>
            <param name = "uSize">No documentation.</param>
            <param name = "keyAccessOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaEngineClassFactory3::CreateMediaKeySystemAccess([In] wchar_t* keySystem,[In, Buffer] IPropertyStore** ppSupportedConfigurationsArray,[In] unsigned int uSize,[Out] IMFMediaKeySystemAccess** ppKeyAccess)</unmanaged>
            <unmanaged-short>IMFMediaEngineClassFactory3::CreateMediaKeySystemAccess</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineClassFactory3.CreateMediaKeySystemAccess(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            No documentation.
            </summary>
            <param name = "keySystem">No documentation.</param>
            <param name = "supportedConfigurationsArrayOut">No documentation.</param>
            <param name = "uSize">No documentation.</param>
            <param name = "keyAccessOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaEngineClassFactory3::CreateMediaKeySystemAccess([In] wchar_t* keySystem,[In, Buffer] IPropertyStore** ppSupportedConfigurationsArray,[In] unsigned int uSize,[Out] IMFMediaKeySystemAccess** ppKeyAccess)</unmanaged>
            <unmanaged-short>IMFMediaEngineClassFactory3::CreateMediaKeySystemAccess</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineClassFactoryEx.CreateMediaSourceExtension(System.Int32,SharpDX.MediaFoundation.MediaAttributes,SharpDX.MediaFoundation.MediaSourceExtension@)">
            <summary>
            <p>Creates an instance of <strong><see cref = "T:SharpDX.MediaFoundation.MediaSourceExtension"/></strong>.</p>
            </summary>
            <param name = "dwFlags">No documentation.</param>
            <param name = "attrRef">No documentation.</param>
            <param name = "mSEOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280691</doc-id>
            <unmanaged>HRESULT IMFMediaEngineClassFactoryEx::CreateMediaSourceExtension([In] DWORD dwFlags,[In] IMFAttributes* pAttr,[Out] IMFMediaSourceExtension** ppMSE)</unmanaged>
            <unmanaged-short>IMFMediaEngineClassFactoryEx::CreateMediaSourceExtension</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineClassFactoryEx.CreateMediaKeys(System.String,System.String,SharpDX.MediaFoundation.MediaKeys@)">
            <summary>
            <p>Creates a media keys object based on the specified key system.</p>
            </summary>
            <param name = "keySystem"><dd> <p>The media keys system.</p> </dd></param>
            <param name = "cdmStorePath"><dd> <p>Points to a location to store Content Decryption Module (CDM) data which might be locked by multiple process and so might be incompatible with store app suspension.</p> </dd></param>
            <param name = "keysOut"><dd> <p>The media keys.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> Checks if <em>keySystem</em> is a supported key system and creates the related Content Decryption Module (CDM).
            </p>
            </remarks>
            <doc-id>dn280690</doc-id>
            <unmanaged>HRESULT IMFMediaEngineClassFactoryEx::CreateMediaKeys([In] wchar_t* keySystem,[In, Optional] wchar_t* cdmStorePath,[Out] IMFMediaKeys** ppKeys)</unmanaged>
            <unmanaged-short>IMFMediaEngineClassFactoryEx::CreateMediaKeys</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineClassFactoryEx.IsTypeSupported(System.String,System.String,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Gets a value that indicates if the specified key system supports the specified media type.</p>
            </summary>
            <param name = "type"><dd> <p>The MIME type to check support for.</p> </dd></param>
            <param name = "keySystem"><dd> <p>The key system to check support for.</p> </dd></param>
            <param name = "isSupported"><dd> <p><strong>true</strong> if type is supported by <em>keySystem</em>; otherwise, <strong>false.</strong></p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280692</doc-id>
            <unmanaged>HRESULT IMFMediaEngineClassFactoryEx::IsTypeSupported([In, Optional] wchar_t* type,[In] wchar_t* keySystem,[Out] BOOL* isSupported)</unmanaged>
            <unmanaged-short>IMFMediaEngineClassFactoryEx::IsTypeSupported</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngineEME.Keys">
            <summary>
            <p>Gets the media keys object associated with the media engine or <strong>null</strong> if there is not a media keys object.</p>
            </summary>
            <doc-id>dn280694</doc-id>
            <unmanaged>get_Keys</unmanaged>
            <unmanaged-short>get_Keys</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngineEME.MediaKeys">
            <summary>
            <p>Sets the media keys object to use with the media engine.</p>
            </summary>
            <doc-id>dn280695</doc-id>
            <unmanaged>SetMediaKeys</unmanaged>
            <unmanaged-short>SetMediaKeys</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEME.GetKeys(SharpDX.MediaFoundation.MediaKeys@)">
            <summary>
            <p>Gets the media keys object associated with the media engine or <strong>null</strong> if there is not a media keys object.</p>
            </summary>
            <param name = "keys"><dd> <p>The media keys object associated with the media engine or <strong>null</strong> if there is not a media keys object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280694</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEME::get_Keys([Out, Optional] IMFMediaKeys** keys)</unmanaged>
            <unmanaged-short>IMFMediaEngineEME::get_Keys</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEME.SetMediaKeys(SharpDX.MediaFoundation.MediaKeys)">
            <summary>
            <p>Sets the media keys object to use with the media engine.</p>
            </summary>
            <param name = "keys"><dd> <p>The media keys.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280695</doc-id>
            <unmanaged>HRESULT IMFMediaEngineEME::SetMediaKeys([In, Optional] IMFMediaKeys* keys)</unmanaged>
            <unmanaged-short>IMFMediaEngineEME::SetMediaKeys</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEMENotify.Encrypted(System.Byte[],System.Int32,System.String)">
            <summary>
            No documentation.
            </summary>
            <param name = "bInitDataRef">No documentation.</param>
            <param name = "cb">No documentation.</param>
            <param name = "bstrInitDataType">No documentation.</param>
            <unmanaged>void IMFMediaEngineEMENotify::Encrypted([In, Buffer, Optional] const unsigned char* pbInitData,[In] DWORD cb,[In] wchar_t* bstrInitDataType)</unmanaged>
            <unmanaged-short>IMFMediaEngineEMENotify::Encrypted</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineEMENotify.WaitingForKey">
            <summary>
            No documentation.
            </summary>
            <unmanaged>void IMFMediaEngineEMENotify::WaitingForKey()</unmanaged>
            <unmanaged-short>IMFMediaEngineEMENotify::WaitingForKey</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineExtension.CanPlayType(SharpDX.Mathematics.Interop.RawBool,System.String,SharpDX.MediaFoundation.MediaEngineCanPlay@)">
            <summary>
            <p>Queries whether the object can load a specified type of media resource.</p>
            </summary>
            <param name = "audioOnly"><dd> <p>If <strong>TRUE</strong>, the Media Engine is set to audio-only mode. Otherwise, the Media Engine is set to audio-video mode.</p> </dd></param>
            <param name = "mimeType"><dd> <p>A string that contains a MIME type with an optional codecs parameter, as defined in RFC 4281.</p> </dd></param>
            <param name = "answerRef"><dd> <p>Receives a member of the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineCanPlay"/></strong> enumeration.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Implement this method if your Media Engine extension supports one or more MIME types.</p>
            </remarks>
            <doc-id>hh447927</doc-id>
            <unmanaged>HRESULT IMFMediaEngineExtension::CanPlayType([In] BOOL AudioOnly,[In] wchar_t* MimeType,[Out] MF_MEDIA_ENGINE_CANPLAY* pAnswer)</unmanaged>
            <unmanaged-short>IMFMediaEngineExtension::CanPlayType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineExtension.BeginCreateObject(System.String,SharpDX.MediaFoundation.IByteStream,SharpDX.MediaFoundation.ObjectType,SharpDX.IUnknown@,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p>Begins an asynchronous request to create either a byte stream or a media source.</p>
            </summary>
            <param name = "bstrURL"><dd> <p>The URL of the media resource.</p> </dd></param>
            <param name = "byteStreamRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface.</p> <p>If the <em>type</em> parameter equals  <strong>MF_OBJECT_BYTESTREAM</strong>, this parameter is <strong><c>null</c></strong>. </p> <p>If <em>type</em> equals <strong>MF_OBJECT_MEDIASOURCE</strong>, this parameter either contains a reference to a byte stream or is <strong><c>null</c></strong>. See Remarks for more information.</p> </dd></param>
            <param name = "type"><dd> <p>A member of the <strong><see cref = "T:SharpDX.MediaFoundation.ObjectType"/></strong> enumeration that specifies which type of object to create.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MF_OBJECT_BYTESTREAM</strong></dt> </dl> </td><td> <p>Create a byte stream. The byte stream must support the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface.</p> </td></tr> <tr><td><dl> <dt><strong>MF_OBJECT_MEDIASOURCE</strong></dt> </dl> </td><td> <p>Create a media source. The media source must support the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSource"/></strong> interface.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "iUnknownCancelCookieOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface.  This reference can be used to cancel the asynchronous operation, by passing the reference to the <strong>IMFMediaEngineExtension::CancelObjectCreation</strong> method. </p> <p>The caller must release the interface. This parameter can be <c>null</c>.</p> </dd></param>
            <param name = "callbackRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface. This interface is used to signal the completion of the asynchronous operation.</p> </dd></param>
            <param name = "unkStateRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of an object impemented by the caller. You can use this object to hold state information for the callback. The object is returned to the caller when the callback is invoked. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method requests the object to create either a byte stream or a media source, depending on the value of the <em>type</em> parameter:</p><ul> <li>If <em>type</em> is <strong>MF_OBJECT_BYTESTREAM</strong>, the method creates a byte stream for the URL that is specified in <em>bstrURL</em>. In this case, the <em>pByteStream</em> parameter is <strong><c>null</c></strong>. </li> <li>If <em>type</em> is <strong>MF_OBJECT_MEDIASOURCE</strong>, the method creates a media source, using the byte stream that is specified in the <em>pByteStream</em> parameter. Note that <em>pByteStream</em> can also be <strong><c>null</c></strong> in this case.</li> </ul><p>The method is performed asynchronously. The Media Engine calls the <strong>IMFMediaEngineExtension::EndCreateObject</strong> method to complete the operation.</p>
            </remarks>
            <doc-id>hh447925</doc-id>
            <unmanaged>HRESULT IMFMediaEngineExtension::BeginCreateObject([In] wchar_t* bstrURL,[In, Optional] IMFByteStream* pByteStream,[In] MF_OBJECT_TYPE type,[Out] IUnknown** ppIUnknownCancelCookie,[In] IMFAsyncCallback* pCallback,[In, Optional] IUnknown* punkState)</unmanaged>
            <unmanaged-short>IMFMediaEngineExtension::BeginCreateObject</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineExtension.CancelObjectCreation(SharpDX.IUnknown)">
            <summary>
            <p>Cancels the current request to create an object.</p>
            </summary>
            <param name = "iUnknownCancelCookieRef"><dd> <p>The reference that was returned in the the <em>ppIUnknownCancelCookie</em> parameter of the <strong>IMFMediaEngineExtension::BeginCreateObject</strong> method. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method attempts to cancel a previous call to <strong>BeginCreateObject</strong>. Because that method is asynchronous, however, it might complete before the operation can be canceled.</p>
            </remarks>
            <doc-id>hh447926</doc-id>
            <unmanaged>HRESULT IMFMediaEngineExtension::CancelObjectCreation([In] IUnknown* pIUnknownCancelCookie)</unmanaged>
            <unmanaged-short>IMFMediaEngineExtension::CancelObjectCreation</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineExtension.EndCreateObject(SharpDX.MediaFoundation.AsyncResult,SharpDX.IUnknown@)">
            <summary>
            <p>Completes an asynchronous request to create a byte stream or media source.</p>
            </summary>
            <param name = "resultRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface.</p> </dd></param>
            <param name = "objectOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of the byte stream or media source. The caller must release the interface</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The Media Engine calls this method to complete the <strong>IMFMediaEngineExtension::BeginCreateObject</strong> method.</p>
            </remarks>
            <doc-id>hh447928</doc-id>
            <unmanaged>HRESULT IMFMediaEngineExtension::EndCreateObject([In] IMFAsyncResult* pResult,[Out] IUnknown** ppObject)</unmanaged>
            <unmanaged-short>IMFMediaEngineExtension::EndCreateObject</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineNeedKeyNotify.NeedKey(System.Byte[],System.Int32)">
            <summary>
            <p>Notifies the application that a key or keys are needed along with any initialization data.</p>
            </summary>
            <param name = "initData"><dd> <p>The initialization data.</p> </dd></param>
            <param name = "cb"><dd> <p>The count in bytes of <em>initData</em>.</p> </dd></param>
            <doc-id>dn280697</doc-id>
            <unmanaged>void IMFMediaEngineNeedKeyNotify::NeedKey([In, Buffer, Optional] const unsigned char* initData,[In] DWORD cb)</unmanaged>
            <unmanaged-short>IMFMediaEngineNeedKeyNotify::NeedKey</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineOPMInfo.GetOPMInfo(SharpDX.MediaFoundation.MediaEngineOpmStatus@,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Gets status information about the   Output Protection Manager (OPM).</p>
            </summary>
            <param name = "statusRef">No documentation.</param>
            <param name = "constrictedRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded</p> </td></tr> <tr><td> <dl> <dt><strong>INVALIDARG</strong></dt> </dl> </td><td> <p>If any of the parameters are <strong><c>null</c></strong>.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dn280699</doc-id>
            <unmanaged>HRESULT IMFMediaEngineOPMInfo::GetOPMInfo([Out] MF_MEDIA_ENGINE_OPM_STATUS* pStatus,[Out] BOOL* pConstricted)</unmanaged>
            <unmanaged-short>IMFMediaEngineOPMInfo::GetOPMInfo</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngineProtectedContent.RequiredProtections">
            <summary>
            <p>Gets the content protections that must be applied in frame-server mode.</p>
            </summary>
            <doc-id>hh447965</doc-id>
            <unmanaged>GetRequiredProtections</unmanaged>
            <unmanaged-short>GetRequiredProtections</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngineProtectedContent.OPMWindow">
            <summary>
            <p>Specifies the window that should receive output link protections.</p>
            </summary>
            <remarks>
            <p>In frame-server mode, call this method to specify the destination window for protected video content. The Media Engine uses this window to set link protections, using the Output Protection Manager (OPM).</p>
            </remarks>
            <doc-id>hh447968</doc-id>
            <unmanaged>SetOPMWindow</unmanaged>
            <unmanaged-short>SetOPMWindow</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngineProtectedContent.ContentProtectionManager">
            <summary>
            <p>Sets the content protection manager (CPM).</p>
            </summary>
            <remarks>
            <p>The Media Engine uses the CPM to handle events related to protected content, such as license acquisition.</p>
            </remarks>
            <doc-id>hh447967</doc-id>
            <unmanaged>SetContentProtectionManager</unmanaged>
            <unmanaged-short>SetContentProtectionManager</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineProtectedContent.ShareResources(SharpDX.IUnknown)">
            <summary>
            <p>Enables the Media Engine to access protected content while in frame-server mode.</p>
            </summary>
            <param name = "unkDeviceContextRef"><dd> <p>A reference to the Direct3D?11 device content. The Media Engine queries this reference for the <strong><see cref = "!:SharpDX.Direct3D11.VideoContext"/></strong> interface. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>In frame-server mode, this method enables the Media Engine to share protected content with the Direct3D?11 device.</p>
            </remarks>
            <doc-id>hh447969</doc-id>
            <unmanaged>HRESULT IMFMediaEngineProtectedContent::ShareResources([In] IUnknown* pUnkDeviceContext)</unmanaged>
            <unmanaged-short>IMFMediaEngineProtectedContent::ShareResources</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineProtectedContent.GetRequiredProtections(System.Int32@)">
            <summary>
            <p>Gets the content protections that must be applied in frame-server mode.</p>
            </summary>
            <param name = "frameProtectionFlagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineFrameProtectionFlags"/></strong> enumeration.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447965</doc-id>
            <unmanaged>HRESULT IMFMediaEngineProtectedContent::GetRequiredProtections([Out] DWORD* pFrameProtectionFlags)</unmanaged>
            <unmanaged-short>IMFMediaEngineProtectedContent::GetRequiredProtections</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineProtectedContent.SetOPMWindow(System.IntPtr)">
            <summary>
            <p>Specifies the window that should receive output link protections.</p>
            </summary>
            <param name = "hwnd"><dd> <p>A handle to the window.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>In frame-server mode, call this method to specify the destination window for protected video content. The Media Engine uses this window to set link protections, using the Output Protection Manager (OPM).</p>
            </remarks>
            <doc-id>hh447968</doc-id>
            <unmanaged>HRESULT IMFMediaEngineProtectedContent::SetOPMWindow([In] HWND hwnd)</unmanaged>
            <unmanaged-short>IMFMediaEngineProtectedContent::SetOPMWindow</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineProtectedContent.TransferVideoFrame(SharpDX.IUnknown,System.Nullable{SharpDX.MediaFoundation.VideoNormalizedRect},SharpDX.Mathematics.Interop.RawRectangle,System.Nullable{SharpDX.Mathematics.Interop.RawColorBGRA},System.Int32@)">
            <summary>
            <p>Copies a protected video frame to a DXGI surface.</p>
            </summary>
            <param name = "dstSurfRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of the destination surface.</p> </dd></param>
            <param name = "srcRef"><dd> <p>A reference to an <strong><see cref = "T:SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure that specifies the source rectangle.</p> </dd></param>
            <param name = "dstRef"><dd> <p>A reference to a <strong><see cref = "T:SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that specifies the destination rectangle.</p> </dd></param>
            <param name = "borderClrRef"><dd> <p>A reference to an <strong><see cref = "T:SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> structure that specifies the border color. </p> </dd></param>
            <param name = "frameProtectionFlagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineFrameProtectionFlags"/></strong> enumeration. These flags indicate which content protections the application must apply before presenting the surface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>For protected content, call this method instead of the <strong>IMFMediaEngine::TransferVideoFrame</strong> method.</p>
            </remarks>
            <doc-id>hh447970</doc-id>
            <unmanaged>HRESULT IMFMediaEngineProtectedContent::TransferVideoFrame([In] IUnknown* pDstSurf,[In, Optional] const MFVideoNormalizedRect* pSrc,[In] const RECT* pDst,[In, Optional] const MFARGB* pBorderClr,[Out] DWORD* pFrameProtectionFlags)</unmanaged>
            <unmanaged-short>IMFMediaEngineProtectedContent::TransferVideoFrame</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineProtectedContent.SetContentProtectionManager(System.IntPtr)">
            <summary>
            <p>Sets the content protection manager (CPM).</p>
            </summary>
            <param name = "cPMRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.ContentProtectionManager"/></strong> interface, implemented by the caller.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The Media Engine uses the CPM to handle events related to protected content, such as license acquisition.</p>
            </remarks>
            <doc-id>hh447967</doc-id>
            <unmanaged>HRESULT IMFMediaEngineProtectedContent::SetContentProtectionManager([In, Optional] IMFContentProtectionManager* pCPM)</unmanaged>
            <unmanaged-short>IMFMediaEngineProtectedContent::SetContentProtectionManager</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineProtectedContent.SetApplicationCertificate(System.Byte[],System.Int32)">
            <summary>
            <p>Sets the application's certificate.</p>
            </summary>
            <param name = "bBlobRef"><dd> <p>A reference to a buffer that contains the certificate in X.509 format, followed by the application identifier signed with a SHA-256 signature using the private key from the certificate.</p> </dd></param>
            <param name = "cbBlob"><dd> <p>The size of the <em>pbBlob</em> buffer, in bytes.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Call this method to access protected video content in frame-server mode.</p>
            </remarks>
            <doc-id>hh447966</doc-id>
            <unmanaged>HRESULT IMFMediaEngineProtectedContent::SetApplicationCertificate([In, Buffer] const unsigned char* pbBlob,[In] DWORD cbBlob)</unmanaged>
            <unmanaged-short>IMFMediaEngineProtectedContent::SetApplicationCertificate</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEngineSrcElements.Length">
            <summary>
            <p>Gets the number of source elements in the list.</p>
            </summary>
            <doc-id>hh447973</doc-id>
            <unmanaged>GetLength</unmanaged>
            <unmanaged-short>GetLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineSrcElements.GetLength">
            <summary>
            <p>Gets the number of source elements in the list.</p>
            </summary>
            <returns><p>Returns the number of source elements.</p></returns>
            <doc-id>hh447973</doc-id>
            <unmanaged>DWORD IMFMediaEngineSrcElements::GetLength()</unmanaged>
            <unmanaged-short>IMFMediaEngineSrcElements::GetLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineSrcElements.GetURL(System.Int32,System.IntPtr)">
            <summary>
            <p>Gets the URL of an element in the list.</p>
            </summary>
            <param name = "index"><dd> <p>The zero-based index of the source element. To get the number of source elements, call <strong>IMFMediaEngineSrcElements::GetLength</strong>.</p> </dd></param>
            <param name = "uRLRef"><dd> <p>Receives a <strong>BSTR</strong> that contains the URL of the source element. The caller must free the  <strong>BSTR</strong> by calling <strong>SysFreeString</strong>. If no URL is set, this parameter receives the value <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447976</doc-id>
            <unmanaged>HRESULT IMFMediaEngineSrcElements::GetURL([In] DWORD index,[Out] wchar_t** pURL)</unmanaged>
            <unmanaged-short>IMFMediaEngineSrcElements::GetURL</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineSrcElements.GetTypeInfo(System.Int32,System.IntPtr)">
            <summary>
            <p>Gets the MIME type of an element in the list.</p>
            </summary>
            <param name = "index"><dd> <p>The zero-based index of the source element. To get the number of source elements, call <strong>IMFMediaEngineSrcElements::GetLength</strong>.</p> </dd></param>
            <param name = "typeRef"><dd> <p>Receives a <strong>BSTR</strong> that contains the MIME type. The caller must free the  <strong>BSTR</strong> by calling <strong>SysFreeString</strong>. If no MIME type is set, this parameter receives the value <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447975</doc-id>
            <unmanaged>HRESULT IMFMediaEngineSrcElements::GetType([In] DWORD index,[Out] wchar_t** pType)</unmanaged>
            <unmanaged-short>IMFMediaEngineSrcElements::GetType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineSrcElements.GetMedia(System.Int32,System.IntPtr)">
            <summary>
            <p>Gets the intended media type of an element in the list.</p>
            </summary>
            <param name = "index"><dd> <p>The zero-based index of the source element. To get the number of source elements, call <strong>IMFMediaEngineSrcElements::GetLength</strong>.</p> </dd></param>
            <param name = "mediaRef"><dd> <p>Receives a <strong>BSTR</strong> that contains a media-query string. The caller must free the  <strong>BSTR</strong> by calling <strong>SysFreeString</strong>. If no media type is set, this parameter receives the value <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The string returned in <em>pMedia</em> should be a media-query string that conforms to the W3C <em>Media Queries</em> specification.</p>
            </remarks>
            <doc-id>hh447974</doc-id>
            <unmanaged>HRESULT IMFMediaEngineSrcElements::GetMedia([In] DWORD index,[Out] wchar_t** pMedia)</unmanaged>
            <unmanaged-short>IMFMediaEngineSrcElements::GetMedia</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineSrcElements.AddElement(System.String,System.String,System.String)">
            <summary>
            <p>Adds a source element to the end of the list.</p>
            </summary>
            <param name = "uRLRef"><dd> <p>The URL of the source element, or <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "typeRef"><dd> <p>The MIME type of the source element, or <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "mediaRef"><dd> <p>A media-query string that specifies the intended media type, or <strong><c>null</c></strong>. If specified, the string should conform to the W3C <em>Media Queries</em> specification.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Any of the parameters to this method can be <strong><c>null</c></strong>.</p><p>This method allocates copies of the <strong>BSTR</strong>s that are passed in.</p>
            </remarks>
            <doc-id>hh447972</doc-id>
            <unmanaged>HRESULT IMFMediaEngineSrcElements::AddElement([In, Optional] wchar_t* pURL,[In, Optional] wchar_t* pType,[In, Optional] wchar_t* pMedia)</unmanaged>
            <unmanaged-short>IMFMediaEngineSrcElements::AddElement</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineSrcElements.RemoveAllElements">
            <summary>
            <p>Removes all of the source elements from the list.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447977</doc-id>
            <unmanaged>HRESULT IMFMediaEngineSrcElements::RemoveAllElements()</unmanaged>
            <unmanaged-short>IMFMediaEngineSrcElements::RemoveAllElements</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineSrcElementsEx.AddElementEx(System.String,System.String,System.String,System.String)">
            <summary>
            <p>Provides an enhanced version of <strong>IMFMediaEngineSrcElements::AddElement</strong> to add the key system intended to be used with content to an element.</p>
            </summary>
            <param name = "uRLRef">No documentation.</param>
            <param name = "typeRef">No documentation.</param>
            <param name = "mediaRef">No documentation.</param>
            <param name = "keySystem">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280701</doc-id>
            <unmanaged>HRESULT IMFMediaEngineSrcElementsEx::AddElementEx([In, Optional] wchar_t* pURL,[In, Optional] wchar_t* pType,[In, Optional] wchar_t* pMedia,[In, Optional] wchar_t* keySystem)</unmanaged>
            <unmanaged-short>IMFMediaEngineSrcElementsEx::AddElementEx</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineSrcElementsEx.GetKeySystem(System.Int32,System.IntPtr)">
            <summary>
            <p>Gets the key system for the given source element index.</p>
            </summary>
            <param name = "index"><dd> <p>The source element index.</p> </dd></param>
            <param name = "typeRef"><dd> <p>The MIME type of the source element.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280702</doc-id>
            <unmanaged>HRESULT IMFMediaEngineSrcElementsEx::GetKeySystem([In] DWORD index,[Out, Optional] wchar_t** pType)</unmanaged>
            <unmanaged-short>IMFMediaEngineSrcElementsEx::GetKeySystem</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineSupportsSourceTransfer.ShouldTransferSource(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Specifies wether or not the source should be transferred.</p>
            </summary>
            <param name = "fShouldTransferRef"><dd> <p><strong>true</strong> if the source should be transferred; otherwise, <strong>false</strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280706</doc-id>
            <unmanaged>HRESULT IMFMediaEngineSupportsSourceTransfer::ShouldTransferSource([Out] BOOL* pfShouldTransfer)</unmanaged>
            <unmanaged-short>IMFMediaEngineSupportsSourceTransfer::ShouldTransferSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineSupportsSourceTransfer.DetachMediaSource(SharpDX.MediaFoundation.IByteStream@,SharpDX.MediaFoundation.MediaSource@,SharpDX.MediaFoundation.MediaSourceExtension@)">
            <summary>
            <p>Detaches the media source.</p>
            </summary>
            <param name = "byteStreamOut"><dd> <p>Receives the byte stream.</p> </dd></param>
            <param name = "mediaSourceOut"><dd> <p>Receives the media source.</p> </dd></param>
            <param name = "mSEOut"><dd> <p>Receives the media source extension.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280705</doc-id>
            <unmanaged>HRESULT IMFMediaEngineSupportsSourceTransfer::DetachMediaSource([Out] IMFByteStream** ppByteStream,[Out] IMFMediaSource** ppMediaSource,[Out] IMFMediaSourceExtension** ppMSE)</unmanaged>
            <unmanaged-short>IMFMediaEngineSupportsSourceTransfer::DetachMediaSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineSupportsSourceTransfer.AttachMediaSource(SharpDX.MediaFoundation.IByteStream,SharpDX.MediaFoundation.MediaSource,SharpDX.MediaFoundation.MediaSourceExtension)">
            <summary>
            <p>Attaches the media source.</p>
            </summary>
            <param name = "byteStreamRef"><dd> <p>Specifies the byte stream. </p> </dd></param>
            <param name = "mediaSourceRef"><dd> <p>Specifies the media source.</p> </dd></param>
            <param name = "mSERef"><dd> <p>Specifies the media source extension.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280704</doc-id>
            <unmanaged>HRESULT IMFMediaEngineSupportsSourceTransfer::AttachMediaSource([In, Optional] IMFByteStream* pByteStream,[In] IMFMediaSource* pMediaSource,[In, Optional] IMFMediaSourceExtension* pMSE)</unmanaged>
            <unmanaged-short>IMFMediaEngineSupportsSourceTransfer::AttachMediaSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineTransferSource.TransferSourceToMediaEngine(SharpDX.MediaFoundation.MediaEngine)">
            <summary>
            No documentation.
            </summary>
            <param name = "destination">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaEngineTransferSource::TransferSourceToMediaEngine([In] IMFMediaEngine* destination)</unmanaged>
            <unmanaged-short>IMFMediaEngineTransferSource::TransferSourceToMediaEngine</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineWebSupport.ShouldDelayTheLoadEvent">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets a value indicating if the connecting to Web audio should delay the page's load event.</p>
            </summary>
            <returns><p>True if connection to Web audio should delay the page's load event; otherwise, false.</p></returns>
            <doc-id>mt668769</doc-id>
            <unmanaged>BOOL IMFMediaEngineWebSupport::ShouldDelayTheLoadEvent()</unmanaged>
            <unmanaged-short>IMFMediaEngineWebSupport::ShouldDelayTheLoadEvent</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineWebSupport.ConnectWebAudio(System.Int32,SharpDX.MediaFoundation.IAudioSourceProvider@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Connects web audio to Media Engine using the specified sample rate.</p>
            </summary>
            <param name = "dwSampleRate"><dd> <p>The sample rate of the web audio.</p> </dd></param>
            <param name = "sourceProviderOut"><dd> <p>The sample rate of the web audio.</p> </dd></param>
            <returns><p>Returns <see cref = "F:SharpDX.Result.Ok"/> on successful completion.</p></returns>
            <doc-id>mt668767</doc-id>
            <unmanaged>HRESULT IMFMediaEngineWebSupport::ConnectWebAudio([In] DWORD dwSampleRate,[Out] IAudioSourceProvider** ppSourceProvider)</unmanaged>
            <unmanaged-short>IMFMediaEngineWebSupport::ConnectWebAudio</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEngineWebSupport.DisconnectWebAudio">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Disconnects web audio from the Media Engine </p>
            </summary>
            <returns><p>Returns <see cref = "F:SharpDX.Result.Ok"/> on successful completion.</p></returns>
            <doc-id>mt668768</doc-id>
            <unmanaged>HRESULT IMFMediaEngineWebSupport::DisconnectWebAudio()</unmanaged>
            <unmanaged-short>IMFMediaEngineWebSupport::DisconnectWebAudio</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaError.ExtendedErrorCode">
            <summary>
            <p>Gets or sets the extended error code.</p>
            </summary>
            <doc-id>hh448024</doc-id>
            <unmanaged>GetExtendedErrorCode / SetExtendedErrorCode</unmanaged>
            <unmanaged-short>GetExtendedErrorCode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaError.GetErrorCode">
            <summary>
            <p>Gets the error code.</p>
            </summary>
            <returns><p>Returns a value from the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineErr"/></strong> enumeration.</p></returns>
            <doc-id>hh448023</doc-id>
            <unmanaged>unsigned short IMFMediaError::GetErrorCode()</unmanaged>
            <unmanaged-short>IMFMediaError::GetErrorCode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaError.GetExtendedErrorCode">
            <summary>
            <p>Gets the extended error code.</p>
            </summary>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value that gives additional information about the last error.</p></returns>
            <doc-id>hh448024</doc-id>
            <unmanaged>HRESULT IMFMediaError::GetExtendedErrorCode()</unmanaged>
            <unmanaged-short>IMFMediaError::GetExtendedErrorCode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaError.SetErrorCode(SharpDX.MediaFoundation.MediaEngineErr)">
            <summary>
            <p>Sets the error code.</p>
            </summary>
            <param name = "error"><dd> <p>The error code, specified as an <strong><see cref = "T:SharpDX.MediaFoundation.MediaEngineErr"/></strong> value.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh448025</doc-id>
            <unmanaged>HRESULT IMFMediaError::SetErrorCode([In] MF_MEDIA_ENGINE_ERR error)</unmanaged>
            <unmanaged-short>IMFMediaError::SetErrorCode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaError.SetExtendedErrorCode(SharpDX.Result)">
            <summary>
            <p>Sets the extended error code.</p>
            </summary>
            <param name = "error"><dd> <p>An <strong><see cref = "T:SharpDX.Result"/></strong> value that gives additional information about the last error.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh448026</doc-id>
            <unmanaged>HRESULT IMFMediaError::SetExtendedErrorCode([In] HRESULT error)</unmanaged>
            <unmanaged-short>IMFMediaError::SetExtendedErrorCode</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEvent.TypeInfo">
            <summary>
            <p> </p><p>Retrieves the event type. The event type indicates what happened to trigger the event. It also defines the meaning of the event value.</p>
            </summary>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms702255</doc-id>
            <unmanaged>GetType</unmanaged>
            <unmanaged-short>GetType</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEvent.ExtendedType">
            <summary>
            <p> </p><p>Retrieves the extended type of the event.</p>
            </summary>
            <remarks>
            <p>To define a custom event, create a new extended-type <see cref = "T:System.Guid"/> and send an MEExtendedType event with that <see cref = "T:System.Guid"/>.</p><p>Some standard Media Foundation events also use the extended type to differentiate between types of event data.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms697235</doc-id>
            <unmanaged>GetExtendedType</unmanaged>
            <unmanaged-short>GetExtendedType</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEvent.Status">
            <summary>
            <p> </p><p>Retrieves an <strong><see cref = "T:SharpDX.Result"/></strong> that specifies the event status.</p>
            </summary>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms704650</doc-id>
            <unmanaged>GetStatus</unmanaged>
            <unmanaged-short>GetStatus</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaEvent.Value">
            <summary>
            <p> </p><p>Retrieves the value associated with the event, if any. The value is retrieved as a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> structure. The actual data type and the meaning of the value depend on the event.</p>
            </summary>
            <remarks>
            <p>Before calling this method, call <strong>PropVariantInit</strong> to initialize the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> structure. After the method returns, call <strong>PropVariantClear</strong> to free the memory that was allocated for the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> data.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms693864</doc-id>
            <unmanaged>GetValue</unmanaged>
            <unmanaged-short>GetValue</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEvent.GetTypeInfo(SharpDX.MediaFoundation.MediaEventTypes@)">
            <summary>
            <p> </p><p>Retrieves the event type. The event type indicates what happened to trigger the event. It also defines the meaning of the event value.</p>
            </summary>
            <param name = "metRef"><dd> <p>Receives the event type. For a list of event types, see Media Foundation Events.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms702255</doc-id>
            <unmanaged>HRESULT IMFMediaEvent::GetType([Out] DWORD* pmet)</unmanaged>
            <unmanaged-short>IMFMediaEvent::GetType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEvent.GetExtendedType(System.Guid@)">
            <summary>
            <p> </p><p>Retrieves the extended type of the event.</p>
            </summary>
            <param name = "guidExtendedTypeRef"><dd> <p>Receives a <strong><see cref = "T:System.Guid"/></strong> that identifies the extended type.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>To define a custom event, create a new extended-type <see cref = "T:System.Guid"/> and send an MEExtendedType event with that <see cref = "T:System.Guid"/>.</p><p>Some standard Media Foundation events also use the extended type to differentiate between types of event data.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms697235</doc-id>
            <unmanaged>HRESULT IMFMediaEvent::GetExtendedType([Out] GUID* pguidExtendedType)</unmanaged>
            <unmanaged-short>IMFMediaEvent::GetExtendedType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEvent.GetStatus(SharpDX.Result@)">
            <summary>
            <p> </p><p>Retrieves an <strong><see cref = "T:SharpDX.Result"/></strong> that specifies the event status.</p>
            </summary>
            <param name = "hrStatusRef"><dd> <p>Receives the event status. If the operation that generated the event was successful, the value is a success code. A failure code means that an error condition triggered the event.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms704650</doc-id>
            <unmanaged>HRESULT IMFMediaEvent::GetStatus([Out] HRESULT* phrStatus)</unmanaged>
            <unmanaged-short>IMFMediaEvent::GetStatus</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEvent.GetValue(SharpDX.Win32.Variant@)">
            <summary>
            <p> </p><p>Retrieves the value associated with the event, if any. The value is retrieved as a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> structure. The actual data type and the meaning of the value depend on the event.</p>
            </summary>
            <param name = "vValueRef"><dd> <p>Pointer to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> structure. The method fills this structure with the data.</p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Before calling this method, call <strong>PropVariantInit</strong> to initialize the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> structure. After the method returns, call <strong>PropVariantClear</strong> to free the memory that was allocated for the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> data.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms693864</doc-id>
            <unmanaged>HRESULT IMFMediaEvent::GetValue([Out] PROPVARIANT* pvValue)</unmanaged>
            <unmanaged-short>IMFMediaEvent::GetValue</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEventQueue.GetEvent(System.Int32,SharpDX.MediaFoundation.MediaEvent@)">
            <summary>
            <p> </p><p>Retrieves the next event in the queue. This method is synchronous.</p><p>Call this method inside your implementation of <strong>IMFMediaEventGenerator::GetEvent</strong>. Pass the parameters from that method directly to this method.</p>
            </summary>
            <param name = "dwFlags">No documentation.</param>
            <param name = "eventOut">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaEventQueue.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms702270</doc-id>
            <unmanaged>HRESULT IMFMediaEventQueue::GetEvent([In] DWORD dwFlags,[Out] IMFMediaEvent** ppEvent)</unmanaged>
            <unmanaged-short>IMFMediaEventQueue::GetEvent</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEventQueue.BeginGetEvent(SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Begins an asynchronous request for the next event in the queue.</p><p>Call this method inside your implementation of <strong>IMFMediaEventGenerator::BeginGetEvent</strong>. Pass the parameters from that method directly to this method.</p>
            </summary>
            <param name = "callbackRef">No documentation.</param>
            <param name = "unkStateRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaEventQueue.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms696998</doc-id>
            <unmanaged>HRESULT IMFMediaEventQueue::BeginGetEvent([In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>
            <unmanaged-short>IMFMediaEventQueue::BeginGetEvent</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEventQueue.EndGetEvent(SharpDX.MediaFoundation.AsyncResult,SharpDX.MediaFoundation.MediaEvent@)">
            <summary>
            <p> </p><p>Completes an asynchronous request for the next event in the queue.</p><p>Call this method inside your implementation of <strong>IMFMediaEventGenerator::EndGetEvent</strong>. Pass the parameters from that method directly to this method.</p>
            </summary>
            <param name = "resultRef">No documentation.</param>
            <param name = "eventOut">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaEventQueue.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms702986</doc-id>
            <unmanaged>HRESULT IMFMediaEventQueue::EndGetEvent([In] IMFAsyncResult* pResult,[Out] IMFMediaEvent** ppEvent)</unmanaged>
            <unmanaged-short>IMFMediaEventQueue::EndGetEvent</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEventQueue.QueueEvent(SharpDX.MediaFoundation.MediaEvent)">
            <summary>
            <p> </p><p>Puts an event in the queue.</p>
            </summary>
            <param name = "eventRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEvent"/></strong> interface of the event to be put in the queue.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaEventQueue.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this method when your component needs to raise an event that contains attributes. To create the event object, call <strong>MFCreateMediaEvent</strong>. Add attributes to the event by using methods from the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. (The <strong><see cref = "T:SharpDX.MediaFoundation.MediaEvent"/></strong> interface inherits <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong>.)</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms704792</doc-id>
            <unmanaged>HRESULT IMFMediaEventQueue::QueueEvent([In] IMFMediaEvent* pEvent)</unmanaged>
            <unmanaged-short>IMFMediaEventQueue::QueueEvent</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEventQueue.QueueEventParamVar(System.Int32,System.Guid,SharpDX.Result,SharpDX.Win32.Variant)">
            <summary>
            <p> </p><p>Creates an event, sets a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> as the event data, and puts the event in the queue.</p><p>Call this method inside your implementation of <strong>IMFMediaEventGenerator::QueueEvent</strong>. Pass the parameters from that method directly to this method.</p><p>You can also call this method when your component needs to raise an event that does not contain attributes. If the event data is an <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference, you can use <strong>IMFMediaEventQueue::QueueEventParamUnk</strong>. If the event contains attributes, use <strong>IMFMediaEventQueue::QueueEvent</strong> instead.</p>
            </summary>
            <param name = "met">No documentation.</param>
            <param name = "guidExtendedType">No documentation.</param>
            <param name = "hrStatus">No documentation.</param>
            <param name = "vValueRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaEventQueue.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms704641</doc-id>
            <unmanaged>HRESULT IMFMediaEventQueue::QueueEventParamVar([In] DWORD met,[In] const GUID&amp; guidExtendedType,[In] HRESULT hrStatus,[In] const PROPVARIANT* pvValue)</unmanaged>
            <unmanaged-short>IMFMediaEventQueue::QueueEventParamVar</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEventQueue.QueueEventParamUnk(System.Int32,System.Guid,SharpDX.Result,SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Creates an event, sets an <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference as the event data, and puts the event in the queue.</p>
            </summary>
            <param name = "met"><dd> <p>Specifies the event type of the event to be added to the queue. The event type is returned by the event's <strong>IMFMediaEvent::GetType</strong> method. For a list of event types, see Media Foundation Events.</p> </dd></param>
            <param name = "guidExtendedType"><dd> <p>The extended type of the event. If the event does not have an extended type, use the value GUID_NULL. The extended type is returned by the event's <strong>IMFMediaEvent::GetExtendedType</strong> method.</p> </dd></param>
            <param name = "hrStatus"><dd> <p>A success or failure code indicating the status of the event. This value is returned by the event's <strong>IMFMediaEvent::GetStatus</strong> method.</p> </dd></param>
            <param name = "unkRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface. The method sets this reference as the event value. The reference is returned by the event's <strong>IMFMediaEvent::GetValue</strong> method.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaEventQueue.Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this method when your component needs to raise an event that contains an <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference value and no attributes. If the event contains attributes, use <strong>IMFMediaEventQueue::QueueEvent</strong> instead.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms704686</doc-id>
            <unmanaged>HRESULT IMFMediaEventQueue::QueueEventParamUnk([In] DWORD met,[In] const GUID&amp; guidExtendedType,[In] HRESULT hrStatus,[In] IUnknown* pUnk)</unmanaged>
            <unmanaged-short>IMFMediaEventQueue::QueueEventParamUnk</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaEventQueue.Shutdown">
            <summary>
            <p> </p><p>Shuts down the event queue.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this method when your component shuts down. After this method is called, all <strong><see cref = "T:SharpDX.MediaFoundation.MediaEventQueue"/></strong> methods return <strong><see cref = "M:SharpDX.MediaFoundation.MediaEventQueue.Shutdown"/></strong>.</p><p>This method removes all of the events from the queue.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms698923</doc-id>
            <unmanaged>HRESULT IMFMediaEventQueue::Shutdown()</unmanaged>
            <unmanaged-short>IMFMediaEventQueue::Shutdown</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaKeys.SuspendNotify">
            <summary>
            <p>Gets the suspend notify interface of the Content Decryption Module (CDM).</p>
            </summary>
            <doc-id>dn280723</doc-id>
            <unmanaged>GetSuspendNotify</unmanaged>
            <unmanaged-short>GetSuspendNotify</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeys.CreateSession(System.String,System.Byte[],System.Int32,System.Byte[],System.Int32,SharpDX.MediaFoundation.MediaKeySessionNotify,SharpDX.MediaFoundation.MediaKeySession@)">
            <summary>
            <p>Creates a media key session object using the specified initialization data and custom data.
            .
            </p>
            </summary>
            <param name = "mimeType"><dd> <p>The MIME type of the media container used for the content.</p> </dd></param>
            <param name = "initData"><dd> <p>The initialization data for the key system. </p> </dd></param>
            <param name = "cb"><dd> <p>The count in bytes of <em>initData</em>.</p> </dd></param>
            <param name = "customData"><dd> <p>Custom data sent to the key system.</p> </dd></param>
            <param name = "cbCustomData"><dd> <p>The count in bytes of <em>cbCustomData</em>.</p> </dd></param>
            <param name = "notify"><dd> <p>notify</p> </dd></param>
            <param name = "sessionOut"><dd> <p>The media key session.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280722</doc-id>
            <unmanaged>HRESULT IMFMediaKeys::CreateSession([In, Optional] wchar_t* mimeType,[In, Buffer, Optional] const unsigned char* initData,[In, Optional] DWORD cb,[In, Buffer, Optional] const unsigned char* customData,[In] DWORD cbCustomData,[In] IMFMediaKeySessionNotify* notify,[Out] IMFMediaKeySession** ppSession)</unmanaged>
            <unmanaged-short>IMFMediaKeys::CreateSession</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeys.GetKeySystem(System.IntPtr)">
            <summary>
            <p>Gets the key system string the <strong><see cref = "T:SharpDX.MediaFoundation.MediaKeys"/></strong> object was created with.</p>
            </summary>
            <param name = "keySystem">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280724</doc-id>
            <unmanaged>HRESULT IMFMediaKeys::get_KeySystem([Out] wchar_t** keySystem)</unmanaged>
            <unmanaged-short>IMFMediaKeys::get_KeySystem</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeys.Shutdown">
            <summary>
            <p></p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p><strong>Shutdown</strong> should be called by the application before final release.  The Content Decryption Module (CDM) reference and any other resources is released at this point.  However, related sessions are not freed or closed.</p>
            </remarks>
            <doc-id>dn280725</doc-id>
            <unmanaged>HRESULT IMFMediaKeys::Shutdown()</unmanaged>
            <unmanaged-short>IMFMediaKeys::Shutdown</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeys.GetSuspendNotify(SharpDX.MediaFoundation.CdmSuspendNotify@)">
            <summary>
            <p>Gets the suspend notify interface of the Content Decryption Module (CDM).</p>
            </summary>
            <param name = "notify"><dd> <p>The suspend notify interface of the Content Decryption Module (CDM).</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280723</doc-id>
            <unmanaged>HRESULT IMFMediaKeys::GetSuspendNotify([Out] IMFCdmSuspendNotify** notify)</unmanaged>
            <unmanaged-short>IMFMediaKeys::GetSuspendNotify</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeys2.CreateSession2(SharpDX.MediaFoundation.MediaKeysessionType,SharpDX.MediaFoundation.MediaKeySessionNotify2,SharpDX.MediaFoundation.MediaKeySession2@)">
            <summary>
            No documentation.
            </summary>
            <param name = "eSessionType">No documentation.</param>
            <param name = "mFMediaKeySessionNotify2Ref">No documentation.</param>
            <param name = "sessionOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaKeys2::CreateSession2([In] MF_MEDIAKEYSESSION_TYPE eSessionType,[In] IMFMediaKeySessionNotify2* pMFMediaKeySessionNotify2,[Out] IMFMediaKeySession2** ppSession)</unmanaged>
            <unmanaged-short>IMFMediaKeys2::CreateSession2</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeys2.SetServerCertificate(System.Byte[],System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "bServerCertificateRef">No documentation.</param>
            <param name = "cb">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaKeys2::SetServerCertificate([In, Buffer, Optional] const unsigned char* pbServerCertificate,[In] DWORD cb)</unmanaged>
            <unmanaged-short>IMFMediaKeys2::SetServerCertificate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeys2.GetDOMException(SharpDX.Result,SharpDX.Result@)">
            <summary>
            No documentation.
            </summary>
            <param name = "systemCode">No documentation.</param>
            <param name = "code">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaKeys2::GetDOMException([In] HRESULT systemCode,[Out] HRESULT* code)</unmanaged>
            <unmanaged-short>IMFMediaKeys2::GetDOMException</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeySession.GetError(System.Int16@,System.Int32@)">
            <summary>
            <p>Gets the error state associated with the media key session.</p>
            </summary>
            <param name = "code"><dd> <p>The error code.</p> </dd></param>
            <param name = "systemCode"><dd> <p>Platform specific error information.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280718</doc-id>
            <unmanaged>HRESULT IMFMediaKeySession::GetError([Out] unsigned short* code,[Out] DWORD* systemCode)</unmanaged>
            <unmanaged-short>IMFMediaKeySession::GetError</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeySession.GetKeySystem(System.IntPtr)">
            <summary>
            <p>Gets the name of the  key system name the media keys object was created with.</p>
            </summary>
            <param name = "keySystem"><dd> <p>The name of the key system.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280719</doc-id>
            <unmanaged>HRESULT IMFMediaKeySession::get_KeySystem([Out] wchar_t** keySystem)</unmanaged>
            <unmanaged-short>IMFMediaKeySession::get_KeySystem</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeySession.GetSessionId(System.IntPtr)">
            <summary>
            <p>Gets a unique session id created for this session.</p>
            </summary>
            <param name = "sessionId"><dd> <p>The media key session id.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280720</doc-id>
            <unmanaged>HRESULT IMFMediaKeySession::get_SessionId([Out] wchar_t** sessionId)</unmanaged>
            <unmanaged-short>IMFMediaKeySession::get_SessionId</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeySession.Update(System.Byte[],System.Int32)">
            <summary>
            <p>Passes in a key value with any associated data required by the Content Decryption Module for the given key system.</p>
            </summary>
            <param name = "key"><dd></dd></param>
            <param name = "cb"><dd> <p>The count in bytes of <em>key</em>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280721</doc-id>
            <unmanaged>HRESULT IMFMediaKeySession::Update([In, Buffer] const unsigned char* key,[In] DWORD cb)</unmanaged>
            <unmanaged-short>IMFMediaKeySession::Update</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeySession.Close">
            <summary>
            <p>Closes the media key session and must be called before the key session is released.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280717</doc-id>
            <unmanaged>HRESULT IMFMediaKeySession::Close()</unmanaged>
            <unmanaged-short>IMFMediaKeySession::Close</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaKeySession2.Expiration">
            <summary>
            No documentation.
            </summary>
            <unmanaged>get_Expiration</unmanaged>
            <unmanaged-short>get_Expiration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeySession2.GetKeyStatuses(SharpDX.MediaFoundation.MediaKeyStatus[],System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "keyStatusesArrayRef">No documentation.</param>
            <param name = "uSizeRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaKeySession2::get_KeyStatuses([Out, Buffer] MFMediaKeyStatus** pKeyStatusesArray,[Out] unsigned int* puSize)</unmanaged>
            <unmanaged-short>IMFMediaKeySession2::get_KeyStatuses</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeySession2.Load(System.String,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            No documentation.
            </summary>
            <param name = "bstrSessionId">No documentation.</param>
            <param name = "fLoadedRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaKeySession2::Load([In] wchar_t* bstrSessionId,[Out] BOOL* pfLoaded)</unmanaged>
            <unmanaged-short>IMFMediaKeySession2::Load</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeySession2.GenerateRequest(System.String,System.Byte[],System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "initDataType">No documentation.</param>
            <param name = "bInitDataRef">No documentation.</param>
            <param name = "cb">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaKeySession2::GenerateRequest([In] wchar_t* initDataType,[In, Buffer] const unsigned char* pbInitData,[In] DWORD cb)</unmanaged>
            <unmanaged-short>IMFMediaKeySession2::GenerateRequest</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeySession2.GetExpiration(System.Double@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dblExpiration">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaKeySession2::get_Expiration([Out] double* dblExpiration)</unmanaged>
            <unmanaged-short>IMFMediaKeySession2::get_Expiration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeySession2.Remove">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaKeySession2::Remove()</unmanaged>
            <unmanaged-short>IMFMediaKeySession2::Remove</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeySession2.Shutdown">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaKeySession2::Shutdown()</unmanaged>
            <unmanaged-short>IMFMediaKeySession2::Shutdown</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeySessionNotify.KeyMessage(System.String,System.Byte[],System.Int32)">
            <summary>
            <p>Passes information to the application so it can initiate a key acquisition.</p>
            </summary>
            <param name = "destinationURL"><dd> <p>The URL to send the message to.</p> </dd></param>
            <param name = "message"><dd> <p>The message to send to the application.</p> </dd></param>
            <param name = "cb"><dd> <p>The length in bytes of <em>message</em>.</p> </dd></param>
            <doc-id>dn280716</doc-id>
            <unmanaged>void IMFMediaKeySessionNotify::KeyMessage([In, Optional] wchar_t* destinationURL,[In, Buffer] const unsigned char* message,[In] DWORD cb)</unmanaged>
            <unmanaged-short>IMFMediaKeySessionNotify::KeyMessage</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeySessionNotify.KeyAdded">
            <summary>
            <p>Notifies the application that the key has been added.  </p>
            </summary>
            <remarks>
            <p><strong>KeyAdded</strong> can also be called if the keys requested for the session have already been acquired.</p>
            </remarks>
            <doc-id>dn280714</doc-id>
            <unmanaged>void IMFMediaKeySessionNotify::KeyAdded()</unmanaged>
            <unmanaged-short>IMFMediaKeySessionNotify::KeyAdded</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeySessionNotify.KeyError(System.Int16,System.Int32)">
            <summary>
            <p>Notifies the application that an error occurred while processing the key.</p>
            </summary>
            <param name = "code"><dd></dd></param>
            <param name = "systemCode"><dd></dd></param>
            <doc-id>dn280715</doc-id>
            <unmanaged>void IMFMediaKeySessionNotify::KeyError([In] unsigned short code,[In] DWORD systemCode)</unmanaged>
            <unmanaged-short>IMFMediaKeySessionNotify::KeyError</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeySessionNotify2.KeyMessage2(SharpDX.MediaFoundation.MediaKeysessionMessagetype,System.String,System.Byte[],System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "eMessageType">No documentation.</param>
            <param name = "destinationURL">No documentation.</param>
            <param name = "bMessageRef">No documentation.</param>
            <param name = "cbMessage">No documentation.</param>
            <unmanaged>void IMFMediaKeySessionNotify2::KeyMessage2([In] MF_MEDIAKEYSESSION_MESSAGETYPE eMessageType,[In, Optional] wchar_t* destinationURL,[In, Buffer] const unsigned char* pbMessage,[In] DWORD cbMessage)</unmanaged>
            <unmanaged-short>IMFMediaKeySessionNotify2::KeyMessage2</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeySessionNotify2.KeyStatusChange">
            <summary>
            No documentation.
            </summary>
            <unmanaged>void IMFMediaKeySessionNotify2::KeyStatusChange()</unmanaged>
            <unmanaged-short>IMFMediaKeySessionNotify2::KeyStatusChange</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaKeySystemAccess.SupportedConfiguration">
            <summary>
            No documentation.
            </summary>
            <unmanaged>get_SupportedConfiguration</unmanaged>
            <unmanaged-short>get_SupportedConfiguration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeySystemAccess.CreateMediaKeys(SharpDX.ComObject,SharpDX.MediaFoundation.MediaKeys2@)">
            <summary>
            No documentation.
            </summary>
            <param name = "cdmCustomConfigRef">No documentation.</param>
            <param name = "keysOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaKeySystemAccess::CreateMediaKeys([In, Optional] IPropertyStore* pCdmCustomConfig,[Out] IMFMediaKeys2** ppKeys)</unmanaged>
            <unmanaged-short>IMFMediaKeySystemAccess::CreateMediaKeys</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeySystemAccess.GetSupportedConfiguration(SharpDX.ComObject@)">
            <summary>
            No documentation.
            </summary>
            <param name = "supportedConfigurationOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaKeySystemAccess::get_SupportedConfiguration([Out] IPropertyStore** ppSupportedConfiguration)</unmanaged>
            <unmanaged-short>IMFMediaKeySystemAccess::get_SupportedConfiguration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaKeySystemAccess.GetKeySystem(System.IntPtr)">
            <summary>
            No documentation.
            </summary>
            <param name = "keySystemRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaKeySystemAccess::get_KeySystem([Out] wchar_t** pKeySystem)</unmanaged>
            <unmanaged-short>IMFMediaKeySystemAccess::get_KeySystem</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaSession.Clock">
            <summary>
            <p> </p><p>Retrieves the Media Session's presentation clock.</p>
            </summary>
            <remarks>
            <p>The application can query the returned <strong><see cref = "T:SharpDX.MediaFoundation.Clock"/></strong> reference for the <strong><see cref = "T:SharpDX.MediaFoundation.PresentationClock"/></strong> interface. However, the application should not use this interface to control the state of the presentation clock. Instead, the application should always call the transport control methods on the Media Session's <strong><see cref = "T:SharpDX.MediaFoundation.MediaSession"/></strong> interface, such as <strong>Start</strong>, <strong>Stop</strong>, and <strong>Pause</strong>.</p>
            </remarks>
            <doc-id>bb970342</doc-id>
            <unmanaged>GetClock</unmanaged>
            <unmanaged-short>GetClock</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaSession.SessionCapabilities">
            <summary>
            <p> </p><p>Retrieves the capabilities of the Media Session, based on the current presentation.</p>
            </summary>
            <doc-id>ms696229</doc-id>
            <unmanaged>GetSessionCapabilities</unmanaged>
            <unmanaged-short>GetSessionCapabilities</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSession.SetTopology(SharpDX.MediaFoundation.SessionSetTopologyFlags,SharpDX.MediaFoundation.Topology)">
            <summary>
            <p> Sets a topology on the Media Session. </p>
            </summary>
            <param name = "dwSetTopologyFlags"><dd> <p> Bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.SessionSetTopologyFlags"/></strong> enumeration. </p> </dd></param>
            <param name = "topologyRef"><dd> <p> Pointer to the topology object's <strong><see cref = "T:SharpDX.MediaFoundation.Topology"/></strong> interface. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p> The operation cannot be performed in the Media Session's current state. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSession.Shutdown"/></strong></dt> </dl> </td><td> <p> The Media Session has been shut down. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TopoInvalidTimeAttributes"/></strong></dt> </dl> </td><td> <p>The topology has invalid values for one or more of the following attributes:</p> <ul> <li> <strong><see cref = "!:Mediastart"/></strong> </li> <li> <strong><see cref = "!:Mediastop"/></strong> </li> <li> <strong><see cref = "!:ProjectStart"/></strong> </li> <li> <strong><see cref = "!:ProjectStop"/></strong> </li> </ul> </td></tr> <tr><td> <dl> <dt><strong>NS_E_DRM_DEBUGGING_NOT_ALLOWED</strong></dt> </dl> </td><td> <p> Protected content cannot be played while debugging. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> If <em>pTopology</em> is a full topology, set the <strong>MFSESSION_SETTOPOLOGY_NORESOLUTION</strong> flag in the <em>dwSetTopologyFlags</em> parameter. Otherwise, the topology is assumed to be a partial topology. The Media Session uses the topology loader to resolve a partial topology into a full topology.</p><p>If the Media Session is currently paused or stopped, the <strong>SetTopology</strong> method does not take effect until the next call to <strong>IMFMediaSession::Start</strong>.</p><p>If the Media Session is currently running, or on the next call to <strong>Start</strong>, the <strong>SetTopology</strong> method does the following:</p><ul> <li>If the <strong>MFSESSION_SETTOPOLOGY_IMMEDIATE</strong> flag is set in <em>dwSetTopologyFlags</em>, the Media Session ends the current presentation immediately, clears all pending topologies, and uses <em>pTopology</em> to start a new presentation.</li> <li>Otherwise, the Media Session queues <em>pTopology</em> and starts the new presentation when the current presentation has completed. If there is no current presentation, the new presentation starts immediately.</li> <li>Starting in Windows?7, you can also specify the <strong>MFSESSION_SETTOPOLOGY_CLEAR_CURRENT</strong> flag to clear the current topology but leave any other pending topologies on the queue.</li> </ul><p> This method is asynchronous. If the method returns <see cref = "F:SharpDX.Result.Ok"/>, the Media Session sends an MESessionTopologySet event when the operation completes. If the Media Session is currently paused to stopped, the Media Session does not send the MESessionTopologySet event until the next call to <strong>IMFMediaSession::Start</strong> </p>
            </remarks>
            <doc-id>ms704785</doc-id>
            <unmanaged>HRESULT IMFMediaSession::SetTopology([In] DWORD dwSetTopologyFlags,[In, Optional] IMFTopology* pTopology)</unmanaged>
            <unmanaged-short>IMFMediaSession::SetTopology</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSession.ClearTopologies">
            <summary>
            <p> </p><p>Clears all of the presentations that are queued for playback in the Media Session.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p> The operation cannot be performed in the Media Session's current state. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSession.Shutdown"/></strong></dt> </dl> </td><td> <p> The Media Session has been shut down. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is asynchronous. When the operation completes, the Media Session sends an MESessionTopologiesCleared event.</p><p>This method does not clear the current topology; it only removes topologies that are placed in the queue, waiting for playback. To remove the current topology, call <strong>IMFMediaSession::SetTopology</strong> with the <strong>MFSESSION_SETTOPOLOGY_CLEAR_CURRENT</strong> flag.</p>
            </remarks>
            <doc-id>ms705648</doc-id>
            <unmanaged>HRESULT IMFMediaSession::ClearTopologies()</unmanaged>
            <unmanaged-short>IMFMediaSession::ClearTopologies</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSession.Start(System.Nullable{System.Guid},System.Nullable{SharpDX.Win32.Variant})">
            <summary>
            <p> Starts the Media Session. </p>
            </summary>
            <param name = "guidTimeFormatRef"><dd> <p>Pointer to a <see cref = "T:System.Guid"/> that specifies the time format for the <em>pvarStartPosition</em> parameter. This parameter can be <strong><c>null</c></strong>. The value <strong><c>null</c></strong> is equivalent to passing in <strong>GUID_NULL</strong>.</p> <p>The following time format GUIDs are defined:</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>GUID_NULL</strong></dt> </dl> </td><td> <p>Presentation time. The <em>pvarStartPosition</em> parameter must have one of the following <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> types.</p> <ul> <li><strong>VT_I8</strong>: The <em>pvarStartPosition</em> parameter contains the starting position in 100-nanosecond units, relative to the start of the presentation.</li> <li><strong>VT_EMPTY</strong>: Playback starts from the current position.</li> </ul> <p>All media sources support this time format.</p> </td></tr> <tr><td><dl> <dt><strong>MF_TIME_FORMAT_SEGMENT_OFFSET</strong></dt> </dl> </td><td> <p>Segment offset. This time format is supported by the Sequencer Source. The starting time is an offset within a segment.</p> <p>Call the <strong>MFCreateSequencerSegmentOffset</strong> function to create the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> value for the <em>pvarStartPosition</em> parameter.</p> </td></tr> <tr><td><dl> <dt><strong>MF_TIME_FORMAT_ENTRY_RELATIVE</strong></dt> </dl> </td><td> <strong>Note</strong>??Requires Windows?7 or later. ? <p>Skip to a playlist entry. The <em>pvarStartPosition</em> parameter specifies the index of the playlist entry, relative to the current entry. For example, the value 2 skips forward two entries. To skip backward, pass a negative value. The <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> type is <strong>VT_I4</strong>.</p> <p>If a media source supports this time format, the <strong>IMFMediaSource::GetCharacteristics</strong> method returns one or both of the following flags:</p> <ul> <li><strong>MFMEDIASOURCE_CAN_SKIPFORWARD</strong></li> <li><strong>MFMEDIASOURCE_CAN_SKIPBACKWARD</strong></li> </ul> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "varStartPositionRef"><dd> <p> Pointer to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that specifies the starting position for playback. The meaning and data type of this parameter are indicated by the <em>pguidTimeFormat</em> parameter. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p> The operation cannot be performed in the Media Session's current state. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSession.Shutdown"/></strong></dt> </dl> </td><td> <p> The Media Session has been shut down. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>When this method is called, the Media Session starts the presentation clock and begins to process media samples.</p><p>This method is asynchronous. When the method completes, the Media Session sends an MESessionStarted event.</p>
            </remarks>
            <doc-id>ms694908</doc-id>
            <unmanaged>HRESULT IMFMediaSession::Start([In, Optional] const GUID* pguidTimeFormat,[In, Optional] const PROPVARIANT* pvarStartPosition)</unmanaged>
            <unmanaged-short>IMFMediaSession::Start</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSession.Pause">
            <summary>
            <p> </p><p>Pauses the Media Session.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The operation cannot be performed in the Media Session's current state.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSession.Shutdown"/></strong></dt> </dl> </td><td> <p>The Media Session has been shut down.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:SessionPausewhilestopped"/></strong></dt> </dl> </td><td> <p>The Media Session cannot pause while stopped.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method pauses the presentation clock.</p><p>This method is asynchronous. When the operation completes, the Media Session sends an MESessionPaused event.</p><p>This method fails if the Media Session is stopped.</p>
            </remarks>
            <doc-id>ms705650</doc-id>
            <unmanaged>HRESULT IMFMediaSession::Pause()</unmanaged>
            <unmanaged-short>IMFMediaSession::Pause</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSession.Stop">
            <summary>
            <p> </p><p>Stops the Media Session.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The operation cannot be performed in the Media Session's current state.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSession.Shutdown"/></strong></dt> </dl> </td><td> <p>The Media Session has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is asynchronous. When the operation completes, the Media Session sends an MESessionStopped event.</p>
            </remarks>
            <doc-id>ms701607</doc-id>
            <unmanaged>HRESULT IMFMediaSession::Stop()</unmanaged>
            <unmanaged-short>IMFMediaSession::Stop</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSession.Close">
            <summary>
            <p> </p><p>Closes the Media Session and releases all of the resources it is using.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSession.Shutdown"/></strong></dt> </dl> </td><td> <p>The Media Session has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is asynchronous. When the operation completes, the Media Session sends an MESessionClosed event.</p><p>After the <strong>Close</strong> method is called, the only valid methods on the Media Session are the following:</p><ul> <li> <p> <strong>IMFMediaSession::GetClock</strong> </p> </li> <li> <p> <strong>IMFMediaSession::GetFullTopology</strong> </p> </li> <li> <p> <strong>IMFMediaSession::GetSessionCapabilities</strong> </p> </li> <li> <p> <strong>IMFMediaSession::Shutdown</strong> </p> </li> </ul><p>All other methods return <see cref = "!:InvalidRequest"/>, or else queue an event with that error code.</p>
            </remarks>
            <doc-id>ms698928</doc-id>
            <unmanaged>HRESULT IMFMediaSession::Close()</unmanaged>
            <unmanaged-short>IMFMediaSession::Close</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSession.Shutdown">
            <summary>
            <p> </p><p>Shuts down the Media Session and releases all the resources used by the Media Session.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this method when you are done using the Media Session, before the final call to <strong>IUnknown::Release</strong>. Otherwise, your application will leak memory.</p><p>After this method is called, other <strong><see cref = "T:SharpDX.MediaFoundation.MediaSession"/></strong> methods return <see cref = "M:SharpDX.MediaFoundation.MediaSession.Shutdown"/>.</p>
            </remarks>
            <doc-id>ms697318</doc-id>
            <unmanaged>HRESULT IMFMediaSession::Shutdown()</unmanaged>
            <unmanaged-short>IMFMediaSession::Shutdown</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSession.GetClock(SharpDX.MediaFoundation.Clock@)">
            <summary>
            <p> </p><p>Retrieves the Media Session's presentation clock.</p>
            </summary>
            <param name = "clockOut"><dd> <p>Receives a reference to the presentation clock's <strong><see cref = "T:SharpDX.MediaFoundation.Clock"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_UNEXPECTED</strong></dt> </dl> </td><td> <p>The Media Session does not have a presentation clock.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSession.Shutdown"/></strong></dt> </dl> </td><td> <p>The Media Session has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The application can query the returned <strong><see cref = "T:SharpDX.MediaFoundation.Clock"/></strong> reference for the <strong><see cref = "T:SharpDX.MediaFoundation.PresentationClock"/></strong> interface. However, the application should not use this interface to control the state of the presentation clock. Instead, the application should always call the transport control methods on the Media Session's <strong><see cref = "T:SharpDX.MediaFoundation.MediaSession"/></strong> interface, such as <strong>Start</strong>, <strong>Stop</strong>, and <strong>Pause</strong>.</p>
            </remarks>
            <doc-id>bb970342</doc-id>
            <unmanaged>HRESULT IMFMediaSession::GetClock([Out] IMFClock** ppClock)</unmanaged>
            <unmanaged-short>IMFMediaSession::GetClock</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSession.GetSessionCapabilities(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the capabilities of the Media Session, based on the current presentation.</p>
            </summary>
            <param name = "dwCapsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more of the following flags.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MFSESSIONCAP_PAUSE</strong></dt> </dl> </td><td> <p>The Media Session can be paused.</p> </td></tr> <tr><td><dl> <dt><strong>MFSESSIONCAP_RATE_FORWARD</strong></dt> </dl> </td><td> <p>The Media Session supports forward playback at rates faster than 1.0.</p> </td></tr> <tr><td><dl> <dt><strong>MFSESSIONCAP_RATE_REVERSE</strong></dt> </dl> </td><td> <p>The Media Session supports reverse playback.</p> </td></tr> <tr><td><dl> <dt><strong>MFSESSIONCAP_SEEK</strong></dt> </dl> </td><td> <p>The Media Session can be seeked.</p> </td></tr> <tr><td><dl> <dt><strong>MFSESSIONCAP_START</strong></dt> </dl> </td><td> <p>The Media Session can be started.</p> </td></tr> </table> <p>?</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p><c>null</c> reference argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSession.Shutdown"/></strong></dt> </dl> </td><td> <p>The Media Session has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms696229</doc-id>
            <unmanaged>HRESULT IMFMediaSession::GetSessionCapabilities([Out] DWORD* pdwCaps)</unmanaged>
            <unmanaged-short>IMFMediaSession::GetSessionCapabilities</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSession.GetFullTopology(System.Int32,System.Int64,SharpDX.MediaFoundation.Topology@)">
            <summary>
            <p> Gets a topology from the Media Session.</p><p>This method can get the current topology or a queued topology.</p>
            </summary>
            <param name = "dwGetFullTopologyFlags"><dd> <p> Bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.SessionGetFullTopologyFlags"/></strong> enumeration. </p> </dd></param>
            <param name = "topoId"><dd> <p>The identifier of the topology. This parameter is ignored if the <em>dwGetFullTopologyFlags</em> parameter contains the <strong>MFSESSION_GETFULLTOPOLOGY_CURRENT</strong> flag. To get the identifier of a topology, call <strong>IMFTopology::GetTopologyID</strong>. </p> </dd></param>
            <param name = "fullTopologyOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Topology"/></strong> interface of the topology. The caller must release the interface. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSession.Shutdown"/></strong></dt> </dl> </td><td> <p> The Media Session has been shut down. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> If the <strong>MFSESSION_GETFULLTOPOLOGY_CURRENT</strong> flag is specified in the <em>dwGetFullTopologyFlags</em> parameter, the method returns the topology for the current presentation. Otherwise, the method searches all of the queued topologies for one that matches the identifier given in the <em>TopoId</em> parameter. </p><p> This method can be used to retrieve the topology for the current presentation or any pending presentations. It cannot be used to retrieve a topology that has already ended. </p><p> The topology returned in <em>ppFullTopo</em> is a full topology, not a partial topology. </p>
            </remarks>
            <doc-id>bb970422</doc-id>
            <unmanaged>HRESULT IMFMediaSession::GetFullTopology([In] DWORD dwGetFullTopologyFlags,[In] unsigned longlong TopoId,[Out] IMFTopology** ppFullTopology)</unmanaged>
            <unmanaged-short>IMFMediaSession::GetFullTopology</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaSink.Characteristics">
            <summary>
            <p> </p><p>Gets the characteristics of the media sink.</p>
            </summary>
            <remarks>
            <p> The characteristics of a media sink are fixed throughout the life time of the sink. </p>
            </remarks>
            <doc-id>ms701973</doc-id>
            <unmanaged>GetCharacteristics</unmanaged>
            <unmanaged-short>GetCharacteristics</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaSink.StreamSinkCount">
            <summary>
            <p> </p><p>Gets the number of stream sinks on this media sink.</p>
            </summary>
            <doc-id>ms703020</doc-id>
            <unmanaged>GetStreamSinkCount</unmanaged>
            <unmanaged-short>GetStreamSinkCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaSink.PresentationClock">
            <summary>
            <p> </p><p>Gets the presentation clock that was set on the media sink.</p>
            </summary>
            <doc-id>ms705665</doc-id>
            <unmanaged>GetPresentationClock / SetPresentationClock</unmanaged>
            <unmanaged-short>GetPresentationClock</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSink.GetCharacteristics(System.Int32@)">
            <summary>
            <p> </p><p>Gets the characteristics of the media sink.</p>
            </summary>
            <param name = "dwCharacteristicsRef"><dd> <p> Receives a bitwise <strong>OR</strong> of zero or more flags. The following flags are defined: </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong>MEDIASINK_FIXED_STREAMS</strong></strong></dt> <dt>0x00000001</dt> </dl> </td><td> <p> The media sink has a fixed number of streams. It does not support the <strong>IMFMediaSink::AddStreamSink</strong> and <strong>IMFMediaSink::RemoveStreamSink</strong> methods. This flag is a hint to the application. </p> </td></tr> <tr><td><dl> <dt><strong><strong>MEDIASINK_CANNOT_MATCH_CLOCK</strong></strong></dt> <dt>0x00000002</dt> </dl> </td><td> <p>The media sink cannot match rates with an external clock.</p> <p>For best results, this media sink should be used as the time source for the presentation clock. If any other time source is used, the media sink cannot match rates with the clock, with poor results (for example, glitching).</p> <p>This flag should be used sparingly, because it limits how the pipeline can be configured.</p> <p>For more information about the presentation clock, see Presentation Clock.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MEDIASINK_RATELESS</strong></strong></dt> <dt>0x00000004</dt> </dl> </td><td> <p>The media sink is rateless. It consumes samples as quickly as possible, and does not synchronize itself to a presentation clock.</p> <p>Most archiving sinks are rateless.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MEDIASINK_CLOCK_REQUIRED</strong></strong></dt> <dt>0x00000008</dt> </dl> </td><td> <p>The media sink requires a presentation clock. The presentation clock is set by calling the media sink's <strong>IMFMediaSink::SetPresentationClock</strong> method.</p> <p>This flag is obsolete, because all media sinks must support the <strong>SetPresentationClock</strong> method, even if the media sink ignores the clock (as in a rateless media sink).</p> </td></tr> <tr><td><dl> <dt><strong><strong>MEDIASINK_CAN_PREROLL</strong></strong></dt> <dt>0x00000010</dt> </dl> </td><td> <p> The media sink can accept preroll samples before the presentation clock starts. The media sink exposes the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSinkPreroll"/></strong> interface. </p> </td></tr> <tr><td><dl> <dt><strong><strong>MEDIASINK_REQUIRE_REFERENCE_MEDIATYPE</strong></strong></dt> <dt>0x00000020</dt> </dl> </td><td> <p>The first stream sink (index 0) is a reference stream. The reference stream must have a media type before the media types can be set on the other stream sinks.</p> </td></tr> </table> <p>?</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "M:SharpDX.MediaFoundation.MediaSink.Shutdown"/></strong></strong></dt> </dl> </td><td> <p> The media sink's <strong>Shutdown</strong> method has been called. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> The characteristics of a media sink are fixed throughout the life time of the sink. </p>
            </remarks>
            <doc-id>ms701973</doc-id>
            <unmanaged>HRESULT IMFMediaSink::GetCharacteristics([Out] DWORD* pdwCharacteristics)</unmanaged>
            <unmanaged-short>IMFMediaSink::GetCharacteristics</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSink.AddStreamSink(System.Int32,SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.StreamSink@)">
            <summary>
            <p> </p><p>Adds a new stream sink to the media sink.</p>
            </summary>
            <param name = "dwStreamSinkIdentifier"><dd> <p>Identifier for the new stream. The value is arbitrary but must be unique.</p> </dd></param>
            <param name = "mediaTypeRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface, specifying the media type for the stream. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "streamSinkOut"><dd> <p>Receives a reference to the new stream sink's <strong><see cref = "T:SharpDX.MediaFoundation.StreamSink"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The specified stream identifier is not valid.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSink.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:StreamsInkExists"/></strong></dt> </dl> </td><td> <p>There is already a stream sink with the same stream identifier.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:StreamsInksFixed"/></strong></dt> </dl> </td><td> <p>This media sink has a fixed set of stream sinks. New stream sinks cannot be added.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Not all media sinks support this method. If the media sink does not support this method, the <strong>IMFMediaSink::GetCharacteristics</strong> method returns the MEDIASINK_FIXED_STREAMS flag.</p><p>If <em>pMediaType</em> is <strong><c>null</c></strong>, use the <strong><see cref = "T:SharpDX.MediaFoundation.MediaTypeHandler"/></strong> interface to set the media type. Call <strong>IMFStreamSink::GetMediaTypeHandler</strong> to get a reference to the interface.</p>
            </remarks>
            <doc-id>ms694890</doc-id>
            <unmanaged>HRESULT IMFMediaSink::AddStreamSink([In] DWORD dwStreamSinkIdentifier,[In, Optional] IMFMediaType* pMediaType,[Out] IMFStreamSink** ppStreamSink)</unmanaged>
            <unmanaged-short>IMFMediaSink::AddStreamSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSink.RemoveStreamSink(System.Int32)">
            <summary>
            <p> </p><p>Removes a stream sink from the media sink.</p>
            </summary>
            <param name = "dwStreamSinkIdentifier"><dd> <p>Identifier of the stream to remove. The stream identifier is defined when you call <strong>IMFMediaSink::AddStreamSink</strong> to add the stream sink.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>This particular stream sink cannot be removed.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The stream number is not valid.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotInitializeD"/></strong></dt> </dl> </td><td> <p>The media sink has not been initialized.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSink.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:StreamsInksFixed"/></strong></dt> </dl> </td><td> <p>This media sink has a fixed set of stream sinks. Stream sinks cannot be removed.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>After this method is called, the corresponding stream sink object is no longer valid. The <strong>IMFMediaSink::GetStreamSinkByIndex</strong> and <strong>IMFMediaSink::GetStreamSinkById</strong> methods will no longer return that stream sink. You can re-use the stream identifier if you add another stream (by calling <strong>AddStreamSink</strong>).</p><p>Not all media sinks support this method. If the media sink does not support this method, the <strong>IMFMediaSink::GetCharacteristics</strong> method returns the MEDIASINK_FIXED_STREAMS flag.</p><p>In some cases, the media sink supports this method but does not allow every stream sink to be removed. (For example, it might not allow stream 0 to be removed.)</p>
            </remarks>
            <doc-id>ms705627</doc-id>
            <unmanaged>HRESULT IMFMediaSink::RemoveStreamSink([In] DWORD dwStreamSinkIdentifier)</unmanaged>
            <unmanaged-short>IMFMediaSink::RemoveStreamSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSink.GetStreamSinkCount(System.Int32@)">
            <summary>
            <p> </p><p>Gets the number of stream sinks on this media sink.</p>
            </summary>
            <param name = "cStreamSinkCountRef"><dd> <p>Receives the number of stream sinks.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSink.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms703020</doc-id>
            <unmanaged>HRESULT IMFMediaSink::GetStreamSinkCount([Out] DWORD* pcStreamSinkCount)</unmanaged>
            <unmanaged-short>IMFMediaSink::GetStreamSinkCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSink.GetStreamSinkByIndex(System.Int32,SharpDX.MediaFoundation.StreamSink@)">
            <summary>
            <p> </p><p>Gets a stream sink, specified by index.</p>
            </summary>
            <param name = "dwIndex"><dd> <p>Zero-based index of the stream. To get the number of streams, call <strong>IMFMediaSink::GetStreamSinkCount</strong>.</p> </dd></param>
            <param name = "streamSinkOut"><dd> <p>Receives a reference to the stream's <strong><see cref = "T:SharpDX.MediaFoundation.StreamSink"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidIndex"/></strong></dt> </dl> </td><td> <p>Invalid index.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSink.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Enumerating stream sinks is not a thread-safe operation, because stream sinks can be added or removed between calls to this method.</p>
            </remarks>
            <doc-id>ms693512</doc-id>
            <unmanaged>HRESULT IMFMediaSink::GetStreamSinkByIndex([In] DWORD dwIndex,[Out] IMFStreamSink** ppStreamSink)</unmanaged>
            <unmanaged-short>IMFMediaSink::GetStreamSinkByIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSink.GetStreamSinkById(System.Int32,SharpDX.MediaFoundation.StreamSink@)">
            <summary>
            <p> </p><p>Gets a stream sink, specified by stream identifier.</p>
            </summary>
            <param name = "dwStreamSinkIdentifier"><dd> <p>Stream identifier of the stream sink.</p> </dd></param>
            <param name = "streamSinkOut"><dd> <p>Receives a reference to the stream's <strong><see cref = "T:SharpDX.MediaFoundation.StreamSink"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>The stream identifier is not valid.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSink.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If you add a stream sink by calling the <strong>IMFMediaSink::AddStreamSink</strong> method, the stream identifier is specified in the <em>dwStreamSinkIdentifier</em> parameter of that method. If the media sink has a fixed set of streams, the media sink assigns the stream identifiers.</p><p>To enumerate the streams by index number instead of stream identifier, call <strong>IMFMediaSink::GetStreamSinkByIndex</strong>.</p>
            </remarks>
            <doc-id>ms695360</doc-id>
            <unmanaged>HRESULT IMFMediaSink::GetStreamSinkById([In] DWORD dwStreamSinkIdentifier,[Out] IMFStreamSink** ppStreamSink)</unmanaged>
            <unmanaged-short>IMFMediaSink::GetStreamSinkById</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSink.SetPresentationClock(SharpDX.MediaFoundation.PresentationClock)">
            <summary>
            <p> </p><p>Sets the presentation clock on the media sink.</p>
            </summary>
            <param name = "presentationClockRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.PresentationClock"/></strong> interface of the presentation clock, or <strong><c>null</c></strong>. If the value is <strong><c>null</c></strong>, the media sink stops listening to the presentaton clock that was previously set, if any.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ClockNoTimeSource"/></strong></dt> </dl> </td><td> <p>The presentation clock does not have a time source. Call <strong>SetTimeSource</strong> on the presentation clock.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSink.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>During streaming, the media sink attempts to match rates with the presentation clock. Ideally, the media sink presents samples at the correct time according to the presentation clock and does not fall behind. Rateless media sinks are an exception to this rule, as they consume samples as quickly as possible and ignore the clock. If the sink is rateless, the <strong>IMFMediaSink::GetCharacteristics</strong> method returns the MEDIASINK_RATELESS flag.</p><p>The presentation clock must have a time source. Before calling this method, call <strong>IMFPresentationClock::SetTimeSource</strong> on the presentation clock to set the presentation time source. Some media sinks provide time sources; therefore, the media sink might be the time source for its own presentation clock. Regardless of what object provides the time source, however, the media sink must attempt to match rates with the clock specified in <em>pPresentationClock</em>. If a media sink cannot match rates with an external time source, the media sink's <strong>IMFMediaSink::GetCharacteristics</strong> method retrieves the MEDIASINK_CANNOT_MATCH_CLOCK flag. In this case, <strong>SetPresentationClock</strong> will still succeed, but the results will not be optimal. The sink might not render samples quickly enough to match rates with the presentation clock.</p><p>If <em>pPresentationClock</em> is non-<strong><c>null</c></strong>, the media sink must register for clock state notifications, by calling <strong>IMFPresentationClock::AddClockStateSink</strong> on the presentation clock. If the method is called again with a new presentation clock, or if <em>pPresentationClock</em> is <strong><c>null</c></strong>, the media sink must call <strong>IMFPresentationClock::RemoveClockStateSink</strong> to deregister itself from the previous clock.</p><p>All media sinks must support this method.</p>
            </remarks>
            <doc-id>ms700160</doc-id>
            <unmanaged>HRESULT IMFMediaSink::SetPresentationClock([In, Optional] IMFPresentationClock* pPresentationClock)</unmanaged>
            <unmanaged-short>IMFMediaSink::SetPresentationClock</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSink.GetPresentationClock(SharpDX.MediaFoundation.PresentationClock@)">
            <summary>
            <p> </p><p>Gets the presentation clock that was set on the media sink.</p>
            </summary>
            <param name = "presentationClockOut"><dd> <p>Receives a reference to the presentation clock's <strong><see cref = "T:SharpDX.MediaFoundation.PresentationClock"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NoClock"/></strong></dt> </dl> </td><td> <p>No clock has been set. To set the presentation clock, call <strong>IMFMediaSink::SetPresentationClock</strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSink.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms705665</doc-id>
            <unmanaged>HRESULT IMFMediaSink::GetPresentationClock([Out] IMFPresentationClock** ppPresentationClock)</unmanaged>
            <unmanaged-short>IMFMediaSink::GetPresentationClock</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSink.Shutdown">
            <summary>
            <p> </p><p>Shuts down the media sink and releases the resources it is using.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSink.Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink was shut down.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the application creates the media sink, it is responsible for calling <strong>Shutdown</strong> to avoid memory or resource leaks. In most applications, however, the application creates an activation object for the media sink, and the Media Session uses that object to create the media sink. In that case, the Media Session ? not the application ? shuts down the media sink. (For more information, see Activation Objects.)</p><p>After this method returns, all methods on the media sink return <see cref = "M:SharpDX.MediaFoundation.MediaSink.Shutdown"/>,  except for <strong><see cref = "T:SharpDX.IUnknown"/></strong> methods and <strong><see cref = "T:SharpDX.MediaFoundation.MediaEventGenerator"/></strong> methods. The sink will not raise any events after this method is called.</p>
            </remarks>
            <doc-id>ms702084</doc-id>
            <unmanaged>HRESULT IMFMediaSink::Shutdown()</unmanaged>
            <unmanaged-short>IMFMediaSink::Shutdown</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSinkPreroll.NotifyPreroll(System.Int64)">
            <summary>
            <p> Notifies the media sink that the presentation clock is about to start. </p>
            </summary>
            <param name = "hnsUpcomingStartTime"><dd> <p> The upcoming start time for the presentation clock, in 100-nanosecond units. This time is the same value that will be given to the <strong>IMFPresentationClock::Start</strong> method when the presentation clock is started. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> After this method is called, the media sink sends any number of MEStreamSinkRequestSample events to request samples, until is has enough preroll data. When it has enough preroll data, the media sink sends an MEStreamSinkPrerolled event. This event signals that the client can start the presentation clock. </p><p> During preroll, the media sink can prepare the samples that it receives, so that they are ready to be rendered. It does not actually render any samples until the clock starts. </p>
            </remarks>
            <doc-id>ms703799</doc-id>
            <unmanaged>HRESULT IMFMediaSinkPreroll::NotifyPreroll([In] longlong hnsUpcomingStartTime)</unmanaged>
            <unmanaged-short>IMFMediaSinkPreroll::NotifyPreroll</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaSource.Characteristics">
            <summary>
            <p> </p><p>Retrieves the characteristics of the media source.</p>
            </summary>
            <remarks>
            <p>The characteristics of a media source can change at any time. If this happens, the source sends an MESourceCharacteristicsChanged event.</p>
            </remarks>
            <doc-id>ms703148</doc-id>
            <unmanaged>GetCharacteristics</unmanaged>
            <unmanaged-short>GetCharacteristics</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSource.GetCharacteristics(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the characteristics of the media source.</p>
            </summary>
            <param name = "dwCharacteristicsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSourceCharacteristics"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSource.Shutdown"/></strong></dt> </dl> </td><td> <p>The media source's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The characteristics of a media source can change at any time. If this happens, the source sends an MESourceCharacteristicsChanged event.</p>
            </remarks>
            <doc-id>ms703148</doc-id>
            <unmanaged>HRESULT IMFMediaSource::GetCharacteristics([Out] DWORD* pdwCharacteristics)</unmanaged>
            <unmanaged-short>IMFMediaSource::GetCharacteristics</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSource.CreatePresentationDescriptor(SharpDX.MediaFoundation.PresentationDescriptor@)">
            <summary>
            <p> </p><p>Retrieves a copy of the media source's presentation descriptor. Applications use the presentation descriptor to select streams and to get information about the source content.</p>
            </summary>
            <param name = "presentationDescriptorOut"><dd> <p>Receives a reference to the presentation descriptor's <strong><see cref = "T:SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSource.Shutdown"/></strong></dt> </dl> </td><td> <p>The media source's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The presentation descriptor contains the media source's default settings for the presentation. The application can change these settings by selecting or deselecting streams, or by changing the media type on a stream. Do not modify the presentation descriptor unless the source is stopped. The changes take affect when the source's <strong>IMFMediaSource::Start</strong> method is called.</p>
            </remarks>
            <doc-id>ms702261</doc-id>
            <unmanaged>HRESULT IMFMediaSource::CreatePresentationDescriptor([Out] IMFPresentationDescriptor** ppPresentationDescriptor)</unmanaged>
            <unmanaged-short>IMFMediaSource::CreatePresentationDescriptor</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSource.Start(SharpDX.MediaFoundation.PresentationDescriptor,System.Nullable{System.Guid},System.Nullable{SharpDX.Win32.Variant})">
            <summary>
            <p> </p><p>Starts, seeks, or restarts the media source by specifying where to start playback.</p>
            </summary>
            <param name = "presentationDescriptorRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the media source's presentation descriptor. To get the presentation descriptor, call <strong>IMFMediaSource::CreatePresentationDescriptor</strong>. You can modify the presentation descriptor before calling <strong>Start</strong>, to select or deselect streams or change the media types. </p> </dd></param>
            <param name = "guidTimeFormatRef"><dd> <p> Pointer to a <see cref = "T:System.Guid"/> that specifies the time format. The time format defines the units for the <em>pvarStartPosition</em> parameter. If the value <em></em> is <strong>GUID_NULL</strong>, the time format is 100-nanosecond units. Some media sources might support additional time format GUIDs. This parameter can be <strong><c>null</c></strong>. If the value is <strong><c>null</c></strong>, it is equalivent to <strong>GUID_NULL</strong>. </p> </dd></param>
            <param name = "varStartPositionRef"><dd> <p> Specifies where to start playback. The units of this parameter are indicated by the time format given in <em>pguidTimeFormat</em>. If the time format is <strong>GUID_NULL</strong>, the variant type must be <strong>VT_I8</strong> or <strong>VT_EMPTY</strong>. Use <strong>VT_I8</strong> to specify a new starting position, in 100-nanosecond units. Use <strong>VT_EMPTY</strong> to start from the current position. Other time formats might use other <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> types. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:AsfOufOfRange"/></strong></dt> </dl> </td><td> <p> The start position is past the end of the presentation (ASF media source). </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:HwMftFailedStartStreaming"/></strong></dt> </dl> </td><td> <p>A hardware device was unable to start streaming. This error code can be returned by a media source that represents a hardware device, such as a camera. For example, if the camera is already being used by another application, the method might return this error code.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p> The start request is not valid. For example, the start position is past the end of the presentation. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSource.Shutdown"/></strong></dt> </dl> </td><td> <p> The media source's <strong>Shutdown</strong> method has been called. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedTimeFormat"/></strong></dt> </dl> </td><td> <p> The media source does not support the time format specified in <em>pguidTimeFormat</em>. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is asynchronous. If the operation succeeds, the media source sends the following events:</p><ul> <li> For each new stream, the source sends an MENewStream event. This event is sent for the first <strong>Start</strong> call in which the stream appears. The event data is a reference to the stream's <strong><see cref = "T:SharpDX.MediaFoundation.MediaStream"/></strong> interface. </li> <li> For each <em>updated</em> stream, the source sends an MEUpdatedStream event. A stream is updated if the stream already existed when <strong>Start</strong> was called (for example, if the application seeks during playback). The event data is a reference to the stream's <strong><see cref = "T:SharpDX.MediaFoundation.MediaStream"/></strong> interface. </li> <li> If the previous state was stopped, the source sends an MESourceStarted event. </li> <li> If the previous state was started or paused and the starting position is the current position (<strong>VT_EMPTY</strong>), the source sends an MESourceStarted event. </li> <li> If the previous state was started or paused, and a new starting position is specified, the source sends an MESourceSeeked event. </li> <li> If the source sends an MESourceStarted event, each media stream sends an MEStreamStarted event. If the source sends an MESourceSeeked event, each stream sends an MEStreamSeeked event. </li> </ul><p> If the start operation fails asynchronously (after the method returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>), the media source sends an MESourceStarted event that contains a failure code, without sending any of the other events listed here. If the method fails synchronously (returns an error code), no events are raised. </p><p> A call to <strong>Start</strong> results in a <em>seek</em> if the previous state was started or paused, and the new starting position is not <strong>VT_EMPTY</strong>. Not every media source can seek. If a media source can seek, the <strong>IMFMediaSource::GetCharacteristics</strong> method returns the <strong>MFMEDIASOURCE_CAN_SEEK</strong> flag. </p><p> Events from the media source are not synchronized with events from the media streams. If you seek a media source, therefore, you can still receive samples from the earlier position after getting the MESourceSeeked event. If you need to synchronize the operations, wait for the stream event, MEStreamSeeked, which marks the exact point in the stream where the seek occurs. </p>
            </remarks>
            <doc-id>ms694101</doc-id>
            <unmanaged>HRESULT IMFMediaSource::Start([In, Optional] IMFPresentationDescriptor* pPresentationDescriptor,[In, Optional] const GUID* pguidTimeFormat,[In, Optional] const PROPVARIANT* pvarStartPosition)</unmanaged>
            <unmanaged-short>IMFMediaSource::Start</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSource.Stop">
            <summary>
            <p> </p><p>Stops all active streams in the media source.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSource.Shutdown"/></strong></dt> </dl> </td><td> <p>The media source's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is asynchronous. When the operation completes, the media source sends and MESourceStopped event, and every active stream sends an MEStreamStopped event. If the method returns a failure code, no events are raised.</p><p>When a media source is stopped, its current position reverts to zero. After that, if the <strong>Start</strong> method is called with VT_EMPTY for the starting position, playback starts from the beginning of the presentation.</p><p>While the source is stopped, no streams produce data.</p>
            </remarks>
            <doc-id>ms702045</doc-id>
            <unmanaged>HRESULT IMFMediaSource::Stop()</unmanaged>
            <unmanaged-short>IMFMediaSource::Stop</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSource.Pause">
            <summary>
            <p> </p><p>Pauses all active streams in the media source.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStateTransition"/></strong></dt> </dl> </td><td> <p>Invalid state transition. The media source must be in the started state.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.MediaSource.Shutdown"/></strong></dt> </dl> </td><td> <p>The media source's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is asynchronous. When the operation completes, the media source sends and MESourcePaused event, and every active stream sends an MEStreamPaused event. If the method returns a failure code, no events are raised.</p><p>The media source must be in the started state. The method fails if the media source is paused or stopped.</p><p>While the source is paused, calls to <strong>IMFMediaStream::RequestSample</strong> succeed, but the streams will not deliver any samples until after the source is started again. Note that the source's event queue is not serialized with the stream event queues, so the client might receive some samples after the MESourcePaused event, due to multi-threading issues. But the client will not receive any samples from a stream after the MEStreamPaused event.</p><p>Not every media source can pause. If a media source can pause, the <strong>IMFMediaSource::GetCharacteristics</strong> method returns the MFMEDIASOURCE_CAN_PAUSE flag.</p>
            </remarks>
            <doc-id>ms694275</doc-id>
            <unmanaged>HRESULT IMFMediaSource::Pause()</unmanaged>
            <unmanaged-short>IMFMediaSource::Pause</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSource.Shutdown">
            <summary>
            <p> </p><p>Shuts down the media source and releases the resources it is using.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the application creates the media source, either directly or through the source resolver, the application is responsible for calling <strong>Shutdown</strong> to avoid memory or resource leaks.</p><p>After this method is called, methods on the media source and all of its media streams return <see cref = "M:SharpDX.MediaFoundation.MediaSource.Shutdown"/> (except for <strong><see cref = "T:SharpDX.IUnknown"/></strong> methods).</p>
            </remarks>
            <doc-id>ms703110</doc-id>
            <unmanaged>HRESULT IMFMediaSource::Shutdown()</unmanaged>
            <unmanaged-short>IMFMediaSource::Shutdown</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSource2.SetMediaType(System.Int32,SharpDX.MediaFoundation.MediaType)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwStreamID">No documentation.</param>
            <param name = "mediaTypeRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaSource2::SetMediaType([In] DWORD dwStreamID,[In] IMFMediaType* pMediaType)</unmanaged>
            <unmanaged-short>IMFMediaSource2::SetMediaType</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaSourceEx.SourceAttributes">
            <summary>
            <p>Gets an attribute store for the media source.</p>
            </summary>
            <remarks>
            <p>Use the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> reference to get or set attributes that apply to the entire source. For stream-level attributes, use the <strong>IMFMediaSourceEx::GetStreamAttributes</strong> method instead.</p>
            </remarks>
            <doc-id>hh448030</doc-id>
            <unmanaged>GetSourceAttributes</unmanaged>
            <unmanaged-short>GetSourceAttributes</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaSourceEx.D3DManager">
            <summary>
            <p>Sets a reference to the Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager on the media source.</p>
            </summary>
            <doc-id>hh448032</doc-id>
            <unmanaged>SetD3DManager</unmanaged>
            <unmanaged-short>SetD3DManager</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourceEx.GetSourceAttributes(SharpDX.MediaFoundation.MediaAttributes@)">
            <summary>
            <p>Gets an attribute store for the media source.</p>
            </summary>
            <param name = "attributesOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>The media source does not support source-level attributes.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Use the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> reference to get or set attributes that apply to the entire source. For stream-level attributes, use the <strong>IMFMediaSourceEx::GetStreamAttributes</strong> method instead.</p>
            </remarks>
            <doc-id>hh448030</doc-id>
            <unmanaged>HRESULT IMFMediaSourceEx::GetSourceAttributes([Out] IMFAttributes** ppAttributes)</unmanaged>
            <unmanaged-short>IMFMediaSourceEx::GetSourceAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourceEx.GetStreamAttributes(System.Int32,SharpDX.MediaFoundation.MediaAttributes@)">
            <summary>
            <p>Gets an attribute store for a stream on the media source.</p>
            </summary>
            <param name = "dwStreamIdentifier"><dd> <p>The identifier of the stream. To get the identifier, call <strong>IMFStreamDescriptor::GetStreamIdentifier</strong> on the stream descriptor.</p> </dd></param>
            <param name = "attributesOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>The media source does not support stream-level attributes.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>Invalid stream identifier.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Use the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> reference to get or set attributes that apply to the specified stream. For attributes that apply to the entire source, use the <strong>IMFMediaSourceEx::GetSourceAttributes</strong> method instead.</p>
            </remarks>
            <doc-id>hh448031</doc-id>
            <unmanaged>HRESULT IMFMediaSourceEx::GetStreamAttributes([In] DWORD dwStreamIdentifier,[Out] IMFAttributes** ppAttributes)</unmanaged>
            <unmanaged-short>IMFMediaSourceEx::GetStreamAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourceEx.SetD3DManager(SharpDX.IUnknown)">
            <summary>
            <p>Sets a reference to the Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager on the media source.</p>
            </summary>
            <param name = "managerRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of the DXGI Manager. The media source should query this reference for the <strong><see cref = "T:SharpDX.MediaFoundation.DXGIDeviceManager"/></strong> interface.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>The media source does not support source-level attributes.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>hh448032</doc-id>
            <unmanaged>HRESULT IMFMediaSourceEx::SetD3DManager([In, Optional] IUnknown* pManager)</unmanaged>
            <unmanaged-short>IMFMediaSourceEx::SetD3DManager</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaSourceExtension.SourceBuffers">
            <summary>
            <p>Gets the collection of source buffers associated with this media source.</p>
            </summary>
            <doc-id>dn280736</doc-id>
            <unmanaged>GetSourceBuffers</unmanaged>
            <unmanaged-short>GetSourceBuffers</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaSourceExtension.ActiveSourceBuffers">
            <summary>
            <p>Gets the source buffers that are actively supplying media data to the media source.</p>
            </summary>
            <doc-id>dn280732</doc-id>
            <unmanaged>GetActiveSourceBuffers</unmanaged>
            <unmanaged-short>GetActiveSourceBuffers</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaSourceExtension.ReadyState">
            <summary>
            <p>Gets the ready state of the media source.</p>
            </summary>
            <doc-id>dn280734</doc-id>
            <unmanaged>GetReadyState</unmanaged>
            <unmanaged-short>GetReadyState</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaSourceExtension.Duration">
            <summary>
            <p>Gets or sets the duration of the media source in 100-nanosecond units.</p>
            </summary>
            <doc-id>dn280733</doc-id>
            <unmanaged>GetDuration / SetDuration</unmanaged>
            <unmanaged-short>GetDuration</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaSourceExtension.EndOfStream">
            <summary>
            <p>Indicate that the end of the media stream has been reached. </p>
            </summary>
            <doc-id>dn280740</doc-id>
            <unmanaged>SetEndOfStream</unmanaged>
            <unmanaged-short>SetEndOfStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourceExtension.GetSourceBuffers">
            <summary>
            <p>Gets the collection of source buffers associated with this media source.</p>
            </summary>
            <returns><p>The collection of source buffers.</p></returns>
            <doc-id>dn280736</doc-id>
            <unmanaged>IMFSourceBufferList* IMFMediaSourceExtension::GetSourceBuffers()</unmanaged>
            <unmanaged-short>IMFMediaSourceExtension::GetSourceBuffers</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourceExtension.GetActiveSourceBuffers">
            <summary>
            <p>Gets the source buffers that are actively supplying media data to the media source.</p>
            </summary>
            <returns><p>The list of active source buffers.</p></returns>
            <doc-id>dn280732</doc-id>
            <unmanaged>IMFSourceBufferList* IMFMediaSourceExtension::GetActiveSourceBuffers()</unmanaged>
            <unmanaged-short>IMFMediaSourceExtension::GetActiveSourceBuffers</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourceExtension.GetReadyState">
            <summary>
            <p>Gets the ready state of the media source.</p>
            </summary>
            <returns><p>The ready state of the media source.</p></returns>
            <doc-id>dn280734</doc-id>
            <unmanaged>MF_MSE_READY IMFMediaSourceExtension::GetReadyState()</unmanaged>
            <unmanaged-short>IMFMediaSourceExtension::GetReadyState</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourceExtension.GetDuration">
            <summary>
            <p>Gets the duration of the media source in 100-nanosecond units.</p>
            </summary>
            <returns><p>The duration of the media source in 100-nanosecond units. </p></returns>
            <doc-id>dn280733</doc-id>
            <unmanaged>double IMFMediaSourceExtension::GetDuration()</unmanaged>
            <unmanaged-short>IMFMediaSourceExtension::GetDuration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourceExtension.SetDuration(System.Double)">
            <summary>
            <p>Sets the duration of the media source in 100-nanosecond units.</p>
            </summary>
            <param name = "duration"><dd> <p>The duration of the media source in 100-nanosecond units.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280739</doc-id>
            <unmanaged>HRESULT IMFMediaSourceExtension::SetDuration([In] double duration)</unmanaged>
            <unmanaged-short>IMFMediaSourceExtension::SetDuration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourceExtension.AddSourceBuffer(System.String,SharpDX.MediaFoundation.SourceBufferNotify,SharpDX.MediaFoundation.SourceBuffer@)">
            <summary>
            <p>Adds a <strong><see cref = "T:SharpDX.MediaFoundation.SourceBuffer"/></strong> to the collection of buffers associated with the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSourceExtension"/></strong>.</p>
            </summary>
            <param name = "type">No documentation.</param>
            <param name = "notifyRef">No documentation.</param>
            <param name = "sourceBufferOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280731</doc-id>
            <unmanaged>HRESULT IMFMediaSourceExtension::AddSourceBuffer([In] wchar_t* type,[In] IMFSourceBufferNotify* pNotify,[Out] IMFSourceBuffer** ppSourceBuffer)</unmanaged>
            <unmanaged-short>IMFMediaSourceExtension::AddSourceBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourceExtension.RemoveSourceBuffer(SharpDX.MediaFoundation.SourceBuffer)">
            <summary>
            <p>Removes the specified source buffer from the collection of source buffers managed by the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSourceExtension"/></strong> object.</p>
            </summary>
            <param name = "sourceBufferRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280738</doc-id>
            <unmanaged>HRESULT IMFMediaSourceExtension::RemoveSourceBuffer([In] IMFSourceBuffer* pSourceBuffer)</unmanaged>
            <unmanaged-short>IMFMediaSourceExtension::RemoveSourceBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourceExtension.SetEndOfStream(SharpDX.MediaFoundation.MultisampledEError)">
            <summary>
            <p>Indicate that the end of the media stream has been reached. </p>
            </summary>
            <param name = "error"><dd> <p>Used to pass error information.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280740</doc-id>
            <unmanaged>HRESULT IMFMediaSourceExtension::SetEndOfStream([In] MF_MSE_ERROR error)</unmanaged>
            <unmanaged-short>IMFMediaSourceExtension::SetEndOfStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourceExtension.IsTypeSupported(System.String)">
            <summary>
            <p>Gets a value that indicates if the specified MIME type is supported by the media source.</p>
            </summary>
            <param name = "type"><dd> <p>The media type to check support for.</p> </dd></param>
            <returns><p><strong>true</strong> if the media type is supported; otherwise, <strong>false</strong>.</p></returns>
            <doc-id>dn280737</doc-id>
            <unmanaged>BOOL IMFMediaSourceExtension::IsTypeSupported([In] wchar_t* type)</unmanaged>
            <unmanaged-short>IMFMediaSourceExtension::IsTypeSupported</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourceExtension.GetSourceBuffer(System.Int32)">
            <summary>
            <p>Gets the <strong><see cref = "T:SharpDX.MediaFoundation.SourceBuffer"/></strong> at the specified index in the collection of buffers.</p>
            </summary>
            <param name = "dwStreamIndex">No documentation.</param>
            <returns><p>The source buffer.</p></returns>
            <doc-id>dn280735</doc-id>
            <unmanaged>IMFSourceBuffer* IMFMediaSourceExtension::GetSourceBuffer([In] DWORD dwStreamIndex)</unmanaged>
            <unmanaged-short>IMFMediaSourceExtension::GetSourceBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourceExtensionLiveSeekableRange.SetLiveSeekableRange(System.Double,System.Double)">
            <summary>
            No documentation.
            </summary>
            <param name = "start">No documentation.</param>
            <param name = "end">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaSourceExtensionLiveSeekableRange::SetLiveSeekableRange([In] double start,[In] double end)</unmanaged>
            <unmanaged-short>IMFMediaSourceExtensionLiveSeekableRange::SetLiveSeekableRange</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourceExtensionLiveSeekableRange.ClearLiveSeekableRange">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaSourceExtensionLiveSeekableRange::ClearLiveSeekableRange()</unmanaged>
            <unmanaged-short>IMFMediaSourceExtensionLiveSeekableRange::ClearLiveSeekableRange</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourceExtensionNotify.OnSourceOpen">
            <summary>
            <p>Used to indicate that the  media source has opened.</p>
            </summary>
            <doc-id>dn280730</doc-id>
            <unmanaged>void IMFMediaSourceExtensionNotify::OnSourceOpen()</unmanaged>
            <unmanaged-short>IMFMediaSourceExtensionNotify::OnSourceOpen</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourceExtensionNotify.OnSourceEnded">
            <summary>
            <p>Used to indicate that the media source has ended.</p>
            </summary>
            <doc-id>dn280729</doc-id>
            <unmanaged>void IMFMediaSourceExtensionNotify::OnSourceEnded()</unmanaged>
            <unmanaged-short>IMFMediaSourceExtensionNotify::OnSourceEnded</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourceExtensionNotify.OnSourceClose">
            <summary>
            <p>Used to indicate that the media source has closed.</p>
            </summary>
            <doc-id>dn280728</doc-id>
            <unmanaged>void IMFMediaSourceExtensionNotify::OnSourceClose()</unmanaged>
            <unmanaged-short>IMFMediaSourceExtensionNotify::OnSourceClose</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourcePresentationProvider.ForceEndOfPresentation(SharpDX.MediaFoundation.PresentationDescriptor)">
            <summary>
            <p> </p><p>Notifies the source when playback has reached the end of a segment. For timelines, this corresponds to reaching a mark-out point.</p>
            </summary>
            <param name = "presentationDescriptorRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the presentation descriptor for the segment that has ended.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms705639</doc-id>
            <unmanaged>HRESULT IMFMediaSourcePresentationProvider::ForceEndOfPresentation([In, Optional] IMFPresentationDescriptor* pPresentationDescriptor)</unmanaged>
            <unmanaged-short>IMFMediaSourcePresentationProvider::ForceEndOfPresentation</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaSourceTopologyProvider.GetMediaSourceTopology(SharpDX.MediaFoundation.PresentationDescriptor,SharpDX.MediaFoundation.Topology@)">
            <summary>
            <p> </p><p>Returns a topology for a media source that builds an internal topology.</p>
            </summary>
            <param name = "presentationDescriptorRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the media source's presentation descriptor. To get this reference, either call <strong>IMFMediaSource::CreatePresentationDescriptor</strong> on the media source, or get the reference from the MENewPresentation event.</p> </dd></param>
            <param name = "topologyOut"><dd> <p>Receives a reference to the topology's <strong><see cref = "T:SharpDX.MediaFoundation.Topology"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument. For example, a <strong><c>null</c></strong> input parameter, or the presentation descriptor is not valid.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970383</doc-id>
            <unmanaged>HRESULT IMFMediaSourceTopologyProvider::GetMediaSourceTopology([In, Optional] IMFPresentationDescriptor* pPresentationDescriptor,[Out] IMFTopology** ppTopology)</unmanaged>
            <unmanaged-short>IMFMediaSourceTopologyProvider::GetMediaSourceTopology</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaStream.MediaSource">
            <summary>
            <p> </p><p>Retrieves a reference to the media source that created this media stream.</p>
            </summary>
            <doc-id>ms705668</doc-id>
            <unmanaged>GetMediaSource</unmanaged>
            <unmanaged-short>GetMediaSource</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaStream.StreamDescriptor">
            <summary>
            <p> </p><p>Retrieves a stream descriptor for this media stream.</p>
            </summary>
            <remarks>
            <p>Do not modify the stream descriptor. To change the presentation, call <strong>IMFMediaSource::CreatePresentationDescriptor</strong> and modify the presentation descriptor.</p>
            </remarks>
            <doc-id>ms697244</doc-id>
            <unmanaged>GetStreamDescriptor</unmanaged>
            <unmanaged-short>GetStreamDescriptor</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaStream.GetMediaSource(SharpDX.MediaFoundation.MediaSource@)">
            <summary>
            <p> </p><p>Retrieves a reference to the media source that created this media stream.</p>
            </summary>
            <param name = "mediaSourceOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSource"/></strong> interface of the media source. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The media source's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms705668</doc-id>
            <unmanaged>HRESULT IMFMediaStream::GetMediaSource([Out] IMFMediaSource** ppMediaSource)</unmanaged>
            <unmanaged-short>IMFMediaStream::GetMediaSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaStream.GetStreamDescriptor(SharpDX.MediaFoundation.StreamDescriptor@)">
            <summary>
            <p> </p><p>Retrieves a stream descriptor for this media stream.</p>
            </summary>
            <param name = "streamDescriptorOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.StreamDescriptor"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The media source's <strong>Shutdown</strong> method has been called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Do not modify the stream descriptor. To change the presentation, call <strong>IMFMediaSource::CreatePresentationDescriptor</strong> and modify the presentation descriptor.</p>
            </remarks>
            <doc-id>ms697244</doc-id>
            <unmanaged>HRESULT IMFMediaStream::GetStreamDescriptor([Out] IMFStreamDescriptor** ppStreamDescriptor)</unmanaged>
            <unmanaged-short>IMFMediaStream::GetStreamDescriptor</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaStream.RequestSample(SharpDX.IUnknown)">
            <summary>
            <p> Requests a sample from the media source. </p>
            </summary>
            <param name = "tokenRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface to an object that is used as a token for the request. The caller must implement this object. This parameter can be <strong><c>null</c></strong>. See Remarks.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:EndOfStream"/></strong></dt> </dl> </td><td> <p> The end of the stream was reached. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:MediaSourceWrongState"/></strong></dt> </dl> </td><td> <p> The media source is stopped.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p> The source's <strong>Shutdown</strong> method has been called. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If <em>pToken</em> is not <strong><c>null</c></strong>, the media stream calls <strong>AddRef</strong> on <em>pToken</em> and places the token in a first-in, first-out queue.</p><p>When the next sample is available, the media stream stream does the following:</p><ol> <li> Pulls the first token from the queue. </li> <li> Sets the <strong><see cref = "!:Token"/></strong> attribute on the media sample. The attribute data is a reference to the token object. </li> <li> Sends an MEMediaSample event. The event data is a reference to the media sample's <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface. </li> <li> Calls <strong>Release</strong> on the token. </li> </ol><p>If the media stream cannot fulfill the caller's request for a sample, it simply releases the token object and skips steps 2 and 3.</p><p>The caller should monitor the reference count on the request token. If the media stream sends an MEMediaSample event, get the <strong><see cref = "!:Token"/></strong> attribute from the sample and match the attribute value against the token. If the token's reference count falls to zero and you did not receive an MEMediaSample event, it means that the request was dropped.</p><p>Because the Media Foundation pipeline is multithreaded, the source's <strong>RequestSample</strong> method might get called after the source has stopped. If the media source is stopped, the method should return <strong><see cref = "!:MediaSourceWrongState"/></strong>. The pipeline does not treat this return code as an error condition. If the source returns any other error code, the pipeline treats it as fatal error and halts the session.</p><strong>Note</strong>??Earlier versions of the documentation listed the wrong error code for this case.?<p>If the media source is paused, the method succeeds, but the stream does not deliver the sample until the source is started again.</p><p>If a media source enounters an error asynchronously while processing data, it should signal the error in one of the following ways (but not both):</p><ul> <li>Return an error code from the next <strong>RequestSample</strong> call.</li> <li>Send an MEError event.</li> </ul>
            </remarks>
            <doc-id>ms696240</doc-id>
            <unmanaged>HRESULT IMFMediaStream::RequestSample([In] IUnknown* pToken)</unmanaged>
            <unmanaged-short>IMFMediaStream::RequestSample</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaStream2.StreamState">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetStreamState / SetStreamState</unmanaged>
            <unmanaged-short>GetStreamState</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaStream2.SetStreamState(SharpDX.MediaFoundation.StreamState)">
            <summary>
            No documentation.
            </summary>
            <param name = "value">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaStream2::SetStreamState([In] MF_STREAM_STATE value)</unmanaged>
            <unmanaged-short>IMFMediaStream2::SetStreamState</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaStream2.GetStreamState(SharpDX.MediaFoundation.StreamState@)">
            <summary>
            No documentation.
            </summary>
            <param name = "value">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMediaStream2::GetStreamState([Out] MF_STREAM_STATE* value)</unmanaged>
            <unmanaged-short>IMFMediaStream2::GetStreamState</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaStreamSourceSampleRequest.Sample">
            <summary>
            <p>Sets the sample for the media stream source.</p>
            </summary>
            <doc-id>dn280742</doc-id>
            <unmanaged>SetSample</unmanaged>
            <unmanaged-short>SetSample</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaStreamSourceSampleRequest.SetSample(SharpDX.MediaFoundation.Sample)">
            <summary>
            <p>Sets the sample for the media stream source.</p>
            </summary>
            <param name = "value"><dd> <p>The sample for the media stream source.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280742</doc-id>
            <unmanaged>HRESULT IMFMediaStreamSourceSampleRequest::SetSample([In, Optional] IMFSample* value)</unmanaged>
            <unmanaged-short>IMFMediaStreamSourceSampleRequest::SetSample</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MediaTimeRange.Length">
            <summary>
            <p>Gets the number of time ranges contained in the object.</p>
            </summary>
            <remarks>
            <p>This method corresponds to the <strong>TimeRanges.length</strong> attribute in HTML5.</p>
            </remarks>
            <doc-id>hh448038</doc-id>
            <unmanaged>GetLength</unmanaged>
            <unmanaged-short>GetLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaTimeRange.GetLength">
            <summary>
            <p>Gets the number of time ranges contained in the object.</p>
            </summary>
            <returns><p>Returns the number of time ranges.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>TimeRanges.length</strong> attribute in HTML5.</p>
            </remarks>
            <doc-id>hh448038</doc-id>
            <unmanaged>DWORD IMFMediaTimeRange::GetLength()</unmanaged>
            <unmanaged-short>IMFMediaTimeRange::GetLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaTimeRange.GetStart(System.Int32,System.Double@)">
            <summary>
            <p>Gets the start time for a specified time range.</p>
            </summary>
            <param name = "index"><dd> <p>The zero-based index of the time range to query. To get the  number of time ranges, call <strong>IMFMediaTimeRange::GetLength</strong>.</p> </dd></param>
            <param name = "startRef"><dd> <p>Receives the start time, in seconds.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>TimeRanges.start</strong> method in HTML5.</p>
            </remarks>
            <doc-id>hh448039</doc-id>
            <unmanaged>HRESULT IMFMediaTimeRange::GetStart([In] DWORD index,[Out] double* pStart)</unmanaged>
            <unmanaged-short>IMFMediaTimeRange::GetStart</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaTimeRange.GetEnd(System.Int32,System.Double@)">
            <summary>
            <p>Gets the end time for a specified time range.</p>
            </summary>
            <param name = "index"><dd> <p>The zero-based index of the time range to query. To get the  number of time ranges, call <strong>IMFMediaTimeRange::GetLength</strong>.</p> </dd></param>
            <param name = "endRef"><dd> <p>Receives the end time, in seconds.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method corresponds to the <strong>TimeRanges.end</strong> method in HTML5.</p>
            </remarks>
            <doc-id>hh448037</doc-id>
            <unmanaged>HRESULT IMFMediaTimeRange::GetEnd([In] DWORD index,[Out] double* pEnd)</unmanaged>
            <unmanaged-short>IMFMediaTimeRange::GetEnd</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaTimeRange.ContainsTime(System.Double)">
            <summary>
            <p>Queries whether a specified time falls within any of the time ranges.</p>
            </summary>
            <param name = "time"><dd> <p>The time, in seconds.</p> </dd></param>
            <returns><p>Returns <strong>TRUE</strong> if any time range contained in this object spans the value of the <em>time</em> parameter. Otherwise, returns <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p></returns>
            <remarks>
            <p>This method returns <strong>TRUE</strong> if the following condition holds for any time range in the list:</p><dl> <dd>(<em>start</em> &lt;= <em>time</em>) &amp; &amp; (<em>time</em> &lt;= <em>end</em>)</dd> </dl>
            </remarks>
            <doc-id>hh448036</doc-id>
            <unmanaged>BOOL IMFMediaTimeRange::ContainsTime([In] double time)</unmanaged>
            <unmanaged-short>IMFMediaTimeRange::ContainsTime</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaTimeRange.AddRange(System.Double,System.Double)">
            <summary>
            <p>Adds a new range to the list of time ranges.</p>
            </summary>
            <param name = "startTime"><dd> <p>The start time, in seconds.</p> </dd></param>
            <param name = "endTime"><dd> <p>The end time, in seconds.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If the new range intersects a range already in the list, the two ranges are combined. Otherwise, the new range is added to the list.</p>
            </remarks>
            <doc-id>hh448034</doc-id>
            <unmanaged>HRESULT IMFMediaTimeRange::AddRange([In] double startTime,[In] double endTime)</unmanaged>
            <unmanaged-short>IMFMediaTimeRange::AddRange</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MediaTimeRange.Clear">
            <summary>
            <p>Clears the list of time ranges.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh448035</doc-id>
            <unmanaged>HRESULT IMFMediaTimeRange::Clear()</unmanaged>
            <unmanaged-short>IMFMediaTimeRange::Clear</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.Metadata.AllLanguages">
            <summary>
            <p> Gets a list of the languages in which metadata is available.</p>
            </summary>
            <remarks>
            <p> For more information about language tags, see RFC 1766, "Tags for the Identification of Languages". </p><p> To set the current language, call <strong>IMFMetadata::SetLanguage</strong>. </p>
            </remarks>
            <doc-id>ms698736</doc-id>
            <unmanaged>GetAllLanguages</unmanaged>
            <unmanaged-short>GetAllLanguages</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.Metadata.AllPropertyNames">
            <summary>
            <p> Gets a list of all the metadata property names on this object.</p>
            </summary>
            <doc-id>ms704581</doc-id>
            <unmanaged>GetAllPropertyNames</unmanaged>
            <unmanaged-short>GetAllPropertyNames</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Metadata.SetLanguage(System.String)">
            <summary>
            <p> Sets the language for setting and retrieving metadata. </p>
            </summary>
            <param name = "wszRFC1766Ref"><dd> <p>Pointer to a null-terminated string containing an RFC 1766-compliant language tag.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>For more information about language tags, see RFC 1766, "Tags for the Identification of Languages".</p>
            </remarks>
            <doc-id>ms703982</doc-id>
            <unmanaged>HRESULT IMFMetadata::SetLanguage([In] const wchar_t* pwszRFC1766)</unmanaged>
            <unmanaged-short>IMFMetadata::SetLanguage</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Metadata.GetLanguage(System.IntPtr)">
            <summary>
            <p> Gets the current language setting.</p>
            </summary>
            <param name = "wszRFC1766Out"><dd> <p> Receives a reference to a null-terminated string containing an RFC 1766-compliant language tag. The caller must release the string by calling <strong>CoTaskMemFree</strong>. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>The metadata provider does not support multiple languages.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p> No language was set. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>For more information about language tags, see RFC 1766, "Tags for the Identification of Languages."</p><p>The <strong>IMFMetadata::SetLanguage</strong> and <strong>IMFMetadata::GetProperty</strong> methods set and get metadata for the current language setting.</p>
            </remarks>
            <doc-id>ms698978</doc-id>
            <unmanaged>HRESULT IMFMetadata::GetLanguage([Out] wchar_t** ppwszRFC1766)</unmanaged>
            <unmanaged-short>IMFMetadata::GetLanguage</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Metadata.GetAllLanguages(SharpDX.Win32.Variant@)">
            <summary>
            <p> Gets a list of the languages in which metadata is available.</p>
            </summary>
            <param name = "vLanguagesOut"><dd> <p> A reference to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that receives the list of languages. The list is returned as an array of null-terminated wide-character strings. Each string in the array is an RFC 1766-compliant language tag. </p> <p>The returned <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> type is VT_VECTOR | VT_LPWSTR. The list might be empty, if no language tags are present. The caller must free the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> by calling <strong>PropVariantClear</strong>. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> For more information about language tags, see RFC 1766, "Tags for the Identification of Languages". </p><p> To set the current language, call <strong>IMFMetadata::SetLanguage</strong>. </p>
            </remarks>
            <doc-id>ms698736</doc-id>
            <unmanaged>HRESULT IMFMetadata::GetAllLanguages([Out] PROPVARIANT* ppvLanguages)</unmanaged>
            <unmanaged-short>IMFMetadata::GetAllLanguages</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Metadata.SetProperty(System.String,SharpDX.Win32.Variant)">
            <summary>
            <p> Sets the value of a metadata property. </p>
            </summary>
            <param name = "wszNameRef"><dd> <p>Pointer to a null-terminated string containing the name of the property.</p> </dd></param>
            <param name = "vValueOut"><dd> <p>Pointer to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that contains the value of the property. For multivalued properties, use a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> with a VT_VECTOR type.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ms696972</doc-id>
            <unmanaged>HRESULT IMFMetadata::SetProperty([In] const wchar_t* pwszName,[In] const PROPVARIANT* ppvValue)</unmanaged>
            <unmanaged-short>IMFMetadata::SetProperty</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Metadata.GetProperty(System.String,SharpDX.Win32.Variant@)">
            <summary>
            <p> Gets the value of a metadata property.</p>
            </summary>
            <param name = "wszNameRef"><dd> <p> A reference to a null-terminated string that containings the name of the property. To get the list of property names, call <strong>IMFMetadata::GetAllPropertyNames</strong>.</p> </dd></param>
            <param name = "vValueOut"><dd> <p> Pointer to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that receives the value of the property. The <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> type depends on the property. For multivalued properties, the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> is a <strong>VT_VECTOR</strong> type. The caller must free the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> by calling <strong>PropVariantClear</strong>. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:PropertyNotFound"/></strong></dt> </dl> </td><td> <p> The requested property was not found. </p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms694844</doc-id>
            <unmanaged>HRESULT IMFMetadata::GetProperty([In] const wchar_t* pwszName,[Out] PROPVARIANT* ppvValue)</unmanaged>
            <unmanaged-short>IMFMetadata::GetProperty</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Metadata.DeleteProperty(System.String)">
            <summary>
            <p> Deletes a metadata property.</p>
            </summary>
            <param name = "wszNameRef"><dd> <p>Pointer to a null-terminated string containing the name of the property.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:PropertyNotFound"/></strong></dt> </dl> </td><td> <p> The property was not found. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>For a media source, deleting a property from the metadata collection does not change the original content.</p>
            </remarks>
            <doc-id>ms699021</doc-id>
            <unmanaged>HRESULT IMFMetadata::DeleteProperty([In] const wchar_t* pwszName)</unmanaged>
            <unmanaged-short>IMFMetadata::DeleteProperty</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Metadata.GetAllPropertyNames(SharpDX.Win32.Variant@)">
            <summary>
            <p> Gets a list of all the metadata property names on this object.</p>
            </summary>
            <param name = "vNamesOut"><dd> <p>Pointer to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that receives an array of null-terminated wide-character strings. If no properties are available, the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> type is VT_EMPTY. Otherwise, the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> type is VT_VECTOR | VT_LPWSTR. The caller must free the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> by calling <strong>PropVariantClear</strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ms704581</doc-id>
            <unmanaged>HRESULT IMFMetadata::GetAllPropertyNames([Out] PROPVARIANT* ppvNames)</unmanaged>
            <unmanaged-short>IMFMetadata::GetAllPropertyNames</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MetadataProvider.GetMFMetadata(SharpDX.MediaFoundation.PresentationDescriptor,System.Int32,System.Int32,SharpDX.MediaFoundation.Metadata@)">
            <summary>
            <p> Gets a collection of metadata, either for an entire presentation, or for one stream in the presentation.</p>
            </summary>
            <param name = "presentationDescriptorRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the media source's presentation descriptor. </p> </dd></param>
            <param name = "dwStreamIdentifier"><dd> <p> If this parameter is zero, the method retrieves metadata that applies to the entire presentation. Otherwise, this <em></em> parameter specifies a stream identifier, and the method retrieves metadata for that stream. To get the stream identifier for a stream, call <strong>IMFStreamDescriptor::GetStreamIdentifier</strong>. </p> </dd></param>
            <param name = "dwFlags"><dd> <p> Reserved. Must be zero. </p> </dd></param>
            <param name = "mFMetadataOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Metadata"/></strong> interface. Use this interface to access the metadata. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:PropertyNotFound"/></strong></dt> </dl> </td><td> <p>No metadata is available for the requested stream or presentation.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms694097</doc-id>
            <unmanaged>HRESULT IMFMetadataProvider::GetMFMetadata([In, Optional] IMFPresentationDescriptor* pPresentationDescriptor,[In] DWORD dwStreamIdentifier,[In] DWORD dwFlags,[Out] IMFMetadata** ppMFMetadata)</unmanaged>
            <unmanaged-short>IMFMetadataProvider::GetMFMetadata</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MuxStreamAttributesManager.StreamCount">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetStreamCount</unmanaged>
            <unmanaged-short>GetStreamCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MuxStreamAttributesManager.GetStreamCount(System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwMuxStreamCountRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMuxStreamAttributesManager::GetStreamCount([Out] DWORD* pdwMuxStreamCount)</unmanaged>
            <unmanaged-short>IMFMuxStreamAttributesManager::GetStreamCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MuxStreamAttributesManager.GetAttributes(System.Int32,SharpDX.MediaFoundation.MediaAttributes@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> for the substream with the specified index.</p>
            </summary>
            <param name = "dwMuxStreamIndex">No documentation.</param>
            <param name = "streamAttributesOut">No documentation.</param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> Invalid argument. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> The stream specified substream index is invalid. Call <strong>GetStreamCount</strong> to get the number of substreams managed by the multiplexed media source.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>mt797928</doc-id>
            <unmanaged>HRESULT IMFMuxStreamAttributesManager::GetAttributes([In] DWORD dwMuxStreamIndex,[Out] IMFAttributes** ppStreamAttributes)</unmanaged>
            <unmanaged-short>IMFMuxStreamAttributesManager::GetAttributes</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MuxStreamMediaTypeManager.StreamCount">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetStreamCount</unmanaged>
            <unmanaged-short>GetStreamCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MuxStreamMediaTypeManager.StreamConfigurationCount">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetStreamConfigurationCount</unmanaged>
            <unmanaged-short>GetStreamConfigurationCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MuxStreamMediaTypeManager.GetStreamCount(System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwMuxStreamCountRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMuxStreamMediaTypeManager::GetStreamCount([Out] DWORD* pdwMuxStreamCount)</unmanaged>
            <unmanaged-short>IMFMuxStreamMediaTypeManager::GetStreamCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MuxStreamMediaTypeManager.GetMediaType(System.Int32,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwMuxStreamIndex">No documentation.</param>
            <param name = "mediaTypeOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMuxStreamMediaTypeManager::GetMediaType([In] DWORD dwMuxStreamIndex,[Out] IMFMediaType** ppMediaType)</unmanaged>
            <unmanaged-short>IMFMuxStreamMediaTypeManager::GetMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MuxStreamMediaTypeManager.GetStreamConfigurationCount(System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwCountRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMuxStreamMediaTypeManager::GetStreamConfigurationCount([Out] DWORD* pdwCount)</unmanaged>
            <unmanaged-short>IMFMuxStreamMediaTypeManager::GetStreamConfigurationCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MuxStreamMediaTypeManager.AddStreamConfiguration(System.Int64)">
            <summary>
            No documentation.
            </summary>
            <param name = "ullStreamMask">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMuxStreamMediaTypeManager::AddStreamConfiguration([In] unsigned longlong ullStreamMask)</unmanaged>
            <unmanaged-short>IMFMuxStreamMediaTypeManager::AddStreamConfiguration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MuxStreamMediaTypeManager.RemoveStreamConfiguration(System.Int64)">
            <summary>
            No documentation.
            </summary>
            <param name = "ullStreamMask">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMuxStreamMediaTypeManager::RemoveStreamConfiguration([In] unsigned longlong ullStreamMask)</unmanaged>
            <unmanaged-short>IMFMuxStreamMediaTypeManager::RemoveStreamConfiguration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MuxStreamMediaTypeManager.GetStreamConfiguration(System.Int32,System.Int64@)">
            <summary>
            No documentation.
            </summary>
            <param name = "ulIndex">No documentation.</param>
            <param name = "ullStreamMaskRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMuxStreamMediaTypeManager::GetStreamConfiguration([In] DWORD ulIndex,[Out] unsigned longlong* pullStreamMask)</unmanaged>
            <unmanaged-short>IMFMuxStreamMediaTypeManager::GetStreamConfiguration</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MuxStreamSampleManager.StreamCount">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Provides the ability to retrieve <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> objects for individual substreams within the output of a multiplexed media source.</p>
            </summary>
            <doc-id>mt797937</doc-id>
            <unmanaged>GetStreamCount</unmanaged>
            <unmanaged-short>GetStreamCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MuxStreamSampleManager.StreamConfiguration">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetStreamConfiguration</unmanaged>
            <unmanaged-short>GetStreamConfiguration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MuxStreamSampleManager.GetStreamCount(System.Int32@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Provides the ability to retrieve <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> objects for individual substreams within the output of a multiplexed media source.</p>
            </summary>
            <param name = "dwMuxStreamCountRef">No documentation.</param>
            <returns>No documentation.</returns>
            <doc-id>mt797937</doc-id>
            <unmanaged>HRESULT IMFMuxStreamSampleManager::GetStreamCount([Out] DWORD* pdwMuxStreamCount)</unmanaged>
            <unmanaged-short>IMFMuxStreamSampleManager::GetStreamCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MuxStreamSampleManager.GetSample(System.Int32,SharpDX.MediaFoundation.Sample@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwMuxStreamIndex">No documentation.</param>
            <param name = "sampleOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFMuxStreamSampleManager::GetSample([In] DWORD dwMuxStreamIndex,[Out] IMFSample** ppSample)</unmanaged>
            <unmanaged-short>IMFMuxStreamSampleManager::GetSample</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.MuxStreamSampleManager.GetStreamConfiguration">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>unsigned longlong IMFMuxStreamSampleManager::GetStreamConfiguration()</unmanaged>
            <unmanaged-short>IMFMuxStreamSampleManager::GetStreamConfiguration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetCredential.SetUser(System.Byte[],System.Int32,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p> </p><p>Sets the user name.</p>
            </summary>
            <param name = "bDataRef"><dd> <p>Pointer to a buffer that contains the user name. If <em>fDataIsEncrypted</em> is <strong><see cref = "F:SharpDX.Result.False"/></strong>, the buffer is a wide-character string. Otherwise, the buffer contains encrypted data.</p> </dd></param>
            <param name = "cbData"><dd> <p>Size of <em>pbData</em>, in bytes. If <em>fDataIsEncrypted</em> is <strong><see cref = "F:SharpDX.Result.False"/></strong>, the size includes the terminating null character.</p> </dd></param>
            <param name = "fDataIsEncrypted"><dd> <p>If <strong>TRUE</strong>, the user name is encrypted. Otherwise, the user name is not encrypted.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms693551</doc-id>
            <unmanaged>HRESULT IMFNetCredential::SetUser([In, Buffer] unsigned char* pbData,[In] DWORD cbData,[In] BOOL fDataIsEncrypted)</unmanaged>
            <unmanaged-short>IMFNetCredential::SetUser</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetCredential.SetPassword(System.Byte[],System.Int32,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p> </p><p>Sets the password.</p>
            </summary>
            <param name = "bDataRef"><dd> <p>Pointer to a buffer that contains the password. If <em>fDataIsEncrypted</em> is <strong><see cref = "F:SharpDX.Result.False"/></strong>, the buffer is a wide-character string. Otherwise, the buffer contains encrypted data.</p> </dd></param>
            <param name = "cbData"><dd> <p>Size of <em>pbData</em>, in bytes. If <em>fDataIsEncrypted</em> is <strong><see cref = "F:SharpDX.Result.False"/></strong>, the size includes the terminating null character.</p> </dd></param>
            <param name = "fDataIsEncrypted"><dd> <p>If <strong>TRUE</strong>, the password is encrypted. Otherwise, the password is not encrypted.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms699838</doc-id>
            <unmanaged>HRESULT IMFNetCredential::SetPassword([In, Buffer] unsigned char* pbData,[In] DWORD cbData,[In] BOOL fDataIsEncrypted)</unmanaged>
            <unmanaged-short>IMFNetCredential::SetPassword</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetCredential.GetUser(System.Byte[],System.Int32@,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p> </p><p>Retrieves the user name.</p>
            </summary>
            <param name = "bDataRef"><dd> <p>Pointer to a buffer that receives the user name. To find the required buffer size, set this parameter to <strong><c>null</c></strong>. If <em>fEncryptData</em> is <strong><see cref = "F:SharpDX.Result.False"/></strong>, the buffer contains a wide-character string. Otherwise, the buffer contains encrypted data.</p> </dd></param>
            <param name = "cbDataRef"><dd> <p>On input, specifies the size of the <em>pbData</em> buffer, in bytes. On output, receives the required buffer size. If <em>fEncryptData</em> is <strong><see cref = "F:SharpDX.Result.False"/></strong>, the size includes the terminating null character.</p> </dd></param>
            <param name = "fEncryptData"><dd> <p>If <strong>TRUE</strong>, the method returns an encrypted string. Otherwise, the method returns an unencrypted string.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the user name is not available, the method might succeed and set *<em>pcbData</em> to zero.</p>
            </remarks>
            <doc-id>ms694290</doc-id>
            <unmanaged>HRESULT IMFNetCredential::GetUser([Out, Buffer, Optional] unsigned char* pbData,[InOut] DWORD* pcbData,[In] BOOL fEncryptData)</unmanaged>
            <unmanaged-short>IMFNetCredential::GetUser</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetCredential.GetPassword(System.Byte[],System.Int32@,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p> </p><p>Retrieves the password.</p>
            </summary>
            <param name = "bDataRef"><dd> <p>Pointer to a buffer that receives the password. To find the required buffer size, set this parameter to <strong><c>null</c></strong>. If <em>fEncryptData</em> is <strong><see cref = "F:SharpDX.Result.False"/></strong>, the buffer contains a wide-character string. Otherwise, the buffer contains encrypted data.</p> </dd></param>
            <param name = "cbDataRef"><dd> <p>On input, specifies the size of the <em>pbData</em> buffer, in bytes. On output, receives the required buffer size. If <em>fEncryptData</em> is <strong><see cref = "F:SharpDX.Result.False"/></strong>, the size includes the terminating null character.</p> </dd></param>
            <param name = "fEncryptData"><dd> <p>If <strong>TRUE</strong>, the method returns an encrypted string. Otherwise, the method returns an unencrypted string.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the password is not available, the method might succeed and set *<em>pcbData</em> to zero.</p>
            </remarks>
            <doc-id>ms702055</doc-id>
            <unmanaged>HRESULT IMFNetCredential::GetPassword([Out, Buffer, Optional] unsigned char* pbData,[InOut] DWORD* pcbData,[In] BOOL fEncryptData)</unmanaged>
            <unmanaged-short>IMFNetCredential::GetPassword</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetCredential.LoggedOnUser(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p> </p><p>Queries whether logged-on credentials should be used.</p>
            </summary>
            <param name = "fLoggedOnUserRef"><dd> <p>Receives a Boolean value. If logged-on credentials should be used, the value is <strong>TRUE</strong>. Otherwise, the value is <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms698960</doc-id>
            <unmanaged>HRESULT IMFNetCredential::LoggedOnUser([Out] BOOL* pfLoggedOnUser)</unmanaged>
            <unmanaged-short>IMFNetCredential::LoggedOnUser</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetCredentialCache.GetCredential(System.String,System.String,System.Int32,SharpDX.MediaFoundation.NetCredential@,System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the credential object for the specified URL.</p>
            </summary>
            <param name = "szUrlRef"><dd> <p>A null-terminated wide-character string containing the URL for which the credential is needed.</p> </dd></param>
            <param name = "szRealmRef"><dd> <p>A null-terminated wide-character string containing the realm for the authentication.</p> </dd></param>
            <param name = "dwAuthenticationFlags"><dd> <p>Bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.NetAuthenticationFlags"/></strong> enumeration.</p> </dd></param>
            <param name = "credOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.NetCredential"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <param name = "dwRequirementsFlagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.NetCredentialRequirements"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms699842</doc-id>
            <unmanaged>HRESULT IMFNetCredentialCache::GetCredential([In] const wchar_t* pszUrl,[In] const wchar_t* pszRealm,[In] DWORD dwAuthenticationFlags,[Out] IMFNetCredential** ppCred,[Out] DWORD* pdwRequirementsFlags)</unmanaged>
            <unmanaged-short>IMFNetCredentialCache::GetCredential</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetCredentialCache.SetGood(SharpDX.MediaFoundation.NetCredential,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p> </p><p>Reports whether the credential object provided successfully passed the authentication challenge.</p>
            </summary>
            <param name = "credRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.NetCredential"/></strong> interface.</p> </dd></param>
            <param name = "fGood"><dd> <p><strong>TRUE</strong> if the credential object succeeded in the authentication challenge; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is called by the network source into the credential manager.</p>
            </remarks>
            <doc-id>ms704649</doc-id>
            <unmanaged>HRESULT IMFNetCredentialCache::SetGood([In] IMFNetCredential* pCred,[In] BOOL fGood)</unmanaged>
            <unmanaged-short>IMFNetCredentialCache::SetGood</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetCredentialCache.SetUserOptions(SharpDX.MediaFoundation.NetCredential,System.Int32)">
            <summary>
            <p> </p><p>Specifies how user credentials are stored.</p>
            </summary>
            <param name = "credRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.NetCredential"/></strong> interface. Obtain this reference by calling <strong>IMFNetCredentialCache::GetCredential</strong>.</p> </dd></param>
            <param name = "dwOptionsFlags"><dd> <p>Bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.NetCredentialOptions"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If no flags are specified, the credentials are cached in memory. This method can be implemented by the credential manager and called by the network source.</p>
            </remarks>
            <doc-id>ms693547</doc-id>
            <unmanaged>HRESULT IMFNetCredentialCache::SetUserOptions([In] IMFNetCredential* pCred,[In] DWORD dwOptionsFlags)</unmanaged>
            <unmanaged-short>IMFNetCredentialCache::SetUserOptions</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetCredentialManager.BeginGetCredentials(SharpDX.MediaFoundation.NetCredentialManagerGetParam@,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Begins an asynchronous request to retrieve the user's credentials.</p>
            </summary>
            <param name = "paramRef"><dd> <p>Pointer to an <strong><see cref = "T:SharpDX.MediaFoundation.NetCredentialManagerGetParam"/></strong> structure.</p> </dd></param>
            <param name = "callbackRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>
            <param name = "stateRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. The object is returned to the caller when the callback is invoked.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms705663</doc-id>
            <unmanaged>HRESULT IMFNetCredentialManager::BeginGetCredentials([In] MFNetCredentialManagerGetParam* pParam,[In] IMFAsyncCallback* pCallback,[In] IUnknown* pState)</unmanaged>
            <unmanaged-short>IMFNetCredentialManager::BeginGetCredentials</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetCredentialManager.EndGetCredentials(SharpDX.MediaFoundation.AsyncResult,SharpDX.MediaFoundation.NetCredential@)">
            <summary>
            <p> </p><p>Completes an asynchronous request to retrieve the user's credentials.</p>
            </summary>
            <param name = "resultRef"><dd> <p>Pointer to an <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface that contains the asynchronous result.</p> </dd></param>
            <param name = "credOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.NetCredential"/></strong> interface, which is used to retrieve the credentials. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms701589</doc-id>
            <unmanaged>HRESULT IMFNetCredentialManager::EndGetCredentials([In] IMFAsyncResult* pResult,[Out] IMFNetCredential** ppCred)</unmanaged>
            <unmanaged-short>IMFNetCredentialManager::EndGetCredentials</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetCredentialManager.SetGood(SharpDX.MediaFoundation.NetCredential,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p> </p><p>Specifies whether the user's credentials succeeded in the authentication challenge. The network source calls this method to informs the application whether the user's credentials were authenticated.</p>
            </summary>
            <param name = "credRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.NetCredential"/></strong> interface.</p> </dd></param>
            <param name = "fGood"><dd> <p>Boolean value. The value is <strong>TRUE</strong> if the credentials succeeded in the authentication challenge. Otherwise, the value is <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms705614</doc-id>
            <unmanaged>HRESULT IMFNetCredentialManager::SetGood([In] IMFNetCredential* pCred,[In] BOOL fGood)</unmanaged>
            <unmanaged-short>IMFNetCredentialManager::SetGood</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.NetCrossOriginSupport.CrossOriginPolicy">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetCrossOriginPolicy</unmanaged>
            <unmanaged-short>GetCrossOriginPolicy</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetCrossOriginSupport.GetCrossOriginPolicy(SharpDX.MediaFoundation.CrossOriginPolicy@)">
            <summary>
            No documentation.
            </summary>
            <param name = "policyRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFNetCrossOriginSupport::GetCrossOriginPolicy([Out] MF_CROSS_ORIGIN_POLICY* pPolicy)</unmanaged>
            <unmanaged-short>IMFNetCrossOriginSupport::GetCrossOriginPolicy</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetCrossOriginSupport.GetSourceOrigin(System.IntPtr)">
            <summary>
            No documentation.
            </summary>
            <param name = "wszSourceOrigin">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFNetCrossOriginSupport::GetSourceOrigin([Out] wchar_t** wszSourceOrigin)</unmanaged>
            <unmanaged-short>IMFNetCrossOriginSupport::GetSourceOrigin</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetCrossOriginSupport.IsSameOrigin(System.String,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            No documentation.
            </summary>
            <param name = "wszURL">No documentation.</param>
            <param name = "fIsSameOriginRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFNetCrossOriginSupport::IsSameOrigin([In] const wchar_t* wszURL,[Out] BOOL* pfIsSameOrigin)</unmanaged>
            <unmanaged-short>IMFNetCrossOriginSupport::IsSameOrigin</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetProxyLocator.FindFirstProxy(System.String,System.String,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p> </p><p>Initializes the proxy locator object.</p>
            </summary>
            <param name = "szHostRef"><dd> <p>Null-terminated wide-character string containing the hostname of the destination server.</p> </dd></param>
            <param name = "szUrlRef"><dd> <p>Null-terminated wide-character string containing the destination URL.</p> </dd></param>
            <param name = "fReserved"><dd> <p>Reserved. Set to <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms697016</doc-id>
            <unmanaged>HRESULT IMFNetProxyLocator::FindFirstProxy([In] const wchar_t* pszHost,[In] const wchar_t* pszUrl,[In] BOOL fReserved)</unmanaged>
            <unmanaged-short>IMFNetProxyLocator::FindFirstProxy</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetProxyLocator.FindNextProxy">
            <summary>
            <p> </p><p>Determines the next proxy to use.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>S_FALSE</strong></dt> </dl> </td><td> <p>There are no more proxy objects.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms700807</doc-id>
            <unmanaged>HRESULT IMFNetProxyLocator::FindNextProxy()</unmanaged>
            <unmanaged-short>IMFNetProxyLocator::FindNextProxy</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetProxyLocator.RegisterProxyResult(SharpDX.Result)">
            <summary>
            <p> </p><p>Keeps a record of the success or failure of using the current proxy.</p>
            </summary>
            <param name = "hrOp"><dd> <p><strong><see cref = "T:SharpDX.Result"/></strong> specifying the result of using the current proxy for connection.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms696180</doc-id>
            <unmanaged>HRESULT IMFNetProxyLocator::RegisterProxyResult([In] HRESULT hrOp)</unmanaged>
            <unmanaged-short>IMFNetProxyLocator::RegisterProxyResult</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetProxyLocator.GetCurrentProxy(System.IntPtr,System.Int32)">
            <summary>
            <p> </p><p>Retrieves the current proxy information including hostname and port.</p>
            </summary>
            <param name = "szStrRef"><dd> <p>Pointer to a buffer that receives a null-terminated string containing the proxy hostname and port. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "cchStrRef"><dd> <p>On input, specifies the number of elements in the <em>pszStr</em> array. On output, receives the required size of the buffer.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOT_SUFFICIENT_BUFFER</strong></dt> </dl> </td><td> <p>The buffer specified in <em>pszStr</em> is too small.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms697327</doc-id>
            <unmanaged>HRESULT IMFNetProxyLocator::GetCurrentProxy([Out, Buffer, Optional] wchar_t* pszStr,[In] DWORD* pcchStr)</unmanaged>
            <unmanaged-short>IMFNetProxyLocator::GetCurrentProxy</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetProxyLocator.Clone(SharpDX.MediaFoundation.NetProxyLocator@)">
            <summary>
            <p> </p><p>Creates a new instance of the default proxy locator.</p>
            </summary>
            <param name = "proxyLocatorOut"><dd> <p>Receives a reference to the new proxy locator object's <strong><see cref = "T:SharpDX.MediaFoundation.NetProxyLocator"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms697210</doc-id>
            <unmanaged>HRESULT IMFNetProxyLocator::Clone([In] IMFNetProxyLocator** ppProxyLocator)</unmanaged>
            <unmanaged-short>IMFNetProxyLocator::Clone</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetProxyLocatorFactory.CreateProxyLocator(System.String,SharpDX.MediaFoundation.NetProxyLocator@)">
            <summary>
            <p> </p><p>Creates an <strong><see cref = "T:SharpDX.MediaFoundation.NetProxyLocator"/></strong> interface proxy locator object based on the protocol name.</p>
            </summary>
            <param name = "szProtocolRef">No documentation.</param>
            <param name = "proxyLocatorOut">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms694154</doc-id>
            <unmanaged>HRESULT IMFNetProxyLocatorFactory::CreateProxyLocator([In] const wchar_t* pszProtocol,[Out] IMFNetProxyLocator** ppProxyLocator)</unmanaged>
            <unmanaged-short>IMFNetProxyLocatorFactory::CreateProxyLocator</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetResourceFilter.OnRedirect(System.String,System.Int16@)">
            <summary>
            <p>Called when the byte stream redirects to a URL.</p>
            </summary>
            <param name = "szUrlRef"><dd> <p>The URL to which the connection has been redirected.</p> </dd></param>
            <param name = "vbCancelRef"><dd> <p>To cancel the redirection, set this parameter to <strong>VARIANT_TRUE</strong>. To allow the redirection, set this parameter to <strong>VARIANT_FALSE</strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh448041</doc-id>
            <unmanaged>HRESULT IMFNetResourceFilter::OnRedirect([In] const wchar_t* pszUrl,[Out] short* pvbCancel)</unmanaged>
            <unmanaged-short>IMFNetResourceFilter::OnRedirect</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetResourceFilter.OnSendingRequest(System.String)">
            <summary>
            <p>Called when the byte stream requests a URL.</p>
            </summary>
            <param name = "szUrlRef"><dd> <p>The URL that the byte stream is requesting.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh448042</doc-id>
            <unmanaged>HRESULT IMFNetResourceFilter::OnSendingRequest([In] const wchar_t* pszUrl)</unmanaged>
            <unmanaged-short>IMFNetResourceFilter::OnSendingRequest</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.NetSchemeHandlerConfig.NumberOfSupportedProtocols">
            <summary>
            <p> </p><p>Retrieves the number of protocols supported by the network scheme plug-in.</p>
            </summary>
            <doc-id>ms701625</doc-id>
            <unmanaged>GetNumberOfSupportedProtocols</unmanaged>
            <unmanaged-short>GetNumberOfSupportedProtocols</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetSchemeHandlerConfig.GetNumberOfSupportedProtocols(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the number of protocols supported by the network scheme plug-in.</p>
            </summary>
            <param name = "cProtocolsRef"><dd> <p>Receives the number of protocols.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms701625</doc-id>
            <unmanaged>HRESULT IMFNetSchemeHandlerConfig::GetNumberOfSupportedProtocols([Out] ULONG* pcProtocols)</unmanaged>
            <unmanaged-short>IMFNetSchemeHandlerConfig::GetNumberOfSupportedProtocols</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetSchemeHandlerConfig.GetSupportedProtocolType(System.Int32,SharpDX.MediaFoundation.NetsourceProtocolType@)">
            <summary>
            <p> </p><p>Retrieves a supported protocol by index</p>
            </summary>
            <param name = "nProtocolIndex"><dd> <p>Zero-based index of the protocol to retrieve. To get the number of supported protocols, call <strong>IMFNetSchemeHandlerConfig::GetNumberOfSupportedProtocols</strong>.</p> </dd></param>
            <param name = "nProtocolTypeRef"><dd> <p>Receives a member of the <strong><see cref = "T:SharpDX.MediaFoundation.NetsourceProtocolType"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The value passed in the <em>nProtocolIndex</em> parameter was greater than the total number of supported protocols, returned by <strong>GetNumberOfSupportedProtocols</strong>.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms697058</doc-id>
            <unmanaged>HRESULT IMFNetSchemeHandlerConfig::GetSupportedProtocolType([In] ULONG nProtocolIndex,[Out] MFNETSOURCE_PROTOCOL_TYPE* pnProtocolType)</unmanaged>
            <unmanaged-short>IMFNetSchemeHandlerConfig::GetSupportedProtocolType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.NetSchemeHandlerConfig.ResetProtocolRolloverSettings">
            <summary>
            <p> </p><p>Not implemented in this release.</p>
            </summary>
            <returns><p>This method returns <see cref = "F:SharpDX.Result.Ok"/>.</p></returns>
            <doc-id>ms705604</doc-id>
            <unmanaged>HRESULT IMFNetSchemeHandlerConfig::ResetProtocolRolloverSettings()</unmanaged>
            <unmanaged-short>IMFNetSchemeHandlerConfig::ResetProtocolRolloverSettings</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ObjectReferenceStream.SaveReference(System.Guid,SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Stores the data needed to marshal an interface across a process boundary.</p>
            </summary>
            <param name = "riid"><dd> <p>Interface identifier of the interface to marshal.</p> </dd></param>
            <param name = "unkRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms698988</doc-id>
            <unmanaged>HRESULT IMFObjectReferenceStream::SaveReference([In] const GUID&amp; riid,[In] IUnknown* pUnk)</unmanaged>
            <unmanaged-short>IMFObjectReferenceStream::SaveReference</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ObjectReferenceStream.LoadReference(System.Guid,System.IntPtr)">
            <summary>
            <p> </p><p>Marshals an interface from data stored in the stream.</p>
            </summary>
            <param name = "riid"><dd> <p>Interface identifier of the interface to marshal.</p> </dd></param>
            <param name = "vOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms705636</doc-id>
            <unmanaged>HRESULT IMFObjectReferenceStream::LoadReference([In] const GUID&amp; riid,[In] void** ppv)</unmanaged>
            <unmanaged-short>IMFObjectReferenceStream::LoadReference</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.OutputPolicy.OriginatorID">
            <summary>
            <p> </p><p>Retrieives a <see cref = "T:System.Guid"/> identifying the input trust authority (ITA) that created this output policy object.</p>
            </summary>
            <remarks>
            <p>All of the policy objects and output schemas from the same ITA should return the same originator identifier (including dynamic policy changes). This value enables the OTA to distinguish policies that originate from different ITAs, so that the OTA can update dynamic policies correctly.</p>
            </remarks>
            <doc-id>bb970379</doc-id>
            <unmanaged>GetOriginatorID</unmanaged>
            <unmanaged-short>GetOriginatorID</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.OutputPolicy.MinimumGRLVersion">
            <summary>
            <p> </p><p>Retrieves the minimum version of the global revocation list (GRL) that must be enforced by the protected environment for this policy.</p>
            </summary>
            <doc-id>bb970389</doc-id>
            <unmanaged>GetMinimumGRLVersion</unmanaged>
            <unmanaged-short>GetMinimumGRLVersion</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.OutputPolicy.GenerateRequiredSchemas(System.Int32,System.Guid,System.Guid,System.Int32,SharpDX.MediaFoundation.Collection@)">
            <summary>
            <p> Retrieves a list of the output protection systems that the output trust authority (OTA) must enforce, along with configuration data for each protection system. </p>
            </summary>
            <param name = "dwAttributes"><dd> <p> Describes the output that is represented by the OTA calling this method. This value is a bitwise OR of zero or more of the following flags. </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MFOUTPUTATTRIBUTE_BUS</strong></dt> </dl> </td><td> <p> Hardware bus. </p> </td></tr> <tr><td><dl> <dt><strong>MFOUTPUTATTRIBUTE_COMPRESSED</strong></dt> </dl> </td><td> <p> The output sends compressed data. If this flag is absent, the output sends uncompressed data. </p> </td></tr> <tr><td><dl> <dt><strong>MFOUTPUTATTRIBUTE_BUSIMPLEMENTATION</strong></dt> </dl> </td><td> <p> Reserved. Do not use. </p> </td></tr> <tr><td><dl> <dt><strong>MFOUTPUTATTRIBUTE_DIGITAL</strong></dt> </dl> </td><td> <p> The output sends a digital signal. If this flag is absent, the output sends an analog signal. </p> </td></tr> <tr><td><dl> <dt><strong>MFOUTPUTATTRIBUTE_NONSTANDARDIMPLEMENTATION</strong></dt> </dl> </td><td> <p> Reserved. Do not use. </p> </td></tr> <tr><td><dl> <dt><strong>MFOUTPUTATTRIBUTE_SOFTWARE</strong></dt> </dl> </td><td> <p> Reserved. Do not use. </p> </td></tr> <tr><td><dl> <dt><strong>MFOUTPUTATTRIBUTE_VIDEO</strong></dt> </dl> </td><td> <p> The output sends video data. If this flag is absent, the output sends audio data. </p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "guidOutputSubType"><dd> <p> Indicates a specific family of output connectors that is represented by the OTA calling this method. Possible values include the following. </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_AGP</strong></dt> </dl> </td><td> <p> AGP bus. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_COMPONENT</strong></dt> </dl> </td><td> <p> Component video. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_COMPOSITE</strong></dt> </dl> </td><td> <p> Composite video. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_D_JPN</strong></dt> </dl> </td><td> <p> Japanese D connector. (Connector conforming to the EIAJ RC-5237 standard.) </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_DISPLAYPORT_EMBEDDED</strong></dt> </dl> </td><td> <p> Embedded DisplayPort connector. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_DISPLAYPORT_EXTERNAL</strong></dt> </dl> </td><td> <p> External DisplayPort connector. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_DVI</strong></dt> </dl> </td><td> <p> Digital video interface (DVI) connector. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_HDMI</strong></dt> </dl> </td><td> <p> High-definition multimedia interface (HDMI) connector. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_LVDS</strong></dt> </dl> </td><td> <p> Low voltage differential signaling (LVDS) connector.</p> <p>A connector using the LVDS interface to connect internally to a display device. The connection between the graphics adapter and the display device is permanent and not accessible to the user. Applications should not enable High-Bandwidth Digital Content Protection (HDCP) for this connector.</p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_PCI</strong></dt> </dl> </td><td> <p> PCI bus. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_PCI_Express</strong></dt> </dl> </td><td> <p> PCI Express bus. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_PCIX</strong></dt> </dl> </td><td> <p> PCI-X bus. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_SDI</strong></dt> </dl> </td><td> <p> Audio data sent over a connector via S/PDIF. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_SPDIF</strong></dt> </dl> </td><td> <p> Serial digital interface connector. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_SVIDEO</strong></dt> </dl> </td><td> <p> S-Video connector. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_UDI_EMBEDDED</strong></dt> </dl> </td><td> <p> Embedded Unified Display Interface (UDI). </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_UDI_EXTERNAL</strong></dt> </dl> </td><td> <p> External UDI. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_UNKNOWN</strong></dt> </dl> </td><td> <p> Unknown connector type. See Remarks. </p> </td></tr> <tr><td><dl> <dt><strong>MFCONNECTOR_VGA</strong></dt> </dl> </td><td> <p> VGA connector. </p> </td></tr> <tr><td><dl> <dt><strong> MFCONNECTOR_MIRACAST</strong></dt> </dl> </td><td> <p>Miracast wireless connector. </p> <p>Supported in Windows?8.1 and later.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "rgGuidProtectionSchemasSupported"><dd> <p> Pointer to an array of <see cref = "T:System.Guid"/> values that specify which output protection systems are supported by the OTA that is calling this method. </p> </dd></param>
            <param name = "cProtectionSchemasSupported"><dd> <p> Number of elements in the <em>rgGuidProtectionSchemasSupported</em> array. </p> </dd></param>
            <param name = "requiredProtectionSchemasOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Collection"/></strong> interface of a collection object. The caller must release the interface. Each object in the collection is an <strong><see cref = "T:SharpDX.MediaFoundation.OutputSchema"/></strong> reference. Each <strong><see cref = "T:SharpDX.MediaFoundation.OutputSchema"/></strong> reference defines an output protection system that the OTA must enforce. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The video OTA returns  the <strong>MFCONNECTOR_UNKNOWN</strong> connector type unless the Direct3D device is in full-screen mode. (Direct3D windowed mode is not generally a secure video mode.) You can override this behavior by implementing a custom EVR presenter that implements the <strong><see cref = "T:SharpDX.MediaFoundation.TrustedVideoPlugin"/></strong> interface.</p>
            </remarks>
            <doc-id>bb970362</doc-id>
            <unmanaged>HRESULT IMFOutputPolicy::GenerateRequiredSchemas([In] DWORD dwAttributes,[In] GUID guidOutputSubType,[In] GUID* rgGuidProtectionSchemasSupported,[In] DWORD cProtectionSchemasSupported,[Out] IMFCollection** ppRequiredProtectionSchemas)</unmanaged>
            <unmanaged-short>IMFOutputPolicy::GenerateRequiredSchemas</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.OutputPolicy.GetOriginatorID(System.Guid@)">
            <summary>
            <p> </p><p>Retrieives a <see cref = "T:System.Guid"/> identifying the input trust authority (ITA) that created this output policy object.</p>
            </summary>
            <param name = "guidOriginatorIDRef"><dd> <p>Receives a <see cref = "T:System.Guid"/> that identifies the originating ITA.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>All of the policy objects and output schemas from the same ITA should return the same originator identifier (including dynamic policy changes). This value enables the OTA to distinguish policies that originate from different ITAs, so that the OTA can update dynamic policies correctly.</p>
            </remarks>
            <doc-id>bb970379</doc-id>
            <unmanaged>HRESULT IMFOutputPolicy::GetOriginatorID([Out] GUID* pguidOriginatorID)</unmanaged>
            <unmanaged-short>IMFOutputPolicy::GetOriginatorID</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.OutputPolicy.GetMinimumGRLVersion(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the minimum version of the global revocation list (GRL) that must be enforced by the protected environment for this policy.</p>
            </summary>
            <param name = "dwMinimumGRLVersionRef"><dd> <p>Receives the minimum GRL version.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970389</doc-id>
            <unmanaged>HRESULT IMFOutputPolicy::GetMinimumGRLVersion([Out] DWORD* pdwMinimumGRLVersion)</unmanaged>
            <unmanaged-short>IMFOutputPolicy::GetMinimumGRLVersion</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.OutputSchema.SchemaType">
            <summary>
            <p> </p><p>Retrieves the output protection system that is represented by this object. Output protection systems are identified by <see cref = "T:System.Guid"/> value.</p>
            </summary>
            <doc-id>bb970414</doc-id>
            <unmanaged>GetSchemaType</unmanaged>
            <unmanaged-short>GetSchemaType</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.OutputSchema.ConfigurationData">
            <summary>
            <p> </p><p>Returns configuration data for the output protection system. The configuration data is used to enable or disable the protection system, and to set the protection levels.</p>
            </summary>
            <doc-id>bb970364</doc-id>
            <unmanaged>GetConfigurationData</unmanaged>
            <unmanaged-short>GetConfigurationData</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.OutputSchema.OriginatorID">
            <summary>
            <p> </p><p>Retrieves a <see cref = "T:System.Guid"/> identifying the input trust authority (ITA) that generated this output schema object.</p>
            </summary>
            <remarks>
            <p>All of the policy objects and output schemas from the same ITA should return the same originator identifier (including dynamic policy changes). This value enables the OTA to distinguish policies that originate from different ITAs, so that the OTA can update dynamic policies correctly.</p>
            </remarks>
            <doc-id>bb970483</doc-id>
            <unmanaged>GetOriginatorID</unmanaged>
            <unmanaged-short>GetOriginatorID</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.OutputSchema.GetSchemaType(System.Guid@)">
            <summary>
            <p> </p><p>Retrieves the output protection system that is represented by this object. Output protection systems are identified by <see cref = "T:System.Guid"/> value.</p>
            </summary>
            <param name = "guidSchemaTypeRef"><dd> <p>Receives the <see cref = "T:System.Guid"/> that identifies the output protection system.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970414</doc-id>
            <unmanaged>HRESULT IMFOutputSchema::GetSchemaType([Out] GUID* pguidSchemaType)</unmanaged>
            <unmanaged-short>IMFOutputSchema::GetSchemaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.OutputSchema.GetConfigurationData(System.Int32@)">
            <summary>
            <p> </p><p>Returns configuration data for the output protection system. The configuration data is used to enable or disable the protection system, and to set the protection levels.</p>
            </summary>
            <param name = "dwValRef"><dd> <p>Receives the configuration data. The meaning of this data depends on the output protection system.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970364</doc-id>
            <unmanaged>HRESULT IMFOutputSchema::GetConfigurationData([Out] DWORD* pdwVal)</unmanaged>
            <unmanaged-short>IMFOutputSchema::GetConfigurationData</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.OutputSchema.GetOriginatorID(System.Guid@)">
            <summary>
            <p> </p><p>Retrieves a <see cref = "T:System.Guid"/> identifying the input trust authority (ITA) that generated this output schema object.</p>
            </summary>
            <param name = "guidOriginatorIDRef"><dd> <p>Receives a <see cref = "T:System.Guid"/> that identifies the originating ITA.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>All of the policy objects and output schemas from the same ITA should return the same originator identifier (including dynamic policy changes). This value enables the OTA to distinguish policies that originate from different ITAs, so that the OTA can update dynamic policies correctly.</p>
            </remarks>
            <doc-id>bb970483</doc-id>
            <unmanaged>HRESULT IMFOutputSchema::GetOriginatorID([Out] GUID* pguidOriginatorID)</unmanaged>
            <unmanaged-short>IMFOutputSchema::GetOriginatorID</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.OutputTrustAuthority.Action">
            <summary>
            <p> </p><p>Retrieves the action that is performed by this output trust authority (OTA).</p>
            </summary>
            <doc-id>bb970410</doc-id>
            <unmanaged>GetAction</unmanaged>
            <unmanaged-short>GetAction</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.OutputTrustAuthority.GetAction(SharpDX.MediaFoundation.PolicymanagerAction@)">
            <summary>
            <p> </p><p>Retrieves the action that is performed by this output trust authority (OTA).</p>
            </summary>
            <param name = "actionRef"><dd> <p>Receives a member of the <see cref = "T:SharpDX.MediaFoundation.PolicymanagerAction"/> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970410</doc-id>
            <unmanaged>HRESULT IMFOutputTrustAuthority::GetAction([Out] MFPOLICYMANAGER_ACTION* pAction)</unmanaged>
            <unmanaged-short>IMFOutputTrustAuthority::GetAction</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.OutputTrustAuthority.SetPolicy(SharpDX.MediaFoundation.OutputPolicy[],System.Int32,System.Byte[],System.Int32@)">
            <summary>
            <p> Sets one or more policy objects on the output trust authority (OTA). </p>
            </summary>
            <param name = "policyOut"><dd> <p>The address of  an array of <strong><see cref = "T:SharpDX.MediaFoundation.OutputPolicy"/></strong> references. </p> </dd></param>
            <param name = "nPolicy"><dd> <p> The number of elements in the <em>ppPolicy</em> array. </p> </dd></param>
            <param name = "bTicketOut"><dd> <p> Receives either a reference to a buffer allocated by the OTA, or the value <strong><c>null</c></strong>. If this parameter receives a non-<strong><c>null</c></strong> value, the caller must release the buffer by calling <strong>CoTaskMemFree</strong>. </p> <strong>Note</strong>??Currently this parameter is reserved. An OTA should set the reference to <strong><c>null</c></strong>. ? </dd></param>
            <param name = "cbTicketRef"><dd> <p> Receives the size of the <em>ppbTicket</em> buffer, in bytes. If <em>ppbTicket</em> receives the value <strong><c>null</c></strong>, <em>pcbTicket</em> receives the value zero.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>MF_S_WAIT_FOR_POLICY_SET</strong></dt> </dl> </td><td> <p> The policy was negotiated successfully, but the OTA will enforce it asynchronously. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:PolicyUnsupported"/></strong></dt> </dl> </td><td> <p> The OTA does not support the requirements of this policy. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the method returns <strong>MF_S_WAIT_FOR_POLICY_SET</strong>, the OTA sends an MEPolicySet event when it enforces the policy.</p>
            </remarks>
            <doc-id>bb970572</doc-id>
            <unmanaged>HRESULT IMFOutputTrustAuthority::SetPolicy([In, Buffer, Optional] IMFOutputPolicy** ppPolicy,[In] DWORD nPolicy,[Out, Buffer, Optional] unsigned char** ppbTicket,[Out, Optional] DWORD* pcbTicket)</unmanaged>
            <unmanaged-short>IMFOutputTrustAuthority::SetPolicy</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.OutputTrustAuthority.SetPolicy(SharpDX.ComArray{SharpDX.MediaFoundation.OutputPolicy},System.Int32,System.Byte[],System.Int32@)">
            <summary>
            <p> Sets one or more policy objects on the output trust authority (OTA). </p>
            </summary>
            <param name = "policyOut"><dd> <p>The address of  an array of <strong><see cref = "T:SharpDX.MediaFoundation.OutputPolicy"/></strong> references. </p> </dd></param>
            <param name = "nPolicy"><dd> <p> The number of elements in the <em>ppPolicy</em> array. </p> </dd></param>
            <param name = "bTicketOut"><dd> <p> Receives either a reference to a buffer allocated by the OTA, or the value <strong><c>null</c></strong>. If this parameter receives a non-<strong><c>null</c></strong> value, the caller must release the buffer by calling <strong>CoTaskMemFree</strong>. </p> <strong>Note</strong>??Currently this parameter is reserved. An OTA should set the reference to <strong><c>null</c></strong>. ? </dd></param>
            <param name = "cbTicketRef"><dd> <p> Receives the size of the <em>ppbTicket</em> buffer, in bytes. If <em>ppbTicket</em> receives the value <strong><c>null</c></strong>, <em>pcbTicket</em> receives the value zero.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>MF_S_WAIT_FOR_POLICY_SET</strong></dt> </dl> </td><td> <p> The policy was negotiated successfully, but the OTA will enforce it asynchronously. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:PolicyUnsupported"/></strong></dt> </dl> </td><td> <p> The OTA does not support the requirements of this policy. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the method returns <strong>MF_S_WAIT_FOR_POLICY_SET</strong>, the OTA sends an MEPolicySet event when it enforces the policy.</p>
            </remarks>
            <doc-id>bb970572</doc-id>
            <unmanaged>HRESULT IMFOutputTrustAuthority::SetPolicy([In, Buffer, Optional] IMFOutputPolicy** ppPolicy,[In] DWORD nPolicy,[Out, Buffer, Optional] unsigned char** ppbTicket,[Out, Optional] DWORD* pcbTicket)</unmanaged>
            <unmanaged-short>IMFOutputTrustAuthority::SetPolicy</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.OutputTrustAuthority.SetPolicy(System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            <p> Sets one or more policy objects on the output trust authority (OTA). </p>
            </summary>
            <param name = "policyOut"><dd> <p>The address of  an array of <strong><see cref = "T:SharpDX.MediaFoundation.OutputPolicy"/></strong> references. </p> </dd></param>
            <param name = "nPolicy"><dd> <p> The number of elements in the <em>ppPolicy</em> array. </p> </dd></param>
            <param name = "bTicketOut"><dd> <p> Receives either a reference to a buffer allocated by the OTA, or the value <strong><c>null</c></strong>. If this parameter receives a non-<strong><c>null</c></strong> value, the caller must release the buffer by calling <strong>CoTaskMemFree</strong>. </p> <strong>Note</strong>??Currently this parameter is reserved. An OTA should set the reference to <strong><c>null</c></strong>. ? </dd></param>
            <param name = "cbTicketRef"><dd> <p> Receives the size of the <em>ppbTicket</em> buffer, in bytes. If <em>ppbTicket</em> receives the value <strong><c>null</c></strong>, <em>pcbTicket</em> receives the value zero.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>MF_S_WAIT_FOR_POLICY_SET</strong></dt> </dl> </td><td> <p> The policy was negotiated successfully, but the OTA will enforce it asynchronously. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:PolicyUnsupported"/></strong></dt> </dl> </td><td> <p> The OTA does not support the requirements of this policy. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the method returns <strong>MF_S_WAIT_FOR_POLICY_SET</strong>, the OTA sends an MEPolicySet event when it enforces the policy.</p>
            </remarks>
            <doc-id>bb970572</doc-id>
            <unmanaged>HRESULT IMFOutputTrustAuthority::SetPolicy([In, Buffer, Optional] IMFOutputPolicy** ppPolicy,[In] DWORD nPolicy,[Out, Buffer, Optional] unsigned char** ppbTicket,[Out, Optional] DWORD* pcbTicket)</unmanaged>
            <unmanaged-short>IMFOutputTrustAuthority::SetPolicy</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PluginControl.GetPreferredClsid(System.Int32,System.String,System.Guid@)">
            <summary>
            <p>Searches the preferred list for a class identifier (CLSID) that matches a specified key name.</p>
            </summary>
            <param name = "pluginType"><dd> <p>Member of the <strong><see cref = "T:SharpDX.MediaFoundation.PluginType"/></strong> enumeration, specifying the type of object.</p> </dd></param>
            <param name = "selector"><dd> <p>The key name to match. For more information about the format of key names, see the Remarks section of <strong><see cref = "T:SharpDX.MediaFoundation.PluginControl"/></strong>.</p> </dd></param>
            <param name = "clsid"><dd> <p>Receives a CLSID from the preferred list.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>HRESULT_FROM_WIN32(ERROR_NOT_FOUND)</strong></strong></dt> </dl> </td><td> <p>No CLSID matching this key was found.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dd374304</doc-id>
            <unmanaged>HRESULT IMFPluginControl::GetPreferredClsid([In] DWORD pluginType,[In] const wchar_t* selector,[Out] GUID* clsid)</unmanaged>
            <unmanaged-short>IMFPluginControl::GetPreferredClsid</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PluginControl.GetPreferredClsidByIndex(System.Int32,System.Int32,System.IntPtr,System.Guid@)">
            <summary>
            <p>Gets a class identifier (CLSID) from the preferred list, specified by index value.</p>
            </summary>
            <param name = "pluginType"><dd> <p>Member of the <strong><see cref = "T:SharpDX.MediaFoundation.PluginType"/></strong> enumeration, specifying the type of object to enumerate.</p> </dd></param>
            <param name = "index"><dd> <p>The zero-based index of the CLSID to retrieve.</p> </dd></param>
            <param name = "selector"><dd> <p>Receives the key name associated with the CLSID. The caller must free the memory for the returned string by calling the <strong>CoTaskMemFree</strong> function. For more information about the format of key names, see the Remarks section of <strong><see cref = "T:SharpDX.MediaFoundation.PluginControl"/></strong>.</p> </dd></param>
            <param name = "clsid"><dd> <p>Receives the CLSID at the specified index.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)</strong></strong></dt> </dl> </td><td> <p>The <em>index</em> parameter is out of range.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dd374305</doc-id>
            <unmanaged>HRESULT IMFPluginControl::GetPreferredClsidByIndex([In] DWORD pluginType,[In] DWORD index,[Out] wchar_t** selector,[Out] GUID* clsid)</unmanaged>
            <unmanaged-short>IMFPluginControl::GetPreferredClsidByIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PluginControl.SetPreferredClsid(System.Int32,System.String,System.Nullable{System.Guid})">
            <summary>
            <p>Adds a class identifier (CLSID) to the preferred list or removes a CLSID from the list.</p>
            </summary>
            <param name = "pluginType"><dd> <p>Member of the <strong><see cref = "T:SharpDX.MediaFoundation.PluginType"/></strong> enumeration, specifying the type of object.</p> </dd></param>
            <param name = "selector"><dd> <p>The key name for the CLSID. For more information about the format of key names, see the Remarks section of <strong><see cref = "T:SharpDX.MediaFoundation.PluginControl"/></strong>.</p> </dd></param>
            <param name = "clsid"><dd> <p>The CLSID to add to the list. If this parameter is <strong><c>null</c></strong>, the key/value entry specified by the <em>selector</em> parameter is removed from the list. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The preferred list is global to the caller's process. Calling this method does not affect the list in other process.</p>
            </remarks>
            <doc-id>dd374308</doc-id>
            <unmanaged>HRESULT IMFPluginControl::SetPreferredClsid([In] DWORD pluginType,[In] const wchar_t* selector,[In, Optional] const GUID* clsid)</unmanaged>
            <unmanaged-short>IMFPluginControl::SetPreferredClsid</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PluginControl.IsDisabled(System.Int32,System.Guid)">
            <summary>
            <p>Queries whether a class identifier (CLSID) appears in the blocked list.</p>
            </summary>
            <param name = "pluginType"><dd> <p>Member of the <strong><see cref = "T:SharpDX.MediaFoundation.PluginType"/></strong> enumeration, specifying the type of object for the query.</p> </dd></param>
            <param name = "clsid"><dd> <p>The CLSID to search for.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The specified CLSID appears in the blocked list.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>HRESULT_FROM_WIN32(ERROR_NOT_FOUND)</strong></strong></dt> </dl> </td><td> <p>The specified CLSID is not in the blocked list.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dd374306</doc-id>
            <unmanaged>HRESULT IMFPluginControl::IsDisabled([In] DWORD pluginType,[In] const GUID&amp; clsid)</unmanaged>
            <unmanaged-short>IMFPluginControl::IsDisabled</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PluginControl.GetDisabledByIndex(System.Int32,System.Int32,System.Guid@)">
            <summary>
            <p>Gets a class identifier (CLSID) from the blocked list.</p>
            </summary>
            <param name = "pluginType"><dd> <p>Member of the <strong><see cref = "T:SharpDX.MediaFoundation.PluginType"/></strong> enumeration, specifying the type of object to enumerate.</p> </dd></param>
            <param name = "index"><dd> <p>The zero-based index of the CLSID to retrieve.</p> </dd></param>
            <param name = "clsid"><dd> <p>Receives the CLSID at the specified index.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)</strong></strong></dt> </dl> </td><td> <p>The <em>index</em> parameter is out of range.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dd374303</doc-id>
            <unmanaged>HRESULT IMFPluginControl::GetDisabledByIndex([In] DWORD pluginType,[In] DWORD index,[Out] GUID* clsid)</unmanaged>
            <unmanaged-short>IMFPluginControl::GetDisabledByIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PluginControl.SetDisabled(System.Int32,System.Guid,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Adds a class identifier (CLSID) to the blocked list, or removes a CLSID from the list.</p>
            </summary>
            <param name = "pluginType"><dd> <p>Member of the <strong><see cref = "T:SharpDX.MediaFoundation.PluginType"/></strong> enumeration, specifying the type of object.</p> </dd></param>
            <param name = "clsid"><dd> <p>The CLSID to add or remove.</p> </dd></param>
            <param name = "disabled"><dd> <p>Specifies whether to add or remove the CSLID. If the value is <strong>TRUE</strong>, the method adds the CLSID to the blocked list. Otherwise, the method removes it from the list.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> The blocked list is global to the caller's process. Calling this method does not affect the list in other processes. </p>
            </remarks>
            <doc-id>dd374307</doc-id>
            <unmanaged>HRESULT IMFPluginControl::SetDisabled([In] DWORD pluginType,[In] const GUID&amp; clsid,[In] BOOL disabled)</unmanaged>
            <unmanaged-short>IMFPluginControl::SetDisabled</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PluginControl2.Policy">
            <summary>
            <p>Sets the policy for which media sources and transforms are enumerated.</p>
            </summary>
            <doc-id>hh448044</doc-id>
            <unmanaged>SetPolicy</unmanaged>
            <unmanaged-short>SetPolicy</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PluginControl2.SetPolicy(SharpDX.MediaFoundation.PluginControlPolicy)">
            <summary>
            <p>Sets the policy for which media sources and transforms are enumerated.</p>
            </summary>
            <param name = "policy"><dd> <p>A value from the <strong><see cref = "T:SharpDX.MediaFoundation.PluginControlPolicy"/></strong> enumeration that specifies the policy.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh448044</doc-id>
            <unmanaged>HRESULT IMFPluginControl2::SetPolicy([In] MF_PLUGIN_CONTROL_POLICY policy)</unmanaged>
            <unmanaged-short>IMFPluginControl2::SetPolicy</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PMediaItem.MediaPlayer">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets a reference to the MFPlay player object that created the media item.</p>
            </summary>
            <doc-id>dd374313</doc-id>
            <unmanaged>GetMediaPlayer</unmanaged>
            <unmanaged-short>GetMediaPlayer</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PMediaItem.ObjectW">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the object that was used to create the media item.</p>
            </summary>
            <remarks>
            <p>The object reference is set if the application uses <strong>IMFPMediaPlayer::CreateMediaItemFromObject</strong> to create the media item. Otherwise, <strong>GetObject</strong> returns  MF_E_NOTFOUND.</p>
            </remarks>
            <doc-id>dd374315</doc-id>
            <unmanaged>GetObjectW</unmanaged>
            <unmanaged-short>GetObjectW</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PMediaItem.UserData">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the application-defined value stored in the media item.</p>
            </summary>
            <remarks>
            <p>You can assign this value when you first create the media item, by specifying it in the <em>dwUserData</em> parameter of the <strong>IMFPMediaPlayer::CreateMediaItemFromURL</strong> or <strong>IMFPMediaPlayer::CreateMediaItemFromObject</strong> method. To update the value, call <strong>IMFPMediaItem::SetUserData</strong>.</p><p>This method can be called after the player object is shut down.</p>
            </remarks>
            <doc-id>dd374321</doc-id>
            <unmanaged>GetUserData / SetUserData</unmanaged>
            <unmanaged-short>GetUserData</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PMediaItem.IsProtected">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queries whether the media item contains protected content.</p><strong>Note</strong>??Currently <strong><see cref = "T:SharpDX.MediaFoundation.PMediaPlayer"/></strong> does not support playing protected content.?
            </summary>
            <doc-id>dd374324</doc-id>
            <unmanaged>IsProtected</unmanaged>
            <unmanaged-short>IsProtected</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PMediaItem.NumberOfStreams">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the number of streams (audio, video, and other) in the media item.</p>
            </summary>
            <doc-id>dd374314</doc-id>
            <unmanaged>GetNumberOfStreams</unmanaged>
            <unmanaged-short>GetNumberOfStreams</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PMediaItem.Characteristics">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets various flags that describe the media item.</p>
            </summary>
            <doc-id>dd374311</doc-id>
            <unmanaged>GetCharacteristics</unmanaged>
            <unmanaged-short>GetCharacteristics</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PMediaItem.Metadata">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets a property store that contains metadata for the source, such as author or title.</p>
            </summary>
            <doc-id>dd798056</doc-id>
            <unmanaged>GetMetadata</unmanaged>
            <unmanaged-short>GetMetadata</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaItem.GetMediaPlayer(SharpDX.MediaFoundation.PMediaPlayer@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets a reference to the MFPlay player object that created the media item.</p>
            </summary>
            <param name = "mediaPlayerOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd374313</doc-id>
            <unmanaged>HRESULT IMFPMediaItem::GetMediaPlayer([Out] IMFPMediaPlayer** ppMediaPlayer)</unmanaged>
            <unmanaged-short>IMFPMediaItem::GetMediaPlayer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaItem.GetURL(System.IntPtr)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the URL that was used to create the media item.</p>
            </summary>
            <param name = "wszURLOut">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>MF_E_NOTFOUND</strong></dt> </dl> </td><td> <p>No URL is associated with this media item.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong>IMFPMediaPlayer::Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method applies when the application calls  <strong>IMFPMediaPlayer::CreateMediaItemFromURL</strong> to create a media item. If the application calls <strong>IMFPMediaPlayer::CreateMediaItemFromObject</strong> to create a media item, the  <strong>GetURL</strong> method for that media item returns  <strong>MF_E_NOTFOUND</strong>.</p>
            </remarks>
            <doc-id>dd374320</doc-id>
            <unmanaged>HRESULT IMFPMediaItem::GetURL([Out] wchar_t** ppwszURL)</unmanaged>
            <unmanaged-short>IMFPMediaItem::GetURL</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaItem.GetObjectW(SharpDX.IUnknown@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the object that was used to create the media item.</p>
            </summary>
            <param name = "iUnknownOut">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>MF_E_NOTFOUND</strong></dt> </dl> </td><td> <p>The media item was created from a URL, not from an object.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The <strong>IMFPMediaPlayer::Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The object reference is set if the application uses <strong>IMFPMediaPlayer::CreateMediaItemFromObject</strong> to create the media item. Otherwise, <strong>GetObject</strong> returns  MF_E_NOTFOUND.</p>
            </remarks>
            <doc-id>dd374315</doc-id>
            <unmanaged>HRESULT IMFPMediaItem::GetObjectW([Out] IUnknown** ppIUnknown)</unmanaged>
            <unmanaged-short>IMFPMediaItem::GetObjectW</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaItem.GetUserData(System.IntPtr@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the application-defined value stored in the media item.</p>
            </summary>
            <param name = "dwUserDataRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>You can assign this value when you first create the media item, by specifying it in the <em>dwUserData</em> parameter of the <strong>IMFPMediaPlayer::CreateMediaItemFromURL</strong> or <strong>IMFPMediaPlayer::CreateMediaItemFromObject</strong> method. To update the value, call <strong>IMFPMediaItem::SetUserData</strong>.</p><p>This method can be called after the player object is shut down.</p>
            </remarks>
            <doc-id>dd374321</doc-id>
            <unmanaged>HRESULT IMFPMediaItem::GetUserData([Out] ULONG_PTR* pdwUserData)</unmanaged>
            <unmanaged-short>IMFPMediaItem::GetUserData</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaItem.SetUserData(System.IntPtr)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Stores an application-defined value in the media item.</p>
            </summary>
            <param name = "dwUserData">No documentation.</param>
            <returns><p>This method can return one of these values.</p></returns>
            <remarks>
            <p>This method can be called after the player object is shut down.</p>
            </remarks>
            <doc-id>dd374328</doc-id>
            <unmanaged>HRESULT IMFPMediaItem::SetUserData([In] ULONG_PTR dwUserData)</unmanaged>
            <unmanaged-short>IMFPMediaItem::SetUserData</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaItem.GetStartStopPosition(System.Guid@,SharpDX.Win32.Variant@,System.Guid@,SharpDX.Win32.Variant@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the start and stop times for the media item.</p>
            </summary>
            <param name = "guidStartPositionTypeRef">No documentation.</param>
            <param name = "vStartValueRef">No documentation.</param>
            <param name = "guidStopPositionTypeRef">No documentation.</param>
            <param name = "vStopValueRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The <em>pguidStartPositionType</em> and <em>pguidStopPositionType</em> parameters receive the units of time that are used. Currently, the only supported value is <strong>MFP_POSITIONTYPE_100NS</strong>.</p><table> <tr><th>Value</th><th>Description</th></tr> <tr><td>MFP_POSITIONTYPE_100NS</td><td>100-nanosecond units. The time parameter (<em>pvStartValue</em> or <em>pvStopValue</em>) uses the following data type:<ul> <li>Variant type (<strong>vt</strong>): VT_I8</li> <li>Variant member: <strong>hVal</strong></li> </ul> </td></tr> </table><p>?</p>
            </remarks>
            <doc-id>dd374317</doc-id>
            <unmanaged>HRESULT IMFPMediaItem::GetStartStopPosition([Out, Optional] GUID* pguidStartPositionType,[Out, Optional] PROPVARIANT* pvStartValue,[Out, Optional] GUID* pguidStopPositionType,[Out, Optional] PROPVARIANT* pvStopValue)</unmanaged>
            <unmanaged-short>IMFPMediaItem::GetStartStopPosition</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaItem.SetStartStopPosition(System.Nullable{System.Guid},System.Nullable{SharpDX.Win32.Variant},System.Nullable{System.Guid},System.Nullable{SharpDX.Win32.Variant})">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Sets the start and stop time for the media item.</p>
            </summary>
            <param name = "guidStartPositionTypeRef">No documentation.</param>
            <param name = "vStartValueRef">No documentation.</param>
            <param name = "guidStopPositionTypeRef">No documentation.</param>
            <param name = "vStopValueRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:OutOfRange"/></strong></dt> </dl> </td><td> <p>Invalid start or stop time. Any of the following can cause this error:</p> <ul> <li>Time less than zero.</li> <li>Time greater than the total duration of the media item.</li> <li>Stop time less than start time.</li> </ul> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>By default, a media item plays from the beginning to the end of the file. This method adjusts the start time and/or  the stop time:</p><ul> <li>To set the start time, pass non-<strong><c>null</c></strong> values for <em>pguidStartPositionType</em> and <em>pvStartValue</em>.</li> <li>To set the stop time, pass non-<strong><c>null</c></strong> values for <em>pguidStopPositionType</em> and <em>pvStopValue</em>.</li> </ul><p>The <em>pguidStartPositionType</em> and <em>pguidStopPositionType</em> parameters give the units of time that are used. Currently, the only supported value is <strong>MFP_POSITIONTYPE_100NS</strong>.</p><table> <tr><th>Value</th><th>Description</th></tr> <tr><td><strong>MFP_POSITIONTYPE_100NS</strong></td><td>100-nanosecond units. The time parameter (<em>pvStartValue</em> or <em>pvStopValue</em>) uses the following data type:<ul> <li>Variant type (<strong>vt</strong>): <strong>VT_I8</strong></li> <li>Variant member: <strong>hVal</strong></li> </ul> <p>To clear a previously set time, use an empty <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> (<strong>VT_EMPTY</strong>).</p> </td></tr> </table><p>?</p><p>The adjusted start and stop times are used the next time that <strong>IMFPMediaPlayer::SetMediaItem</strong> is called with this media item. If the media item is already set on the player, the change does not happen unless you call <strong>SetMediaItem</strong> again.</p>
            </remarks>
            <doc-id>dd374325</doc-id>
            <unmanaged>HRESULT IMFPMediaItem::SetStartStopPosition([In, Optional] const GUID* pguidStartPositionType,[In, Optional] const PROPVARIANT* pvStartValue,[In, Optional] const GUID* pguidStopPositionType,[In, Optional] const PROPVARIANT* pvStopValue)</unmanaged>
            <unmanaged-short>IMFPMediaItem::SetStartStopPosition</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaItem.HasVideo(SharpDX.Mathematics.Interop.RawBool@,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queries whether the media item contains a video stream.</p>
            </summary>
            <param name = "fHasVideoRef">No documentation.</param>
            <param name = "fSelectedRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> To select or deselect streams before playback starts, call <strong>IMFPMediaItem::SetStreamSelection</strong>.</p>
            </remarks>
            <doc-id>dd374323</doc-id>
            <unmanaged>HRESULT IMFPMediaItem::HasVideo([Out, Optional] BOOL* pfHasVideo,[Out, Optional] BOOL* pfSelected)</unmanaged>
            <unmanaged-short>IMFPMediaItem::HasVideo</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaItem.HasAudio(SharpDX.Mathematics.Interop.RawBool@,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queries whether the media item contains an audio stream.</p>
            </summary>
            <param name = "fHasAudioRef">No documentation.</param>
            <param name = "fSelectedRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> To select or deselect streams before playback starts, call <strong>IMFPMediaItem::SetStreamSelection</strong>.</p>
            </remarks>
            <doc-id>dd374322</doc-id>
            <unmanaged>HRESULT IMFPMediaItem::HasAudio([Out, Optional] BOOL* pfHasAudio,[Out, Optional] BOOL* pfSelected)</unmanaged>
            <unmanaged-short>IMFPMediaItem::HasAudio</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaItem.IsProtected_(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queries whether the media item contains protected content.</p><strong>Note</strong>??Currently <strong><see cref = "T:SharpDX.MediaFoundation.PMediaPlayer"/></strong> does not support playing protected content.?
            </summary>
            <param name = "fProtectedRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd374324</doc-id>
            <unmanaged>HRESULT IMFPMediaItem::IsProtected([Out] BOOL* pfProtected)</unmanaged>
            <unmanaged-short>IMFPMediaItem::IsProtected</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaItem.GetDuration(System.Guid,SharpDX.Win32.Variant@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the duration of the media item.</p>
            </summary>
            <param name = "guidPositionType">No documentation.</param>
            <param name = "vDurationValueRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The method returns the total duration of the content, regardless of any values set through <strong>IMFPMediaItem::SetStartStopPosition</strong>.</p>
            </remarks>
            <doc-id>dd374312</doc-id>
            <unmanaged>HRESULT IMFPMediaItem::GetDuration([In] const GUID&amp; guidPositionType,[Out] PROPVARIANT* pvDurationValue)</unmanaged>
            <unmanaged-short>IMFPMediaItem::GetDuration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaItem.GetNumberOfStreams(System.Int32@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the number of streams (audio, video, and other) in the media item.</p>
            </summary>
            <param name = "dwStreamCountRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd374314</doc-id>
            <unmanaged>HRESULT IMFPMediaItem::GetNumberOfStreams([Out] DWORD* pdwStreamCount)</unmanaged>
            <unmanaged-short>IMFPMediaItem::GetNumberOfStreams</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaItem.GetStreamSelection(System.Int32,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queries whether a stream is selected to play.</p>
            </summary>
            <param name = "dwStreamIndex">No documentation.</param>
            <param name = "fEnabledRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> To select or deselect a stream, call <strong>IMFPMediaItem::SetStreamSelection</strong>. </p>
            </remarks>
            <doc-id>dd374319</doc-id>
            <unmanaged>HRESULT IMFPMediaItem::GetStreamSelection([In] DWORD dwStreamIndex,[Out] BOOL* pfEnabled)</unmanaged>
            <unmanaged-short>IMFPMediaItem::GetStreamSelection</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaItem.SetStreamSelection(System.Int32,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Selects or deselects a stream.</p>
            </summary>
            <param name = "dwStreamIndex">No documentation.</param>
            <param name = "fEnabled">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>You can use this method to change which streams are selected. The change goes into effect the next time that <strong>IMFPMediaPlayer::SetMediaItem</strong> is called with this media item. If the media item is already set on the player, the change does not happen unless you call <strong>SetMediaItem</strong> again with this media item.</p>
            </remarks>
            <doc-id>dd374326</doc-id>
            <unmanaged>HRESULT IMFPMediaItem::SetStreamSelection([In] DWORD dwStreamIndex,[In] BOOL fEnabled)</unmanaged>
            <unmanaged-short>IMFPMediaItem::SetStreamSelection</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaItem.GetStreamAttribute(System.Int32,System.Guid,SharpDX.Win32.Variant@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queries the media item for a stream attribute.</p>
            </summary>
            <param name = "dwStreamIndex">No documentation.</param>
            <param name = "guidMFAttribute">No documentation.</param>
            <param name = "vValueRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Stream attributes describe an individual stream (audio, video, or other) within the presentation. To get an attribute that applies to the entire presentation, call <strong>IMFPMediaItem::GetPresentationAttribute</strong>.</p>
            </remarks>
            <doc-id>dd374318</doc-id>
            <unmanaged>HRESULT IMFPMediaItem::GetStreamAttribute([In] DWORD dwStreamIndex,[In] const GUID&amp; guidMFAttribute,[Out] PROPVARIANT* pvValue)</unmanaged>
            <unmanaged-short>IMFPMediaItem::GetStreamAttribute</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaItem.GetPresentationAttribute(System.Guid,SharpDX.Win32.Variant@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queries the media item for a presentation attribute.</p>
            </summary>
            <param name = "guidMFAttribute">No documentation.</param>
            <param name = "vValueRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Presentation attributes describe the presentation as a whole. To get an attribute that applies to an individual stream within the presentation, call <strong>IMFPMediaItem::GetStreamAttribute</strong>.</p>
            </remarks>
            <doc-id>dd374316</doc-id>
            <unmanaged>HRESULT IMFPMediaItem::GetPresentationAttribute([In] const GUID&amp; guidMFAttribute,[Out] PROPVARIANT* pvValue)</unmanaged>
            <unmanaged-short>IMFPMediaItem::GetPresentationAttribute</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaItem.GetCharacteristics(System.Int32@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets various flags that describe the media item.</p>
            </summary>
            <param name = "characteristicsRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd374311</doc-id>
            <unmanaged>HRESULT IMFPMediaItem::GetCharacteristics([Out] unsigned int* pCharacteristics)</unmanaged>
            <unmanaged-short>IMFPMediaItem::GetCharacteristics</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaItem.SetStreamSink(System.Int32,SharpDX.IUnknown)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p> Sets a media sink for the media item. A <em>media sink</em> is an object that consumes the data from one or more streams. </p>
            </summary>
            <param name = "dwStreamIndex">No documentation.</param>
            <param name = "mediaSinkRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>By default, the MFPlay player object renders audio streams to the Streaming Audio Renderer (SAR) and video streams to the Enhanced Video Renderer (EVR). You can use the <strong>SetStreamSink</strong> method to provide a different media sink for an audio or video stream; or to support other stream types besides audio and video. You can also use it to configure the SAR or EVR before they are used.</p><p>Call this method before calling <strong>IMFPMediaPlayer::SetMediaItem</strong>. Calling this method after <strong>SetMediaItem</strong> has no effect, unless you stop playback and call <strong>SetMediaItem</strong> again.</p><p>To reset the media item to use the default media sink, set <em>pMediaSink</em> to <strong><c>null</c></strong>.</p>
            </remarks>
            <doc-id>dd374327</doc-id>
            <unmanaged>HRESULT IMFPMediaItem::SetStreamSink([In] DWORD dwStreamIndex,[In, Optional] IUnknown* pMediaSink)</unmanaged>
            <unmanaged-short>IMFPMediaItem::SetStreamSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaItem.GetMetadata(SharpDX.ComObject@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets a property store that contains metadata for the source, such as author or title.</p>
            </summary>
            <param name = "metadataStoreOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd798056</doc-id>
            <unmanaged>HRESULT IMFPMediaItem::GetMetadata([Out] IPropertyStore** ppMetadataStore)</unmanaged>
            <unmanaged-short>IMFPMediaItem::GetMetadata</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PMediaPlayer.Rate">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current playback rate.</p>
            </summary>
            <doc-id>dd374346</doc-id>
            <unmanaged>GetRate / SetRate</unmanaged>
            <unmanaged-short>GetRate</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PMediaPlayer.State">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current playback state of the MFPlay player object.</p>
            </summary>
            <remarks>
            <p>This method can be called after the player object has been shut down.</p><p>Many of the <strong><see cref = "T:SharpDX.MediaFoundation.PMediaPlayer"/></strong> methods complete asynchronously. While an asynchronous operation is pending, the current state is not updated until the operation completes. When the operation completes, the application receives an event callback, and the new state is given in the <strong><see cref = "T:SharpDX.MediaFoundation.PEventHeader"/></strong> structure that is passed to the callback.</p>
            </remarks>
            <doc-id>dd374347</doc-id>
            <unmanaged>GetState</unmanaged>
            <unmanaged-short>GetState</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PMediaPlayer.MediaItem">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets a reference to the current media item.</p>
            </summary>
            <remarks>
            <p>The <strong>IMFPMediaPlayer::SetMediaItem</strong> method is asynchronous. Therefore, while <strong>SetMediaItem</strong> is pending, <strong>GetMediaItem</strong> will not return the media item that was just set. Instead, the application should implement <strong><see cref = "T:SharpDX.MediaFoundation.PMediaPlayerCallback"/></strong> interface and handle the <strong>MFP_EVENT_TYPE_MEDIAITEM_SET</strong> event. For more information, see Receiving Events From the Player.</p><p>The previous remark also applies to setting the media item in the <strong>MFPCreateMediaPlayer</strong> function.</p>
            </remarks>
            <doc-id>dd374342</doc-id>
            <unmanaged>GetMediaItem / SetMediaItem</unmanaged>
            <unmanaged-short>GetMediaItem</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PMediaPlayer.Volume">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current audio volume.</p>
            </summary>
            <doc-id>dd374351</doc-id>
            <unmanaged>GetVolume / SetVolume</unmanaged>
            <unmanaged-short>GetVolume</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PMediaPlayer.Balance">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current audio balance.</p>
            </summary>
            <doc-id>dd374338</doc-id>
            <unmanaged>GetBalance / SetBalance</unmanaged>
            <unmanaged-short>GetBalance</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PMediaPlayer.Mute">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queries whether the audio is muted.</p>
            </summary>
            <doc-id>dd374343</doc-id>
            <unmanaged>GetMute / SetMute</unmanaged>
            <unmanaged-short>GetMute</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PMediaPlayer.VideoSourceRect">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the video source rectangle.</p>
            </summary>
            <doc-id>dd743246</doc-id>
            <unmanaged>GetVideoSourceRect / SetVideoSourceRect</unmanaged>
            <unmanaged-short>GetVideoSourceRect</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PMediaPlayer.AspectRatioMode">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current aspect-ratio correction mode. This mode controls whether the aspect ratio of the video is preserved during playback.</p>
            </summary>
            <doc-id>dd374337</doc-id>
            <unmanaged>GetAspectRatioMode / SetAspectRatioMode</unmanaged>
            <unmanaged-short>GetAspectRatioMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PMediaPlayer.VideoWindow">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the window where the video is displayed.</p>
            </summary>
            <remarks>
            <p>The video window is specified when you first call <strong>MFPCreateMediaPlayer</strong> to create the MFPlay player object.</p>
            </remarks>
            <doc-id>dd374350</doc-id>
            <unmanaged>GetVideoWindow</unmanaged>
            <unmanaged-short>GetVideoWindow</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PMediaPlayer.BorderColor">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current color of the video border. The border color is used to letterbox the video.</p>
            </summary>
            <doc-id>dd374339</doc-id>
            <unmanaged>GetBorderColor / SetBorderColor</unmanaged>
            <unmanaged-short>GetBorderColor</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.Play">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Starts playback.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method completes asynchronously.  When the operation completes, the application's <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> callback method is invoked. The event type is <strong>MFP_EVENT_TYPE_PLAY</strong>.</p>
            </remarks>
            <doc-id>dd374354</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::Play()</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::Play</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.Pause">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Pauses playback. While playback is paused, the most recent video frame is displayed, and audio is silent.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method completes asynchronously.  When the operation completes, the application's <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> callback method is invoked. The event type is <strong>MFP_EVENT_TYPE_PAUSE</strong>.</p>
            </remarks>
            <doc-id>dd374353</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::Pause()</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::Pause</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.Stop">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Stops playback.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method completes asynchronously.  When the operation completes, the application's <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> callback method is invoked. The event type is <strong>MFP_EVENT_TYPE_STOP</strong>.</p><p>The current media item is still valid. After playback stops, the playback position resets to the beginning of the current media item. </p>
            </remarks>
            <doc-id>dd374368</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::Stop()</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::Stop</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.FrameStep">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Steps forward one video frame.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>Cannot frame step. Reasons for this error code include:</p> <ul> <li>There is no media item queued for playback.</li> <li>The current media item does not contain video.</li> </ul> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedRate"/></strong></dt> </dl> </td><td> <p>The media source does not support frame stepping, or the current playback rate is negative.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> This method completes asynchronously.  When the operation completes, the application's <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> callback method is invoked. The event type is <strong>MFP_EVENT_TYPE_FRAME_STEP</strong>.</p><p>The player object does not support frame stepping during reverse playback (that is, while the playback rate is negative).</p>
            </remarks>
            <doc-id>dd374336</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::FrameStep()</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::FrameStep</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.SetPosition(System.Guid,SharpDX.Win32.Variant)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Sets the playback position.</p>
            </summary>
            <param name = "guidPositionType">No documentation.</param>
            <param name = "vPositionValueRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>HRESULT_FROM_WIN32( ERROR_SEEK )</strong></strong></dt> </dl> </td><td> <p>The value of <em>pvPositionValue</em> is not valid.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>No media item has been queued.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If you call this method while playback is stopped, the new position takes effect after playback resumes.</p><p>This method completes asynchronously. When the operation completes, the application's <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> callback method is invoked. The event type is <strong>MFP_EVENT_TYPE_POSITION_SET</strong>.</p><p>If playback was started before <strong>SetPosition</strong> is called, playback resumes at the new position. If playback was paused, the video is refreshed to display the current frame at the new position. </p><p>If you make two consecutive calls to <strong>SetPosition</strong> with <em>guidPositionType</em> equal to <strong>MFP_POSITIONTYPE_100NS</strong>, and the second call is made before the first call has completed, the second call supersedes the first. The status code for the superseded call is set to <strong>S_FALSE</strong> in the event data for that call. This behavior prevents excessive latency from repeated calls to <strong>SetPosition</strong>, as each call may force the media source to perform a relatively lengthy seek operation. </p>
            </remarks>
            <doc-id>dd374363</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::SetPosition([In] const GUID&amp; guidPositionType,[In] const PROPVARIANT* pvPositionValue)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::SetPosition</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.GetPosition(System.Guid,SharpDX.Win32.Variant@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current playback position.</p>
            </summary>
            <param name = "guidPositionType">No documentation.</param>
            <param name = "vPositionValueRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>No media item has been queued.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The playback position is calculated relative to the start time of the media item, which can be specified by calling <strong>IMFPMediaItem::SetStartStopPosition</strong>. For example, if you set the start time to 20 seconds and the source duration is 60 seconds, the range of values returned by <strong>GetPosition</strong> is 0?40 seconds.</p>
            </remarks>
            <doc-id>dd374345</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::GetPosition([In] const GUID&amp; guidPositionType,[Out] PROPVARIANT* pvPositionValue)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::GetPosition</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.GetDuration(System.Guid,SharpDX.Win32.Variant@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the playback duration of the current media item.</p>
            </summary>
            <param name = "guidPositionType">No documentation.</param>
            <param name = "vDurationValueRef">No documentation.</param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Attributenotfound"/></strong></dt> </dl> </td><td> <p>The media source does not have a duration. This error can occur with a live source, such as a video camera.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>There is no current media item.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method calculates the playback duration, taking into account the start and stop times for the media item. To set the start and stop times, call <strong>IMFPMediaItem::SetStartStopPosition</strong> on the media item. To get the actual duration of the underlying media file, regardless of start and stop times, call <strong>IMFPMediaItem::GetDuration</strong>.</p><p>For example, suppose that you load a 30-second audio file and set the start time equal to 2 seconds and stop time equal to 10 seconds. The <strong>IMFPMediaItem::GetDuration</strong> method will return 30 seconds, but the <strong>IMFPMediaPlayer::GetDuration</strong> method will return 8 seconds.</p>
            </remarks>
            <doc-id>dd374340</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::GetDuration([In] const GUID&amp; guidPositionType,[Out] PROPVARIANT* pvDurationValue)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::GetDuration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.SetRate(System.Single)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Sets the playback rate.</p>
            </summary>
            <param name = "flRate">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:OutOfRange"/></strong></strong></dt> </dl> </td><td> <p>The <em>flRate</em> parameter is zero.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method completes asynchronously.  When the operation completes, the application's <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> callback method is invoked. The event type is <strong>MFP_EVENT_TYPE_RATE_SET</strong>.</p><p>The method sets the nearest supported rate, which will depend on the underlying media source. For example, if <em>flRate</em> is 50 and the source's maximum rate is 8? normal rate, the method will set the rate to 8.0.  The actual rate is indicated in the event data for the <strong>MFP_EVENT_TYPE_RATE_SET</strong> event.</p><p>To find the range of supported rates, call <strong>IMFPMediaPlayer::GetSupportedRates</strong>.</p><p>This method does not support playback rates of zero, although Media Foundation defines a meaning for zero rates in some other contexts.</p><p>The new rate applies only to the current media item. Setting a new media item resets the playback rate to 1.0.</p>
            </remarks>
            <doc-id>dd374364</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::SetRate([In] float flRate)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::SetRate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.GetRate(System.Single@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current playback rate.</p>
            </summary>
            <param name = "flRateRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd374346</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::GetRate([Out] float* pflRate)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::GetRate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.GetSupportedRates(SharpDX.Mathematics.Interop.RawBool,System.Single@,System.Single@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the range of supported playback rates.</p>
            </summary>
            <param name = "fForwardDirection">No documentation.</param>
            <param name = "flSlowestRateRef">No documentation.</param>
            <param name = "flFastestRateRef">No documentation.</param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:UnsupportedRate"/></strong></strong></dt> </dl> </td><td> <p>The current media item does not support playback in the requested direction (either forward or reverse).</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Playback rates are expressed as a ratio of the current rate to the normal rate. For example, 1.0 indicates normal playback speed, 0.5 indicates half speed, and 2.0 indicates twice speed. Positive values indicate forward playback, and negative values indicate reverse playback.
            </p>
            </remarks>
            <doc-id>dd374348</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::GetSupportedRates([In] BOOL fForwardDirection,[Out] float* pflSlowestRate,[Out] float* pflFastestRate)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::GetSupportedRates</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.GetState(SharpDX.MediaFoundation.PMediaPlayerState@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current playback state of the MFPlay player object.</p>
            </summary>
            <param name = "eStateRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method can be called after the player object has been shut down.</p><p>Many of the <strong><see cref = "T:SharpDX.MediaFoundation.PMediaPlayer"/></strong> methods complete asynchronously. While an asynchronous operation is pending, the current state is not updated until the operation completes. When the operation completes, the application receives an event callback, and the new state is given in the <strong><see cref = "T:SharpDX.MediaFoundation.PEventHeader"/></strong> structure that is passed to the callback.</p>
            </remarks>
            <doc-id>dd374347</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::GetState([Out] MFP_MEDIAPLAYER_STATE* peState)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::GetState</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.CreateMediaItemFromURL(System.String,SharpDX.Mathematics.Interop.RawBool,System.IntPtr,SharpDX.MediaFoundation.PMediaItem@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Creates a media item from a URL.</p>
            </summary>
            <param name = "wszURLRef">No documentation.</param>
            <param name = "fSync">No documentation.</param>
            <param name = "dwUserData">No documentation.</param>
            <param name = "mediaItemOut">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>Invalid request. This error can occur when <em>fSync</em> is <strong><see cref = "F:SharpDX.Result.False"/></strong> and the application did not provide a callback interface. See Remarks.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:UnsupportedScheme"/></strong></strong></dt> </dl> </td><td> <p>Unsupported protocol. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method does not queue the media item for playback. To queue the item for playback, call <strong>IMFPMediaPlayer::SetMediaItem</strong>.</p><p>The <strong>CreateMediaItemFromURL</strong> method can be called either synchronously or asynchronously: </p><ul> <li>If <em>fSync</em> is <strong>TRUE</strong>, the method completes synchronously. The <strong><see cref = "T:SharpDX.MediaFoundation.PMediaItem"/></strong> reference is returned in the <em>ppMediaItem</em> parameter. </li> <li>If <em>fSync</em> is <strong><see cref = "F:SharpDX.Result.False"/></strong>, the method completes asynchronously. When the operation completes, the application's <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> callback method is invoked. The event type is <strong>MFP_EVENT_TYPE_MEDIAITEM_CREATED</strong>. The event data contains the <strong><see cref = "T:SharpDX.MediaFoundation.PMediaItem"/></strong> reference for the new media item.</li> </ul><p>The callback interface is set when you first call <strong>MFPCreateMediaPlayer</strong> to create the MFPlay player object. If you do not provide a callback interface, the <em>fSync</em> parameter must be <strong>TRUE</strong>. Otherwise, <strong>CreateMediaItemFromURL</strong> returns <strong><see cref = "!:InvalidRequest"/></strong>. </p><p>If you make multiple asynchronous calls to <strong>CreateMediaItemFromURL</strong>, they are not guaranteed to complete in the same order. Use the <em>dwUserData</em> parameter to match created media items with pending requests.</p><p>Currently, this method returns <strong><see cref = "!:UnsupportedScheme"/></strong> if the URL specifies any of the following protocols: rtsp*, mms*, or mcast. If you want to use the Media Foundation network source with MFPlay, first use the Source Resolver to create the source, and then call <strong>IMFPMediaPlayer::CreateMediaItemFromObject</strong>.</p>
            </remarks>
            <doc-id>dd374335</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::CreateMediaItemFromURL([In] const wchar_t* pwszURL,[In] BOOL fSync,[In] ULONG_PTR dwUserData,[Out, Optional] IMFPMediaItem** ppMediaItem)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::CreateMediaItemFromURL</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.CreateMediaItemFromObject(SharpDX.IUnknown,SharpDX.Mathematics.Interop.RawBool,System.IntPtr,SharpDX.MediaFoundation.PMediaItem@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Creates a media item from an object.</p>
            </summary>
            <param name = "iUnknownObjRef">No documentation.</param>
            <param name = "fSync">No documentation.</param>
            <param name = "dwUserData">No documentation.</param>
            <param name = "mediaItemOut">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>Invalid request. This error can occur when <em>fSync</em> is <strong><see cref = "F:SharpDX.Result.False"/></strong> and the application did not provide a callback interface. See Remarks.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The <em>pIUnknownObj</em> parameter must specify one of the following:</p><ul> <li>A reference to a media source. Media sources expose the <strong><see cref = "T:SharpDX.MediaFoundation.MediaSource"/></strong> interface. It is the caller's responsibility to call <strong>IMFMediaSource::Shutdown</strong> on the media source.</li> <li>A reference to a byte stream. Byte streams expose the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface. Internally, the method calls the <strong>IMFSourceResolver::CreateObjectFromByteStream</strong> method to create a media source from the byte stream. Therefore, a byte-stream handler must be registered for the byte stream. For more information about byte-stream handlers, see Scheme Handlers and Byte-Stream Handlers. </li> </ul><p>This method does not queue the media item for playback. To queue the item for playback, call <strong>IMFPMediaPlayer::SetMediaItem</strong>.</p><p>The <strong>CreateMediaItemFromObject</strong> method can be called either synchronously or asynchronously: </p><ul> <li>If <em>fSync</em> is <strong>TRUE</strong>, the method completes synchronously. The <strong><see cref = "T:SharpDX.MediaFoundation.PMediaItem"/></strong> reference is returned in the <em>ppMediaItem</em> parameter. </li> <li>If <em>fSync</em> is <strong><see cref = "F:SharpDX.Result.False"/></strong>, the method completes asynchronously. When the operation completes, the application's <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> callback method is invoked. The event type is <strong>MFP_EVENT_TYPE_MEDIAITEM_CREATED</strong>. The event data contains the <strong><see cref = "T:SharpDX.MediaFoundation.PMediaItem"/></strong> reference for the new media item.</li> </ul><p>The callback interface is set when you first call <strong>MFPCreateMediaPlayer</strong> to create the MFPlay player object. If you do not provide a callback interface, the <em>fSync</em> parameter must be <strong>TRUE</strong>. Otherwise, <strong>CreateMediaItemFromObject</strong> returns <strong><see cref = "!:InvalidRequest"/></strong>. </p><p>If you make multiple asynchronous calls to <strong>CreateMediaItemFromObject</strong>, they are not guaranteed to complete in the same order. Use the <em>dwUserData</em> parameter to match created media items with pending requests.</p>
            </remarks>
            <doc-id>dd374334</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::CreateMediaItemFromObject([In] IUnknown* pIUnknownObj,[In] BOOL fSync,[In] ULONG_PTR dwUserData,[Out, Optional] IMFPMediaItem** ppMediaItem)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::CreateMediaItemFromObject</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.SetMediaItem(SharpDX.MediaFoundation.PMediaItem)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queues a media item for playback.</p>
            </summary>
            <param name = "iMFPMediaItemRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_INVALIDARG</strong></strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:DrmUnsupported"/></strong></strong></dt> </dl> </td><td> <p>The media item contains protected content. MFPlay currently does not support protected content.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:NoAudioPlaybackDevice"/></strong></strong></dt> </dl> </td><td> <p>No audio playback device was found. This error can occur if the media source contains audio, but no audio playback devices are available on the system.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method completes asynchronously.  When the operation completes, the application's <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> callback method is invoked. The event type is <strong>MFP_EVENT_TYPE_MEDIAITEM_SET</strong>.</p><p>To create a media item, call <strong>IMFPMediaPlayer::CreateMediaItemFromObject</strong> or <strong>IMFPMediaPlayer::CreateMediaItemFromURL</strong>. A media item must be used with the same MFPlay player object that created that item. If the media item was created by a different instance of the player object, <strong>SetMediaItem</strong> returns <strong>E_INVALIDARG</strong>.
            </p>
            </remarks>
            <doc-id>dd374361</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::SetMediaItem([In] IMFPMediaItem* pIMFPMediaItem)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::SetMediaItem</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.ClearMediaItem">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Clears the current media item.</p><strong>Note</strong>??This method is currently not implemented.?
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method stops playback and releases the player object's references to the current media item.</p><p>This method completes asynchronously.  When the operation completes, the application's <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> callback method is invoked. The event type is <strong>MFP_EVENT_TYPE_MEDIAITEM_CLEARED</strong>.</p>
            </remarks>
            <doc-id>dd374332</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::ClearMediaItem()</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::ClearMediaItem</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.GetMediaItem(SharpDX.MediaFoundation.PMediaItem@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets a reference to the current media item.</p>
            </summary>
            <param name = "iMFPMediaItemOut">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong>E_FAIL</strong></strong></dt> </dl> </td><td> <p>There is no current media item.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:NotFound"/></strong></strong></dt> </dl> </td><td> <p>There is no current media item.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The <strong>IMFPMediaPlayer::SetMediaItem</strong> method is asynchronous. Therefore, while <strong>SetMediaItem</strong> is pending, <strong>GetMediaItem</strong> will not return the media item that was just set. Instead, the application should implement <strong><see cref = "T:SharpDX.MediaFoundation.PMediaPlayerCallback"/></strong> interface and handle the <strong>MFP_EVENT_TYPE_MEDIAITEM_SET</strong> event. For more information, see Receiving Events From the Player.</p><p>The previous remark also applies to setting the media item in the <strong>MFPCreateMediaPlayer</strong> function.</p>
            </remarks>
            <doc-id>dd374342</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::GetMediaItem([Out] IMFPMediaItem** ppIMFPMediaItem)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::GetMediaItem</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.GetVolume(System.Single@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current audio volume.</p>
            </summary>
            <param name = "flVolumeRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd374351</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::GetVolume([Out] float* pflVolume)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::GetVolume</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.SetVolume(System.Single)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Sets the audio volume.</p>
            </summary>
            <param name = "flVolume">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:OutOfRange"/></strong></dt> </dl> </td><td> <p>The <em>flVolume</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If you call this method before playback starts, the setting is applied after playback starts.</p><p>This method does not change the master volume level for the player's audio session. Instead, it adjusts the per-channel volume levels for audio stream(s) that belong to the current media item. Other streams in the audio session are not affected. For more information, see Managing the Audio Session.</p>
            </remarks>
            <doc-id>dd374366</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::SetVolume([In] float flVolume)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::SetVolume</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.GetBalance(System.Single@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current audio balance.</p>
            </summary>
            <param name = "flBalanceRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd374338</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::GetBalance([Out] float* pflBalance)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::GetBalance</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.SetBalance(System.Single)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Sets the audio balance.</p>
            </summary>
            <param name = "flBalance">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:OutOfRange"/></strong></strong></dt> </dl> </td><td> <p>The <em>flBalance</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If you call this method before playback starts, the setting is applied when playback starts.</p>
            </remarks>
            <doc-id>dd374359</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::SetBalance([In] float flBalance)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::SetBalance</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.GetMute(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Queries whether the audio is muted.</p>
            </summary>
            <param name = "fMuteRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd374343</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::GetMute([Out] BOOL* pfMute)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::GetMute</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.SetMute(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Mutes or unmutes the audio.</p>
            </summary>
            <param name = "fMute">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If you call this method before playback starts, the setting is applied after playback starts.</p><p> This method does not mute the entire audio session to which the player belongs. It mutes only the streams from the current media item. Other streams in the audio session are not affected. For more information, see Managing the Audio Session. 
            </p>
            </remarks>
            <doc-id>dd374362</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::SetMute([In] BOOL fMute)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::SetMute</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.GetNativeVideoSize(SharpDX.Size2@,SharpDX.Size2@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the size and aspect ratio of the video. These values are computed before any scaling is done to fit the video into the destination window.</p>
            </summary>
            <param name = "szVideoRef">No documentation.</param>
            <param name = "szARVideoRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The current media item does not contain video.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>At least one parameter must be non-<strong><c>null</c></strong>.</p>
            </remarks>
            <doc-id>dd374344</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::GetNativeVideoSize([Out, Optional] SIZE* pszVideo,[Out, Optional] SIZE* pszARVideo)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::GetNativeVideoSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.GetIdealVideoSize(SharpDX.Size2@,SharpDX.Size2@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the range of video sizes that can be displayed without significantly degrading performance or image quality.</p>
            </summary>
            <param name = "szMinRef">No documentation.</param>
            <param name = "szMaxRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The current media item does not contain video.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>At least one parameter must be non-<strong><c>null</c></strong>. Sizes are given in pixels.</p>
            </remarks>
            <doc-id>dd374341</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::GetIdealVideoSize([Out, Optional] SIZE* pszMin,[Out, Optional] SIZE* pszMax)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::GetIdealVideoSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.SetVideoSourceRect(SharpDX.MediaFoundation.VideoNormalizedRect)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Sets the video source rectangle.</p><p>MFPlay clips the video to this rectangle and stretches the rectangle to fill the video window.</p>
            </summary>
            <param name = "nrcSourceRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The current media item does not contain video.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>MFPlay stretches the source rectangle to fill the entire video window. By default, MFPlay maintains the source's correct aspect ratio, letterboxing if needed. The letterbox color is controlled by the <strong>IMFPMediaPlayer::SetBorderColor</strong> method.</p><p>This method fails if no media item is currently set, or if the current media item does not contain video.</p><p> To set the video position before playback starts, call this method inside your event handler for the <strong>MFP_EVENT_TYPE_MEDIAITEM_SET</strong> event. For more information, see <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong>. </p>
            </remarks>
            <doc-id>dd743247</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::SetVideoSourceRect([In] const MFVideoNormalizedRect* pnrcSource)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::SetVideoSourceRect</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.GetVideoSourceRect(SharpDX.MediaFoundation.VideoNormalizedRect@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the video source rectangle.</p>
            </summary>
            <param name = "nrcSourceRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The current media item does not contain video.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dd743246</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::GetVideoSourceRect([Out] MFVideoNormalizedRect* pnrcSource)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::GetVideoSourceRect</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.SetAspectRatioMode(System.Int32)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Specifies whether the aspect ratio of the video is preserved during playback.</p>
            </summary>
            <param name = "dwAspectRatioMode">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The current media item does not contain video.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method fails if no media item is currently set, or if the current media item does not contain video.</p><p>To set the aspect-ratio mode before playback starts, call this method inside your event handler for the <strong>MFP_EVENT_TYPE_MEDIAITEM_SET</strong> event. For more information, see <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong>.</p>
            </remarks>
            <doc-id>dd374358</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::SetAspectRatioMode([In] DWORD dwAspectRatioMode)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::SetAspectRatioMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.GetAspectRatioMode(System.Int32@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current aspect-ratio correction mode. This mode controls whether the aspect ratio of the video is preserved during playback.</p>
            </summary>
            <param name = "dwAspectRatioModeRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The current media item does not contain video.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dd374337</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::GetAspectRatioMode([Out] DWORD* pdwAspectRatioMode)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::GetAspectRatioMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.GetVideoWindow(System.IntPtr@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the window where the video is displayed.</p>
            </summary>
            <param name = "hwndVideoRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The video window is specified when you first call <strong>MFPCreateMediaPlayer</strong> to create the MFPlay player object.</p>
            </remarks>
            <doc-id>dd374350</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::GetVideoWindow([Out] HWND* phwndVideo)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::GetVideoWindow</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.UpdateVideo">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Updates the video frame.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The current media item does not contain video.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this method when your application's video playback window receives either a <strong>WM_PAINT</strong> or <strong>WM_SIZE</strong> message. This method performs two functions: </p><ul> <li>Ensures that the video frame is repainted while playback is paused or stopped.  </li> <li>Adjusts the displayed video to match the current size of the video window.</li> </ul><strong>Important</strong>??Call the GDI <strong>BeginPaint</strong> function before calling  <strong>UpdateVideo</strong>.?
            </remarks>
            <doc-id>dd743248</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::UpdateVideo()</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::UpdateVideo</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.SetBorderColor(System.Int32)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Sets the color for the video border. The border color is used to letterbox the video.</p>
            </summary>
            <param name = "clr">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidRequest"/></strong></strong></dt> </dl> </td><td> <p>The current media item does not contain video.</p> </td></tr> <tr><td> <dl> <dt><strong>M<strong>F_E_SHUTDOWN</strong></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method fails if no media item is currently set, or if the current media item does not contain video.</p><p>To set the border color before playback starts, call this method inside your event handler for the <strong>MFP_EVENT_TYPE_MEDIAITEM_SET</strong> event. For more information, see <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong>.</p>
            </remarks>
            <doc-id>dd374360</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::SetBorderColor([In] COLORREF Clr)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::SetBorderColor</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.GetBorderColor(System.Int32@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Gets the current color of the video border. The border color is used to letterbox the video.</p>
            </summary>
            <param name = "clrRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The current media item does not contain video.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dd374339</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::GetBorderColor([Out] COLORREF* pClr)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::GetBorderColor</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.InsertEffect(SharpDX.IUnknown,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Applies an audio or video effect to playback.</p>
            </summary>
            <param name = "effectRef">No documentation.</param>
            <param name = "fOptional">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidIndex"/></strong></strong></dt> </dl> </td><td> <p>This effect was already added.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The object specified in the <em>pEffect</em> parameter can implement either a video effect or an audio effect. The effect is applied to any media items set after the method is called. It is not applied to the current media item. </p><p>For each media item, the effect is applied to the first selected stream of the matching type (audio or video). If a media item has two selected streams of the same type, the second stream does not receive the effect. The effect is ignored if the media item does not contain a stream that matches the effect type. For example, if you set a video effect and play a file that contains just audio, the video effect is ignored, although no error is raised.</p><p>The effect is applied to all subsequent media items, until the application removes the effect. To remove an effect, call <strong>IMFPMediaPlayer::RemoveEffect</strong> or <strong>IMFPMediaPlayer::RemoveAllEffects</strong>.</p><p>If you set multiple effects of the same type (audio or video), they are applied in the same order in which you call <strong>InsertEffect</strong>.</p>
            </remarks>
            <doc-id>dd374352</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::InsertEffect([In] IUnknown* pEffect,[In] BOOL fOptional)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::InsertEffect</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.RemoveEffect(SharpDX.IUnknown)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Removes an effect that was added with the <strong>IMFPMediaPlayer::InsertEffect</strong> method.</p>
            </summary>
            <param name = "effectRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotFound"/></strong></dt> </dl> </td><td> <p>The effect was not found.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The change applies to the next media item that is set on the player. The effect is not removed from the current media item.</p>
            </remarks>
            <doc-id>dd374356</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::RemoveEffect([In] IUnknown* pEffect)</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::RemoveEffect</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.RemoveAllEffects">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Removes all effects that were added with the <strong>IMFPMediaPlayer::InsertEffect</strong> method.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The change applies to the next media item that is set on the player. The effects are not removed from the current media item.</p>
            </remarks>
            <doc-id>dd374355</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::RemoveAllEffects()</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::RemoveAllEffects</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Shuts down the MFPlay player object and releases any resources the object is using.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>After this method is called, most <strong><see cref = "T:SharpDX.MediaFoundation.PMediaPlayer"/></strong> methods return <strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong>. Also, any media items created from this instance of the player object are invalidated and most <strong><see cref = "T:SharpDX.MediaFoundation.PMediaItem"/></strong> methods also return <strong><see cref = "M:SharpDX.MediaFoundation.PMediaPlayer.Shutdown"/></strong>.</p><p>The player object automatically shuts itself down when its reference count reaches zero. You can use the <strong>Shutdown</strong> method to shut down the player before all of the references have been released.</p>
            </remarks>
            <doc-id>dd374367</doc-id>
            <unmanaged>HRESULT IMFPMediaPlayer::Shutdown()</unmanaged>
            <unmanaged-short>IMFPMediaPlayer::Shutdown</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMediaPlayerCallback.OnMediaPlayerEvent(SharpDX.MediaFoundation.PEventHeader@)">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Called by the MFPlay player object to notify the application of a playback event.</p>
            </summary>
            <param name = "eventHeaderRef">No documentation.</param>
            <remarks>
            <p> The specific type of playback event is given in the <strong>eEventType</strong> member of the <strong><see cref = "T:SharpDX.MediaFoundation.PEventHeader"/></strong> structure. This structure contains information that is common to all of the event types. Some event types use extended structures. A set of macros is defined for casting the <em>pEventHeader</em> reference to the correct structure type. For more information, see <strong><see cref = "T:SharpDX.MediaFoundation.PEventType"/></strong>. </p><p>It is safe to call <strong><see cref = "T:SharpDX.MediaFoundation.PMediaPlayer"/></strong> and <strong><see cref = "T:SharpDX.MediaFoundation.PMediaItem"/></strong> methods inside the <strong>OnMediaPlayer</strong> method. MFPlay is guaranteed not to reenter the <strong>OnMediaPlayer</strong> method. That is, calls to <strong>OnMediaPlayer</strong> are serialized, and the method will not be invoked again from inside <strong>OnMediaPlayer</strong>. </p>
            </remarks>
            <doc-id>dd374331</doc-id>
            <unmanaged>void IMFPMediaPlayerCallback::OnMediaPlayerEvent([In] MFP_EVENT_HEADER* pEventHeader)</unmanaged>
            <unmanaged-short>IMFPMediaPlayerCallback::OnMediaPlayerEvent</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PMPClient.PMPHost">
            <summary>
            <p> Provides a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.PMPHost"/></strong> interface. </p>
            </summary>
            <remarks>
            <p>The <strong><see cref = "T:SharpDX.MediaFoundation.PMPHost"/></strong> reference is apartment threaded. The media source must add the reference to the global interface table (GIT) before using it.</p>
            </remarks>
            <doc-id>ms703915</doc-id>
            <unmanaged>SetPMPHost</unmanaged>
            <unmanaged-short>SetPMPHost</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMPClient.SetPMPHost(SharpDX.MediaFoundation.PMPHost)">
            <summary>
            <p> Provides a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.PMPHost"/></strong> interface. </p>
            </summary>
            <param name = "pMPHostRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The <strong><see cref = "T:SharpDX.MediaFoundation.PMPHost"/></strong> reference is apartment threaded. The media source must add the reference to the global interface table (GIT) before using it.</p>
            </remarks>
            <doc-id>ms703915</doc-id>
            <unmanaged>HRESULT IMFPMPClient::SetPMPHost([In] IMFPMPHost* pPMPHost)</unmanaged>
            <unmanaged-short>IMFPMPClient::SetPMPHost</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PMPClientApp.PMPHost">
            <summary>
            <p>Sets a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.PMPHostApp"/></strong> interface allowing a media source to create objects in the PMP process.</p>
            </summary>
            <doc-id>jj128317</doc-id>
            <unmanaged>SetPMPHost</unmanaged>
            <unmanaged-short>SetPMPHost</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMPClientApp.SetPMPHost(SharpDX.MediaFoundation.PMPHostApp)">
            <summary>
            <p>Sets a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.PMPHostApp"/></strong> interface allowing a media source to create objects in the PMP process.</p>
            </summary>
            <param name = "pMPHostRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>jj128317</doc-id>
            <unmanaged>HRESULT IMFPMPClientApp::SetPMPHost([In] IMFPMPHostApp* pPMPHost)</unmanaged>
            <unmanaged-short>IMFPMPClientApp::SetPMPHost</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMPHost.LockProcess">
            <summary>
            <p> Blocks the protected media path (PMP) process from ending. </p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>When this method is called, it increments the lock count on the PMP process. For every call to this method, the application should make a corresponding call to <strong>IMFPMPHost::UnlockProcess</strong>, which decrements the lock count. When the PMP process is ready to exit, it waits for about 3 seconds, or until the lock count reaches zero, before exiting.</p>
            </remarks>
            <doc-id>ms697003</doc-id>
            <unmanaged>HRESULT IMFPMPHost::LockProcess()</unmanaged>
            <unmanaged-short>IMFPMPHost::LockProcess</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMPHost.UnlockProcess">
            <summary>
            <p> Decrements the lock count on the protected media path (PMP) process. Call this method once for each call to <strong>IMFPMPHost::LockProcess</strong>. </p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ms698984</doc-id>
            <unmanaged>HRESULT IMFPMPHost::UnlockProcess()</unmanaged>
            <unmanaged-short>IMFPMPHost::UnlockProcess</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMPHost.CreateObjectByCLSID(System.Guid,SharpDX.Win32.IStream,System.Guid,System.IntPtr)">
            <summary>
            <p> Creates an object in the protect media path (PMP) process, from a CLSID. </p>
            </summary>
            <param name = "clsid"><dd> <p> The CLSID of the object to create. </p> </dd></param>
            <param name = "streamRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.Win32.IStream"/></strong> interface. This parameter can be <strong><c>null</c></strong>. If this parameter is not <strong><c>null</c></strong>, the PMP host queries the created object for the <strong>IPersistStream</strong> interface and calls <strong>IPersistStream::Load</strong>, passing in the <em>pStream</em> reference. </p> </dd></param>
            <param name = "riid"><dd> <p> The interface identifier (IID) of the interface to retrieve. </p> </dd></param>
            <param name = "vOut"><dd> <p> Receives a reference to the requested interface. The caller must release the interface. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> You can use the <em>pStream</em> parameter to initialize the object after it is created. </p>
            </remarks>
            <doc-id>ms698995</doc-id>
            <unmanaged>HRESULT IMFPMPHost::CreateObjectByCLSID([In] const GUID&amp; clsid,[In] IStream* pStream,[In] const GUID&amp; riid,[In] void** ppv)</unmanaged>
            <unmanaged-short>IMFPMPHost::CreateObjectByCLSID</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMPHostApp.LockProcess">
            <summary>
            <p> Blocks the protected media path (PMP) process from ending. </p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>When this method is called, it increments the lock count on the PMP process. For every call to this method, the application should make a corresponding call to <strong>IMFPMPHostApp::UnlockProcess</strong>, which decrements the lock count. When the PMP process is ready to exit, it waits for about 3 seconds, or until the lock count reaches zero, before exiting.</p>
            </remarks>
            <doc-id>jj128320</doc-id>
            <unmanaged>HRESULT IMFPMPHostApp::LockProcess()</unmanaged>
            <unmanaged-short>IMFPMPHostApp::LockProcess</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMPHostApp.UnlockProcess">
            <summary>
            <p> Decrements the lock count on the protected media path (PMP) process. Call this method once for each call to <strong>IMFPMPHostApp::LockProcess</strong>. </p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>jj128321</doc-id>
            <unmanaged>HRESULT IMFPMPHostApp::UnlockProcess()</unmanaged>
            <unmanaged-short>IMFPMPHostApp::UnlockProcess</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMPHostApp.ActivateClassById(System.String,SharpDX.Win32.IStream,System.Guid,System.IntPtr@)">
            <summary>
            <p> Creates a Windows Runtime object in the protected media path (PMP) process. </p>
            </summary>
            <param name = "id"><dd> <p>Id of object to create.</p> </dd></param>
            <param name = "streamRef"><dd> <p>Data to be passed to the object by way of a <strong>IPersistStream</strong>.</p> </dd></param>
            <param name = "riid"><dd> <p> The interface identifier (IID) of the interface to retrieve. </p> </dd></param>
            <param name = "vOut"><dd> <p> Receives a reference to the created object. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>jj128319</doc-id>
            <unmanaged>HRESULT IMFPMPHostApp::ActivateClassById([In] const wchar_t* id,[In, Optional] IStream* pStream,[In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>
            <unmanaged-short>IMFPMPHostApp::ActivateClassById</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMPServer.LockProcess">
            <summary>
            <p> </p><p>Blocks the protected media path (PMP) process from ending.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>When this method is called, it increments the lock count on the PMP process. For every call to this method, the application should make a corresponding call to IMFPMPServer::UnlockProcess, which decrements the lock count. When the PMP process is ready to exit, it waits for about 3 seconds, or until the lock count reaches zero, before exiting.</p>
            </remarks>
            <doc-id>ms701590</doc-id>
            <unmanaged>HRESULT IMFPMPServer::LockProcess()</unmanaged>
            <unmanaged-short>IMFPMPServer::LockProcess</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMPServer.UnlockProcess">
            <summary>
            <p> </p><p>Decrements the lock count on the protected media path (PMP) process. Call this method once for each call to IMFPMPServer::LockProcess.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms696204</doc-id>
            <unmanaged>HRESULT IMFPMPServer::UnlockProcess()</unmanaged>
            <unmanaged-short>IMFPMPServer::UnlockProcess</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PMPServer.CreateObjectByCLSID(System.Guid,System.Guid,System.IntPtr@)">
            <summary>
            <p> </p><p>Creates an object in the protected media path (PMP) process.</p>
            </summary>
            <param name = "clsid"><dd> <p>CLSID of the object to create.</p> </dd></param>
            <param name = "riid"><dd> <p>Interface identifier of the interface to retrieve.</p> </dd></param>
            <param name = "objectOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms704806</doc-id>
            <unmanaged>HRESULT IMFPMPServer::CreateObjectByCLSID([In] const GUID&amp; clsid,[In] const GUID&amp; riid,[Out] void** ppObject)</unmanaged>
            <unmanaged-short>IMFPMPServer::CreateObjectByCLSID</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PresentationClock.TimeSource">
            <summary>
            <p> </p><p>Retrieves the clock's presentation time source.</p>
            </summary>
            <doc-id>ms704730</doc-id>
            <unmanaged>GetTimeSource / SetTimeSource</unmanaged>
            <unmanaged-short>GetTimeSource</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PresentationClock.Time">
            <summary>
            <p> Retrieves the latest clock time. </p>
            </summary>
            <remarks>
            <p>This method does not attempt to smooth out jitter or otherwise account for any inaccuracies in the clock time.</p>
            </remarks>
            <doc-id>ms696209</doc-id>
            <unmanaged>GetTime</unmanaged>
            <unmanaged-short>GetTime</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PresentationClock.SetTimeSource(SharpDX.MediaFoundation.PresentationTimeSource)">
            <summary>
            <p> </p><p>Sets the time source for the presentation clock. The time source is the object that drives the clock by providing the current time.</p>
            </summary>
            <param name = "timeSourceRef"><dd> <p>Pointer to the <see cref = "T:SharpDX.MediaFoundation.PresentationTimeSource"/> interface of the time source.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ClockNotSimple"/></strong></dt> </dl> </td><td> <p>The time source does not have a frequency of 10 MHz.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotInitializeD"/></strong></dt> </dl> </td><td> <p>The time source has not been initialized.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The presentation clock cannot start until it has a time source.</p><p>The time source is automatically registered to receive state change notifications from the clock, through the time source's <see cref = "T:SharpDX.MediaFoundation.ClockStateSink"/> interface, which all time sources must implement.</p><p>This time source have a frequency of 10 MHz. See IMFClock::GetClockCharacteristics. If not, the method returns <see cref = "!:ClockNotSimple"/>.</p>
            </remarks>
            <doc-id>ms694835</doc-id>
            <unmanaged>HRESULT IMFPresentationClock::SetTimeSource([In, Optional] IMFPresentationTimeSource* pTimeSource)</unmanaged>
            <unmanaged-short>IMFPresentationClock::SetTimeSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PresentationClock.GetTimeSource(SharpDX.MediaFoundation.PresentationTimeSource@)">
            <summary>
            <p> </p><p>Retrieves the clock's presentation time source.</p>
            </summary>
            <param name = "timeSourceOut"><dd> <p>Receives a reference to the time source's <see cref = "T:SharpDX.MediaFoundation.PresentationTimeSource"/> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ClockNoTimeSource"/></strong></dt> </dl> </td><td> <p>No time source was set on this clock.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms704730</doc-id>
            <unmanaged>HRESULT IMFPresentationClock::GetTimeSource([Out] IMFPresentationTimeSource** ppTimeSource)</unmanaged>
            <unmanaged-short>IMFPresentationClock::GetTimeSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PresentationClock.GetTime(System.Int64@)">
            <summary>
            <p> Retrieves the latest clock time. </p>
            </summary>
            <param name = "hnsClockTimeRef"><dd> <p> Receives the latest clock time, in 100-nanosecond units. The time is relative to when the clock was last started. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ClockNoTimeSource"/></strong></dt> </dl> </td><td> <p> The clock does not have a presentation time source. Call <strong>IMFPresentationClock::SetTimeSource</strong>. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method does not attempt to smooth out jitter or otherwise account for any inaccuracies in the clock time.</p>
            </remarks>
            <doc-id>ms696209</doc-id>
            <unmanaged>HRESULT IMFPresentationClock::GetTime([Out] longlong* phnsClockTime)</unmanaged>
            <unmanaged-short>IMFPresentationClock::GetTime</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PresentationClock.AddClockStateSink(SharpDX.MediaFoundation.ClockStateSink)">
            <summary>
            <p> </p><p>Registers an object to be notified whenever the clock starts, stops, or pauses, or changes rate.</p>
            </summary>
            <param name = "stateSinkRef"><dd> <p>Pointer to the object's <see cref = "T:SharpDX.MediaFoundation.ClockStateSink"/> interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Before releasing the object, call IMFPresentationClock::RemoveClockStateSink to unregister the object for state-change notifications.</p>
            </remarks>
            <doc-id>ms703129</doc-id>
            <unmanaged>HRESULT IMFPresentationClock::AddClockStateSink([In, Optional] IMFClockStateSink* pStateSink)</unmanaged>
            <unmanaged-short>IMFPresentationClock::AddClockStateSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PresentationClock.RemoveClockStateSink(SharpDX.MediaFoundation.ClockStateSink)">
            <summary>
            <p> </p><p>Unregisters an object that is receiving state-change notifications from the clock.</p>
            </summary>
            <param name = "stateSinkRef"><dd> <p>Pointer to the object's <see cref = "T:SharpDX.MediaFoundation.ClockStateSink"/> interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms703032</doc-id>
            <unmanaged>HRESULT IMFPresentationClock::RemoveClockStateSink([In, Optional] IMFClockStateSink* pStateSink)</unmanaged>
            <unmanaged-short>IMFPresentationClock::RemoveClockStateSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PresentationClock.Start(System.Int64)">
            <summary>
            <p> </p><p>Starts the presentation clock.</p>
            </summary>
            <param name = "llClockStartOffset"><dd> <p>Initial starting time, in 100-nanosecond units. At the time the <strong>Start</strong> method is called, the clock's IMFPresentationClock::GetTime method returns this value, and the clock time increments from there. If the value is PRESENTATION_CURRENT_POSITION, the clock starts from its current position. Use this value if the clock is paused and you want to restart it from the same position.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ClockNoTimeSource"/></strong></dt> </dl> </td><td> <p>No time source was set on this clock.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is valid in all states (stopped, paused, or running).</p><p>If the clock is paused and restarted from the same position (<em>llClockStartOffset</em> is PRESENTATION_CURRENT_POSITION), the presentation clock sends an IMFClockStateSink::OnClockRestart notification. Otherwise, the clock sends an IMFClockStateSink::OnClockStart notification.</p><p>The presentation clock initiates the state change by calling <strong>OnClockStart</strong> or <strong>OnClockRestart</strong> on the clock's time source. This call is made synchronously. If it fails, the state change does not occur. If the call succeeds, the state changes, and the clock notifies the other state-change subscribers by calling their <strong>OnClockStart</strong> or <strong>OnClockRestart</strong> methods. These calls are made asynchronously.</p><p>If the clock is already running, calling <strong>Start</strong> again has the effect of seeking the clock to the new <em>StartOffset</em> position.</p>
            </remarks>
            <doc-id>ms702290</doc-id>
            <unmanaged>HRESULT IMFPresentationClock::Start([In] longlong llClockStartOffset)</unmanaged>
            <unmanaged-short>IMFPresentationClock::Start</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PresentationClock.Stop">
            <summary>
            <p> </p><p>Stops the presentation clock. While the clock is stopped, the clock time does not advance, and the clock's IMFPresentationClock::GetTime method returns zero.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ClockNoTimeSource"/></strong></dt> </dl> </td><td> <p>No time source was set on this clock.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ClockStateAlreadySet"/></strong></dt> </dl> </td><td> <p>The clock is already stopped.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is valid when the clock is running or paused.</p><p>The presentation clock initiates the state change by calling IMFClockStateSink::OnClockStop on the clock's time source. This call is made synchronously. If it fails, the state change does not occur. If the call succeeds, the state changes, and the clock notifies the other state-change subscribers by calling their <strong>OnClockStop</strong> methods. These calls are made asynchronously.</p>
            </remarks>
            <doc-id>ms697195</doc-id>
            <unmanaged>HRESULT IMFPresentationClock::Stop()</unmanaged>
            <unmanaged-short>IMFPresentationClock::Stop</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PresentationClock.Pause">
            <summary>
            <p> </p><p>Pauses the presentation clock. While the clock is paused, the clock time does not advance, and the clock's IMFPresentationClock::GetTime returns the time at which the clock was paused.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ClockNoTimeSource"/></strong></dt> </dl> </td><td> <p>No time source was set on this clock.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ClockStateAlreadySet"/></strong></dt> </dl> </td><td> <p>The clock is already paused.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The clock is stopped. This request is not valid when the clock is stopped.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is valid when the clock is running. It is not valid when the clock is paused or stopped.</p><p>The presentation clock initiates the state change by calling IMFClockStateSink::OnClockPause on the clock's time source. This call is made synchronously. If it fails, the state change does not occur. If the call succeeds, the state changes, and the clock notifies the other state-change subscribers by calling their <strong>OnClockPause</strong> methods. These calls are made asynchronously.</p>
            </remarks>
            <doc-id>ms696201</doc-id>
            <unmanaged>HRESULT IMFPresentationClock::Pause()</unmanaged>
            <unmanaged-short>IMFPresentationClock::Pause</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PresentationTimeSource.UnderlyingClock">
            <summary>
            <p> </p><p>Retrieves the underlying clock that the presentation time source uses to generate its clock times.</p>
            </summary>
            <remarks>
            <p>A presentation time source must support stopping, starting, pausing, and rate changes. However, in many cases the time source derives its clock times from a hardware clock or other device. The underlying clock is always running, and might not support rate changes.</p><p>Optionally, a time source can expose the underlying clock by implementing this method. The underlying clock is always running, even when the presentation time source is paused or stopped. (Therefore, the underlying clock returns the MFCLOCK_CHARACTERISTICS_FLAG_ALWAYS_RUNNING flag in the <strong>IMFClock::GetClockCharacteristics</strong> method).</p><p>The underlying clock is useful if you want to make decisions based on the clock times while the presentation clock is stopped or paused.</p><p>If the time source does not expose an underlying clock, the method returns <see cref = "!:NoClock"/>.</p>
            </remarks>
            <doc-id>ms694071</doc-id>
            <unmanaged>GetUnderlyingClock</unmanaged>
            <unmanaged-short>GetUnderlyingClock</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.PresentationTimeSource.GetUnderlyingClock(SharpDX.MediaFoundation.Clock@)">
            <summary>
            <p> </p><p>Retrieves the underlying clock that the presentation time source uses to generate its clock times.</p>
            </summary>
            <param name = "clockOut"><dd> <p>Receives a reference to the clock's <strong><see cref = "T:SharpDX.MediaFoundation.Clock"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NoClock"/></strong></dt> </dl> </td><td> <p>This time source does not expose an underlying clock.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>A presentation time source must support stopping, starting, pausing, and rate changes. However, in many cases the time source derives its clock times from a hardware clock or other device. The underlying clock is always running, and might not support rate changes.</p><p>Optionally, a time source can expose the underlying clock by implementing this method. The underlying clock is always running, even when the presentation time source is paused or stopped. (Therefore, the underlying clock returns the MFCLOCK_CHARACTERISTICS_FLAG_ALWAYS_RUNNING flag in the <strong>IMFClock::GetClockCharacteristics</strong> method).</p><p>The underlying clock is useful if you want to make decisions based on the clock times while the presentation clock is stopped or paused.</p><p>If the time source does not expose an underlying clock, the method returns <see cref = "!:NoClock"/>.</p>
            </remarks>
            <doc-id>ms694071</doc-id>
            <unmanaged>HRESULT IMFPresentationTimeSource::GetUnderlyingClock([Out] IMFClock** ppClock)</unmanaged>
            <unmanaged-short>IMFPresentationTimeSource::GetUnderlyingClock</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ProtectedEnvironmentAccess.Call(System.Int32,System.Byte[],System.Int32,System.Byte[])">
            <summary>
            <p>Allows content protection systems to access the protected environment.</p>
            </summary>
            <param name = "inputLength"><dd> <p>The length in bytes of the input data.</p> </dd></param>
            <param name = "input"><dd> <p>A reference to the input data.</p> </dd></param>
            <param name = "outputLength"><dd> <p>The length in bytes of the output data.</p> </dd></param>
            <param name = "output"><dd> <p>A reference to the output data.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>See  <strong>MFCreateProtectedEnvironmentAccess</strong> for an example of how to create an <strong><see cref = "T:SharpDX.MediaFoundation.ProtectedEnvironmentAccess"/></strong> object and use the <strong>Call</strong> method.</p>
            </remarks>
            <doc-id>hh448046</doc-id>
            <unmanaged>HRESULT IMFProtectedEnvironmentAccess::Call([In] unsigned int inputLength,[In, Buffer] const unsigned char* input,[In] unsigned int outputLength,[Out, Buffer] unsigned char* output)</unmanaged>
            <unmanaged-short>IMFProtectedEnvironmentAccess::Call</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ProtectedEnvironmentAccess.ReadGRL(System.Int32@,System.Byte[])">
            <summary>
            <p>Gets the Global Revocation List (GLR).</p>
            </summary>
            <param name = "outputLength"><dd> <p>The length of the data returned in <strong>output</strong>.</p> </dd></param>
            <param name = "output"><dd> <p>Receives the contents of the global revocation list file.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Allows reading of the system Global Revocation List (GRL).  </p>
            </remarks>
            <doc-id>jj128322</doc-id>
            <unmanaged>HRESULT IMFProtectedEnvironmentAccess::ReadGRL([Out] unsigned int* outputLength,[Out, Buffer] unsigned char** output)</unmanaged>
            <unmanaged-short>IMFProtectedEnvironmentAccess::ReadGRL</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.QualityAdvise.DropMode">
            <summary>
            <p> </p><p>Retrieves the current drop mode.</p>
            </summary>
            <doc-id>ms702987</doc-id>
            <unmanaged>GetDropMode / SetDropMode</unmanaged>
            <unmanaged-short>GetDropMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.QualityAdvise.QualityLevel">
            <summary>
            <p> </p><p>Retrieves the current quality level.</p>
            </summary>
            <doc-id>ms701591</doc-id>
            <unmanaged>GetQualityLevel / SetQualityLevel</unmanaged>
            <unmanaged-short>GetQualityLevel</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.QualityAdvise.SetDropMode(SharpDX.MediaFoundation.QualityDropMode)">
            <summary>
            <p> </p><p>Sets the drop mode. In drop mode, a component drops samples, more or less aggressively depending on the level of the drop mode.</p>
            </summary>
            <param name = "eDropMode"><dd> <p>Requested drop mode, specified as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.QualityDropMode"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NoMoreDropModes"/></strong></dt> </dl> </td><td> <p>The component does not support the specified mode or any higher modes.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If this method is called on a media source, the media source might switch between thinned and non-thinned output. If that occurs, the affected streams will send an MEStreamThinMode event to indicate the transition. The operation is asynchronous; after <strong>SetDropMode</strong> returns, you might receive samples that were queued before the transition. The MEStreamThinMode event marks the exact point in the stream where the transition occurs.</p>
            </remarks>
            <doc-id>ms694861</doc-id>
            <unmanaged>HRESULT IMFQualityAdvise::SetDropMode([In] MF_QUALITY_DROP_MODE eDropMode)</unmanaged>
            <unmanaged-short>IMFQualityAdvise::SetDropMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.QualityAdvise.SetQualityLevel(SharpDX.MediaFoundation.QualityLevel)">
            <summary>
            <p> </p><p>Sets the quality level. The quality level determines how the component consumes or produces samples.</p>
            </summary>
            <param name = "eQualityLevel"><dd> <p>Requested quality level, specified as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.QualityLevel"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NoMoreQualityLevels"/></strong></dt> </dl> </td><td> <p>The component does not support the specified quality level or any levels below it.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms705619</doc-id>
            <unmanaged>HRESULT IMFQualityAdvise::SetQualityLevel([In] MF_QUALITY_LEVEL eQualityLevel)</unmanaged>
            <unmanaged-short>IMFQualityAdvise::SetQualityLevel</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.QualityAdvise.GetDropMode(SharpDX.MediaFoundation.QualityDropMode@)">
            <summary>
            <p> </p><p>Retrieves the current drop mode.</p>
            </summary>
            <param name = "eDropModeRef"><dd> <p>Receives the drop mode, specified as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.QualityDropMode"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms702987</doc-id>
            <unmanaged>HRESULT IMFQualityAdvise::GetDropMode([Out] MF_QUALITY_DROP_MODE* peDropMode)</unmanaged>
            <unmanaged-short>IMFQualityAdvise::GetDropMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.QualityAdvise.GetQualityLevel(SharpDX.MediaFoundation.QualityLevel@)">
            <summary>
            <p> </p><p>Retrieves the current quality level.</p>
            </summary>
            <param name = "eQualityLevelRef"><dd> <p>Receives the quality level, specified as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.QualityLevel"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms701591</doc-id>
            <unmanaged>HRESULT IMFQualityAdvise::GetQualityLevel([Out] MF_QUALITY_LEVEL* peQualityLevel)</unmanaged>
            <unmanaged-short>IMFQualityAdvise::GetQualityLevel</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.QualityAdvise.DropTime(System.Int64)">
            <summary>
            <p> </p><p>Drops samples over a specified interval of time.</p>
            </summary>
            <param name = "hnsAmountToDrop"><dd> <p>Amount of time to drop, in 100-nanosecond units. This value is always absolute. If the method is called multiple times, do not add the times from previous calls.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:DroptimeNotSupported"/></strong></dt> </dl> </td><td> <p>The object does not support this method.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Ideally the quality manager can prevent a renderer from falling behind. But if this does occur, then simply lowering quality does not guarantee the renderer will ever catch up. As a result, audio and video might fall out of sync. To correct this problem, the quality manager can call <strong>DropTime</strong> to request that the renderer drop samples quickly over a specified time interval. After that period, the renderer stops dropping samples.</p><p>This method is primarily intended for the video renderer. Dropped audio samples cause audio glitching, which is not desirable.</p><p>If a component does not support this method, it should return <see cref = "!:DroptimeNotSupported"/>.</p>
            </remarks>
            <doc-id>ms697431</doc-id>
            <unmanaged>HRESULT IMFQualityAdvise::DropTime([In] longlong hnsAmountToDrop)</unmanaged>
            <unmanaged-short>IMFQualityAdvise::DropTime</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.QualityAdvise2.NotifyQualityEvent(SharpDX.MediaFoundation.MediaEvent,System.Int32@)">
            <summary>
            <p>Forwards an MEQualityNotify event from the media sink.</p>
            </summary>
            <param name = "eventRef">No documentation.</param>
            <param name = "dwFlagsRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd743250</doc-id>
            <unmanaged>HRESULT IMFQualityAdvise2::NotifyQualityEvent([In, Optional] IMFMediaEvent* pEvent,[Out] DWORD* pdwFlags)</unmanaged>
            <unmanaged-short>IMFQualityAdvise2::NotifyQualityEvent</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.QualityAdviseLimits.MaximumDropMode">
            <summary>
            <p>Gets the maximum <em>drop mode</em>. A higher drop mode means that the object will, if needed, drop samples more aggressively to match the presentation clock.</p>
            </summary>
            <remarks>
            <p>To get the current drop mode, call the <strong>IMFQualityAdvise::GetDropMode</strong> method. To set the drop mode, call the <strong>IMFQualityAdvise::SetDropMode</strong> method.</p>
            </remarks>
            <doc-id>dd374512</doc-id>
            <unmanaged>GetMaximumDropMode</unmanaged>
            <unmanaged-short>GetMaximumDropMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.QualityAdviseLimits.MinimumQualityLevel">
            <summary>
            <p>Gets the minimum quality level that is supported by the component.</p>
            </summary>
            <remarks>
            <p>To get the current quality level, call the <strong>IMFQualityAdvise::GetQualityLevel</strong> method. To set the quality level, call the <strong>IMFQualityAdvise::SetQualityLevel</strong> method.</p>
            </remarks>
            <doc-id>dd374513</doc-id>
            <unmanaged>GetMinimumQualityLevel</unmanaged>
            <unmanaged-short>GetMinimumQualityLevel</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.QualityAdviseLimits.GetMaximumDropMode(SharpDX.MediaFoundation.QualityDropMode@)">
            <summary>
            <p>Gets the maximum <em>drop mode</em>. A higher drop mode means that the object will, if needed, drop samples more aggressively to match the presentation clock.</p>
            </summary>
            <param name = "eDropModeRef"><dd> <p>Receives the maximum drop mode, specified as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.QualityDropMode"/></strong> enumeration.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>To get the current drop mode, call the <strong>IMFQualityAdvise::GetDropMode</strong> method. To set the drop mode, call the <strong>IMFQualityAdvise::SetDropMode</strong> method.</p>
            </remarks>
            <doc-id>dd374512</doc-id>
            <unmanaged>HRESULT IMFQualityAdviseLimits::GetMaximumDropMode([Out] MF_QUALITY_DROP_MODE* peDropMode)</unmanaged>
            <unmanaged-short>IMFQualityAdviseLimits::GetMaximumDropMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.QualityAdviseLimits.GetMinimumQualityLevel(SharpDX.MediaFoundation.QualityLevel@)">
            <summary>
            <p>Gets the minimum quality level that is supported by the component.</p>
            </summary>
            <param name = "eQualityLevelRef"><dd> <p>Receives the minimum quality level, specified as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.QualityLevel"/></strong> enumeration.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>To get the current quality level, call the <strong>IMFQualityAdvise::GetQualityLevel</strong> method. To set the quality level, call the <strong>IMFQualityAdvise::SetQualityLevel</strong> method.</p>
            </remarks>
            <doc-id>dd374513</doc-id>
            <unmanaged>HRESULT IMFQualityAdviseLimits::GetMinimumQualityLevel([Out] MF_QUALITY_LEVEL* peQualityLevel)</unmanaged>
            <unmanaged-short>IMFQualityAdviseLimits::GetMinimumQualityLevel</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.QualityManager.NotifyTopology(SharpDX.MediaFoundation.Topology)">
            <summary>
            <p> </p><p>Called when the Media Session is about to start playing a new topology.</p>
            </summary>
            <param name = "topologyRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.Topology"/></strong> interface of the new topology. If this parameter is <strong><c>null</c></strong>, the quality manager should release any references to the previous topology.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>In a typical quality manager this method does the following:</p><ol> <li> <p>Enumerates the nodes in the topology.</p> </li> <li> <p>Calls <strong>IMFTopologyNode::GetObject</strong> to get the node's underlying object.</p> </li> <li> <p>Queries for the <strong><see cref = "T:SharpDX.MediaFoundation.QualityAdvise"/></strong> interface.</p> </li> </ol><p>The quality manager can then use the <strong><see cref = "T:SharpDX.MediaFoundation.QualityAdvise"/></strong> references to adjust audio-video quality as needed.</p>
            </remarks>
            <doc-id>ms697409</doc-id>
            <unmanaged>HRESULT IMFQualityManager::NotifyTopology([In] IMFTopology* pTopology)</unmanaged>
            <unmanaged-short>IMFQualityManager::NotifyTopology</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.QualityManager.NotifyPresentationClock(SharpDX.MediaFoundation.PresentationClock)">
            <summary>
            <p> </p><p>Called when the Media Session selects a presentation clock.</p>
            </summary>
            <param name = "clockRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.PresentationClock"/></strong> interface of the presentation clock. If this parameter is <strong><c>null</c></strong>, the quality manager should release any references to the presentation clock.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms702211</doc-id>
            <unmanaged>HRESULT IMFQualityManager::NotifyPresentationClock([In] IMFPresentationClock* pClock)</unmanaged>
            <unmanaged-short>IMFQualityManager::NotifyPresentationClock</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.QualityManager.NotifyProcessInput(SharpDX.MediaFoundation.TopologyNode,System.Int32,SharpDX.MediaFoundation.Sample)">
            <summary>
            <p> </p><p>Called when the media processor is about to deliver an input sample to a pipeline component.</p>
            </summary>
            <param name = "nodeRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.TopologyNode"/></strong> interface of the topology node that represents the pipeline component.</p> </dd></param>
            <param name = "lInputIndex"><dd> <p>Index of the input stream on the topology node.</p> </dd></param>
            <param name = "sampleRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface of the input sample.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is called for every sample passing through every pipeline component. Therefore, the method must return quickly to avoid introducing too much latency into the pipeline.</p>
            </remarks>
            <doc-id>ms703097</doc-id>
            <unmanaged>HRESULT IMFQualityManager::NotifyProcessInput([In] IMFTopologyNode* pNode,[In] long lInputIndex,[In] IMFSample* pSample)</unmanaged>
            <unmanaged-short>IMFQualityManager::NotifyProcessInput</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.QualityManager.NotifyProcessOutput(SharpDX.MediaFoundation.TopologyNode,System.Int32,SharpDX.MediaFoundation.Sample)">
            <summary>
            <p> </p><p>Called after the media processor gets an output sample from a pipeline component.</p>
            </summary>
            <param name = "nodeRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.TopologyNode"/></strong> interface of the topology node that represents the pipeline component.</p> </dd></param>
            <param name = "lOutputIndex"><dd> <p>Index of the output stream on the topology node.</p> </dd></param>
            <param name = "sampleRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface of the output sample.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is called for every sample passing through every pipeline component. Therefore, the method must return quickly to avoid introducing too much latency into the pipeline.</p>
            </remarks>
            <doc-id>ms700792</doc-id>
            <unmanaged>HRESULT IMFQualityManager::NotifyProcessOutput([In] IMFTopologyNode* pNode,[In] long lOutputIndex,[In] IMFSample* pSample)</unmanaged>
            <unmanaged-short>IMFQualityManager::NotifyProcessOutput</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.QualityManager.NotifyQualityEvent(SharpDX.IUnknown,SharpDX.MediaFoundation.MediaEvent)">
            <summary>
            <p> </p><p>Called when a pipeline component sends an MEQualityNotify event.</p>
            </summary>
            <param name = "objectRef">No documentation.</param>
            <param name = "eventRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms704768</doc-id>
            <unmanaged>HRESULT IMFQualityManager::NotifyQualityEvent([In] IUnknown* pObject,[In] IMFMediaEvent* pEvent)</unmanaged>
            <unmanaged-short>IMFQualityManager::NotifyQualityEvent</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.QualityManager.Shutdown">
            <summary>
            <p> </p><p>Called when the Media Session is shutting down.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The quality manager should release all references to the Media Session when this method is called.</p>
            </remarks>
            <doc-id>ms703099</doc-id>
            <unmanaged>HRESULT IMFQualityManager::Shutdown()</unmanaged>
            <unmanaged-short>IMFQualityManager::Shutdown</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.RateControl.SetRate(SharpDX.Mathematics.Interop.RawBool,System.Single)">
            <summary>
            <p> Sets the playback rate. </p>
            </summary>
            <param name = "fThin"><dd> <p> If <strong>TRUE</strong>, the media streams are thinned. Otherwise, the stream is not thinned. For media sources and demultiplexers, the object must thin the streams when this parameter is <strong>TRUE</strong>. For downstream transforms, such as decoders and multiplexers, this parameter is informative; it notifies the object that the input streams are thinned. For information, see About Rate Control. </p> </dd></param>
            <param name = "flRate"><dd> <p> The requested playback rate. Postive values indicate forward playback, negative values indicate reverse playback, and zero indicates scrubbing (the source delivers a single frame). </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ReverseUnsupported"/></strong></dt> </dl> </td><td> <p> The object does not support reverse playback. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ThinningUnsupported"/></strong></dt> </dl> </td><td> <p> The object does not support thinning. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedRate"/></strong></dt> </dl> </td><td> <p> The object does not support the requested playback rate. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedRateTransition"/></strong></dt> </dl> </td><td> <p> The object cannot change to the new rate while in the running state. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The Media Session prevents some transitions between rate boundaries, depending on the current playback state:</p><table> <tr><th>Playback State</th><th>Forward/Reverse</th><th>Forward/Zero</th><th>Reverse/Zero</th></tr> <tr><td>Running</td><td>No</td><td>No</td><td>No</td></tr> <tr><td>Paused</td><td>No</td><td>Yes</td><td>No</td></tr> <tr><td>Stopped</td><td>Yes</td><td>Yes</td><td>Yes</td></tr> </table><p>?</p><p>If the transition is not supported, the method returns <strong><see cref = "!:UnsupportedRateTransition"/></strong>.</p><p>When a media source completes a call to <strong>SetRate</strong>, it sends the MESourceRateChanged event. Other pipeline components do not send this event.</p><p>If a media source switches between thinned and non-thinned playback, the streams send an MEStreamThinMode event to indicate the transition. Events from the media source are not synchronized with events from the media streams. After you receive the MESourceRateChanged event, you can still receive samples that were queued before the stream switched to thinned or non-thinned mode. The MEStreamThinMode event marks the exact point in the stream where the transition occurs.</p><p>When the Media Session completes a call to <strong>SetRate</strong>, it sends the MESessionRateChanged event.</p>
            </remarks>
            <doc-id>ms696979</doc-id>
            <unmanaged>HRESULT IMFRateControl::SetRate([In] BOOL fThin,[In] float flRate)</unmanaged>
            <unmanaged-short>IMFRateControl::SetRate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.RateControl.GetRate(System.Single@)">
            <summary>
            <p> </p><p>Gets the current playback rate.</p>
            </summary>
            <param name = "flRateRef"><dd> <p>Receives the current playback rate.</p> </dd></param>
            <returns><dd> <p>Receives the value <strong>TRUE</strong> if the stream is currently being thinned. If the object does not support thinning, this parameter always receives the value <strong><see cref = "F:SharpDX.Result.False"/></strong>. This parameter can be <strong><c>null</c></strong>. For more information, see About Rate Control.</p> </dd></returns>
            <doc-id>ms705641</doc-id>
            <unmanaged>HRESULT IMFRateControl::GetRate([Out] BOOL* pfThin,[Out] float* pflRate)</unmanaged>
            <unmanaged-short>IMFRateControl::GetRate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.RateSupport.GetSlowestRate(SharpDX.MediaFoundation.RateDirection,SharpDX.Mathematics.Interop.RawBool,System.Single@)">
            <summary>
            <p> </p><p>Retrieves the slowest playback rate supported by the object.</p>
            </summary>
            <param name = "eDirection"><dd> <p>Specifies whether to query to the slowest forward playback rate or reverse playback rate. The value is a member of the <strong><see cref = "T:SharpDX.MediaFoundation.RateDirection"/></strong> enumeration.</p> </dd></param>
            <param name = "fThin"><dd> <p>If <strong>TRUE</strong>, the method retrieves the slowest thinned playback rate. Otherwise, the method retrieves the slowest non-thinned playback rate. For information about thinning, see About Rate Control.</p> </dd></param>
            <param name = "flRateRef"><dd> <p>Receives the slowest playback rate that the object supports.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ReverseUnsupported"/></strong></dt> </dl> </td><td> <p>The object does not support reverse playback.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ThinningUnsupported"/></strong></dt> </dl> </td><td> <p>The object does not support thinning.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The value returned in <em>plfRate</em> represents a lower bound. Playback at this rate is not guaranteed. Call <strong>IMFRateSupport::IsRateSupported</strong> to check whether the boundary rate is supported. For example, a component that supports arbitrarily slow rates will return zero in <em>pflRate</em>, and applications should call <strong>IsRateSupported</strong> separately to determine whether the component supports rate 0.</p><p>If <em>eDirection</em> is MFRATE_REVERSE, the method retrieves the slowest reverse playback rate. This is a negative value, assuming the object supports reverse playback.</p>
            </remarks>
            <doc-id>ms704596</doc-id>
            <unmanaged>HRESULT IMFRateSupport::GetSlowestRate([In] MFRATE_DIRECTION eDirection,[In] BOOL fThin,[Out] float* pflRate)</unmanaged>
            <unmanaged-short>IMFRateSupport::GetSlowestRate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.RateSupport.GetFastestRate(SharpDX.MediaFoundation.RateDirection,SharpDX.Mathematics.Interop.RawBool,System.Single@)">
            <summary>
            <p> </p><p>Gets the fastest playback rate supported by the object.</p>
            </summary>
            <param name = "eDirection"><dd> <p>Specifies whether to query to the fastest forward playback rate or reverse playback rate. The value is a member of the <strong><see cref = "T:SharpDX.MediaFoundation.RateDirection"/></strong> enumeration.</p> </dd></param>
            <param name = "fThin"><dd> <p>If <strong>TRUE</strong>, the method retrieves the fastest thinned playback rate. Otherwise, the method retrieves the fastest non-thinned playback rate. For information about thinning, see About Rate Control.</p> </dd></param>
            <param name = "flRateRef"><dd> <p>Receives the fastest playback rate that the object supports.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ReverseUnsupported"/></strong></dt> </dl> </td><td> <p>The object does not support reverse playback.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ThinningUnsupported"/></strong></dt> </dl> </td><td> <p>The object does not support thinning.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>For some formats (such as ASF), thinning means dropping all frames that are not I-frames. If a component produces stream data, such as a media source or a demultiplexer, it should pay attention to the <em>fThin</em> parameter and return <see cref = "!:ThinningUnsupported"/> if it cannot thin the stream.</p><p>If the component processes or receives a stream (most transforms or media sinks), it may ignore this parameter if it does not care whether the stream is thinned. In the Media Session's implementation of rate support, if the transforms do not explicitly support reverse playback, the Media Session will attempt to playback in reverse with thinning but not without thinning. Therefore, most applications will set <em>fThin</em> to <strong>TRUE</strong> when using the Media Session for reverse playback.</p><p>If <em>eDirection</em> is MFRATE_REVERSE, the method retrieves the fastest reverse playback rate. This is a negative value, assuming the object supports reverse playback.</p>
            </remarks>
            <doc-id>ms693505</doc-id>
            <unmanaged>HRESULT IMFRateSupport::GetFastestRate([In] MFRATE_DIRECTION eDirection,[In] BOOL fThin,[Out] float* pflRate)</unmanaged>
            <unmanaged-short>IMFRateSupport::GetFastestRate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.RateSupport.IsRateSupported(SharpDX.Mathematics.Interop.RawBool,System.Single,System.IntPtr)">
            <summary>
            <p> </p><p>Queries whether the object supports a specified playback rate.</p>
            </summary>
            <param name = "fThin"><dd> <p>If <strong>TRUE</strong>, the method queries whether the object supports the playback rate with thinning. Otherwise, the method queries whether the object supports the playback rate without thinning. For information about thinning, see About Rate Control.</p> </dd></param>
            <param name = "flRate"><dd> <p>The playback rate to query.</p> </dd></param>
            <param name = "flNearestSupportedRateRef"><dd> <p>If the object does not support the playback rate given in <em>flRate</em>, this parameter receives the closest supported playback rate. If the method returns <see cref = "F:SharpDX.Result.Ok"/>, this parameter receives the value given in <em>flRate</em>. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The object supports the specified rate.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ReverseUnsupported"/></strong></dt> </dl> </td><td> <p>The object does not support reverse playback.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ThinningUnsupported"/></strong></dt> </dl> </td><td> <p>The object does not support thinning.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedRate"/></strong></dt> </dl> </td><td> <p>The object does not support the specified rate.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms696250</doc-id>
            <unmanaged>HRESULT IMFRateSupport::IsRateSupported([In] BOOL fThin,[In] float flRate,[InOut, Optional] float* pflNearestSupportedRate)</unmanaged>
            <unmanaged-short>IMFRateSupport::IsRateSupported</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ReadWriteClassFactory.CreateInstanceFromURL(System.Guid,System.String,SharpDX.MediaFoundation.MediaAttributes,System.Guid,System.IntPtr@)">
            <summary>
            <p>Creates an instance of the sink writer or source reader, given a URL.</p>
            </summary>
            <param name = "clsid"><dd> <p>The CLSID of the object to create.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong>CLSID_MFSinkWriter</strong></strong></dt> </dl> </td><td> <p>Create the sink writer. The <em>ppvObject</em> parameter receives an <strong><see cref = "T:SharpDX.MediaFoundation.SinkWriter"/></strong> interface reference.</p> </td></tr> <tr><td><dl> <dt><strong><strong>CLSID_MFSourceReader</strong></strong></dt> </dl> </td><td> <p>Create the source reader. The <em>ppvObject</em> parameter receives an <strong><see cref = "T:SharpDX.MediaFoundation.SourceReader"/></strong> interface reference.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "wszURLRef"><dd> <p>A null-terminated string that contains a URL. If <em>clsid</em> is CLSID_<strong>MFSinkWriter</strong>, the URL specifies the name of the output file. The sink writer creates a new file with this name. If <em>clsid</em> is <strong>CLSID_MFSourceReader</strong>, the URL specifies the input file for the source reader.</p> </dd></param>
            <param name = "attributesRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this parameter to configure the sink writer or source reader. For more information, see the following topics:</p> <ul> <li> Sink Writer Attributes </li> <li> Source Reader Attributes </li> </ul> <p>This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "riid"><dd> <p>The IID of the requested interface.</p> </dd></param>
            <param name = "vObjectOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374516</doc-id>
            <unmanaged>HRESULT IMFReadWriteClassFactory::CreateInstanceFromURL([In] const GUID&amp; clsid,[In] const wchar_t* pwszURL,[In, Optional] IMFAttributes* pAttributes,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>
            <unmanaged-short>IMFReadWriteClassFactory::CreateInstanceFromURL</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.ReadWriteClassFactory.CreateInstanceFromObject(System.Guid,SharpDX.IUnknown,SharpDX.MediaFoundation.MediaAttributes,System.Guid,System.IntPtr@)">
            <summary>
            <p>Creates an instance of the sink writer or source reader, given an <strong><see cref = "T:SharpDX.IUnknown"/></strong> reference. </p>
            </summary>
            <param name = "clsid"><dd> <p>The CLSID of the object to create.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong>CLSID_MFSinkWriter</strong></strong></dt> </dl> </td><td> <p>Create the sink writer. The <em>ppvObject</em> parameter receives an <strong><see cref = "T:SharpDX.MediaFoundation.SinkWriter"/></strong> interface reference.</p> </td></tr> <tr><td><dl> <dt><strong><strong>CLSID_MFSourceReader</strong></strong></dt> </dl> </td><td> <p>Create the source reader. The <em>ppvObject</em> parameter receives an <strong><see cref = "T:SharpDX.MediaFoundation.SourceReader"/></strong> interface reference.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "unkObjectRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of an object that is used to initialize the source reader or sink writer. The method queries this reference for one of the following interfaces.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong></strong></dt> </dl> </td><td> <p>Pointer to a byte stream. </p> <p>If <em>clsid</em> is <strong>CLSID_MFSinkWriter</strong>, the sink writer writes data to this byte stream.</p> <p>If <em>clsid</em> is <strong>CLSID_MFSourceReader</strong>, this byte stream provides the source data for the source reader.</p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref = "T:SharpDX.MediaFoundation.MediaSink"/></strong></strong></dt> </dl> </td><td> <p>Pointer to a media sink. Applies only when <em>clsid</em> is <strong>CLSID_MFSinkWriter</strong>. </p> </td></tr> <tr><td><dl> <dt><strong><strong><see cref = "T:SharpDX.MediaFoundation.MediaSource"/></strong></strong></dt> </dl> </td><td> <p>Pointer to a media source. Applies only when <em>clsid</em> is <strong>CLSID_MFSourceReader</strong>.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "attributesRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this parameter to configure the sink writer or source reader. For more information, see the following topics:</p> <ul> <li> Sink Writer Attributes </li> <li> Source Reader Attributes </li> </ul> <p>This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "riid"><dd> <p>The IID of the requested interface.</p> </dd></param>
            <param name = "vObjectOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374515</doc-id>
            <unmanaged>HRESULT IMFReadWriteClassFactory::CreateInstanceFromObject([In] const GUID&amp; clsid,[In] IUnknown* punkObject,[In, Optional] IMFAttributes* pAttributes,[In] const GUID&amp; riid,[Out] void** ppvObject)</unmanaged>
            <unmanaged-short>IMFReadWriteClassFactory::CreateInstanceFromObject</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.RealTimeClient.WorkQueue">
            <summary>
            <p>Specifies the work queue for the topology branch that contains this object.</p>
            </summary>
            <remarks>
            <p> An application can register a branch of the topology to use a private work queue. The Media Session notifies any pipeline object that supports <strong><see cref = "T:SharpDX.MediaFoundation.RealTimeClient"/></strong> by calling <strong>SetWorkQueue</strong> with the application's work queue identifier. </p><p>When the application unregisters the topology branch, the Media Session calls <strong>SetWorkQueue</strong> again with the value <strong>MFASYNC_CALLBACK_QUEUE_UNDEFINED</strong>. </p>
            </remarks>
            <doc-id>aa367678</doc-id>
            <unmanaged>SetWorkQueue</unmanaged>
            <unmanaged-short>SetWorkQueue</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.RealTimeClient.RegisterThreads(System.Int32,System.String)">
            <summary>
            <p>Notifies the object to register its worker threads with the Multimedia Class Scheduler Service (MMCSS).</p>
            </summary>
            <param name = "dwTaskIndex"><dd> <p> The MMCSS task identifier. </p> </dd></param>
            <param name = "wszClass"><dd> <p>The name of the MMCSS task. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The object's worker threads should register themselves with MMCSS by calling <strong>AvSetMmThreadCharacteristics</strong>, using the task name and identifier specified in this method.</p>
            </remarks>
            <doc-id>aa367059</doc-id>
            <unmanaged>HRESULT IMFRealTimeClient::RegisterThreads([In] DWORD dwTaskIndex,[In] const wchar_t* wszClass)</unmanaged>
            <unmanaged-short>IMFRealTimeClient::RegisterThreads</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.RealTimeClient.UnregisterThreads">
            <summary>
            <p> Notifies the object to unregister its worker threads from the Multimedia Class Scheduler Service (MMCSS). </p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The object's worker threads should unregister themselves from MMCSS by calling <strong>AvRevertMmThreadCharacteristics</strong>.</p>
            </remarks>
            <doc-id>aa371717</doc-id>
            <unmanaged>HRESULT IMFRealTimeClient::UnregisterThreads()</unmanaged>
            <unmanaged-short>IMFRealTimeClient::UnregisterThreads</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.RealTimeClient.SetWorkQueue(System.Int32)">
            <summary>
            <p>Specifies the work queue for the topology branch that contains this object.</p>
            </summary>
            <param name = "dwWorkQueueId"><dd> <p>The identifier of the work queue, or the value <strong>MFASYNC_CALLBACK_QUEUE_UNDEFINED</strong>. See Remarks. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> An application can register a branch of the topology to use a private work queue. The Media Session notifies any pipeline object that supports <strong><see cref = "T:SharpDX.MediaFoundation.RealTimeClient"/></strong> by calling <strong>SetWorkQueue</strong> with the application's work queue identifier. </p><p>When the application unregisters the topology branch, the Media Session calls <strong>SetWorkQueue</strong> again with the value <strong>MFASYNC_CALLBACK_QUEUE_UNDEFINED</strong>. </p>
            </remarks>
            <doc-id>aa367678</doc-id>
            <unmanaged>HRESULT IMFRealTimeClient::SetWorkQueue([In] DWORD dwWorkQueueId)</unmanaged>
            <unmanaged-short>IMFRealTimeClient::SetWorkQueue</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.RealTimeClientEx.RegisterThreadsEx(System.Int32@,System.String,System.Int32)">
            <summary>
            <p>Notifies the object to register its worker threads with the Multimedia Class Scheduler Service (MMCSS).</p>
            </summary>
            <param name = "dwTaskIndexRef"><dd> <p>The MMCSS task identifier. If the value is zero on input,  the object should create a new MCCSS task group. See Remarks.</p> </dd></param>
            <param name = "wszClassName"><dd> <p>The name of the MMCSS task.</p> </dd></param>
            <param name = "lBasePriority"><dd> <p>The base priority of the thread.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If the object does not create worker threads, the method should simply return <see cref = "F:SharpDX.Result.Ok"/> and take no further action. </p><p>Otherwise, if the value of <code>*pdwTaskIndex</code> is zero on input, the object should perform the following steps:</p><ol> <li>A single worker thread calls <strong>AvSetMmThreadCharacteristics</strong> to create a new MMCSS task identifier. Store this value.</li> <li>Any additional worker threads call <strong>AvSetMmThreadCharacteristics</strong> using the new task identifier.</li> <li>Return the new task identifier to the caller, by setting <code>*pdwTaskIndex</code> equal to the task identifier.</li> </ol><p>If the value of <code>*pdwTaskIndex</code> is nonzero on input, the parameter contains an existing MMCSS task identifer. In that case, all worker threads of the object should register themselves for that task by calling <strong>AvSetMmThreadCharacteristics</strong>.</p>
            </remarks>
            <doc-id>hh448048</doc-id>
            <unmanaged>HRESULT IMFRealTimeClientEx::RegisterThreadsEx([InOut] DWORD* pdwTaskIndex,[In] const wchar_t* wszClassName,[In] LONG lBasePriority)</unmanaged>
            <unmanaged-short>IMFRealTimeClientEx::RegisterThreadsEx</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.RealTimeClientEx.UnregisterThreads">
            <summary>
            <p>Notifies the object to unregister its worker threads from the Multimedia Class Scheduler Service (MMCSS). </p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh448050</doc-id>
            <unmanaged>HRESULT IMFRealTimeClientEx::UnregisterThreads()</unmanaged>
            <unmanaged-short>IMFRealTimeClientEx::UnregisterThreads</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.RealTimeClientEx.SetWorkQueueEx(System.Int32,System.Int32)">
            <summary>
            <p>Specifies the work queue that this object should use for asynchronous work items. </p>
            </summary>
            <param name = "dwMultithreadedWorkQueueId"><dd> <p>The work queue identifier.</p> </dd></param>
            <param name = "lWorkItemBasePriority"><dd> <p>The base priority for work items.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The object should use the values of <em>dwMultithreadedWorkQueueId</em> and <em>lWorkItemBasePriority</em> when it queues new work items. Use the <strong>MFPutWorkItem2</strong> or <strong>MFPutWorkItemEx2</strong> function to queue the work item.</p>
            </remarks>
            <doc-id>hh448049</doc-id>
            <unmanaged>HRESULT IMFRealTimeClientEx::SetWorkQueueEx([In] DWORD dwMultithreadedWorkQueueId,[In] LONG lWorkItemBasePriority)</unmanaged>
            <unmanaged-short>IMFRealTimeClientEx::SetWorkQueueEx</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.RemoteAsyncCallback.Invoke(SharpDX.Result,SharpDX.IUnknown)">
            <summary>
            No documentation.
            </summary>
            <param name = "hr">No documentation.</param>
            <param name = "remoteResultRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFRemoteAsyncCallback::Invoke([In] HRESULT hr,[In, Optional] IUnknown* pRemoteResult)</unmanaged>
            <unmanaged-short>IMFRemoteAsyncCallback::Invoke</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.RemoteDesktopPlugin.UpdateTopology(SharpDX.MediaFoundation.Topology)">
            <summary>
            <p> </p><p>Modifies a topology for use in a Terminal Services environment.</p>
            </summary>
            <param name = "topologyRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.Topology"/></strong> interface of the topology.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the application is running in a Terminal Services client session, call this method before calling <strong>IMFMediaSession::SetTopology</strong> on the Media Session.</p>
            </remarks>
            <doc-id>ms699001</doc-id>
            <unmanaged>HRESULT IMFRemoteDesktopPlugin::UpdateTopology([In] IMFTopology* pTopology)</unmanaged>
            <unmanaged-short>IMFRemoteDesktopPlugin::UpdateTopology</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.RemoteProxy.GetRemoteObject(System.Guid,System.IntPtr@)">
            <summary>
            <p> </p><p>Retrieves a reference to the remote object for which this object is a proxy.</p>
            </summary>
            <param name = "riid"><dd> <p>Interface identifier (IID) of the requested interface.</p> </dd></param>
            <param name = "vOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970370</doc-id>
            <unmanaged>HRESULT IMFRemoteProxy::GetRemoteObject([In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>
            <unmanaged-short>IMFRemoteProxy::GetRemoteObject</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.RemoteProxy.GetRemoteHost(System.Guid,System.IntPtr@)">
            <summary>
            <p> </p><p>Retrieves a reference to the object that is hosting this proxy.</p>
            </summary>
            <param name = "riid"><dd> <p>Interface identifier (IID) of the requested interface.</p> </dd></param>
            <param name = "vOut"><dd> <p>Receives a reference to the requested interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970549</doc-id>
            <unmanaged>HRESULT IMFRemoteProxy::GetRemoteHost([In] const GUID&amp; riid,[Out] void** ppv)</unmanaged>
            <unmanaged-short>IMFRemoteProxy::GetRemoteHost</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SAMIStyle.StyleCount">
            <summary>
            <p> Gets the number of styles defined in the SAMI file. </p>
            </summary>
            <doc-id>bb970341</doc-id>
            <unmanaged>GetStyleCount</unmanaged>
            <unmanaged-short>GetStyleCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SAMIStyle.Styles">
            <summary>
            <p> Gets a list of the style names defined in the SAMI file. </p>
            </summary>
            <doc-id>bb970547</doc-id>
            <unmanaged>GetStyles</unmanaged>
            <unmanaged-short>GetStyles</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SAMIStyle.GetStyleCount(System.Int32@)">
            <summary>
            <p> Gets the number of styles defined in the SAMI file. </p>
            </summary>
            <param name = "dwCountRef"><dd> <p> Receives the number of SAMI styles in the file. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>bb970341</doc-id>
            <unmanaged>HRESULT IMFSAMIStyle::GetStyleCount([Out] DWORD* pdwCount)</unmanaged>
            <unmanaged-short>IMFSAMIStyle::GetStyleCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SAMIStyle.GetStyles(SharpDX.Win32.Variant@)">
            <summary>
            <p> Gets a list of the style names defined in the SAMI file. </p>
            </summary>
            <param name = "propVarStyleArrayRef"><dd> <p>Pointer to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that receives an array of null-terminated wide-character strings. The <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> type is VT_VECTOR | VT_LPWSTR. The caller must clear the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> by calling <strong>PropVariantClear</strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>bb970547</doc-id>
            <unmanaged>HRESULT IMFSAMIStyle::GetStyles([Out] PROPVARIANT* pPropVarStyleArray)</unmanaged>
            <unmanaged-short>IMFSAMIStyle::GetStyles</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SAMIStyle.SetSelectedStyle(System.String)">
            <summary>
            <p> Sets the current style on the SAMI media source.</p>
            </summary>
            <param name = "wszStyleRef"><dd> <p>Pointer to a null-terminated string containing the name of the style. To clear the current style, pass an empty string ("").  To get the list of style names, call <strong>IMFSAMIStyle::GetStyles</strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>bb970574</doc-id>
            <unmanaged>HRESULT IMFSAMIStyle::SetSelectedStyle([In] const wchar_t* pwszStyle)</unmanaged>
            <unmanaged-short>IMFSAMIStyle::SetSelectedStyle</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SAMIStyle.GetSelectedStyle(System.IntPtr)">
            <summary>
            <p> Gets the current style from the SAMI media source. </p>
            </summary>
            <param name = "wszStyleOut"><dd> <p> Receives a reference to a null-terminated string that contains the name of the style. If no style is currently set, the method returns an empty string. The caller must free the memory for the string by calling <strong>CoTaskMemFree</strong>.  </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>bb970429</doc-id>
            <unmanaged>HRESULT IMFSAMIStyle::GetSelectedStyle([Out] wchar_t** ppwszStyle)</unmanaged>
            <unmanaged-short>IMFSAMIStyle::GetSelectedStyle</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.Sample.SampleFlags">
            <summary>
            <p> </p><p>Retrieves flags associated with the sample.</p><p>Currently no flags are defined. Instead, metadata for samples is defined using attributes. To get attibutes from a sample, use the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface, which <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> inherits. For a list of sample attributes, see Sample Attributes.</p>
            </summary>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms701587</doc-id>
            <unmanaged>GetSampleFlags / SetSampleFlags</unmanaged>
            <unmanaged-short>GetSampleFlags</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.Sample.SampleTime">
            <summary>
            <p> </p><p>Retrieves the presentation time of the sample.</p>
            </summary>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms705645</doc-id>
            <unmanaged>GetSampleTime / SetSampleTime</unmanaged>
            <unmanaged-short>GetSampleTime</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.Sample.SampleDuration">
            <summary>
            <p> </p><p>Retrieves the duration of the sample.</p>
            </summary>
            <remarks>
            <p>If the sample contains more than one buffer, the duration includes the data from all of the buffers.</p><p>If the retrieved duration is zero, or if the method returns <strong><see cref = "!:NoSampleDuration"/></strong>, the duration is unknown. In that case, it might be possible to calculate the duration from the media type?for example, by using the video frame rate or the audio sampling rate.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms703056</doc-id>
            <unmanaged>GetSampleDuration / SetSampleDuration</unmanaged>
            <unmanaged-short>GetSampleDuration</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.Sample.BufferCount">
            <summary>
            <p> </p><p>Retrieves the number of buffers in the sample.</p>
            </summary>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms705655</doc-id>
            <unmanaged>GetBufferCount</unmanaged>
            <unmanaged-short>GetBufferCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.Sample.TotalLength">
            <summary>
            <p> </p><p>Retrieves the total length of the valid data in all of the buffers in the sample. The length is calculated as the sum of the values retrieved by the <strong>IMFMediaBuffer::GetCurrentLength</strong> method.</p>
            </summary>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms704584</doc-id>
            <unmanaged>GetTotalLength</unmanaged>
            <unmanaged-short>GetTotalLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Sample.GetSampleFlags(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves flags associated with the sample.</p><p>Currently no flags are defined. Instead, metadata for samples is defined using attributes. To get attibutes from a sample, use the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface, which <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> inherits. For a list of sample attributes, see Sample Attributes.</p>
            </summary>
            <param name = "dwSampleFlagsRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms701587</doc-id>
            <unmanaged>HRESULT IMFSample::GetSampleFlags([Out] DWORD* pdwSampleFlags)</unmanaged>
            <unmanaged-short>IMFSample::GetSampleFlags</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Sample.SetSampleFlags(System.Int32)">
            <summary>
            <p> </p><p>Sets flags associated with the sample.</p><p>Currently no flags are defined. Instead, metadata for samples is defined using attributes. To set attibutes on a sample, use the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface, which <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> inherits. For a list of sample attributes, see Sample Attributes.</p>
            </summary>
            <param name = "dwSampleFlags">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms696207</doc-id>
            <unmanaged>HRESULT IMFSample::SetSampleFlags([In] DWORD dwSampleFlags)</unmanaged>
            <unmanaged-short>IMFSample::SetSampleFlags</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Sample.GetSampleTime(System.Int64@)">
            <summary>
            <p> </p><p>Retrieves the presentation time of the sample.</p>
            </summary>
            <param name = "hnsSampleTimeRef"><dd> <p>Receives the presentation time, in 100-nanosecond units.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NoSampleTimestamp"/></strong></dt> </dl> </td><td> <p>The sample does not have a presentation time.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms705645</doc-id>
            <unmanaged>HRESULT IMFSample::GetSampleTime([Out] longlong* phnsSampleTime)</unmanaged>
            <unmanaged-short>IMFSample::GetSampleTime</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Sample.SetSampleTime(System.Int64)">
            <summary>
            <p> </p><p>Sets the presentation time of the sample.</p>
            </summary>
            <param name = "hnsSampleTime"><dd> <p>The presentation time, in 100-nanosecond units.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Some pipeline components require samples that have time stamps. Generally the component that generates the data for the sample also sets the time stamp. The Media Session might modify the time stamps.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms697282</doc-id>
            <unmanaged>HRESULT IMFSample::SetSampleTime([In] longlong hnsSampleTime)</unmanaged>
            <unmanaged-short>IMFSample::SetSampleTime</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Sample.GetSampleDuration(System.Int64@)">
            <summary>
            <p> </p><p>Retrieves the duration of the sample.</p>
            </summary>
            <param name = "hnsSampleDurationRef"><dd> <p>Receives the duration, in 100-nanosecond units.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NoSampleDuration"/></strong></dt> </dl> </td><td> <p>The sample does not have a specified duration.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the sample contains more than one buffer, the duration includes the data from all of the buffers.</p><p>If the retrieved duration is zero, or if the method returns <strong><see cref = "!:NoSampleDuration"/></strong>, the duration is unknown. In that case, it might be possible to calculate the duration from the media type?for example, by using the video frame rate or the audio sampling rate.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms703056</doc-id>
            <unmanaged>HRESULT IMFSample::GetSampleDuration([Out] longlong* phnsSampleDuration)</unmanaged>
            <unmanaged-short>IMFSample::GetSampleDuration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Sample.SetSampleDuration(System.Int64)">
            <summary>
            <p> </p><p>Sets the duration of the sample.</p>
            </summary>
            <param name = "hnsSampleDuration"><dd> <p>Duration of the sample, in 100-nanosecond units.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method succeeds if the duration is negative, although negative durations are probably not valid for most types of data. It is the responsibility of the object that consumes the sample to validate the duration.</p><p>The duration can also be zero. This might be valid for some types of data. For example, the sample might contain stream metadata with no buffers.</p><p>Until this method is called, the <strong>IMFSample::GetSampleDuration</strong> method returns <strong><see cref = "!:NoSampleDuration"/></strong>.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms705626</doc-id>
            <unmanaged>HRESULT IMFSample::SetSampleDuration([In] longlong hnsSampleDuration)</unmanaged>
            <unmanaged-short>IMFSample::SetSampleDuration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Sample.GetBufferCount(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the number of buffers in the sample.</p>
            </summary>
            <param name = "dwBufferCountRef"><dd> <p>Receives the number of buffers in the sample. A sample might contain zero buffers.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms705655</doc-id>
            <unmanaged>HRESULT IMFSample::GetBufferCount([Out] DWORD* pdwBufferCount)</unmanaged>
            <unmanaged-short>IMFSample::GetBufferCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Sample.GetBufferByIndex(System.Int32)">
            <summary>
            <p> Gets a buffer from the sample, by index.</p><p> </p><strong>Note</strong>??In most cases, it is safer to use the <strong>IMFSample::ConvertToContiguousBuffer</strong> method.  If the sample contains more than one buffer, the <strong>ConvertToContiguousBuffer</strong> method replaces them with a single buffer, copies the original data into that buffer, and returns the new buffer to the caller. The copy operation occurs at most once. On subsequent calls, no data is copied.?
            </summary>
            <param name = "dwIndex">No documentation.</param>
            <returns>No documentation.</returns>
            <remarks>
            <p>A sample might contain more than one buffer. Use the <strong>GetBufferByIndex</strong> method to enumerate the individual buffers.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms697014</doc-id>
            <unmanaged>HRESULT IMFSample::GetBufferByIndex([In] DWORD dwIndex,[Out] IMFMediaBuffer** ppBuffer)</unmanaged>
            <unmanaged-short>IMFSample::GetBufferByIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Sample.ConvertToContiguousBuffer">
            <summary>
            <p> Converts a sample with multiple buffers into a sample with a single buffer. </p>
            </summary>
            <returns><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> interface. The caller must release the interface.</p> </dd></returns>
            <remarks>
            <p>If the sample contains more than one buffer, this method copies the data from the original buffers into a new buffer, and replaces the original buffer list with the new buffer. The new buffer is returned in the <em>ppBuffer</em> parameter.</p><p> If the sample contains a single buffer, this method returns a reference to the original buffer. In typical use, most samples do not contain multiple buffers.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms698917</doc-id>
            <unmanaged>HRESULT IMFSample::ConvertToContiguousBuffer([Out] IMFMediaBuffer** ppBuffer)</unmanaged>
            <unmanaged-short>IMFSample::ConvertToContiguousBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Sample.AddBuffer(SharpDX.MediaFoundation.MediaBuffer)">
            <summary>
            <p> Adds a buffer to the end of the list of buffers in the sample. </p>
            </summary>
            <param name = "bufferRef"><dd> <p>Pointer to the buffer's <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><c>null</c> reference argument.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>For uncompressed video data, each buffer should contain a single video frame, and samples should not contain multiple frames. In general, storing multiple buffers in a sample is discouraged.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms697465</doc-id>
            <unmanaged>HRESULT IMFSample::AddBuffer([In] IMFMediaBuffer* pBuffer)</unmanaged>
            <unmanaged-short>IMFSample::AddBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Sample.RemoveBufferByIndex(System.Int32)">
            <summary>
            <p> </p><p>Removes a buffer at a specified index from the sample.</p>
            </summary>
            <param name = "dwIndex"><dd> <p>Index of the buffer. To find the number of buffers in the sample, call <strong>IMFSample::GetBufferCount</strong>. Buffers are indexed from zero.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms705646</doc-id>
            <unmanaged>HRESULT IMFSample::RemoveBufferByIndex([In] DWORD dwIndex)</unmanaged>
            <unmanaged-short>IMFSample::RemoveBufferByIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Sample.RemoveAllBuffers">
            <summary>
            <p> </p><p>Removes all of the buffers from the sample.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms703108</doc-id>
            <unmanaged>HRESULT IMFSample::RemoveAllBuffers()</unmanaged>
            <unmanaged-short>IMFSample::RemoveAllBuffers</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Sample.GetTotalLength(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the total length of the valid data in all of the buffers in the sample. The length is calculated as the sum of the values retrieved by the <strong>IMFMediaBuffer::GetCurrentLength</strong> method.</p>
            </summary>
            <param name = "cbTotalLengthRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms704584</doc-id>
            <unmanaged>HRESULT IMFSample::GetTotalLength([Out] DWORD* pcbTotalLength)</unmanaged>
            <unmanaged-short>IMFSample::GetTotalLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Sample.CopyToBuffer(SharpDX.MediaFoundation.MediaBuffer)">
            <summary>
            <p> </p><p>Copies the sample data to a buffer. This method concatenates the valid data from all of the buffers of the sample, in order.</p>
            </summary>
            <param name = "bufferRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaBuffer"/></strong> interface of the destination buffer. The buffer must be large enough to hold the valid data in the sample. To get the size of the data in the sample, call <strong>IMFSample::GetTotalLength</strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><c>null</c> reference argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:BufferTooSmall"/></strong></dt> </dl> </td><td> <p>The buffer is not large enough to contain the data.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms703119</doc-id>
            <unmanaged>HRESULT IMFSample::CopyToBuffer([In] IMFMediaBuffer* pBuffer)</unmanaged>
            <unmanaged-short>IMFSample::CopyToBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SampleOutputStream.BeginWriteSample(SharpDX.MediaFoundation.Sample,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p>Begins an asynchronous request to write a media sample to the stream.</p>
            </summary>
            <param name = "sampleRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface of the sample.</p> </dd></param>
            <param name = "callbackRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>
            <param name = "unkStateRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.  </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>When the sample has been written to the stream, the callback object's <strong>IMFAsyncCallback::Invoke</strong> method is called. At that point, the caller should call <strong>IMFSampleOutputStream::EndWriteSample</strong> to complete the asynchronous request.  </p>
            </remarks>
            <doc-id>hh448052</doc-id>
            <unmanaged>HRESULT IMFSampleOutputStream::BeginWriteSample([In, Optional] IMFSample* pSample,[In, Optional] IMFAsyncCallback* pCallback,[In, Optional] IUnknown* punkState)</unmanaged>
            <unmanaged-short>IMFSampleOutputStream::BeginWriteSample</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SampleOutputStream.EndWriteSample(SharpDX.MediaFoundation.AsyncResult)">
            <summary>
            <p>Completes an asynchronous request to write a media sample to the stream.</p>
            </summary>
            <param name = "resultRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>IMFAsyncCallback::Invoke</strong> method. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Call this method when the <strong>IMFSampleOutputStream::BeginWriteSample</strong> method completes asynchronously.  </p>
            </remarks>
            <doc-id>hh448053</doc-id>
            <unmanaged>HRESULT IMFSampleOutputStream::EndWriteSample([In, Optional] IMFAsyncResult* pResult)</unmanaged>
            <unmanaged-short>IMFSampleOutputStream::EndWriteSample</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SampleOutputStream.Close">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSampleOutputStream::Close()</unmanaged>
            <unmanaged-short>IMFSampleOutputStream::Close</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SampleProtection.InputProtectionVersion">
            <summary>
            <p> </p><p>Retrieves the version of sample protection that the component implements on input.</p>
            </summary>
            <doc-id>bb970365</doc-id>
            <unmanaged>GetInputProtectionVersion</unmanaged>
            <unmanaged-short>GetInputProtectionVersion</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SampleProtection.OutputProtectionVersion">
            <summary>
            <p> </p><p>Retrieves the version of sample protection that the component implements on output.</p>
            </summary>
            <doc-id>bb970415</doc-id>
            <unmanaged>GetOutputProtectionVersion</unmanaged>
            <unmanaged-short>GetOutputProtectionVersion</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SampleProtection.GetInputProtectionVersion(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the version of sample protection that the component implements on input.</p>
            </summary>
            <param name = "dwVersionRef"><dd> <p>Receives a member of the <strong><see cref = "T:SharpDX.MediaFoundation.SampleProtectionVersion"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970365</doc-id>
            <unmanaged>HRESULT IMFSampleProtection::GetInputProtectionVersion([Out] DWORD* pdwVersion)</unmanaged>
            <unmanaged-short>IMFSampleProtection::GetInputProtectionVersion</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SampleProtection.GetOutputProtectionVersion(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the version of sample protection that the component implements on output.</p>
            </summary>
            <param name = "dwVersionRef"><dd> <p>Receives a member of the <strong><see cref = "T:SharpDX.MediaFoundation.SampleProtectionVersion"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970415</doc-id>
            <unmanaged>HRESULT IMFSampleProtection::GetOutputProtectionVersion([Out] DWORD* pdwVersion)</unmanaged>
            <unmanaged-short>IMFSampleProtection::GetOutputProtectionVersion</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SampleProtection.GetProtectionCertificate(System.Int32,System.Byte[],System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the sample protection certificate.</p>
            </summary>
            <param name = "dwVersion"><dd> <p>Specifies the version number of the sample protection scheme for which to receive a certificate. The version number is specified as a <strong><see cref = "T:SharpDX.MediaFoundation.SampleProtectionVersion"/></strong> enumeration value.</p> </dd></param>
            <param name = "certOut"><dd> <p>Receives a reference to a buffer containing the certificate. The caller must free the memory for the buffer by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>
            <param name = "cbCertRef"><dd> <p>Receives the size of the <em>ppCert</em> buffer, in bytes.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>Not implemented.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>For certain version numbers of sample protection, the downstream component must provide a certificate. Components that do not support these version numbers can return E_NOTIMPL.</p>
            </remarks>
            <doc-id>bb970503</doc-id>
            <unmanaged>HRESULT IMFSampleProtection::GetProtectionCertificate([In] DWORD dwVersion,[Out, Buffer] unsigned char** ppCert,[Out] DWORD* pcbCert)</unmanaged>
            <unmanaged-short>IMFSampleProtection::GetProtectionCertificate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SampleProtection.InitOutputProtection(System.Int32,System.Int32,System.Byte,System.Int32,System.Byte,System.Int32)">
            <summary>
            <p> </p><p>Retrieves initialization information for sample protection from the upstream component.</p>
            </summary>
            <param name = "dwVersion"><dd> <p>Specifies the version number of the sample protection scheme. The version number is specified as a <strong><see cref = "T:SharpDX.MediaFoundation.SampleProtectionVersion"/></strong> enumeration value.</p> </dd></param>
            <param name = "dwOutputId"><dd> <p>Identifier of the output stream. The identifier corresponds to the output stream identifier returned by the <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> interface.</p> </dd></param>
            <param name = "bCertRef"><dd> <p>Pointer to a certificate provided by the downstream component.</p> </dd></param>
            <param name = "cbCert"><dd> <p>Size of the certificate, in bytes.</p> </dd></param>
            <param name = "bSeedOut"><dd> <p>Receives a reference to a buffer that contains the initialization information for downstream component. The caller must free the memory for the buffer by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>
            <param name = "cbSeedRef"><dd> <p>Receives the size of the <em>ppbSeed</em> buffer, in bytes.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>Not implemented.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method must be implemented by the upstream component. The method fails if the component does not support the requested sample protection version. Downstream components do not implement this method and should return E_NOTIMPL.</p>
            </remarks>
            <doc-id>ms693577</doc-id>
            <unmanaged>HRESULT IMFSampleProtection::InitOutputProtection([In] DWORD dwVersion,[In] DWORD dwOutputId,[In] unsigned char* pbCert,[In] DWORD cbCert,[In] unsigned char** ppbSeed,[In] DWORD* pcbSeed)</unmanaged>
            <unmanaged-short>IMFSampleProtection::InitOutputProtection</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SampleProtection.InitInputProtection(System.Int32,System.Int32,System.Byte,System.Int32)">
            <summary>
            <p> </p><p>Initializes sample protection on the downstream component.</p>
            </summary>
            <param name = "dwVersion"><dd> <p>Specifies the version number of the sample protection scheme. The version number is specified as a <strong><see cref = "T:SharpDX.MediaFoundation.SampleProtectionVersion"/></strong> enumeration value.</p> </dd></param>
            <param name = "dwInputId"><dd> <p>Identifier of the input stream. The identifier corresponds to the output stream identifier returned by the <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> interface.</p> </dd></param>
            <param name = "bSeedRef"><dd> <p>Pointer to a buffer that contains the initialization data provided by the upstream component. To retrieve this buffer, call <strong>IMFSampleProtection::InitOutputProtection</strong>.</p> </dd></param>
            <param name = "cbSeed"><dd> <p>Size of the <em>pbSeed</em> buffer, in bytes.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms696181</doc-id>
            <unmanaged>HRESULT IMFSampleProtection::InitInputProtection([In] DWORD dwVersion,[In] DWORD dwInputId,[In] unsigned char* pbSeed,[In] DWORD cbSeed)</unmanaged>
            <unmanaged-short>IMFSampleProtection::InitInputProtection</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SaveJob.Progress">
            <summary>
            <p> </p><p>Retrieves the percentage of content saved to the provided byte stream.</p>
            </summary>
            <doc-id>ms700176</doc-id>
            <unmanaged>GetProgress</unmanaged>
            <unmanaged-short>GetProgress</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SaveJob.BeginSave(SharpDX.MediaFoundation.IByteStream,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Begins saving a Windows Media file to the application's byte stream.</p>
            </summary>
            <param name = "streamRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface of the application's byte stream. The data from the source byte stream is written to this byte stream.</p> </dd></param>
            <param name = "callbackRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface</p> </dd></param>
            <param name = "stateRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>When the operation completes, the callback object's <strong>IMFAsyncCallback::Invoke</strong> method is called. At that point, the application should call <strong>IMFSaveJob::EndSave</strong> to complete the asynchronous request.</p>
            </remarks>
            <doc-id>ms705664</doc-id>
            <unmanaged>HRESULT IMFSaveJob::BeginSave([In] IMFByteStream* pStream,[In] IMFAsyncCallback* pCallback,[In] IUnknown* pState)</unmanaged>
            <unmanaged-short>IMFSaveJob::BeginSave</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SaveJob.EndSave(SharpDX.MediaFoundation.AsyncResult)">
            <summary>
            <p> </p><p>Completes the operation started by <strong>IMFSaveJob::BeginSave</strong>.</p>
            </summary>
            <param name = "resultRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms701610</doc-id>
            <unmanaged>HRESULT IMFSaveJob::EndSave([In] IMFAsyncResult* pResult)</unmanaged>
            <unmanaged-short>IMFSaveJob::EndSave</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SaveJob.CancelSave">
            <summary>
            <p> </p><p>Cancels the operation started by <strong>IMFSaveJob::BeginSave</strong>.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms703196</doc-id>
            <unmanaged>HRESULT IMFSaveJob::CancelSave()</unmanaged>
            <unmanaged-short>IMFSaveJob::CancelSave</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SaveJob.GetProgress(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the percentage of content saved to the provided byte stream.</p>
            </summary>
            <param name = "dwPercentCompleteRef"><dd> <p>Receives the percentage of completion.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms700176</doc-id>
            <unmanaged>HRESULT IMFSaveJob::GetProgress([Out] DWORD* pdwPercentComplete)</unmanaged>
            <unmanaged-short>IMFSaveJob::GetProgress</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SchemeHandler.BeginCreateObject(System.String,System.Int32,SharpDX.ComObject,SharpDX.IUnknown@,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Begins an asynchronous request to create an object from a URL.</p><p>When the Source Resolver creates a media source from a URL, it passes the request to a scheme handler. The scheme handler might create a media source directly from the URL, or it might return a byte stream. If it returns a byte stream, the source resolver use a byte-stream handler to create the media source from the byte stream.</p>
            </summary>
            <param name = "wszURLRef">No documentation.</param>
            <param name = "dwFlags">No documentation.</param>
            <param name = "propsRef">No documentation.</param>
            <param name = "iUnknownCancelCookieOut">No documentation.</param>
            <param name = "callbackRef">No documentation.</param>
            <param name = "unkStateRef">No documentation.</param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_ACCESSDENIED</strong></dt> </dl> </td><td> <p> Cannot open the URL with the requested access (read or write). </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedByteStreamType"/></strong></dt> </dl> </td><td> <p> Unsupported byte stream type. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The <em>dwFlags</em> parameter must contain the <strong>MF_RESOLUTION_MEDIASOURCE</strong> flag or the <strong>MF_RESOLUTION_BYTESTREAM</strong> flag. If the <strong>MF_RESOLUTION_MEDIASOURCE</strong> flag is set, the scheme handler might create the media source directly from the URL, or it might create a byte stream. The type of object is returned in the <em>pObjectType</em> parameter of the <strong>IMFSchemeHandler::EndCreateObject</strong> method. If the scheme handler returns a byte stream, the source resolver will pass the byte stream to a byte-stream handler, which will create the media source from the byte stream.</p><p>If the <strong>MF_RESOLUTION_BYTESTREAM</strong> flag is set, the scheme handler will attempt to create a byte stream from the URL. However, if the scheme handler is designed to create a media source directly, rather than a byte stream, the method will fail.</p><p>The following table summarizes the behavior of these two flags when passed to this method:</p><table> <tr><th>Flag</th><th>Object created</th></tr> <tr><td><strong>MF_RESOLUTION_MEDIASOURCE</strong></td><td>Media source or byte stream</td></tr> <tr><td><strong>MF_RESOLUTION_BYTESTREAM</strong></td><td>Byte stream</td></tr> </table><p>?</p><p>The <strong>MF_RESOLUTION_MEDIASOURCE</strong> and <strong>MF_RESOLUTION_BYTESTREAM</strong> flags can be combined, although in this case it is redundant.</p><p>When the operation completes, the scheme handler calls the <strong>IMFAsyncCallback::Invoke</strong> method. The Invoke method should call <strong>IMFSchemeHandler::EndCreateObject</strong> to get a reference to the created object.</p>
            </remarks>
            <doc-id>bb970433</doc-id>
            <unmanaged>HRESULT IMFSchemeHandler::BeginCreateObject([In] const wchar_t* pwszURL,[In] DWORD dwFlags,[In] IPropertyStore* pProps,[Out, Optional] IUnknown** ppIUnknownCancelCookie,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>
            <unmanaged-short>IMFSchemeHandler::BeginCreateObject</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SchemeHandler.EndCreateObject(SharpDX.MediaFoundation.AsyncResult,SharpDX.MediaFoundation.ObjectType@,SharpDX.IUnknown@)">
            <summary>
            <p> </p><p>Completes an asynchronous request to create an object from a URL.</p>
            </summary>
            <param name = "resultRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the Invoke method.</p> </dd></param>
            <param name = "objectTypeRef"><dd> <p>Receives a member of the <strong><see cref = "T:SharpDX.MediaFoundation.ObjectType"/></strong> enumeration, specifying the type of object that was created.</p> </dd></param>
            <param name = "objectOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of the object. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_ABORT</strong></dt> </dl> </td><td> <p>The operation was canceled.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this method from inside the <strong>IMFAsyncCallback::Invoke</strong> method.</p>
            </remarks>
            <doc-id>bb970550</doc-id>
            <unmanaged>HRESULT IMFSchemeHandler::EndCreateObject([In] IMFAsyncResult* pResult,[Out] MF_OBJECT_TYPE* pObjectType,[Out] IUnknown** ppObject)</unmanaged>
            <unmanaged-short>IMFSchemeHandler::EndCreateObject</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SchemeHandler.CancelObjectCreation(SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Cancels the current request to create an object from a URL.</p>
            </summary>
            <param name = "iUnknownCancelCookieRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface that was returned in the <em>ppIUnknownCancelCookie</em> parameter of the <strong>IMFSchemeHandler::BeginCreateObject</strong> method.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>You can use this method to cancel a previous call to <strong>BeginCreateObject</strong>. Because that method is asynchronous, however, it might be completed before the operation can be canceled. Therefore, your callback might still be invoked after you call this method.</p><p>The operation cannot be canceled if <strong>BeginCreateObject</strong> returns <strong><c>null</c></strong> in the <em>ppIUnknownCancelCookie</em> parameter.</p>
            </remarks>
            <doc-id>bb970419</doc-id>
            <unmanaged>HRESULT IMFSchemeHandler::CancelObjectCreation([In] IUnknown* pIUnknownCancelCookie)</unmanaged>
            <unmanaged-short>IMFSchemeHandler::CancelObjectCreation</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SecureChannel.GetCertificate(System.Byte[],System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the client's certificate.</p>
            </summary>
            <param name = "certOut"><dd> <p>Receives a reference to a buffer allocated by the object. The buffer contains the client's certificate. The caller must release the buffer by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>
            <param name = "cbCertRef"><dd> <p>Receives the size of the <em>ppCert</em> buffer, in bytes.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970528</doc-id>
            <unmanaged>HRESULT IMFSecureChannel::GetCertificate([Out, Buffer] unsigned char** ppCert,[Out] DWORD* pcbCert)</unmanaged>
            <unmanaged-short>IMFSecureChannel::GetCertificate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SecureChannel.SetupSession(System.Byte[],System.Int32)">
            <summary>
            <p> </p><p>Passes the encrypted session key to the client.</p>
            </summary>
            <param name = "bEncryptedSessionKeyRef"><dd> <p>Pointer to a buffer that contains the encrypted session key. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "cbSessionKey"><dd> <p>Size of the <em>pbEncryptedSessionKey</em> buffer, in bytes.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970477</doc-id>
            <unmanaged>HRESULT IMFSecureChannel::SetupSession([In, Buffer] unsigned char* pbEncryptedSessionKey,[In] DWORD cbSessionKey)</unmanaged>
            <unmanaged-short>IMFSecureChannel::SetupSession</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SeekInfo.GetNearestKeyFrames(System.Guid,SharpDX.Win32.Variant,SharpDX.Win32.Variant@,SharpDX.Win32.Variant@)">
            <summary>
            <p>For a particular seek position, gets the two nearest key frames.</p>
            </summary>
            <param name = "guidTimeFormatRef"><dd> <p>A reference to a <see cref = "T:System.Guid"/> that specifies the time format. The time format defines the units for the other parameters of this method. If the value is <strong>GUID_NULL</strong>, the time format is 100-nanosecond units. Some media sources might support additional time format GUIDs. </p> </dd></param>
            <param name = "varStartPositionRef"><dd> <p>The seek position. The units for this parameter are specified by <em>pguidTimeFormat</em>.</p> </dd></param>
            <param name = "varPreviousKeyFrameRef"><dd> <p>Receives the position of the nearest key frame that appears earlier than <em>pvarStartPosition</em>. The units for this parameter are specified by <em>pguidTimeFormat</em>.</p> </dd></param>
            <param name = "varNextKeyFrameRef"><dd> <p>Receives the position of the nearest key frame that appears earlier than <em>pvarStartPosition</em>. The units for this parameter are specified by <em>pguidTimeFormat</em>.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedTimeFormat"/></strong></dt> </dl> </td><td> <p>The time format specified in <em>pguidTimeFormat</em> is not supported.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If an application seeks to a non?key frame, the decoder must start decoding from the previous key frame. This can increase latency, because several frames might get decoded before the requested frame is reached. To reduce latency, an application can call this method to find the two key frames that are closest to the desired time, and then seek to one of those key frames. </p>
            </remarks>
            <doc-id>hh448055</doc-id>
            <unmanaged>HRESULT IMFSeekInfo::GetNearestKeyFrames([In] const GUID* pguidTimeFormat,[In] const PROPVARIANT* pvarStartPosition,[Out] PROPVARIANT* pvarPreviousKeyFrame,[Out] PROPVARIANT* pvarNextKeyFrame)</unmanaged>
            <unmanaged-short>IMFSeekInfo::GetNearestKeyFrames</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SensorActivitiesReport.Count">
            <summary>
            <p>Gets the count of <strong><see cref = "T:SharpDX.MediaFoundation.SensorActivityReport"/></strong> objects that are available to be retrieved.</p>
            </summary>
            <doc-id>mt493227</doc-id>
            <unmanaged>GetCount</unmanaged>
            <unmanaged-short>GetCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorActivitiesReport.GetCount(System.Int32@)">
            <summary>
            <p>Gets the count of <strong><see cref = "T:SharpDX.MediaFoundation.SensorActivityReport"/></strong> objects that are available to be retrieved.</p>
            </summary>
            <param name = "cCountRef">No documentation.</param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>The <em>pcCount</em> parameter is null.</p> </td></tr> </table><p> </p></returns>
            <doc-id>mt493227</doc-id>
            <unmanaged>HRESULT IMFSensorActivitiesReport::GetCount([Out] ULONG* pcCount)</unmanaged>
            <unmanaged-short>IMFSensorActivitiesReport::GetCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorActivitiesReport.GetActivityReport(System.Int32,SharpDX.MediaFoundation.SensorActivityReport@)">
            <summary>
            <p>Retrieves an <strong><see cref = "T:SharpDX.MediaFoundation.SensorActivityReport"/></strong> based on the specified index.</p>
            </summary>
            <param name = "index">No documentation.</param>
            <param name = "sensorActivityReport">No documentation.</param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>The <em>sensorActivityReport</em> parameter is null.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidIndex"/></strong></dt> </dl> </td><td> <p>The <em>Index</em> parameter is not less than value returned by <strong>GetCount</strong>. </p> </td></tr> </table><p> </p></returns>
            <doc-id>mt493225</doc-id>
            <unmanaged>HRESULT IMFSensorActivitiesReport::GetActivityReport([In] ULONG Index,[Out] IMFSensorActivityReport** sensorActivityReport)</unmanaged>
            <unmanaged-short>IMFSensorActivitiesReport::GetActivityReport</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorActivitiesReport.GetActivityReportByDeviceName(System.String,SharpDX.MediaFoundation.SensorActivityReport@)">
            <summary>
            <p>Retrieves an <strong><see cref = "T:SharpDX.MediaFoundation.SensorActivityReport"/></strong> based on the specified device name.</p>
            </summary>
            <param name = "symbolicName">No documentation.</param>
            <param name = "sensorActivityReport">No documentation.</param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The <em>symbolicName</em> parameter is null.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>The <em>sensorActivityReport</em> parameter is null.</p> </td></tr> <tr><td> <dl> <dt><strong>E_OUTOFMEMORY</strong></dt> </dl> </td><td> <p>The system is out of memory.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidIndex"/></strong></dt> </dl> </td><td> <p>The <em>Index</em> parameter is not less than value returned by <strong>GetCount</strong>. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotFound"/></strong></dt> </dl> </td><td> <p>No sensor with the specified symbolic name was found.</p> </td></tr> </table><p> </p></returns>
            <doc-id>mt493226</doc-id>
            <unmanaged>HRESULT IMFSensorActivitiesReport::GetActivityReportByDeviceName([In] const wchar_t* SymbolicName,[Out] IMFSensorActivityReport** sensorActivityReport)</unmanaged>
            <unmanaged-short>IMFSensorActivitiesReport::GetActivityReportByDeviceName</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorActivitiesReportCallback.OnActivitiesReport(SharpDX.MediaFoundation.SensorActivitiesReport)">
            <summary>
            <p>Raised by the media pipeline when a new <strong><see cref = "T:SharpDX.MediaFoundation.SensorActivitiesReport"/></strong> is available.</p>
            </summary>
            <param name = "sensorActivitiesReport">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>mt493219</doc-id>
            <unmanaged>HRESULT IMFSensorActivitiesReportCallback::OnActivitiesReport([In] IMFSensorActivitiesReport* sensorActivitiesReport)</unmanaged>
            <unmanaged-short>IMFSensorActivitiesReportCallback::OnActivitiesReport</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorActivityMonitor.Start">
            <summary>
            <p>Starts the sensor activity monitor.</p>
            </summary>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The sensor activity monitor has already been started.</p> </td></tr> </table><p> </p></returns>
            <doc-id>mt493221</doc-id>
            <unmanaged>HRESULT IMFSensorActivityMonitor::Start()</unmanaged>
            <unmanaged-short>IMFSensorActivityMonitor::Start</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorActivityMonitor.Stop">
            <summary>
            <p>Stops the sensor activity monitor.</p>
            </summary>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> </table><p> </p></returns>
            <doc-id>mt493223</doc-id>
            <unmanaged>HRESULT IMFSensorActivityMonitor::Stop()</unmanaged>
            <unmanaged-short>IMFSensorActivityMonitor::Stop</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SensorActivityReport.ProcessCount">
            <summary>
            <p>Gets the count of <strong><see cref = "T:SharpDX.MediaFoundation.SensorProcessActivity"/></strong> objects, representing the current activity of a process associated with the sensor, that are available to be retrieved.</p>
            </summary>
            <doc-id>mt493230</doc-id>
            <unmanaged>GetProcessCount</unmanaged>
            <unmanaged-short>GetProcessCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorActivityReport.GetFriendlyName(System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            <p>Gets the friendly name for the sensor associated with the report.</p>
            </summary>
            <param name = "friendlyName"><dd> <p>The string into which the sensor friendly name is written.</p> </dd></param>
            <param name = "cchFriendlyName"><dd> <p>The character count of the <em>FriendlyName</em> string.</p> </dd></param>
            <param name = "cchWrittenRef"><dd> <p>Receives the number of characters that were written into the <em>FriendlyName</em> string.</p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>The <em>pcchWritten</em> parameter is null.</p> </td></tr> </table><p> </p></returns>
            <doc-id>mt493228</doc-id>
            <unmanaged>HRESULT IMFSensorActivityReport::GetFriendlyName([Out, Buffer] wchar_t* FriendlyName,[In] ULONG cchFriendlyName,[Out] ULONG* pcchWritten)</unmanaged>
            <unmanaged-short>IMFSensorActivityReport::GetFriendlyName</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorActivityReport.GetSymbolicLink(System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            <p>Gets the symbolic link for the sensor associated with the report.</p>
            </summary>
            <param name = "symbolicLink"><dd> <p>The string into which the sensor symbolic link is written.</p> </dd></param>
            <param name = "cchSymbolicLink"><dd> <p>The character count of the <em>SymbolicLink</em> string.</p> </dd></param>
            <param name = "cchWrittenRef"><dd> <p>Receives the number of characters that were written into the <em>SymbolicLink</em> string.</p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>The <em>pcchWritten</em> parameter is null.</p> </td></tr> </table><p> </p></returns>
            <doc-id>mt493231</doc-id>
            <unmanaged>HRESULT IMFSensorActivityReport::GetSymbolicLink([Out, Buffer] wchar_t* SymbolicLink,[In] ULONG cchSymbolicLink,[Out] ULONG* pcchWritten)</unmanaged>
            <unmanaged-short>IMFSensorActivityReport::GetSymbolicLink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorActivityReport.GetProcessCount(System.Int32@)">
            <summary>
            <p>Gets the count of <strong><see cref = "T:SharpDX.MediaFoundation.SensorProcessActivity"/></strong> objects, representing the current activity of a process associated with the sensor, that are available to be retrieved.</p>
            </summary>
            <param name = "cCountRef">No documentation.</param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>The <em>pulCount</em> parameter is null.</p> </td></tr> </table><p> </p></returns>
            <doc-id>mt493230</doc-id>
            <unmanaged>HRESULT IMFSensorActivityReport::GetProcessCount([Out] ULONG* pcCount)</unmanaged>
            <unmanaged-short>IMFSensorActivityReport::GetProcessCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorActivityReport.GetProcessActivity(System.Int32,SharpDX.MediaFoundation.SensorProcessActivity@)">
            <summary>
            <p>Gets an <strong><see cref = "T:SharpDX.MediaFoundation.SensorProcessActivity"/></strong> object representing the current process activity of a sensor.</p>
            </summary>
            <param name = "index">No documentation.</param>
            <param name = "processActivityOut">No documentation.</param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>The <em>ppProcessActivity</em> parameter is null.</p> </td></tr> </table><p> </p></returns>
            <doc-id>mt493229</doc-id>
            <unmanaged>HRESULT IMFSensorActivityReport::GetProcessActivity([In] ULONG Index,[Out] IMFSensorProcessActivity** ppProcessActivity)</unmanaged>
            <unmanaged-short>IMFSensorActivityReport::GetProcessActivity</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SensorDevice.DeviceId">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetDeviceId</unmanaged>
            <unmanaged-short>GetDeviceId</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SensorDevice.DeviceType">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetDeviceType</unmanaged>
            <unmanaged-short>GetDeviceType</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SensorDevice.Flags">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetFlags</unmanaged>
            <unmanaged-short>GetFlags</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SensorDevice.DeviceAttributes">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetDeviceAttributes</unmanaged>
            <unmanaged-short>GetDeviceAttributes</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SensorDevice.SensorDeviceMode">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetSensorDeviceMode / SetSensorDeviceMode</unmanaged>
            <unmanaged-short>GetSensorDeviceMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorDevice.GetDeviceId(System.Int64@)">
            <summary>
            No documentation.
            </summary>
            <param name = "deviceIdRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorDevice::GetDeviceId([Out] unsigned longlong* pDeviceId)</unmanaged>
            <unmanaged-short>IMFSensorDevice::GetDeviceId</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorDevice.GetDeviceType(SharpDX.MediaFoundation.SensorDeviceType@)">
            <summary>
            No documentation.
            </summary>
            <param name = "typeRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorDevice::GetDeviceType([Out] MFSensorDeviceType* pType)</unmanaged>
            <unmanaged-short>IMFSensorDevice::GetDeviceType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorDevice.GetFlags(System.Int64@)">
            <summary>
            No documentation.
            </summary>
            <param name = "flagsRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorDevice::GetFlags([Out] unsigned longlong* pFlags)</unmanaged>
            <unmanaged-short>IMFSensorDevice::GetFlags</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorDevice.GetSymbolicLink(System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "symbolicLink">No documentation.</param>
            <param name = "cchSymbolicLink">No documentation.</param>
            <param name = "cchWrittenRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorDevice::GetSymbolicLink([Out, Buffer] wchar_t* SymbolicLink,[In] LONG cchSymbolicLink,[Out] LONG* pcchWritten)</unmanaged>
            <unmanaged-short>IMFSensorDevice::GetSymbolicLink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorDevice.GetDeviceAttributes(SharpDX.MediaFoundation.MediaAttributes@)">
            <summary>
            No documentation.
            </summary>
            <param name = "attributesOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorDevice::GetDeviceAttributes([Out, Optional] IMFAttributes** ppAttributes)</unmanaged>
            <unmanaged-short>IMFSensorDevice::GetDeviceAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorDevice.GetStreamAttributesCount(SharpDX.MediaFoundation.SensorStreamType,System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "eType">No documentation.</param>
            <param name = "dwCountRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorDevice::GetStreamAttributesCount([In] MFSensorStreamType eType,[Out] DWORD* pdwCount)</unmanaged>
            <unmanaged-short>IMFSensorDevice::GetStreamAttributesCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorDevice.GetStreamAttributes(SharpDX.MediaFoundation.SensorStreamType,System.Int32,SharpDX.MediaFoundation.MediaAttributes@)">
            <summary>
            No documentation.
            </summary>
            <param name = "eType">No documentation.</param>
            <param name = "dwIndex">No documentation.</param>
            <param name = "attributesOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorDevice::GetStreamAttributes([In] MFSensorStreamType eType,[In] DWORD dwIndex,[Out] IMFAttributes** ppAttributes)</unmanaged>
            <unmanaged-short>IMFSensorDevice::GetStreamAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorDevice.SetSensorDeviceMode(SharpDX.MediaFoundation.SensorDeviceMode)">
            <summary>
            No documentation.
            </summary>
            <param name = "eMode">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorDevice::SetSensorDeviceMode([In] MFSensorDeviceMode eMode)</unmanaged>
            <unmanaged-short>IMFSensorDevice::SetSensorDeviceMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorDevice.GetSensorDeviceMode(SharpDX.MediaFoundation.SensorDeviceMode@)">
            <summary>
            No documentation.
            </summary>
            <param name = "eModeRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorDevice::GetSensorDeviceMode([Out] MFSensorDeviceMode* peMode)</unmanaged>
            <unmanaged-short>IMFSensorDevice::GetSensorDeviceMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SensorGroup.Flags">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetFlags</unmanaged>
            <unmanaged-short>GetFlags</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SensorGroup.SensorGroupAttributes">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetSensorGroupAttributes</unmanaged>
            <unmanaged-short>GetSensorGroupAttributes</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SensorGroup.SensorDeviceCount">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetSensorDeviceCount</unmanaged>
            <unmanaged-short>GetSensorDeviceCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SensorGroup.DefaultSensorDeviceIndex">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetDefaultSensorDeviceIndex / SetDefaultSensorDeviceIndex</unmanaged>
            <unmanaged-short>GetDefaultSensorDeviceIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorGroup.GetSymbolicLink(System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "symbolicLink">No documentation.</param>
            <param name = "cchSymbolicLink">No documentation.</param>
            <param name = "cchWrittenRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorGroup::GetSymbolicLink([Out, Buffer] wchar_t* SymbolicLink,[In] LONG cchSymbolicLink,[Out] LONG* pcchWritten)</unmanaged>
            <unmanaged-short>IMFSensorGroup::GetSymbolicLink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorGroup.GetFlags(System.Int64@)">
            <summary>
            No documentation.
            </summary>
            <param name = "flagsRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorGroup::GetFlags([Out] unsigned longlong* pFlags)</unmanaged>
            <unmanaged-short>IMFSensorGroup::GetFlags</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorGroup.GetSensorGroupAttributes(SharpDX.MediaFoundation.MediaAttributes@)">
            <summary>
            No documentation.
            </summary>
            <param name = "attributesOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorGroup::GetSensorGroupAttributes([Out, Optional] IMFAttributes** ppAttributes)</unmanaged>
            <unmanaged-short>IMFSensorGroup::GetSensorGroupAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorGroup.GetSensorDeviceCount(System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwCountRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorGroup::GetSensorDeviceCount([Out] DWORD* pdwCount)</unmanaged>
            <unmanaged-short>IMFSensorGroup::GetSensorDeviceCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorGroup.GetSensorDevice(System.Int32,SharpDX.MediaFoundation.SensorDevice@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwIndex">No documentation.</param>
            <param name = "deviceOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorGroup::GetSensorDevice([In] DWORD dwIndex,[Out] IMFSensorDevice** ppDevice)</unmanaged>
            <unmanaged-short>IMFSensorGroup::GetSensorDevice</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorGroup.SetDefaultSensorDeviceIndex(System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwIndex">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorGroup::SetDefaultSensorDeviceIndex([In] DWORD dwIndex)</unmanaged>
            <unmanaged-short>IMFSensorGroup::SetDefaultSensorDeviceIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorGroup.GetDefaultSensorDeviceIndex(System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwIndexRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorGroup::GetDefaultSensorDeviceIndex([Out] DWORD* pdwIndex)</unmanaged>
            <unmanaged-short>IMFSensorGroup::GetDefaultSensorDeviceIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorGroup.CreateMediaSource(SharpDX.MediaFoundation.MediaSource@)">
            <summary>
            No documentation.
            </summary>
            <param name = "sourceOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorGroup::CreateMediaSource([Out] IMFMediaSource** ppSource)</unmanaged>
            <unmanaged-short>IMFSensorGroup::CreateMediaSource</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SensorProcessActivity.ProcessId">
            <summary>
            <p>Gets the ID of the process with which the activity is associated.</p>
            </summary>
            <doc-id>mt493233</doc-id>
            <unmanaged>GetProcessId</unmanaged>
            <unmanaged-short>GetProcessId</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SensorProcessActivity.StreamingState">
            <summary>
            <p>Gets a value indicating whether the sensor is currently streaming.</p>
            </summary>
            <doc-id>mt493236</doc-id>
            <unmanaged>GetStreamingState</unmanaged>
            <unmanaged-short>GetStreamingState</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SensorProcessActivity.StreamingMode">
            <summary>
            <p>Gets the streaming mode of the sensor process.</p>
            </summary>
            <doc-id>mt493235</doc-id>
            <unmanaged>GetStreamingMode</unmanaged>
            <unmanaged-short>GetStreamingMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SensorProcessActivity.ReportTime">
            <summary>
            <p>Gets the time associated with the sensor activity report.</p>
            </summary>
            <doc-id>mt493234</doc-id>
            <unmanaged>GetReportTime</unmanaged>
            <unmanaged-short>GetReportTime</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorProcessActivity.GetProcessId(System.Int32@)">
            <summary>
            <p>Gets the ID of the process with which the activity is associated.</p>
            </summary>
            <param name = "pIDRef"><dd> <p>Receives the process ID.</p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>The <em>pPID</em> parameter is null.</p> </td></tr> </table><p> </p></returns>
            <doc-id>mt493233</doc-id>
            <unmanaged>HRESULT IMFSensorProcessActivity::GetProcessId([Out] ULONG* pPID)</unmanaged>
            <unmanaged-short>IMFSensorProcessActivity::GetProcessId</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorProcessActivity.GetStreamingState(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Gets a value indicating whether the sensor is currently streaming.</p>
            </summary>
            <param name = "fStreamingRef"><dd> <p>Receives a value indicating whether the sensor is currently streaming.</p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>The <em>pfStreaming</em> parameter is null.</p> </td></tr> </table><p> </p></returns>
            <doc-id>mt493236</doc-id>
            <unmanaged>HRESULT IMFSensorProcessActivity::GetStreamingState([Out] BOOL* pfStreaming)</unmanaged>
            <unmanaged-short>IMFSensorProcessActivity::GetStreamingState</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorProcessActivity.GetStreamingMode(SharpDX.MediaFoundation.SensorDeviceMode@)">
            <summary>
            <p>Gets the streaming mode of the sensor process.</p>
            </summary>
            <param name = "modeRef"><dd> <p>Receives the process ID.</p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>The <em>pMode</em> parameter is null.</p> </td></tr> </table><p> </p></returns>
            <doc-id>mt493235</doc-id>
            <unmanaged>HRESULT IMFSensorProcessActivity::GetStreamingMode([Out] MFSensorDeviceMode* pMode)</unmanaged>
            <unmanaged-short>IMFSensorProcessActivity::GetStreamingMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorProcessActivity.GetReportTime(System.Int64@)">
            <summary>
            <p>Gets the time associated with the sensor activity report.</p>
            </summary>
            <param name = "ftRef"><dd> <p>Receives the time associated with the sensor activity report.</p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>The <em>pft</em> parameter is null.</p> </td></tr> </table><p> </p></returns>
            <doc-id>mt493234</doc-id>
            <unmanaged>HRESULT IMFSensorProcessActivity::GetReportTime([Out] FILETIME* pft)</unmanaged>
            <unmanaged-short>IMFSensorProcessActivity::GetReportTime</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SensorStream.MediaTypeCount">
            <summary>
            <p></p>
            </summary>
            <doc-id>mt797960</doc-id>
            <unmanaged>GetMediaTypeCount</unmanaged>
            <unmanaged-short>GetMediaTypeCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorStream.GetMediaTypeCount(System.Int32@)">
            <summary>
            <p></p>
            </summary>
            <param name = "dwCountRef">No documentation.</param>
            <returns>No documentation.</returns>
            <doc-id>mt797960</doc-id>
            <unmanaged>HRESULT IMFSensorStream::GetMediaTypeCount([Out] DWORD* pdwCount)</unmanaged>
            <unmanaged-short>IMFSensorStream::GetMediaTypeCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorStream.GetMediaType(System.Int32,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            <p></p>
            </summary>
            <param name = "dwIndex">No documentation.</param>
            <param name = "mediaTypeOut">No documentation.</param>
            <returns>No documentation.</returns>
            <doc-id>mt797960</doc-id>
            <unmanaged>HRESULT IMFSensorStream::GetMediaType([In] DWORD dwIndex,[Out] IMFMediaType** ppMediaType)</unmanaged>
            <unmanaged-short>IMFSensorStream::GetMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorStream.CloneSensorStream(SharpDX.MediaFoundation.SensorStream@)">
            <summary>
            No documentation.
            </summary>
            <param name = "streamOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorStream::CloneSensorStream([Out] IMFSensorStream** ppStream)</unmanaged>
            <unmanaged-short>IMFSensorStream::CloneSensorStream</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SensorTransformFactory.FactoryAttributes">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetFactoryAttributes</unmanaged>
            <unmanaged-short>GetFactoryAttributes</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SensorTransformFactory.TransformCount">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetTransformCount</unmanaged>
            <unmanaged-short>GetTransformCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorTransformFactory.GetFactoryAttributes(SharpDX.MediaFoundation.MediaAttributes@)">
            <summary>
            No documentation.
            </summary>
            <param name = "attributesOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorTransformFactory::GetFactoryAttributes([Out] IMFAttributes** ppAttributes)</unmanaged>
            <unmanaged-short>IMFSensorTransformFactory::GetFactoryAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorTransformFactory.InitializeFactory(System.Int32,SharpDX.MediaFoundation.Collection,SharpDX.MediaFoundation.MediaAttributes)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwMaxTransformCount">No documentation.</param>
            <param name = "sensorDevicesRef">No documentation.</param>
            <param name = "attributesRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorTransformFactory::InitializeFactory([In] DWORD dwMaxTransformCount,[In] IMFCollection* pSensorDevices,[In, Optional] IMFAttributes* pAttributes)</unmanaged>
            <unmanaged-short>IMFSensorTransformFactory::InitializeFactory</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorTransformFactory.GetTransformCount(System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dwCountRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorTransformFactory::GetTransformCount([Out] DWORD* pdwCount)</unmanaged>
            <unmanaged-short>IMFSensorTransformFactory::GetTransformCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorTransformFactory.GetTransformInformation(System.Int32,System.Guid@,SharpDX.MediaFoundation.MediaAttributes@,SharpDX.MediaFoundation.Collection@)">
            <summary>
            <p>Called by the media pipeline to get information about a transform provided by the  sensor transform.</p>
            </summary>
            <param name = "transformIndex"><dd> <p>The index of the transform for which information is being requested. In the current release, this value will always be 0.</p> </dd></param>
            <param name = "guidTransformIdRef"><dd> <p>Gets the identifier for the transform.</p> </dd></param>
            <param name = "attributesOut"><dd> <p>The attribute store to be populated.</p> </dd></param>
            <param name = "streamInformationOut"><dd> <p>A collection of <strong><see cref = "T:SharpDX.MediaFoundation.SensorStream"/></strong> objects.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>mt797967</doc-id>
            <unmanaged>HRESULT IMFSensorTransformFactory::GetTransformInformation([In] DWORD TransformIndex,[Out] GUID* pguidTransformId,[Out, Optional] IMFAttributes** ppAttributes,[Out] IMFCollection** ppStreamInformation)</unmanaged>
            <unmanaged-short>IMFSensorTransformFactory::GetTransformInformation</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SensorTransformFactory.CreateTransform(System.Guid,SharpDX.MediaFoundation.MediaAttributes,SharpDX.MediaFoundation.DeviceTransform@)">
            <summary>
            No documentation.
            </summary>
            <param name = "guidSensorTransformID">No documentation.</param>
            <param name = "attributesRef">No documentation.</param>
            <param name = "deviceMFTOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSensorTransformFactory::CreateTransform([In] const GUID&amp; guidSensorTransformID,[In, Optional] IMFAttributes* pAttributes,[Out] IMFDeviceTransform** ppDeviceMFT)</unmanaged>
            <unmanaged-short>IMFSensorTransformFactory::CreateTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SequencerSource.AppendTopology(SharpDX.MediaFoundation.Topology,System.Int32,System.Int32@)">
            <summary>
            <p> </p><p>Adds a topology to the end of the queue.</p>
            </summary>
            <param name = "topologyRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.Topology"/></strong> interface of the topology. This reference cannot be <strong><c>null</c></strong>. If an application passes <strong><c>null</c></strong>, the call fails with an E_INVALIDARG error code.</p> </dd></param>
            <param name = "dwFlags"><dd> <p>A combination of flags from the <strong><see cref = "T:SharpDX.MediaFoundation.SequencerTopologyFlags"/></strong> enumeration.</p> </dd></param>
            <param name = "dwIdRef"><dd> <p>Receives the sequencer element identifier for this topology.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Attributenotfound"/></strong></dt> </dl> </td><td> <p>The source topology node is missing one of the following attributes:</p> <ul> <li> <p> <strong><see cref = "T:SharpDX.MediaFoundation.StreamDescriptor"/></strong> </p> </li> <li> <p> <strong><see cref = "T:SharpDX.MediaFoundation.PresentationDescriptor"/></strong> </p> </li> <li> <p> <strong><see cref = "!:Source"/></strong> </p> </li> </ul> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The sequencer plays topologies in the order they are queued. You can queue as many topologies as you want to preroll.</p><p>The application must indicate to the sequencer when it has queued the last topology on the Media Session. To specify the last topology, set the SequencerTopologyFlags_Last flag in the <em>dwFlags</em> parameter when you append the topology. The sequencer uses this information to end playback with the pipeline. Otherwise, the sequencer waits indefinitely for a new topology to be queued.</p>
            </remarks>
            <doc-id>ms697046</doc-id>
            <unmanaged>HRESULT IMFSequencerSource::AppendTopology([In] IMFTopology* pTopology,[In] DWORD dwFlags,[Out] DWORD* pdwId)</unmanaged>
            <unmanaged-short>IMFSequencerSource::AppendTopology</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SequencerSource.DeleteTopology(System.Int32)">
            <summary>
            <p> </p><p>Deletes a topology from the queue.</p>
            </summary>
            <param name = "dwId"><dd> <p>The sequencer element identifier of the topology to delete.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970428</doc-id>
            <unmanaged>HRESULT IMFSequencerSource::DeleteTopology([In] DWORD dwId)</unmanaged>
            <unmanaged-short>IMFSequencerSource::DeleteTopology</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SequencerSource.GetPresentationContext(SharpDX.MediaFoundation.PresentationDescriptor,System.Int32@,SharpDX.MediaFoundation.Topology@)">
            <summary>
            <p> </p><p>Maps a presentation descriptor to its associated sequencer element identifier and the topology it represents.</p>
            </summary>
            <param name = "pDRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.PresentationDescriptor"/></strong> interface of the presentation descriptor.</p> </dd></param>
            <param name = "idRef"><dd> <p>Receives the sequencer element identifier. This value is assigned by the sequencer source when the application calls <strong>IMFSequencerSource::AppendTopology</strong>. This parameter is optional and can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "topologyOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Topology"/></strong> interface of the original topology that the application added to the sequencer source. The caller must release the interface. This parameter can receive the value <strong><c>null</c></strong> if the sequencer source has switched to the next presentation. This parameter is optional and can be <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The presentation descriptor is not valid.</p> </td></tr> <tr><td> <dl> <dt><strong>MF_S_SEQUENCER_CONTEXT_CANCELED</strong></dt> </dl> </td><td> <p>This segment was canceled.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The topology returned in <em>ppTopology</em> is the original topology that the application specified in <strong>AppendTopology</strong>. The source nodes in this topology contain references to the native sources. Do not queue this topology on the Media Session. Instead, call <strong>IMFMediaSourceTopologyProvider::GetMediaSourceTopology</strong> to get the sequencer source's modified topology. The source nodes in the modified topology contain references to the sequencer source, rather than the native sources.</p>
            </remarks>
            <doc-id>bb970514</doc-id>
            <unmanaged>HRESULT IMFSequencerSource::GetPresentationContext([In] IMFPresentationDescriptor* pPD,[Out, Optional] DWORD* pId,[Out, Optional] IMFTopology** ppTopology)</unmanaged>
            <unmanaged-short>IMFSequencerSource::GetPresentationContext</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SequencerSource.UpdateTopology(System.Int32,SharpDX.MediaFoundation.Topology)">
            <summary>
            <p> </p><p>Updates a topology in the queue.</p>
            </summary>
            <param name = "dwId"><dd> <p>Sequencer element identifier of the topology to update.</p> </dd></param>
            <param name = "topologyRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.Topology"/></strong> interface of the updated topology object.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The sequencer source has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is asynchronous. When the operation is completed, the sequencer source sends an MESequencerSourceTopologyUpdated event.</p>
            </remarks>
            <doc-id>bb970402</doc-id>
            <unmanaged>HRESULT IMFSequencerSource::UpdateTopology([In] DWORD dwId,[In] IMFTopology* pTopology)</unmanaged>
            <unmanaged-short>IMFSequencerSource::UpdateTopology</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SequencerSource.UpdateTopologyFlags(System.Int32,System.Int32)">
            <summary>
            <p> </p><p>Updates the flags for a topology in the queue.</p>
            </summary>
            <param name = "dwId"><dd> <p>Sequencer element identifier of the topology to update.</p> </dd></param>
            <param name = "dwFlags"><dd> <p>Bitwise <strong>OR</strong> of flags from the <strong><see cref = "T:SharpDX.MediaFoundation.SequencerTopologyFlags"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970564</doc-id>
            <unmanaged>HRESULT IMFSequencerSource::UpdateTopologyFlags([In] DWORD dwId,[In] DWORD dwFlags)</unmanaged>
            <unmanaged-short>IMFSequencerSource::UpdateTopologyFlags</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.Shutdownable.ShutdownStatus">
            <summary>
            <p> Queries the status of an earlier call to the <strong>IMFShutdown::Shutdown</strong> method. </p>
            </summary>
            <remarks>
            <p>Until <strong>Shutdown</strong> is called, the <strong>GetShutdownStatus</strong> method returns <strong><see cref = "!:InvalidRequest"/></strong>.</p><p>If an object's <strong>Shutdown</strong> method is asynchronous, <em>pStatus</em> might receive the value <strong>MFSHUTDOWN_INITIATED</strong>. When the object is completely shut down, <em>pStatus</em> receives the value <strong>MFSHUTDOWN_COMPLETED</strong>.</p>
            </remarks>
            <doc-id>bb970451</doc-id>
            <unmanaged>GetShutdownStatus</unmanaged>
            <unmanaged-short>GetShutdownStatus</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Shutdownable.Shutdown">
            <summary>
            <p> Shuts down a Media Foundation object and releases all resources associated with the object. </p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The <strong>MFShutdownObject</strong> helper function is equivalent to calling this method.</p>
            </remarks>
            <doc-id>ms701615</doc-id>
            <unmanaged>HRESULT IMFShutdown::Shutdown()</unmanaged>
            <unmanaged-short>IMFShutdown::Shutdown</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Shutdownable.GetShutdownStatus(SharpDX.MediaFoundation.ShutdownStatus@)">
            <summary>
            <p> Queries the status of an earlier call to the <strong>IMFShutdown::Shutdown</strong> method. </p>
            </summary>
            <param name = "statusRef">No documentation.</param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p> The <strong>Shutdown</strong> method has not been called on this object. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Until <strong>Shutdown</strong> is called, the <strong>GetShutdownStatus</strong> method returns <strong><see cref = "!:InvalidRequest"/></strong>.</p><p>If an object's <strong>Shutdown</strong> method is asynchronous, <em>pStatus</em> might receive the value <strong>MFSHUTDOWN_INITIATED</strong>. When the object is completely shut down, <em>pStatus</em> receives the value <strong>MFSHUTDOWN_COMPLETED</strong>.</p>
            </remarks>
            <doc-id>bb970451</doc-id>
            <unmanaged>HRESULT IMFShutdown::GetShutdownStatus([Out] MFSHUTDOWN_STATUS* pStatus)</unmanaged>
            <unmanaged-short>IMFShutdown::GetShutdownStatus</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SignedLibrary.GetProcedureAddress(System.String,System.IntPtr@)">
            <summary>
            <p>Gets the procedure address of the specified function in the signed library.</p>
            </summary>
            <param name = "name"><dd> <p>The entry point name in the DLL that specifies the function.</p> </dd></param>
            <param name = "address"><dd> <p>Receives the address of the entry point.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>See  <strong>MFLoadSignedLibrary</strong> for an example of how to create an <strong><see cref = "T:SharpDX.MediaFoundation.SignedLibrary"/></strong> object and call the <strong>GetProcedureAddress</strong> method.</p>
            </remarks>
            <doc-id>hh448059</doc-id>
            <unmanaged>HRESULT IMFSignedLibrary::GetProcedureAddress([In] const char* name,[Out] void** address)</unmanaged>
            <unmanaged-short>IMFSignedLibrary::GetProcedureAddress</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SimpleAudioVolume.MasterVolume">
            <summary>
            <p> </p><p>Retrieves the master volume level.</p>
            </summary>
            <remarks>
            <p>If an external event changes the master volume, the audio renderer sends an MEAudioSessionVolumeChanged event, which the Media Session forwards to the application.</p>
            </remarks>
            <doc-id>bb970319</doc-id>
            <unmanaged>GetMasterVolume / SetMasterVolume</unmanaged>
            <unmanaged-short>GetMasterVolume</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SimpleAudioVolume.Mute">
            <summary>
            <p> </p><p>Queries whether the audio is muted.</p>
            </summary>
            <remarks>
            <p>Calling <strong>IMFSimpleAudioVolume::SetMasterVolume</strong> to set the volume does not change whether the audio is muted.</p>
            </remarks>
            <doc-id>bb970332</doc-id>
            <unmanaged>GetMute / SetMute</unmanaged>
            <unmanaged-short>GetMute</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SimpleAudioVolume.SetMasterVolume(System.Single)">
            <summary>
            <p> </p><p>Sets the master volume level.</p>
            </summary>
            <param name = "fLevel"><dd> <p>Volume level. Volume is expressed as an attenuation level, where 0.0 indicates silence and 1.0 indicates full volume (no attenuation).</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotInitializeD"/></strong></dt> </dl> </td><td> <p>The audio renderer is not initialized.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:StreamsInkRemoved"/></strong></dt> </dl> </td><td> <p>The audio renderer was removed from the pipeline.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Events outside of the application can change the master volume level. For example, the user can change the volume from the system volume-control program (SndVol). If an external event changes the master volume, the audio renderer sends an MEAudioSessionVolumeChanged event, which the Media Session forwards to the application.</p>
            </remarks>
            <doc-id>bb970391</doc-id>
            <unmanaged>HRESULT IMFSimpleAudioVolume::SetMasterVolume([In] float fLevel)</unmanaged>
            <unmanaged-short>IMFSimpleAudioVolume::SetMasterVolume</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SimpleAudioVolume.GetMasterVolume(System.Single@)">
            <summary>
            <p> </p><p>Retrieves the master volume level.</p>
            </summary>
            <param name = "fLevelRef"><dd> <p>Receives the volume level. Volume is expressed as an attenuation level, where 0.0 indicates silence and 1.0 indicates full volume (no attenuation).</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotInitializeD"/></strong></dt> </dl> </td><td> <p>The audio renderer is not initialized.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:StreamsInkRemoved"/></strong></dt> </dl> </td><td> <p>The audio renderer was removed from the pipeline.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If an external event changes the master volume, the audio renderer sends an MEAudioSessionVolumeChanged event, which the Media Session forwards to the application.</p>
            </remarks>
            <doc-id>bb970319</doc-id>
            <unmanaged>HRESULT IMFSimpleAudioVolume::GetMasterVolume([Out] float* pfLevel)</unmanaged>
            <unmanaged-short>IMFSimpleAudioVolume::GetMasterVolume</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SimpleAudioVolume.SetMute(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p> </p><p>Mutes or unmutes the audio.</p>
            </summary>
            <param name = "bMute"><dd> <p>Specify <strong>TRUE</strong> to mute the audio, or <strong><see cref = "F:SharpDX.Result.False"/></strong> to unmute the audio.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotInitializeD"/></strong></dt> </dl> </td><td> <p>The audio renderer is not initialized.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:StreamsInkRemoved"/></strong></dt> </dl> </td><td> <p>The audio renderer was removed from the pipeline.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method does not change the volume level returned by the <strong>IMFSimpleAudioVolume::GetMasterVolume</strong> function.</p>
            </remarks>
            <doc-id>bb970531</doc-id>
            <unmanaged>HRESULT IMFSimpleAudioVolume::SetMute([In] const BOOL bMute)</unmanaged>
            <unmanaged-short>IMFSimpleAudioVolume::SetMute</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SimpleAudioVolume.GetMute(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p> </p><p>Queries whether the audio is muted.</p>
            </summary>
            <param name = "bMuteRef"><dd> <p>Receives a Boolean value. If <strong>TRUE</strong>, the audio is muted; otherwise, the audio is not muted.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotInitializeD"/></strong></dt> </dl> </td><td> <p>The audio renderer is not initialized.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:StreamsInkRemoved"/></strong></dt> </dl> </td><td> <p>The audio renderer was removed from the pipeline.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Calling <strong>IMFSimpleAudioVolume::SetMasterVolume</strong> to set the volume does not change whether the audio is muted.</p>
            </remarks>
            <doc-id>bb970332</doc-id>
            <unmanaged>HRESULT IMFSimpleAudioVolume::GetMute([Out] BOOL* pbMute)</unmanaged>
            <unmanaged-short>IMFSimpleAudioVolume::GetMute</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SinkWriterCallback.OnFinalize(SharpDX.Result)">
            <summary>
            <p>Called when the <strong>IMFSinkWriter::Finalize</strong> method completes.</p>
            </summary>
            <param name = "hrStatus">No documentation.</param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Currently, the sink writer ignores the return value.</p></returns>
            <remarks>
            <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374644</doc-id>
            <unmanaged>HRESULT IMFSinkWriterCallback::OnFinalize([In] HRESULT hrStatus)</unmanaged>
            <unmanaged-short>IMFSinkWriterCallback::OnFinalize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SinkWriterCallback.OnMarker(System.Int32,System.IntPtr)">
            <summary>
            <p>Called when the <strong>IMFSinkWriter::PlaceMarker</strong> method completes.</p>
            </summary>
            <param name = "dwStreamIndex">No documentation.</param>
            <param name = "vContextRef">No documentation.</param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Currently, the sink writer ignores the return value.</p></returns>
            <remarks>
            <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374645</doc-id>
            <unmanaged>HRESULT IMFSinkWriterCallback::OnMarker([In] DWORD dwStreamIndex,[In] void* pvContext)</unmanaged>
            <unmanaged-short>IMFSinkWriterCallback::OnMarker</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SinkWriterCallback2.OnTransformChange">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called when the transform chain in the <strong><see cref = "T:SharpDX.MediaFoundation.SourceReader"/></strong> is built or modified.</p>
            </summary>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Currently, the sink writer ignores the return value.</p></returns>
            <doc-id>dn949417</doc-id>
            <unmanaged>HRESULT IMFSinkWriterCallback2::OnTransformChange()</unmanaged>
            <unmanaged-short>IMFSinkWriterCallback2::OnTransformChange</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SinkWriterCallback2.OnStreamError(System.Int32,SharpDX.Result)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called when an asynchronous error occurs with the <strong><see cref = "T:SharpDX.MediaFoundation.SinkWriter"/></strong>.</p>
            </summary>
            <param name = "dwStreamIndex">No documentation.</param>
            <param name = "hrStatus">No documentation.</param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Currently, the sink writer ignores the return value.</p></returns>
            <doc-id>dn949416</doc-id>
            <unmanaged>HRESULT IMFSinkWriterCallback2::OnStreamError([In] DWORD dwStreamIndex,[In] HRESULT hrStatus)</unmanaged>
            <unmanaged-short>IMFSinkWriterCallback2::OnStreamError</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SinkWriterEncoderConfig.SetTargetMediaType(System.Int32,SharpDX.MediaFoundation.MediaType,SharpDX.MediaFoundation.MediaAttributes)">
            <summary>
            <p>Dynamically changes the target media type that Sink Writer is encoding to.  </p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>Specifies the stream index.</p> </dd></param>
            <param name = "targetMediaTypeRef"><dd> <p>The new media format to encode to.</p> </dd></param>
            <param name = "encodingParametersRef"><dd> <p>The new set of encoding parameters to configure the encoder with. If not specified, previously provided parameters will be used.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The new media type must be supported by the media sink being used and by     the encoder MFTs installed on the system.
            </p>
            </remarks>
            <doc-id>dn302048</doc-id>
            <unmanaged>HRESULT IMFSinkWriterEncoderConfig::SetTargetMediaType([In] DWORD dwStreamIndex,[In] IMFMediaType* pTargetMediaType,[In, Optional] IMFAttributes* pEncodingParameters)</unmanaged>
            <unmanaged-short>IMFSinkWriterEncoderConfig::SetTargetMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SinkWriterEncoderConfig.PlaceEncodingParameters(System.Int32,SharpDX.MediaFoundation.MediaAttributes)">
            <summary>
            <p>Dynamically updates the encoder configuration with a collection of new encoder settings.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>Specifies the stream index.</p> </dd></param>
            <param name = "encodingParametersRef"><dd> <p>A set of encoding parameters to configure the encoder with. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The encoder will be configured with these settings after all previously queued input media samples have been sent to it through <strong>IMFTransform::ProcessInput</strong>.
            </p>
            </remarks>
            <doc-id>dn302047</doc-id>
            <unmanaged>HRESULT IMFSinkWriterEncoderConfig::PlaceEncodingParameters([In] DWORD dwStreamIndex,[In] IMFAttributes* pEncodingParameters)</unmanaged>
            <unmanaged-short>IMFSinkWriterEncoderConfig::PlaceEncodingParameters</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SinkWriterEx.GetTransformForStream(System.Int32,System.Int32,System.Guid@,SharpDX.MediaFoundation.Transform@)">
            <summary>
            <p>Gets a reference to a Media Foundation transform (MFT) for a specified stream.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The zero-based index of a stream.</p> </dd></param>
            <param name = "dwTransformIndex"><dd> <p>The zero-based index of the MFT to retreive.</p> </dd></param>
            <param name = "guidCategoryRef"><dd> <p>Receives a reference to a <see cref = "T:System.Guid"/> that specifies the category of the MFT. For a list of possible values, see <strong>MFT_CATEGORY</strong>.</p> </dd></param>
            <param name = "transformOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> interface of the MFT. The caller must release the interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh448061</doc-id>
            <unmanaged>HRESULT IMFSinkWriterEx::GetTransformForStream([In] DWORD dwStreamIndex,[In] DWORD dwTransformIndex,[Out, Optional] GUID* pGuidCategory,[Out] IMFTransform** ppTransform)</unmanaged>
            <unmanaged-short>IMFSinkWriterEx::GetTransformForStream</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SourceBuffer.Updating">
            <summary>
            <p>Gets a value that indicates  if <strong>Append</strong>, <strong>AppendByteStream</strong>, or <strong>Remove</strong> is in process.</p>
            </summary>
            <doc-id>dn302069</doc-id>
            <unmanaged>GetUpdating</unmanaged>
            <unmanaged-short>GetUpdating</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SourceBuffer.Buffered">
            <summary>
            <p>Gets the buffered time range.</p>
            </summary>
            <doc-id>dn302067</doc-id>
            <unmanaged>GetBuffered</unmanaged>
            <unmanaged-short>GetBuffered</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SourceBuffer.TimeStampOffset">
            <summary>
            <p>Gets or sets the timestamp offset for media segments appended to the <strong><see cref = "T:SharpDX.MediaFoundation.SourceBuffer"/></strong>.</p>
            </summary>
            <doc-id>dn302068</doc-id>
            <unmanaged>GetTimeStampOffset / SetTimeStampOffset</unmanaged>
            <unmanaged-short>GetTimeStampOffset</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SourceBuffer.AppendWindowStart">
            <summary>
            <p>Gets or sets the timestamp for the start of the append window.</p>
            </summary>
            <doc-id>dn302066</doc-id>
            <unmanaged>GetAppendWindowStart / SetAppendWindowStart</unmanaged>
            <unmanaged-short>GetAppendWindowStart</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SourceBuffer.AppendWindowEnd">
            <summary>
            <p>Gets or sets the timestamp for the end of the append window.</p>
            </summary>
            <doc-id>dn302065</doc-id>
            <unmanaged>GetAppendWindowEnd / SetAppendWindowEnd</unmanaged>
            <unmanaged-short>GetAppendWindowEnd</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBuffer.GetUpdating">
            <summary>
            <p>Gets a value that indicates  if <strong>Append</strong>, <strong>AppendByteStream</strong>, or <strong>Remove</strong> is in process.</p>
            </summary>
            <returns><p><strong>true</strong> if <strong>Append</strong>, <strong>AppendByteStream</strong>, or <strong>Remove</strong>; otherwise, <strong>false</strong>.</p></returns>
            <doc-id>dn302069</doc-id>
            <unmanaged>BOOL IMFSourceBuffer::GetUpdating()</unmanaged>
            <unmanaged-short>IMFSourceBuffer::GetUpdating</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBuffer.GetBuffered(SharpDX.MediaFoundation.MediaTimeRange@)">
            <summary>
            <p>Gets the buffered time range.</p>
            </summary>
            <param name = "bufferedOut"><dd> <p>The buffered time range.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn302067</doc-id>
            <unmanaged>HRESULT IMFSourceBuffer::GetBuffered([Out] IMFMediaTimeRange** ppBuffered)</unmanaged>
            <unmanaged-short>IMFSourceBuffer::GetBuffered</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBuffer.GetTimeStampOffset">
            <summary>
            <p>Gets the timestamp offset for media segments appended to the <strong><see cref = "T:SharpDX.MediaFoundation.SourceBuffer"/></strong>.</p>
            </summary>
            <returns><p>The timestamp offset.</p></returns>
            <doc-id>dn302068</doc-id>
            <unmanaged>double IMFSourceBuffer::GetTimeStampOffset()</unmanaged>
            <unmanaged-short>IMFSourceBuffer::GetTimeStampOffset</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBuffer.SetTimeStampOffset(System.Double)">
            <summary>
            <p>Sets the timestamp offset for media segments appended to the <strong><see cref = "T:SharpDX.MediaFoundation.SourceBuffer"/></strong>.</p>
            </summary>
            <param name = "offset">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn302073</doc-id>
            <unmanaged>HRESULT IMFSourceBuffer::SetTimeStampOffset([In] double offset)</unmanaged>
            <unmanaged-short>IMFSourceBuffer::SetTimeStampOffset</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBuffer.GetAppendWindowStart">
            <summary>
            <p>Gets the timestamp for the start of the append window.</p>
            </summary>
            <returns><p>The timestamp for the start of the append window.</p></returns>
            <doc-id>dn302066</doc-id>
            <unmanaged>double IMFSourceBuffer::GetAppendWindowStart()</unmanaged>
            <unmanaged-short>IMFSourceBuffer::GetAppendWindowStart</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBuffer.SetAppendWindowStart(System.Double)">
            <summary>
            <p>Sets the timestamp for the start of the append window.</p>
            </summary>
            <param name = "time"><dd> <p>The timestamp for the start of the append window.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn302072</doc-id>
            <unmanaged>HRESULT IMFSourceBuffer::SetAppendWindowStart([In] double time)</unmanaged>
            <unmanaged-short>IMFSourceBuffer::SetAppendWindowStart</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBuffer.GetAppendWindowEnd">
            <summary>
            <p>Gets the timestamp for the end of the append window.</p>
            </summary>
            <returns><p>The timestamp for the end of the append window.</p></returns>
            <doc-id>dn302065</doc-id>
            <unmanaged>double IMFSourceBuffer::GetAppendWindowEnd()</unmanaged>
            <unmanaged-short>IMFSourceBuffer::GetAppendWindowEnd</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBuffer.SetAppendWindowEnd(System.Double)">
            <summary>
            <p>Sets the timestamp for the end of the append window.</p>
            </summary>
            <param name = "time"><dd></dd></param>
            <returns><p>The timestamp for the end of the append window.</p></returns>
            <doc-id>dn302071</doc-id>
            <unmanaged>HRESULT IMFSourceBuffer::SetAppendWindowEnd([In] double time)</unmanaged>
            <unmanaged-short>IMFSourceBuffer::SetAppendWindowEnd</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBuffer.Append(System.Byte[],System.Int32)">
            <summary>
            <p>Appends the specified media segment to the <strong><see cref = "T:SharpDX.MediaFoundation.SourceBuffer"/></strong>.</p>
            </summary>
            <param name = "dataRef">No documentation.</param>
            <param name = "len">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn302063</doc-id>
            <unmanaged>HRESULT IMFSourceBuffer::Append([In, Buffer] const unsigned char* pData,[In] DWORD len)</unmanaged>
            <unmanaged-short>IMFSourceBuffer::Append</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBuffer.AppendByteStream(SharpDX.MediaFoundation.IByteStream,System.Nullable{System.Int64})">
            <summary>
            <p>Appends the media segment from the specified byte stream to the <strong><see cref = "T:SharpDX.MediaFoundation.SourceBuffer"/></strong>.</p>
            </summary>
            <param name = "streamRef">No documentation.</param>
            <param name = "maxLenRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn302064</doc-id>
            <unmanaged>HRESULT IMFSourceBuffer::AppendByteStream([In] IMFByteStream* pStream,[In, Optional] unsigned longlong* pMaxLen)</unmanaged>
            <unmanaged-short>IMFSourceBuffer::AppendByteStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBuffer.Abort">
            <summary>
            <p>Aborts the processing of the current media segment. </p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn302062</doc-id>
            <unmanaged>HRESULT IMFSourceBuffer::Abort()</unmanaged>
            <unmanaged-short>IMFSourceBuffer::Abort</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBuffer.Remove(System.Double,System.Double)">
            <summary>
            <p>Removes the media segments defined by the specified time range from the <strong><see cref = "T:SharpDX.MediaFoundation.SourceBuffer"/></strong>.</p>
            </summary>
            <param name = "start">No documentation.</param>
            <param name = "end">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn302070</doc-id>
            <unmanaged>HRESULT IMFSourceBuffer::Remove([In] double start,[In] double end)</unmanaged>
            <unmanaged-short>IMFSourceBuffer::Remove</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SourceBufferAppendMode.AppendMode">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetAppendMode / SetAppendMode</unmanaged>
            <unmanaged-short>GetAppendMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBufferAppendMode.GetAppendMode">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>MF_MSE_APPEND_MODE IMFSourceBufferAppendMode::GetAppendMode()</unmanaged>
            <unmanaged-short>IMFSourceBufferAppendMode::GetAppendMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBufferAppendMode.SetAppendMode(SharpDX.MediaFoundation.MultisampledEAppendMode)">
            <summary>
            No documentation.
            </summary>
            <param name = "mode">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFSourceBufferAppendMode::SetAppendMode([In] MF_MSE_APPEND_MODE mode)</unmanaged>
            <unmanaged-short>IMFSourceBufferAppendMode::SetAppendMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.SourceBufferList.Length">
            <summary>
            <p>Gets the number of <strong><see cref = "T:SharpDX.MediaFoundation.SourceBuffer"/></strong> objects  in the list.</p>
            </summary>
            <doc-id>dn302051</doc-id>
            <unmanaged>GetLength</unmanaged>
            <unmanaged-short>GetLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBufferList.GetLength">
            <summary>
            <p>Gets the number of <strong><see cref = "T:SharpDX.MediaFoundation.SourceBuffer"/></strong> objects  in the list.</p>
            </summary>
            <returns><p>The number of source buffers in the list.</p></returns>
            <doc-id>dn302051</doc-id>
            <unmanaged>DWORD IMFSourceBufferList::GetLength()</unmanaged>
            <unmanaged-short>IMFSourceBufferList::GetLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBufferList.GetSourceBuffer(System.Int32)">
            <summary>
            <p>Gets the <strong><see cref = "T:SharpDX.MediaFoundation.SourceBuffer"/></strong> at the specified index in the list.</p>
            </summary>
            <param name = "index">No documentation.</param>
            <returns><p>The source buffer.</p></returns>
            <doc-id>dn302052</doc-id>
            <unmanaged>IMFSourceBuffer* IMFSourceBufferList::GetSourceBuffer([In] DWORD index)</unmanaged>
            <unmanaged-short>IMFSourceBufferList::GetSourceBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBufferNotify.OnUpdateStart">
            <summary>
            <p>Used to indicate that the source buffer has started updating.</p>
            </summary>
            <doc-id>dn302061</doc-id>
            <unmanaged>void IMFSourceBufferNotify::OnUpdateStart()</unmanaged>
            <unmanaged-short>IMFSourceBufferNotify::OnUpdateStart</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBufferNotify.OnAbort">
            <summary>
            <p>Used to indicate that the source buffer has been aborted.</p>
            </summary>
            <doc-id>dn302054</doc-id>
            <unmanaged>void IMFSourceBufferNotify::OnAbort()</unmanaged>
            <unmanaged-short>IMFSourceBufferNotify::OnAbort</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBufferNotify.OnError(SharpDX.Result)">
            <summary>
            <p>Used to indicate that an error has occurred with the  source buffer.</p>
            </summary>
            <param name = "hr"><dd></dd></param>
            <doc-id>dn302055</doc-id>
            <unmanaged>void IMFSourceBufferNotify::OnError([In] HRESULT hr)</unmanaged>
            <unmanaged-short>IMFSourceBufferNotify::OnError</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBufferNotify.OnUpdate">
            <summary>
            <p>Used to indicate that the source buffer is updating.</p>
            </summary>
            <doc-id>dn302056</doc-id>
            <unmanaged>void IMFSourceBufferNotify::OnUpdate()</unmanaged>
            <unmanaged-short>IMFSourceBufferNotify::OnUpdate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceBufferNotify.OnUpdateEnd">
            <summary>
            <p>Used to indicate that the source buffer has finished updating.</p>
            </summary>
            <doc-id>dn302057</doc-id>
            <unmanaged>void IMFSourceBufferNotify::OnUpdateEnd()</unmanaged>
            <unmanaged-short>IMFSourceBufferNotify::OnUpdateEnd</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceOpenMonitor.OnSourceEvent(SharpDX.MediaFoundation.MediaEvent)">
            <summary>
            <p> </p><p>Called by the network source when the open operation begins or ends.</p>
            </summary>
            <param name = "eventRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEvent"/></strong> interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The networks source calls this method with the following event types.</p><ul> <li> <p> MEConnectStart </p> </li> <li> <p> MEConnectEnd </p> </li> </ul><p>For more information, see How to Get Events from the Network Source.</p>
            </remarks>
            <doc-id>ms694870</doc-id>
            <unmanaged>HRESULT IMFSourceOpenMonitor::OnSourceEvent([In, Optional] IMFMediaEvent* pEvent)</unmanaged>
            <unmanaged-short>IMFSourceOpenMonitor::OnSourceEvent</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReaderCallback.OnReadSample(SharpDX.Result,System.Int32,System.Int32,System.Int64,SharpDX.MediaFoundation.Sample)">
            <summary>
            <p>Called when the <strong>IMFSourceReader::ReadSample</strong> method completes.</p>
            </summary>
            <param name = "hrStatus">No documentation.</param>
            <param name = "dwStreamIndex">No documentation.</param>
            <param name = "dwStreamFlags">No documentation.</param>
            <param name = "llTimestamp">No documentation.</param>
            <param name = "sampleRef">No documentation.</param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Currently, the source reader ignores the return value.</p></returns>
            <remarks>
            <p>The <em>pSample</em> parameter might be <strong><c>null</c></strong>. For example, when the source reader reaches the end of a stream, <em>dwStreamFlags</em> contains the <strong>MF_SOURCE_READERF_ENDOFSTREAM</strong> flag, and <em>pSample</em> is <strong><c>null</c></strong>. </p><p>If there is a gap in the stream, <em>dwStreamFlags</em> contains the <strong>MF_SOURCE_READERF_STREAMTICK</strong> flag, <em>pSample</em> is <strong><c>null</c></strong>, and <em>llTimestamp</em> indicates the time when the gap occurred.  </p><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374658</doc-id>
            <unmanaged>HRESULT IMFSourceReaderCallback::OnReadSample([In] HRESULT hrStatus,[In] DWORD dwStreamIndex,[In] DWORD dwStreamFlags,[In] longlong llTimestamp,[In, Optional] IMFSample* pSample)</unmanaged>
            <unmanaged-short>IMFSourceReaderCallback::OnReadSample</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReaderCallback.OnFlush(System.Int32)">
            <summary>
            <p>Called when the <strong>IMFSourceReader::Flush</strong> method completes.</p>
            </summary>
            <param name = "dwStreamIndex">No documentation.</param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Currently, the source reader ignores the return value.</p></returns>
            <remarks>
            <p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd374657</doc-id>
            <unmanaged>HRESULT IMFSourceReaderCallback::OnFlush([In] DWORD dwStreamIndex)</unmanaged>
            <unmanaged-short>IMFSourceReaderCallback::OnFlush</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReaderCallback.OnEvent(System.Int32,SharpDX.MediaFoundation.MediaEvent)">
            <summary>
            <p>Called when the source reader receives certain events from the media source.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>For stream events, the value is the zero-based index of the stream that sent the event. For source events, the value is <strong>MF_SOURCE_READER_MEDIASOURCE</strong>.</p> </dd></param>
            <param name = "eventRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaEvent"/></strong> interface of the event.</p> </dd></param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Currently, the source reader ignores the return value.</p></returns>
            <remarks>
            <p>In the current implementation,  the source reader uses this method to forward the following events to the application:</p><ul> <li> MEBufferingStarted </li> <li> MEBufferingStopped </li> <li> MEConnectEnd </li> <li> MEConnectStart </li> <li> MEExtendedType </li> <li> MESourceCharacteristicsChanged </li> <li> MESourceMetadataChanged </li> </ul><p>This interface is available on Windows?Vista if Platform Update Supplement for Windows?Vista is installed.</p>
            </remarks>
            <doc-id>dd743367</doc-id>
            <unmanaged>HRESULT IMFSourceReaderCallback::OnEvent([In] DWORD dwStreamIndex,[In] IMFMediaEvent* pEvent)</unmanaged>
            <unmanaged-short>IMFSourceReaderCallback::OnEvent</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReaderCallback2.OnTransformChange">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called when the transform chain in the <strong><see cref = "T:SharpDX.MediaFoundation.SourceReader"/></strong> is built or modified.</p>
            </summary>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Currently, the source reader ignores the return value.</p></returns>
            <doc-id>dn949420</doc-id>
            <unmanaged>HRESULT IMFSourceReaderCallback2::OnTransformChange()</unmanaged>
            <unmanaged-short>IMFSourceReaderCallback2::OnTransformChange</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReaderCallback2.OnStreamError(System.Int32,SharpDX.Result)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called when an asynchronous error occurs with the <strong><see cref = "T:SharpDX.MediaFoundation.SourceReader"/></strong>.</p>
            </summary>
            <param name = "dwStreamIndex">No documentation.</param>
            <param name = "hrStatus">No documentation.</param>
            <returns><p>Returns an <strong><see cref = "T:SharpDX.Result"/></strong> value. Currently, the source reader ignores the return value.</p></returns>
            <doc-id>dn949419</doc-id>
            <unmanaged>HRESULT IMFSourceReaderCallback2::OnStreamError([In] DWORD dwStreamIndex,[In] HRESULT hrStatus)</unmanaged>
            <unmanaged-short>IMFSourceReaderCallback2::OnStreamError</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReaderEx.SetNativeMediaType(System.Int32,SharpDX.MediaFoundation.MediaType,System.Int32@)">
            <summary>
            <p>Sets the native media type for a stream on the media source.</p>
            </summary>
            <param name = "dwStreamIndex"><dd></dd></param>
            <param name = "mediaTypeRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type.</p> </dd></param>
            <param name = "dwStreamFlagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more of the following flags.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MF_SOURCE_READERF_ALLEFFECTSREMOVED</strong></dt> </dl> </td><td> <p>All effects were removed from the stream.</p> </td></tr> <tr><td><dl> <dt><strong>MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED</strong></dt> </dl> </td><td> <p>The current output type changed.</p> </td></tr> </table> <p>?</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid request.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidStreamNumber"/></strong></strong></dt> </dl> </td><td> <p>The <em>dwStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method sets the output type that is produced by the media source. Unlike the <strong>IMFSourceReader::SetCurrentMediaType</strong> method, this method does not insert any decoders, video processors, or other transforms. The media source must support the specified media type natively. To get a list of supported types from the media source, call <strong>IMFSourceReader::GetNativeMediaType</strong>.</p><p>In asynchronous mode, this method fails if a sample request is pending. In that case, wait for the <strong>OnReadSample</strong> callback to be invoked before calling the method. For more information about using the Source Reader in asynchronous mode, see <strong>IMFSourceReader::ReadSample</strong>.</p><p>This method can trigger a change in the output format for the stream. If so, the <strong>MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED</strong> flag is returned in the  <em>pdwStreamFlags</em> parameter. The method might also cause the Source Reader to remove any effects that were added by the <strong>IMFSourceReaderEx::AddTransformForStream</strong> method. If this occurs, the  <strong>MF_SOURCE_READERF_ALLEFFECTSREMOVED</strong> flag is returned in <em>pdwStreamFlags</em>. </p><p>This method is useful with audio and video capture devices, because a device might support several output formats. This method enables the application to choose the device format before decoders and other transforms are added.</p>
            </remarks>
            <doc-id>hh448066</doc-id>
            <unmanaged>HRESULT IMFSourceReaderEx::SetNativeMediaType([In] DWORD dwStreamIndex,[In, Optional] IMFMediaType* pMediaType,[Out] DWORD* pdwStreamFlags)</unmanaged>
            <unmanaged-short>IMFSourceReaderEx::SetNativeMediaType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReaderEx.AddTransformForStream(System.Int32,SharpDX.IUnknown)">
            <summary>
            <p>Adds a transform, such as an audio or video effect, to a stream.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The stream to configure. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "transformOrActivateRef"><dd> <p>A reference to one of the following:</p> <ul> <li>A Media Foundation transform (MFT) that exposes the <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> interface.</li> <li>An MFT activation object that exposes the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface.</li> </ul> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidMediaType"/></strong></dt> </dl> </td><td> <p>The transform does not support the current stream format, and no conversion was possible. See Remarks for more information.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid request.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidStreamNumber"/></strong></strong></dt> </dl> </td><td> <p>The <em>dwStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method attempts to add the transform at the end of the current processing chain. </p><p>To use this method, make the following sequence of calls:</p><ol> <li>Call <strong>IMFSourceReader::SetCurrentMediaType</strong> to set the output type that you want for the stream. In this step, you can specify a media type that contains only the major type and subtype GUIDs. For example, to get 32-bit RGB output, set a major type of <strong><see cref = "!:Video"/></strong> and a subtype of <strong><see cref = "!:Rgb32"/></strong>. (For more information, see Media Type GUIDs.)</li> <li>Call <strong>AddTransformForStream</strong>. If the Source Reader successfully connects the transform, it sets the output type on the transform.</li> <li>Call <strong>IMFSourceReader::GetCurrentMediaType</strong> to get the output type from the transform. This method returns a media type with a complete format description.</li> <li>Optionally, if you want to modify the output type, call <strong>IMFSourceReader::SetCurrentMediaType</strong> again to set a complete media type on the transform.</li> </ol><p>The <strong>AddTransformForStream</strong> method will not insert a decoder into the processing chain. If the native stream format is encoded, and the transform requires an uncompressed format, call <strong>SetCurrentMediaType</strong> to set the uncompressed format (step 1 in the previous list). However, the method will insert a video processor to convert between RGB and YUV formats, if required.</p><p>The method fails if the source reader was configured with the <see cref = "!:ReadwriteDisableConverters"/> or <see cref = "!:EnableVideoProcessing"/> attributes. </p><p>In asynchronous mode, the method also fails if a sample request is pending. In that case, wait for the <strong>OnReadSample</strong> callback to be invoked before calling the method. For more information about using the Source Reader in asynchronous mode, see <strong>IMFSourceReader::ReadSample</strong>.</p><p>You can add a transform at any time during streaming. However, the method does not flush or drain the pipeline before inserting the transform. Therefore, if data is already in the pipeline, the next sample is not guaranteed to have the transform applied.</p>
            </remarks>
            <doc-id>hh448063</doc-id>
            <unmanaged>HRESULT IMFSourceReaderEx::AddTransformForStream([In] DWORD dwStreamIndex,[In] IUnknown* pTransformOrActivate)</unmanaged>
            <unmanaged-short>IMFSourceReaderEx::AddTransformForStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReaderEx.RemoveAllTransformsForStream(System.Int32)">
            <summary>
            <p>Removes all of the Media Foundation transforms (MFTs) for a specified stream, with the exception of the decoder.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The stream for which to remove the MFTs. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid request.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidStreamNumber"/></strong></strong></dt> </dl> </td><td> <p>The <em>dwStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Calling this method can reset the current output type for the stream. To get the new output type, call <strong>IMFSourceReader::GetCurrentMediaType</strong>.</p><p>In asynchronous mode, this method fails if a sample request is pending. In that case, wait for the <strong>OnReadSample</strong> callback to be invoked before calling the method. For more information about using the Source Reader in asynchronous mode, see <strong>IMFSourceReader::ReadSample</strong>.</p>
            </remarks>
            <doc-id>hh448065</doc-id>
            <unmanaged>HRESULT IMFSourceReaderEx::RemoveAllTransformsForStream([In] DWORD dwStreamIndex)</unmanaged>
            <unmanaged-short>IMFSourceReaderEx::RemoveAllTransformsForStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SourceReaderEx.GetTransformForStream(System.Int32,System.Int32,System.Guid@,SharpDX.MediaFoundation.Transform@)">
            <summary>
            <p>Gets a reference to a Media Foundation transform (MFT) for a specified stream.</p>
            </summary>
            <param name = "dwStreamIndex"><dd> <p>The stream to query for the MFT. The value can be any of the following.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td> <dl> <dt>0?0xFFFFFFFB</dt> </dl> </td><td> <p>The zero-based index of a stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_VIDEO_STREAM</strong></strong></dt> <dt>0xFFFFFFFC</dt> </dl> </td><td> <p>The first video stream.</p> </td></tr> <tr><td><dl> <dt><strong><strong>MF_SOURCE_READER_FIRST_AUDIO_STREAM</strong></strong></dt> <dt>0xFFFFFFFD</dt> </dl> </td><td> <p>The first audio stream.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "dwTransformIndex"><dd> <p>The zero-based index of the MFT to retreive.</p> </dd></param>
            <param name = "guidCategoryRef"><dd> <p>Receives a <see cref = "T:System.Guid"/> that specifies the category of the MFT. For a list of possible values, see <strong>MFT_CATEGORY</strong>.</p> </dd></param>
            <param name = "transformOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> interface of the MFT. The caller must release the interface.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidIndex"/></strong></dt> </dl> </td><td> <p>The <em>dwTransformIndex</em> parameter is out of range.</p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:InvalidStreamNumber"/></strong></strong></dt> </dl> </td><td> <p>The <em>dwStreamIndex</em> parameter is invalid.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>You can use this method to configure an MFT after it is inserted into the processing chain. Do not use the reference returned in <em>ppTransform</em> to set media types on the MFT or to process data. In particular, calling any of the following <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> methods could have unexpected results.</p><ul> <li> <strong>AddInputStreams</strong> </li> <li> <strong>DeleteInputStream</strong> </li> <li> <strong>ProcessEvent</strong> </li> <li> <strong>ProcessInput</strong> </li> <li> <strong>ProcessMessage</strong> </li> <li> <strong>ProcessOutput</strong> </li> <li> <strong>SetInputType</strong> </li> <li> <strong>SetOutputType</strong> </li> </ul><p>If a decoder is present, it appears at index position zero.</p><p>To avoid losing any data, you should drain the source reader before calling this method. For more information, see Draining the Data Pipeline.</p>
            </remarks>
            <doc-id>hh448064</doc-id>
            <unmanaged>HRESULT IMFSourceReaderEx::GetTransformForStream([In] DWORD dwStreamIndex,[In] DWORD dwTransformIndex,[Out, Optional] GUID* pGuidCategory,[Out] IMFTransform** ppTransform)</unmanaged>
            <unmanaged-short>IMFSourceReaderEx::GetTransformForStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SSLCertificateManager.GetClientCertificate(System.String,System.Byte[],System.Int32@)">
            <summary>
            <p>Gets the client SSL certificate synchronously.</p>
            </summary>
            <param name = "szURLRef"><dd> <p>Pointer to a string that contains the URL for which a client-side SSL certificate is required. Media Foundation can resolve the scheme and send the request to the server.</p> </dd></param>
            <param name = "bDataOut"><dd> <p>Pointer to the buffer that stores the certificate.This caller must free the buffer by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>
            <param name = "cbDataRef"><dd> <p>Pointer to a <strong><see cref = "T:System.Int32"/></strong> variable that receives the number of bytes required to hold the certificate data in the buffer pointed by <em>*ppbData</em>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd374674</doc-id>
            <unmanaged>HRESULT IMFSSLCertificateManager::GetClientCertificate([In] const wchar_t* pszURL,[Out, Buffer] unsigned char** ppbData,[Out] DWORD* pcbData)</unmanaged>
            <unmanaged-short>IMFSSLCertificateManager::GetClientCertificate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SSLCertificateManager.BeginGetClientCertificate(System.String,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p>Starts an asynchronous call to get the client SSL certificate.</p>
            </summary>
            <param name = "szURLRef"><dd> <p>A null-terminated string that contains the URL for which a client-side SSL certificate is required. Media Foundation can  resolve the scheme and send the request to the server.</p> </dd></param>
            <param name = "callbackRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>
            <param name = "stateRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.  </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>When the operation completes, the callback object's <strong>IMFAsyncCallback::Invoke</strong> method is called. At that point, the application should call <strong>IMFSSLCertificateManager::EndGetClientCertificate</strong> to complete the asynchronous request.  </p>
            </remarks>
            <doc-id>dd374671</doc-id>
            <unmanaged>HRESULT IMFSSLCertificateManager::BeginGetClientCertificate([In] const wchar_t* pszURL,[In] IMFAsyncCallback* pCallback,[In] IUnknown* pState)</unmanaged>
            <unmanaged-short>IMFSSLCertificateManager::BeginGetClientCertificate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SSLCertificateManager.EndGetClientCertificate(SharpDX.MediaFoundation.AsyncResult,System.Byte[],System.Int32@)">
            <summary>
            <p>Completes an asynchronous request to get the client SSL certificate. </p>
            </summary>
            <param name = "resultRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>IMFAsyncCallback::Invoke</strong> method.  </p> </dd></param>
            <param name = "bDataOut"><dd> <p>Receives a reference to the buffer that stores the certificate.The caller must free the buffer by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>
            <param name = "cbDataRef"><dd> <p>Receives the size of the <em>ppbData</em> buffer, in bytes.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Call this method after the <strong>IMFSSLCertificateManager::BeginGetClientCertificate</strong> method completes asynchronously. </p>
            </remarks>
            <doc-id>dd374672</doc-id>
            <unmanaged>HRESULT IMFSSLCertificateManager::EndGetClientCertificate([In] IMFAsyncResult* pResult,[Out, Buffer] unsigned char** ppbData,[Out] DWORD* pcbData)</unmanaged>
            <unmanaged-short>IMFSSLCertificateManager::EndGetClientCertificate</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SSLCertificateManager.GetCertificatePolicy(System.String,SharpDX.Mathematics.Interop.RawBool,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Indicates whether the server SSL certificate must be verified by the caller, Media Foundation,  or the <strong><see cref = "T:SharpDX.MediaFoundation.SSLCertificateManager"/></strong> implementation class.</p>
            </summary>
            <param name = "szURLRef"><dd> <p> Pointer to a string that contains the URL that  is sent to the server.</p> </dd></param>
            <param name = "fOverrideAutomaticCheckRef"><dd> <p>Pointer to a <strong><see cref = "T:SharpDX.Mathematics.Interop.RawBool"/></strong> value. Set to <strong>TRUE</strong> if <strong>IMFSSLCertificateManager::OnServerCertificate</strong> is used to verify the server certificate.Set to <strong><see cref = "F:SharpDX.Result.False"/></strong> if Media Foundation verifies the server certificate  by using the certificates in the Windows certificate store.</p> </dd></param>
            <param name = "fClientCertificateAvailableRef"><dd> <p>Pointer to a <strong><see cref = "T:SharpDX.Mathematics.Interop.RawBool"/></strong> value. Set to <strong>TRUE</strong> if the SSL certificate for the client is available for immediate retrieval. Media Foundation  calls <strong>IMFSSLCertificateManager::GetClientCertificate</strong> to obtain the client certificate synchronously. If the value is set to <strong><see cref = "F:SharpDX.Result.False"/></strong>, Media Foundation obtains the client SSL certificate with an asynchronous call to <strong>IMFSSLCertificateManager::BeginGetClientCertificate</strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd374673</doc-id>
            <unmanaged>HRESULT IMFSSLCertificateManager::GetCertificatePolicy([In] const wchar_t* pszURL,[In] BOOL* pfOverrideAutomaticCheck,[In] BOOL* pfClientCertificateAvailable)</unmanaged>
            <unmanaged-short>IMFSSLCertificateManager::GetCertificatePolicy</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SSLCertificateManager.OnServerCertificate(System.String,System.Byte[],System.Int32,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Called by Media Foundation when the server SSL certificate has been received; indicates whether the server certificate is accepted.</p>
            </summary>
            <param name = "szURLRef"><dd> <p>Pointer to a string that contains the URL used to send the request to the server, and for which a server-side SSL certificate has been received.</p> </dd></param>
            <param name = "bDataRef"><dd> <p>Pointer to a buffer that contains the server SSL certificate.</p> </dd></param>
            <param name = "cbData"><dd> <p>Pointer to a <strong><see cref = "T:System.Int32"/></strong> variable that indicates the size of <em>pbData</em> in bytes.</p> </dd></param>
            <param name = "fIsGoodRef"><dd> <p>Pointer to a <strong><see cref = "T:SharpDX.Mathematics.Interop.RawBool"/></strong> variable that indicates whether the certificate is accepted.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd374675</doc-id>
            <unmanaged>HRESULT IMFSSLCertificateManager::OnServerCertificate([In] const wchar_t* pszURL,[In, Buffer] unsigned char* pbData,[In] DWORD cbData,[In] BOOL* pfIsGood)</unmanaged>
            <unmanaged-short>IMFSSLCertificateManager::OnServerCertificate</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.StreamDescriptor.StreamIdentifier">
            <summary>
            <p> </p><p>Retrieves an identifier for the stream.</p>
            </summary>
            <remarks>
            <p>The stream identifier uniquely identifies a stream within a presentation. It does not change throughout the lifetime of the stream. For example, if the presentation changes while the source is running, the index number of the stream may change, but the stream identifier does not.</p><p>In general, stream identifiers do not have a specific meaning, other than to identify the stream. Some media sources may assign stream identifiers based on meaningful values, such as packet identifiers, but this depends on the implementation.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms703852</doc-id>
            <unmanaged>GetStreamIdentifier</unmanaged>
            <unmanaged-short>GetStreamIdentifier</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.StreamDescriptor.MediaTypeHandler">
            <summary>
            <p> </p><p>Retrieves a media type handler for the stream. The media type handler can be used to enumerate supported media types for the stream, get the current media type, and set the media type.</p>
            </summary>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms700210</doc-id>
            <unmanaged>GetMediaTypeHandler</unmanaged>
            <unmanaged-short>GetMediaTypeHandler</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.StreamDescriptor.GetStreamIdentifier(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves an identifier for the stream.</p>
            </summary>
            <param name = "dwStreamIdentifierRef"><dd> <p>Receives the stream identifier.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The stream identifier uniquely identifies a stream within a presentation. It does not change throughout the lifetime of the stream. For example, if the presentation changes while the source is running, the index number of the stream may change, but the stream identifier does not.</p><p>In general, stream identifiers do not have a specific meaning, other than to identify the stream. Some media sources may assign stream identifiers based on meaningful values, such as packet identifiers, but this depends on the implementation.</p><p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms703852</doc-id>
            <unmanaged>HRESULT IMFStreamDescriptor::GetStreamIdentifier([Out] DWORD* pdwStreamIdentifier)</unmanaged>
            <unmanaged-short>IMFStreamDescriptor::GetStreamIdentifier</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.StreamDescriptor.GetMediaTypeHandler(SharpDX.MediaFoundation.MediaTypeHandler@)">
            <summary>
            <p> </p><p>Retrieves a media type handler for the stream. The media type handler can be used to enumerate supported media types for the stream, get the current media type, and set the media type.</p>
            </summary>
            <param name = "mediaTypeHandlerOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaTypeHandler"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This interface is available on the following platforms if the Windows Media Format 11 SDK redistributable components are installed:</p><ul> <li>Windows?XP with Service Pack?2 (SP2) and later.</li> <li>Windows?XP Media Center Edition?2005 with KB900325 (Windows?XP Media Center Edition?2005) and KB925766 (October 2006 Update Rollup for Windows?XP Media Center Edition) installed.</li> </ul>
            </remarks>
            <doc-id>ms700210</doc-id>
            <unmanaged>HRESULT IMFStreamDescriptor::GetMediaTypeHandler([Out] IMFMediaTypeHandler** ppMediaTypeHandler)</unmanaged>
            <unmanaged-short>IMFStreamDescriptor::GetMediaTypeHandler</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.StreamingSinkConfig.StartStreaming(SharpDX.Mathematics.Interop.RawBool,System.Int64)">
            <summary>
            <p>Called by the streaming media client before the Media Session starts streaming to specify the byte offset or the time offset.</p>
            </summary>
            <param name = "fSeekOffsetIsByteOffset"><dd> <p> A Boolean value that specifies whether <em>qwSeekOffset</em> gives a byte offset of a time offset.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>TRUE</strong></dt> </dl> </td><td> <p>The <em>qwSeekOffset</em> parameter specifies a byte offset.</p> </td></tr> <tr><td><dl> <dt><strong><see cref = "F:SharpDX.Result.False"/></strong></dt> </dl> </td><td> <p>The <em>qwSeekOffset</em> parameter specifies the time position in 100-nanosecond units.</p> </td></tr> </table> <p>?</p> </dd></param>
            <param name = "qwSeekOffset"><dd> <p>A byte offset or a time offset, depending on the value passed in <em>fSeekOffsetIsByteOffset</em>.  Time offsets are specified in 100-nanosecond units.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd374677</doc-id>
            <unmanaged>HRESULT IMFStreamingSinkConfig::StartStreaming([In] BOOL fSeekOffsetIsByteOffset,[In] unsigned longlong qwSeekOffset)</unmanaged>
            <unmanaged-short>IMFStreamingSinkConfig::StartStreaming</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.StreamSink.MediaSink">
            <summary>
            <p> </p><p>Retrieves the media sink that owns this stream sink.</p>
            </summary>
            <doc-id>ms699003</doc-id>
            <unmanaged>GetMediaSink</unmanaged>
            <unmanaged-short>GetMediaSink</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.StreamSink.Identifier">
            <summary>
            <p> </p><p>Retrieves the stream identifier for this stream sink.</p>
            </summary>
            <doc-id>ms702129</doc-id>
            <unmanaged>GetIdentifier</unmanaged>
            <unmanaged-short>GetIdentifier</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.StreamSink.MediaTypeHandler">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetMediaTypeHandler</unmanaged>
            <unmanaged-short>GetMediaTypeHandler</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.StreamSink.GetMediaSink(SharpDX.MediaFoundation.MediaSink@)">
            <summary>
            <p> </p><p>Retrieves the media sink that owns this stream sink.</p>
            </summary>
            <param name = "mediaSinkOut"><dd> <p>Receives a reference to the media sink's <strong><see cref = "T:SharpDX.MediaFoundation.MediaSink"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:StreamsInkRemoved"/></strong></dt> </dl> </td><td> <p>This stream was removed from the media sink and is no longer valid.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms699003</doc-id>
            <unmanaged>HRESULT IMFStreamSink::GetMediaSink([Out] IMFMediaSink** ppMediaSink)</unmanaged>
            <unmanaged-short>IMFStreamSink::GetMediaSink</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.StreamSink.GetIdentifier(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the stream identifier for this stream sink.</p>
            </summary>
            <param name = "dwIdentifierRef"><dd> <p>Receives the stream identifier. If this stream sink was added by calling <strong>IMFMediaSink::AddStreamSink</strong>, the stream identifier is in the <em>dwStreamSinkIdentifier</em> parameter of that method. Otherwise, the media sink defines the identifier.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:StreamsInkRemoved"/></strong></dt> </dl> </td><td> <p>This stream was removed from the media sink and is no longer valid.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms702129</doc-id>
            <unmanaged>HRESULT IMFStreamSink::GetIdentifier([Out] DWORD* pdwIdentifier)</unmanaged>
            <unmanaged-short>IMFStreamSink::GetIdentifier</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.StreamSink.GetMediaTypeHandler(SharpDX.MediaFoundation.MediaTypeHandler@)">
            <summary>
            No documentation.
            </summary>
            <param name = "handlerOut">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFStreamSink::GetMediaTypeHandler([Out] IMFMediaTypeHandler** ppHandler)</unmanaged>
            <unmanaged-short>IMFStreamSink::GetMediaTypeHandler</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.StreamSink.ProcessSample(SharpDX.MediaFoundation.Sample)">
            <summary>
            <p> </p><p>Delivers a sample to the stream. The media sink processes the sample.</p>
            </summary>
            <param name = "sampleRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface of a sample that contains valid data for the stream.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStateTransition"/></strong></dt> </dl> </td><td> <p>The media sink is in the wrong state to receive a sample. For example, preroll is complete but the presenation clock has not started yet.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidTimestamp"/></strong></dt> </dl> </td><td> <p>The sample has an invalid time stamp. See Remarks.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The media sink is paused or stopped and cannot process the sample.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NoClock"/></strong></dt> </dl> </td><td> <p>The presentation clock was not set. Call <strong>IMFMediaSink::SetPresentationClock</strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NoSampleTimestamp"/></strong></dt> </dl> </td><td> <p>The sample does not have a time stamp.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotInitializeD"/></strong></dt> </dl> </td><td> <p>The stream sink has not been initialized.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:StreamsInkRemoved"/></strong></dt> </dl> </td><td> <p>This stream was removed from the media sink and is no longer valid.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this method when the stream sink sends an MEStreamSinkRequestSample event.</p><p>This method can return <see cref = "!:InvalidTimestamp"/> for various reasons, depending on the implementation of the media sink:</p><ul> <li> <p>Negative time stamps.</p> </li> <li> <p>Time stamps that jump backward (within the same stream).</p> </li> <li> <p>The time stamps for one stream have drifted too far from the time stamps on another stream within the same media sink (for example, an archive sink that multiplexes the streams).</p> </li> </ul><p>Not every media sink returns an error code in these situations.</p>
            </remarks>
            <doc-id>ms696208</doc-id>
            <unmanaged>HRESULT IMFStreamSink::ProcessSample([In, Optional] IMFSample* pSample)</unmanaged>
            <unmanaged-short>IMFStreamSink::ProcessSample</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.StreamSink.PlaceMarker(SharpDX.MediaFoundation.StreamsInkMarkerType,SharpDX.Win32.Variant,SharpDX.Win32.Variant)">
            <summary>
            <p> </p><p>Places a marker in the stream. </p>
            </summary>
            <param name = "eMarkerType"><dd> <p> Specifies the marker type, as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.StreamsInkMarkerType"/></strong> enumeration. </p> </dd></param>
            <param name = "varMarkerValueRef"><dd> <p> Optional reference to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that contains additional information related to the marker. The meaning of this value depends on the marker type. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
            <param name = "varContextValueRef"><dd> <p> Optional reference to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that is attached to the MEStreamSinkMarker event. Call <strong>IMFMediaEvent::GetValue</strong> to get this value from the event. The caller can use this information for any purpose. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><strong><see cref = "F:SharpDX.Result.Ok"/></strong></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:Shutdown"/></strong></strong></dt> </dl> </td><td> <p> The media sink's <strong>Shutdown</strong> method has been called. </p> </td></tr> <tr><td> <dl> <dt><strong><strong><see cref = "!:StreamsInkRemoved"/></strong></strong></dt> </dl> </td><td> <p> This stream was removed from the media sink and is no longer valid. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method causes the stream sink to send an MEStreamSinkMarker event after the stream sink consumes all of the samples that were delivered up to this point (before the call to <strong>PlaceMarker</strong>).</p>
            </remarks>
            <doc-id>ms703026</doc-id>
            <unmanaged>HRESULT IMFStreamSink::PlaceMarker([In] MFSTREAMSINK_MARKER_TYPE eMarkerType,[In] const PROPVARIANT* pvarMarkerValue,[In] const PROPVARIANT* pvarContextValue)</unmanaged>
            <unmanaged-short>IMFStreamSink::PlaceMarker</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.StreamSink.Flush">
            <summary>
            <p> </p><p>Causes the stream sink to drop any samples that it has received and has not rendered yet.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotInitializeD"/></strong></dt> </dl> </td><td> <p>The stream sink has not been initialized yet. You might need to set a media type.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The media sink's <strong>Shutdown</strong> method has been called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:StreamsInkRemoved"/></strong></dt> </dl> </td><td> <p>This stream was removed from the media sink and is no longer valid.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If any samples are still queued from previous calls to the <strong>IMFStreamSink::ProcessSample</strong> method, the media sink immediately discards them, without processing them. This can cause a glitch in the rendered output. The running state of the sink (running, paused, or stopped) does not change.</p><p>Any pending marker events from the <strong>IMFStreamSink::PlaceMarker</strong> method are dispatched immediately, with the status code E_ABORT.</p><p>This method is synchronous. It does not return until the sink has discarded all pending samples.</p>
            </remarks>
            <doc-id>ms697054</doc-id>
            <unmanaged>HRESULT IMFStreamSink::Flush()</unmanaged>
            <unmanaged-short>IMFStreamSink::Flush</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SystemId.GetData(System.Int32@,System.Byte[])">
            <summary>
            <p>Retrieves system id data.</p>
            </summary>
            <param name = "size"><dd> <p>The size in bytes of the returned data.</p> </dd></param>
            <param name = "data"><dd> <p>Receives the returned data.  The caller must free this buffer by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>hh448068</doc-id>
            <unmanaged>HRESULT IMFSystemId::GetData([Out] unsigned int* size,[Out, Buffer] unsigned char** data)</unmanaged>
            <unmanaged-short>IMFSystemId::GetData</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.SystemId.Setup(System.Int32,System.Int32,System.Byte[],System.Int32@,System.Byte[])">
            <summary>
            <p>Sets up the <strong><see cref = "T:SharpDX.MediaFoundation.SystemId"/></strong>.</p>
            </summary>
            <param name = "stage">No documentation.</param>
            <param name = "cbIn">No documentation.</param>
            <param name = "bInRef">No documentation.</param>
            <param name = "cbOutRef">No documentation.</param>
            <param name = "bOutOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>jj128323</doc-id>
            <unmanaged>HRESULT IMFSystemId::Setup([In] unsigned int stage,[In] unsigned int cbIn,[In, Buffer] const unsigned char* pbIn,[Out] unsigned int* pcbOut,[Out, Buffer] unsigned char** ppbOut)</unmanaged>
            <unmanaged-short>IMFSystemId::Setup</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimecodeTranslate.BeginConvertTimecodeToHNS(SharpDX.Win32.Variant,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p>Starts an asynchronous call to convert Society of Motion Picture and Television Engineers (SMPTE) time code to 100-nanosecond units.</p>
            </summary>
            <param name = "propVarTimecodeRef"><dd> <p>Time in SMPTE time code to convert. The <strong>vt</strong> member of the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> structure is set to <strong>VT_I8</strong>. The <strong>hVal.QuadPart</strong> member contains the time in binary coded decimal (BCD) form. See Remarks.</p> </dd></param>
            <param name = "callbackRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>
            <param name = "unkStateRef"><dd> <p>PPointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>pPropVarTimecode</em> is not <strong>VT_I8</strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ByteStreamNotSeekable"/></strong></dt> </dl> </td><td> <p>The byte stream is not seekable. The time code cannot be read from the end of the byte stream.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>When the asynchronous method completes, the callback object's <strong>IMFAsyncCallback::Invoke</strong> method is called. At that point, the application must call <strong>IMFTimecodeTranslate::EndConvertTimecodeToHNS</strong> to complete the asynchronous request.</p><p>The value of <em>pPropVarTimecode</em> is a 64-bit unsigned value typed as a <strong>LONGLONG</strong>. The upper <strong><see cref = "T:System.Int32"/></strong> contains the range. (A <em>range</em> is a continuous series of time codes.) The lower <strong><see cref = "T:System.Int32"/></strong> contains the time code in the form of a hexadecimal number <em>0xhhmmssff</em>,  where each 2-byte sequence is read as a decimal value.</p><pre>void CreateTimeCode( <see cref = "T:System.Int32"/> dwFrames, <see cref = "T:System.Int32"/> dwSeconds, <see cref = "T:System.Int32"/> dwMinutes, <see cref = "T:System.Int32"/> dwHours, <see cref = "T:System.Int32"/> dwRange, <see cref = "T:SharpDX.Win32.Variant"/> *pvar )
            { ULONGLONG ullTimecode = ((ULONGLONG)dwRange) &lt; &lt; 32; ullTimecode +=   dwFrames  % 10; ullTimecode += (( (ULONGLONG)dwFrames )  / 10) &lt; &lt; 4; ullTimecode += (( (ULONGLONG)dwSeconds ) % 10) &lt; &lt; 8; ullTimecode += (( (ULONGLONG)dwSeconds ) / 10) &lt; &lt; 12; ullTimecode += (( (ULONGLONG)dwMinutes ) % 10) &lt; &lt; 16; ullTimecode += (( (ULONGLONG)dwMinutes ) / 10) &lt; &lt; 20; ullTimecode += (( (ULONGLONG)dwHours )   % 10) &lt; &lt; 24; ullTimecode += (( (ULONGLONG)dwHours )   / 10) &lt; &lt; 28; pvar-&gt;vt = VT_I8; pvar-&gt;hVal.QuadPart = (LONGLONG)ullTimecode;
            }
            </pre>
            </remarks>
            <doc-id>dd374680</doc-id>
            <unmanaged>HRESULT IMFTimecodeTranslate::BeginConvertTimecodeToHNS([In] const PROPVARIANT* pPropVarTimecode,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>
            <unmanaged-short>IMFTimecodeTranslate::BeginConvertTimecodeToHNS</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimecodeTranslate.EndConvertTimecodeToHNS(SharpDX.MediaFoundation.AsyncResult,System.Int64)">
            <summary>
            <p>Completes an asynchronous request to convert time in Society of Motion Picture and Television Engineers (SMPTE) time code to 100-nanosecond units.</p>
            </summary>
            <param name = "resultRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>IMFAsyncCallback::Invoke</strong> method. </p> </dd></param>
            <param name = "hnsTimeRef"><dd> <p>Receives the converted time.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Call this method after the <strong>IMFTimecodeTranslate::BeginConvertTimecodeToHNS</strong> method completes asynchronously.</p>
            </remarks>
            <doc-id>dd374682</doc-id>
            <unmanaged>HRESULT IMFTimecodeTranslate::EndConvertTimecodeToHNS([In] IMFAsyncResult* pResult,[In] longlong* phnsTime)</unmanaged>
            <unmanaged-short>IMFTimecodeTranslate::EndConvertTimecodeToHNS</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimecodeTranslate.BeginConvertHNSToTimecode(System.Int64,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p>Starts an asynchronous call to convert time in 100-nanosecond units to Society of Motion Picture and Television Engineers (SMPTE) time code.</p>
            </summary>
            <param name = "hnsTime"><dd> <p>The time to convert, in 100-nanosecond units.</p> </dd></param>
            <param name = "callbackRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>
            <param name = "unkStateRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The object's <strong>Shutdown</strong> method was called.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:ByteStreamNotSeekable"/></strong></dt> </dl> </td><td> <p>The byte stream is not seekable. The time code cannot be read from the end of the byte stream.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>When the asynchronous method completes, the callback object's <strong>IMFAsyncCallback::Invoke</strong> method is called. At that point, the application must call <strong>IMFTimecodeTranslate::EndConvertHNSToTimecode</strong> to complete the asynchronous request.</p>
            </remarks>
            <doc-id>dd374679</doc-id>
            <unmanaged>HRESULT IMFTimecodeTranslate::BeginConvertHNSToTimecode([In] longlong hnsTime,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState)</unmanaged>
            <unmanaged-short>IMFTimecodeTranslate::BeginConvertHNSToTimecode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimecodeTranslate.EndConvertHNSToTimecode(SharpDX.MediaFoundation.AsyncResult,SharpDX.Win32.Variant)">
            <summary>
            <p>Completes an asynchronous request to convert time in 100-nanosecond units to Society of Motion Picture and Television Engineers (SMPTE) time code.</p>
            </summary>
            <param name = "resultRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>IMFAsyncCallback::Invoke</strong> method.</p> </dd></param>
            <param name = "propVarTimecodeRef"><dd> <p>A reference to a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that receives the converted time. The <strong>vt</strong> member of the <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> structure is set to VT_I8. The <strong>hVal.QuadPart</strong> member contains the converted time in binary coded decimal (BCD) form. See Remarks.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Call this method after the <strong>IMFTimecodeTranslate::BeginConvertHNSToTimecode</strong> method completes asynchronously.</p><p>The value of <em>pPropVarTimecode</em> is a 64-bit unsigned value typed as a <strong>LONGLONG</strong>. The upper <strong><see cref = "T:System.Int32"/></strong> contains the range. (A <em>range</em> is a continuous series of time codes.) The lower <strong><see cref = "T:System.Int32"/></strong> contains the time code in the form of a hexadecimal number <em>0xhhmmssff</em>,  where each 2-byte sequence is read as a decimal value.</p><pre><see cref = "T:SharpDX.Result"/> ParseTimeCode( const <see cref = "T:SharpDX.Win32.Variant"/>&amp; var, <see cref = "T:System.Int32"/> *pdwRange, <see cref = "T:System.Int32"/> *pdwFrames, <see cref = "T:System.Int32"/> *pdwSeconds, <see cref = "T:System.Int32"/> *pdwMinutes, <see cref = "T:System.Int32"/> *pdwHours )
            { if (var.vt != VT_I8) { return E_INVALIDARG; } ULONGLONG ullTimeCode = (ULONGLONG)var.hVal.QuadPart; <see cref = "T:System.Int32"/> dwTimecode = (<see cref = "T:System.Int32"/>)(ullTimeCode &amp; 0xFFFFFFFF); *pdwRange   = (<see cref = "T:System.Int32"/>)(ullTimeCode &gt; &gt; 32); *pdwFrames  =     dwTimecode &amp; 0x0000000F; *pdwFrames  += (( dwTimecode &amp; 0x000000F0) &gt; &gt; 4 )  * 10; *pdwSeconds =   ( dwTimecode &amp; 0x00000F00) &gt; &gt; 8; *pdwSeconds += (( dwTimecode &amp; 0x0000F000) &gt; &gt; 12 ) * 10; *pdwMinutes =   ( dwTimecode &amp; 0x000F0000) &gt; &gt; 16; *pdwMinutes += (( dwTimecode &amp; 0x00F00000) &gt; &gt; 20 ) * 10; *pdwHours   =   ( dwTimecode &amp; 0x0F000000) &gt; &gt; 24; *pdwHours   += (( dwTimecode &amp; 0xF0000000) &gt; &gt; 28 ) * 10; return <see cref = "F:SharpDX.Result.Ok"/>;
            }
            </pre>
            </remarks>
            <doc-id>dd374681</doc-id>
            <unmanaged>HRESULT IMFTimecodeTranslate::EndConvertHNSToTimecode([In] IMFAsyncResult* pResult,[In] PROPVARIANT* pPropVarTimecode)</unmanaged>
            <unmanaged-short>IMFTimecodeTranslate::EndConvertHNSToTimecode</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedText.CueTimeOffset">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the offset to the cue time.</p>
            </summary>
            <doc-id>dn800353</doc-id>
            <unmanaged>GetCueTimeOffset / SetCueTimeOffset</unmanaged>
            <unmanaged-short>GetCueTimeOffset</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedText.Tracks">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Retrieves a list of all timed-text tracks registered with the <strong><see cref = "T:SharpDX.MediaFoundation.TimedText"/></strong>.</p>
            </summary>
            <doc-id>dn859184</doc-id>
            <unmanaged>GetTracks</unmanaged>
            <unmanaged-short>GetTracks</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedText.ActiveTracks">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the list of active timed-text tracks in the timed-text component.</p>
            </summary>
            <doc-id>dn800352</doc-id>
            <unmanaged>GetActiveTracks</unmanaged>
            <unmanaged-short>GetActiveTracks</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedText.TextTracks">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the list of all the timed-text tracks in the timed-text component.</p>
            </summary>
            <doc-id>dn800355</doc-id>
            <unmanaged>GetTextTracks</unmanaged>
            <unmanaged-short>GetTextTracks</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedText.MetadataTracks">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the list of the timed-metadata tracks in the timed-text component.</p>
            </summary>
            <doc-id>dn800354</doc-id>
            <unmanaged>GetMetadataTracks</unmanaged>
            <unmanaged-short>GetMetadataTracks</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedText.InBandEnabled">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Enables or disables inband mode.</p>
            </summary>
            <doc-id>dn800360</doc-id>
            <unmanaged>SetInBandEnabled</unmanaged>
            <unmanaged-short>SetInBandEnabled</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedText.IsInBandEnabled">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether inband mode is enabled.</p>
            </summary>
            <doc-id>dn800356</doc-id>
            <unmanaged>IsInBandEnabled</unmanaged>
            <unmanaged-short>IsInBandEnabled</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedText.RegisterNotifications(SharpDX.MediaFoundation.TimedTextNotify)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Registers a timed-text notify object.</p>
            </summary>
            <param name = "notify"><dd>  <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextNotify"/></strong> interface for the timed-text notify object to register.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800357</doc-id>
            <unmanaged>HRESULT IMFTimedText::RegisterNotifications([In, Optional] IMFTimedTextNotify* notify)</unmanaged>
            <unmanaged-short>IMFTimedText::RegisterNotifications</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedText.SelectTrack(System.Int32,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Selects or deselects a track of text in the timed-text component.</p>
            </summary>
            <param name = "trackId"><dd>  <p>The identifier of the track to select. </p> </dd></param>
            <param name = "selected"><dd>  <p>Specifies whether to select or deselect a track of text. Specify <strong>TRUE</strong> to select the track or <strong><see cref = "F:SharpDX.Result.False"/></strong> to deselect the track. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800358</doc-id>
            <unmanaged>HRESULT IMFTimedText::SelectTrack([In] DWORD trackId,[In] BOOL selected)</unmanaged>
            <unmanaged-short>IMFTimedText::SelectTrack</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedText.AddDataSource(SharpDX.MediaFoundation.IByteStream,System.String,System.String,SharpDX.MediaFoundation.TimedTextTrackKind,SharpDX.Mathematics.Interop.RawBool,System.Int32@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Adds a timed-text data source.</p>
            </summary>
            <param name = "byteStream"><dd>  <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IByteStream"/></strong> interface for the data source to add.</p> </dd></param>
            <param name = "label"><dd>  <p>Null-terminated wide-character string that contains the label of the data source.</p> </dd></param>
            <param name = "language"><dd>  <p>Null-terminated wide-character string that contains the language of the data source.</p> </dd></param>
            <param name = "kind"><dd>  <p>A <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextTrackKind"/></strong>-typed value that specifies the kind of timed-text track.</p> </dd></param>
            <param name = "isDefault"><dd>  <p>Specifies whether to add the default data source. Specify <strong>TRUE</strong> to add the default data source or <strong><see cref = "F:SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>
            <param name = "trackId"><dd>  <p>Receives a reference to the unique identifier for the added track.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800351</doc-id>
            <unmanaged>HRESULT IMFTimedText::AddDataSource([In] IMFByteStream* byteStream,[In, Optional] const wchar_t* label,[In, Optional] const wchar_t* language,[In] MF_TIMED_TEXT_TRACK_KIND kind,[In] BOOL isDefault,[Out] DWORD* trackId)</unmanaged>
            <unmanaged-short>IMFTimedText::AddDataSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedText.AddDataSourceFromUrl(System.String,System.String,System.String,SharpDX.MediaFoundation.TimedTextTrackKind,SharpDX.Mathematics.Interop.RawBool,System.Int32@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Adds a timed-text data source from the specified URL.</p>
            </summary>
            <param name = "url"><dd>  <p>The URL of the timed-text data source.</p> </dd></param>
            <param name = "label"><dd>  <p>Null-terminated wide-character string that contains the label of the data source.</p> </dd></param>
            <param name = "language"><dd>  <p>Null-terminated wide-character string that contains the language of the data source.</p> </dd></param>
            <param name = "kind"><dd>  <p>A <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextTrackKind"/></strong>-typed value that specifies the kind of timed-text track.</p> </dd></param>
            <param name = "isDefault"><dd>  <p>Specifies whether to add the default data source. Specify <strong>TRUE</strong> to add the default data source or <strong><see cref = "F:SharpDX.Result.False"/></strong> otherwise.</p> </dd></param>
            <param name = "trackId"><dd>  <p>Receives a reference to the unique identifier for the added track.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn859183</doc-id>
            <unmanaged>HRESULT IMFTimedText::AddDataSourceFromUrl([In] const wchar_t* url,[In, Optional] const wchar_t* label,[In, Optional] const wchar_t* language,[In] MF_TIMED_TEXT_TRACK_KIND kind,[In] BOOL isDefault,[Out] DWORD* trackId)</unmanaged>
            <unmanaged-short>IMFTimedText::AddDataSourceFromUrl</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedText.AddTrack(System.String,System.String,SharpDX.MediaFoundation.TimedTextTrackKind,SharpDX.MediaFoundation.TimedTextTrack@)">
            <summary>
            No documentation.
            </summary>
            <param name = "label">No documentation.</param>
            <param name = "language">No documentation.</param>
            <param name = "kind">No documentation.</param>
            <param name = "track">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFTimedText::AddTrack([In, Optional] const wchar_t* label,[In, Optional] const wchar_t* language,[In] MF_TIMED_TEXT_TRACK_KIND kind,[Out] IMFTimedTextTrack** track)</unmanaged>
            <unmanaged-short>IMFTimedText::AddTrack</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedText.RemoveTrack(SharpDX.MediaFoundation.TimedTextTrack)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Removes the timed-text track with the specified identifier.</p>
            </summary>
            <param name = "track"><dd>  <p>The identifier of the track to remove.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Get the identifier for a track by calling <strong>GetId</strong>. </p><p>When a track is removed, all buffered data from the track is also removed.</p>
            </remarks>
            <doc-id>dn859185</doc-id>
            <unmanaged>HRESULT IMFTimedText::RemoveTrack([In] IMFTimedTextTrack* track)</unmanaged>
            <unmanaged-short>IMFTimedText::RemoveTrack</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedText.GetCueTimeOffset(System.Double@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the offset to the cue time.</p>
            </summary>
            <param name = "offset"><dd>  <p>A reference to a variable that receives the offset to the cue time.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800353</doc-id>
            <unmanaged>HRESULT IMFTimedText::GetCueTimeOffset([Out] double* offset)</unmanaged>
            <unmanaged-short>IMFTimedText::GetCueTimeOffset</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedText.SetCueTimeOffset(System.Double)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Sets the offset to the cue time.</p>
            </summary>
            <param name = "offset"><dd>  <p>The offset to the cue time.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800359</doc-id>
            <unmanaged>HRESULT IMFTimedText::SetCueTimeOffset([In] double offset)</unmanaged>
            <unmanaged-short>IMFTimedText::SetCueTimeOffset</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedText.GetTracks(SharpDX.MediaFoundation.TimedTextTrackList@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Retrieves a list of all timed-text tracks registered with the <strong><see cref = "T:SharpDX.MediaFoundation.TimedText"/></strong>.</p>
            </summary>
            <param name = "tracks">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn859184</doc-id>
            <unmanaged>HRESULT IMFTimedText::GetTracks([Out] IMFTimedTextTrackList** tracks)</unmanaged>
            <unmanaged-short>IMFTimedText::GetTracks</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedText.GetActiveTracks(SharpDX.MediaFoundation.TimedTextTrackList@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the list of active timed-text tracks in the timed-text component.</p>
            </summary>
            <param name = "activeTracks"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextTrackList"/></strong> interface that can enumerate the list of active timed-text tracks.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800352</doc-id>
            <unmanaged>HRESULT IMFTimedText::GetActiveTracks([Out] IMFTimedTextTrackList** activeTracks)</unmanaged>
            <unmanaged-short>IMFTimedText::GetActiveTracks</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedText.GetTextTracks(SharpDX.MediaFoundation.TimedTextTrackList@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the list of all the timed-text tracks in the timed-text component.</p>
            </summary>
            <param name = "textTracks"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextTrackList"/></strong> interface that can enumerate the list of all of the timed-text tracks.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800355</doc-id>
            <unmanaged>HRESULT IMFTimedText::GetTextTracks([Out] IMFTimedTextTrackList** textTracks)</unmanaged>
            <unmanaged-short>IMFTimedText::GetTextTracks</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedText.GetMetadataTracks(SharpDX.MediaFoundation.TimedTextTrackList@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the list of the timed-metadata tracks in the timed-text component.</p>
            </summary>
            <param name = "metadataTracks"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextTrackList"/></strong> interface that can enumerate the list of the timed-metadata tracks.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800354</doc-id>
            <unmanaged>HRESULT IMFTimedText::GetMetadataTracks([Out] IMFTimedTextTrackList** metadataTracks)</unmanaged>
            <unmanaged-short>IMFTimedText::GetMetadataTracks</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedText.SetInBandEnabled(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Enables or disables inband mode.</p>
            </summary>
            <param name = "enabled"><dd>  <p> Specifies whether inband mode is enabled. If <strong>TRUE</strong>, inband mode is enabled. If <strong><see cref = "F:SharpDX.Result.False"/></strong>, inband mode is disabled. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800360</doc-id>
            <unmanaged>HRESULT IMFTimedText::SetInBandEnabled([In] BOOL enabled)</unmanaged>
            <unmanaged-short>IMFTimedText::SetInBandEnabled</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedText.IsInBandEnabled_">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether inband mode is enabled.</p>
            </summary>
            <returns><p>Returns whether inband mode is enabled. If <strong>TRUE</strong>, inband mode is enabled. If <strong><see cref = "F:SharpDX.Result.False"/></strong>, inband mode is disabled. </p></returns>
            <doc-id>dn800356</doc-id>
            <unmanaged>BOOL IMFTimedText::IsInBandEnabled()</unmanaged>
            <unmanaged-short>IMFTimedText::IsInBandEnabled</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextBinary.GetData(System.Byte[],System.Int32@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the data content of the timed-text object.</p>
            </summary>
            <param name = "data"><dd>  <p>A reference to a memory block that receives a reference to the data content of the timed-text object.</p> </dd></param>
            <param name = "length"><dd>  <p>A reference to a variable that receives the length in bytes of the data content.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800289</doc-id>
            <unmanaged>HRESULT IMFTimedTextBinary::GetData([Out, Buffer] const unsigned char** data,[Out] DWORD* length)</unmanaged>
            <unmanaged-short>IMFTimedTextBinary::GetData</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextCue.Id">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the identifier of a timed-text cue.</p>
            </summary>
            <remarks>
            <p>The identifier is retrieved by this method is dynamically generated by the system and is guaranteed to uniquely identify a cue within a single timed-text track. It is not guaranteed to be unique across tracks. If a cue already has an identifier that is provided in the text-track data format, this ID can be retrieved by calling <strong>GetOriginalId</strong>.</p>
            </remarks>
            <doc-id>dn859177</doc-id>
            <unmanaged>GetId</unmanaged>
            <unmanaged-short>GetId</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextCue.CueKind">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the kind of timed-text cue.</p>
            </summary>
            <doc-id>dn800291</doc-id>
            <unmanaged>GetCueKind</unmanaged>
            <unmanaged-short>GetCueKind</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextCue.StartTime">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the start time of the cue in the track.</p>
            </summary>
            <doc-id>dn800297</doc-id>
            <unmanaged>GetStartTime</unmanaged>
            <unmanaged-short>GetStartTime</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextCue.Duration">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the duration time of the cue in the track.</p>
            </summary>
            <doc-id>dn800293</doc-id>
            <unmanaged>GetDuration</unmanaged>
            <unmanaged-short>GetDuration</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextCue.TrackId">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the identifier of the timed-text cue.</p>
            </summary>
            <doc-id>dn800299</doc-id>
            <unmanaged>GetTrackId</unmanaged>
            <unmanaged-short>GetTrackId</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextCue.Data">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the data content of the timed-text cue.</p>
            </summary>
            <doc-id>dn800292</doc-id>
            <unmanaged>GetData</unmanaged>
            <unmanaged-short>GetData</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextCue.Region">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets info about the display region  of the timed-text cue.</p>
            </summary>
            <doc-id>dn800296</doc-id>
            <unmanaged>GetRegion</unmanaged>
            <unmanaged-short>GetRegion</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextCue.Style">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets info about the style  of the timed-text cue.</p>
            </summary>
            <doc-id>dn800298</doc-id>
            <unmanaged>GetStyle</unmanaged>
            <unmanaged-short>GetStyle</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextCue.LineCount">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the number of lines of text in the timed-text cue.</p>
            </summary>
            <doc-id>dn800295</doc-id>
            <unmanaged>GetLineCount</unmanaged>
            <unmanaged-short>GetLineCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextCue.GetId">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the identifier of a timed-text cue.</p>
            </summary>
            <returns><p>The identifier of a timed-text cue.</p></returns>
            <remarks>
            <p>The identifier is retrieved by this method is dynamically generated by the system and is guaranteed to uniquely identify a cue within a single timed-text track. It is not guaranteed to be unique across tracks. If a cue already has an identifier that is provided in the text-track data format, this ID can be retrieved by calling <strong>GetOriginalId</strong>.</p>
            </remarks>
            <doc-id>dn859177</doc-id>
            <unmanaged>DWORD IMFTimedTextCue::GetId()</unmanaged>
            <unmanaged-short>IMFTimedTextCue::GetId</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextCue.GetOriginalId(System.IntPtr)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the cue identifier that is provided in the text-track data format, if available.</p>
            </summary>
            <param name = "originalId"><dd>  <p>The cue identifier that is provided in the text-track data format.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method retrieves an identifier for the cue that is included in the source data, if one was specified. The system dynamically generates identifiers for cues that are guaranteed to be unique within a single time-text track. To obtain this system-generated ID, call <strong>GetId</strong>.</p>
            </remarks>
            <doc-id>dn859178</doc-id>
            <unmanaged>HRESULT IMFTimedTextCue::GetOriginalId([Out] wchar_t** originalId)</unmanaged>
            <unmanaged-short>IMFTimedTextCue::GetOriginalId</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextCue.GetCueKind">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the kind of timed-text cue.</p>
            </summary>
            <returns><p>Returns a <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextTrackKind"/></strong>-typed value that specifies the kind of timed-text cue.</p></returns>
            <doc-id>dn800291</doc-id>
            <unmanaged>MF_TIMED_TEXT_TRACK_KIND IMFTimedTextCue::GetCueKind()</unmanaged>
            <unmanaged-short>IMFTimedTextCue::GetCueKind</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextCue.GetStartTime">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the start time of the cue in the track.</p>
            </summary>
            <returns><p>Returns the start time of the cue in the track.</p></returns>
            <doc-id>dn800297</doc-id>
            <unmanaged>double IMFTimedTextCue::GetStartTime()</unmanaged>
            <unmanaged-short>IMFTimedTextCue::GetStartTime</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextCue.GetDuration">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the duration time of the cue in the track.</p>
            </summary>
            <returns><p>Returns the duration time of the cue in the track.</p></returns>
            <doc-id>dn800293</doc-id>
            <unmanaged>double IMFTimedTextCue::GetDuration()</unmanaged>
            <unmanaged-short>IMFTimedTextCue::GetDuration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextCue.GetTrackId">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the identifier of the timed-text cue.</p>
            </summary>
            <returns><p>Returns the identifier of the timed-text cue.</p></returns>
            <doc-id>dn800299</doc-id>
            <unmanaged>DWORD IMFTimedTextCue::GetTrackId()</unmanaged>
            <unmanaged-short>IMFTimedTextCue::GetTrackId</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextCue.GetData(SharpDX.MediaFoundation.TimedTextBinary@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the data content of the timed-text cue.</p>
            </summary>
            <param name = "data"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextBinary"/></strong> interface for the data content of the timed-text cue. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800292</doc-id>
            <unmanaged>HRESULT IMFTimedTextCue::GetData([Out, Optional] IMFTimedTextBinary** data)</unmanaged>
            <unmanaged-short>IMFTimedTextCue::GetData</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextCue.GetRegion(SharpDX.MediaFoundation.TimedTextRegion@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets info about the display region  of the timed-text cue.</p>
            </summary>
            <param name = "region"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextRegion"/></strong> interface for the timed-text region. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800296</doc-id>
            <unmanaged>HRESULT IMFTimedTextCue::GetRegion([Out, Optional] IMFTimedTextRegion** region)</unmanaged>
            <unmanaged-short>IMFTimedTextCue::GetRegion</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextCue.GetStyle(SharpDX.MediaFoundation.TimedTextStyle@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets info about the style  of the timed-text cue.</p>
            </summary>
            <param name = "style"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextStyle"/></strong> interface for the timed-text style. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800298</doc-id>
            <unmanaged>HRESULT IMFTimedTextCue::GetStyle([Out, Optional] IMFTimedTextStyle** style)</unmanaged>
            <unmanaged-short>IMFTimedTextCue::GetStyle</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextCue.GetLineCount">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the number of lines of text in the timed-text cue.</p>
            </summary>
            <returns><p>Returns the number of lines of text.</p></returns>
            <doc-id>dn800295</doc-id>
            <unmanaged>DWORD IMFTimedTextCue::GetLineCount()</unmanaged>
            <unmanaged-short>IMFTimedTextCue::GetLineCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextCue.GetLine(System.Int32,SharpDX.MediaFoundation.TimedTextFormattedText@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets a line of text in the cue from the index of the line.</p>
            </summary>
            <param name = "index"><dd>  <p>The index of the line of text in the cue to retrieve. </p> </dd></param>
            <param name = "line"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextFormattedText"/></strong> interface for the line of text in the cue.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800294</doc-id>
            <unmanaged>HRESULT IMFTimedTextCue::GetLine([In] DWORD index,[Out] IMFTimedTextFormattedText** line)</unmanaged>
            <unmanaged-short>IMFTimedTextCue::GetLine</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextCueList.Length">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetLength</unmanaged>
            <unmanaged-short>GetLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextCueList.GetLength">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>DWORD IMFTimedTextCueList::GetLength()</unmanaged>
            <unmanaged-short>IMFTimedTextCueList::GetLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextCueList.GetCueByIndex(System.Int32,SharpDX.MediaFoundation.TimedTextCue@)">
            <summary>
            No documentation.
            </summary>
            <param name = "index">No documentation.</param>
            <param name = "cue">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFTimedTextCueList::GetCueByIndex([In] DWORD index,[Out] IMFTimedTextCue** cue)</unmanaged>
            <unmanaged-short>IMFTimedTextCueList::GetCueByIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextCueList.GetCueById(System.Int32,SharpDX.MediaFoundation.TimedTextCue@)">
            <summary>
            No documentation.
            </summary>
            <param name = "id">No documentation.</param>
            <param name = "cue">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFTimedTextCueList::GetCueById([In] DWORD id,[Out] IMFTimedTextCue** cue)</unmanaged>
            <unmanaged-short>IMFTimedTextCueList::GetCueById</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextCueList.GetCueByOriginalId(System.String,SharpDX.MediaFoundation.TimedTextCue@)">
            <summary>
            No documentation.
            </summary>
            <param name = "originalId">No documentation.</param>
            <param name = "cue">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFTimedTextCueList::GetCueByOriginalId([In] const wchar_t* originalId,[Out] IMFTimedTextCue** cue)</unmanaged>
            <unmanaged-short>IMFTimedTextCueList::GetCueByOriginalId</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextCueList.AddTextCue(System.Double,System.Double,System.String,SharpDX.MediaFoundation.TimedTextCue@)">
            <summary>
            No documentation.
            </summary>
            <param name = "start">No documentation.</param>
            <param name = "duration">No documentation.</param>
            <param name = "text">No documentation.</param>
            <param name = "cue">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFTimedTextCueList::AddTextCue([In] double start,[In] double duration,[In] const wchar_t* text,[Out, Optional] IMFTimedTextCue** cue)</unmanaged>
            <unmanaged-short>IMFTimedTextCueList::AddTextCue</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextCueList.AddDataCue(System.Double,System.Double,System.Byte[],System.Int32,SharpDX.MediaFoundation.TimedTextCue@)">
            <summary>
            No documentation.
            </summary>
            <param name = "start">No documentation.</param>
            <param name = "duration">No documentation.</param>
            <param name = "data">No documentation.</param>
            <param name = "dataSize">No documentation.</param>
            <param name = "cue">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFTimedTextCueList::AddDataCue([In] double start,[In] double duration,[In, Buffer] const unsigned char* data,[In] DWORD dataSize,[Out, Optional] IMFTimedTextCue** cue)</unmanaged>
            <unmanaged-short>IMFTimedTextCueList::AddDataCue</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextCueList.RemoveCue(SharpDX.MediaFoundation.TimedTextCue)">
            <summary>
            No documentation.
            </summary>
            <param name = "cue">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFTimedTextCueList::RemoveCue([In] IMFTimedTextCue* cue)</unmanaged>
            <unmanaged-short>IMFTimedTextCueList::RemoveCue</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextFormattedText.SubformattingCount">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the number of subformats in the formatted timed-text object.</p>
            </summary>
            <doc-id>dn800302</doc-id>
            <unmanaged>GetSubformattingCount</unmanaged>
            <unmanaged-short>GetSubformattingCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextFormattedText.GetText(System.IntPtr)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the text in the formatted timed-text object.</p>
            </summary>
            <param name = "text"><dd>  <p>A reference to a variable that receives the null-terminated wide-character string that contains the text.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800303</doc-id>
            <unmanaged>HRESULT IMFTimedTextFormattedText::GetText([Out, Optional] wchar_t** text)</unmanaged>
            <unmanaged-short>IMFTimedTextFormattedText::GetText</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextFormattedText.GetSubformattingCount">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the number of subformats in the formatted timed-text object.</p>
            </summary>
            <returns><p>Returns the number of subformats. </p></returns>
            <doc-id>dn800302</doc-id>
            <unmanaged>DWORD IMFTimedTextFormattedText::GetSubformattingCount()</unmanaged>
            <unmanaged-short>IMFTimedTextFormattedText::GetSubformattingCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextFormattedText.GetSubformatting(System.Int32,System.Int32@,System.Int32@,SharpDX.MediaFoundation.TimedTextStyle@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets a subformat in the formatted timed-text object.</p>
            </summary>
            <param name = "index"><dd>  <p>The index of the subformat in the formatted timed-text object.</p> </dd></param>
            <param name = "firstChar"><dd>  <p>A reference to a variable that receives the first character of the subformat. </p> </dd></param>
            <param name = "charLength"><dd>  <p>A reference to a variable that receives the length, in characters, of the subformat. </p> </dd></param>
            <param name = "style"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextStyle"/></strong> interface for the subformat's timed-text style. This parameter can be <strong><c>null</c></strong>. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800301</doc-id>
            <unmanaged>HRESULT IMFTimedTextFormattedText::GetSubformatting([In] DWORD index,[Out] DWORD* firstChar,[Out] DWORD* charLength,[Out, Optional] IMFTimedTextStyle** style)</unmanaged>
            <unmanaged-short>IMFTimedTextFormattedText::GetSubformatting</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextNotify.TrackAdded(System.Int32)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called when a text track is added</p>
            </summary>
            <param name = "trackId"><dd>  <p>The identifier of the track that was added. </p> </dd></param>
            <doc-id>dn800308</doc-id>
            <unmanaged>void IMFTimedTextNotify::TrackAdded([In] DWORD trackId)</unmanaged>
            <unmanaged-short>IMFTimedTextNotify::TrackAdded</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextNotify.TrackRemoved(System.Int32)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called when a text track is removed.</p>
            </summary>
            <param name = "trackId"><dd>  <p>The identifier of the track that was removed. </p> </dd></param>
            <doc-id>dn800309</doc-id>
            <unmanaged>void IMFTimedTextNotify::TrackRemoved([In] DWORD trackId)</unmanaged>
            <unmanaged-short>IMFTimedTextNotify::TrackRemoved</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextNotify.TrackSelected(System.Int32,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called when a track is selected or deselected.</p>
            </summary>
            <param name = "trackId"><dd>  <p>The identifier of the track that was selected or deselected. </p> </dd></param>
            <param name = "selected"><dd>  <p><strong>TRUE</strong> if the track was selected. <strong><see cref = "F:SharpDX.Result.False"/></strong> if the track was deselected. </p> </dd></param>
            <doc-id>dn800310</doc-id>
            <unmanaged>void IMFTimedTextNotify::TrackSelected([In] DWORD trackId,[In] BOOL selected)</unmanaged>
            <unmanaged-short>IMFTimedTextNotify::TrackSelected</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextNotify.TrackReadyStateChanged(System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "trackId">No documentation.</param>
            <unmanaged>void IMFTimedTextNotify::TrackReadyStateChanged([In] DWORD trackId)</unmanaged>
            <unmanaged-short>IMFTimedTextNotify::TrackReadyStateChanged</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextNotify.Error(SharpDX.MediaFoundation.TimedTextErrorCode,SharpDX.Result,System.Int32)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called when an error occurs in a text track.</p>
            </summary>
            <param name = "errorCode"><dd>  <p>An <see cref = "T:SharpDX.MediaFoundation.TimedTextErrorCode"/> representing the last error.</p> </dd></param>
            <param name = "extendedErrorCode"><dd>  <p>The extended error code for the last error.</p> </dd></param>
            <param name = "sourceTrackId"><dd>  <p>The identifier of the track on which the error occurred.</p> </dd></param>
            <doc-id>dn800306</doc-id>
            <unmanaged>void IMFTimedTextNotify::Error([In] MF_TIMED_TEXT_ERROR_CODE errorCode,[In] HRESULT extendedErrorCode,[In] DWORD sourceTrackId)</unmanaged>
            <unmanaged-short>IMFTimedTextNotify::Error</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextNotify.Cue(SharpDX.MediaFoundation.TimedTextCueEvent,System.Double,SharpDX.MediaFoundation.TimedTextCue)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Called when a cue event occurs in a text track.</p>
            </summary>
            <param name = "cueEvent"><dd>  <p>A value specifying the type of event that has occured.</p> </dd></param>
            <param name = "currentTime"><dd>  <p>The current time when the cue event occurred.</p> </dd></param>
            <param name = "cue"><dd>  <p>The <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextCue"/></strong> object representing the cue.</p> </dd></param>
            <doc-id>dn800305</doc-id>
            <unmanaged>void IMFTimedTextNotify::Cue([In] MF_TIMED_TEXT_CUE_EVENT cueEvent,[In] double currentTime,[In, Optional] IMFTimedTextCue* cue)</unmanaged>
            <unmanaged-short>IMFTimedTextNotify::Cue</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextNotify.Reset">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Resets the timed-text-notify object.</p>
            </summary>
            <doc-id>dn800307</doc-id>
            <unmanaged>void IMFTimedTextNotify::Reset()</unmanaged>
            <unmanaged-short>IMFTimedTextNotify::Reset</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextRegion.BackgroundColor">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the background color of the region.</p>
            </summary>
            <doc-id>dn800312</doc-id>
            <unmanaged>GetBackgroundColor</unmanaged>
            <unmanaged-short>GetBackgroundColor</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextRegion.WritingMode">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the writing mode of the region.</p>
            </summary>
            <doc-id>dn800322</doc-id>
            <unmanaged>GetWritingMode</unmanaged>
            <unmanaged-short>GetWritingMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextRegion.DisplayAlignment">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the display alignment of the region.</p>
            </summary>
            <doc-id>dn800314</doc-id>
            <unmanaged>GetDisplayAlignment</unmanaged>
            <unmanaged-short>GetDisplayAlignment</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextRegion.ClipOverflow">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether a clip of text overflowed the region.</p>
            </summary>
            <doc-id>dn800313</doc-id>
            <unmanaged>GetClipOverflow</unmanaged>
            <unmanaged-short>GetClipOverflow</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextRegion.Wrap">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the word wrap feature is enabled in the region.</p>
            </summary>
            <doc-id>dn800321</doc-id>
            <unmanaged>GetWrap</unmanaged>
            <unmanaged-short>GetWrap</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextRegion.ZIndex">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the Z-index (depth) of the region.</p>
            </summary>
            <doc-id>dn800323</doc-id>
            <unmanaged>GetZIndex</unmanaged>
            <unmanaged-short>GetZIndex</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextRegion.ScrollMode">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the scroll mode of the region.</p>
            </summary>
            <doc-id>dn800320</doc-id>
            <unmanaged>GetScrollMode</unmanaged>
            <unmanaged-short>GetScrollMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextRegion.GetName(System.IntPtr)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the name of the region.</p>
            </summary>
            <param name = "name"><dd>  <p>A reference to a variable that receives the null-terminated wide-character string that contains the name of the region.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800317</doc-id>
            <unmanaged>HRESULT IMFTimedTextRegion::GetName([Out] wchar_t** name)</unmanaged>
            <unmanaged-short>IMFTimedTextRegion::GetName</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextRegion.GetPosition(System.Double@,System.Double@,SharpDX.MediaFoundation.TimedTextUnitType@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the position of the region.</p>
            </summary>
            <param name = "xRef"><dd>  <p>A reference to a variable that receives the X-coordinate of the position.</p> </dd></param>
            <param name = "yRef"><dd>  <p>A reference to a variable that receives the Y-coordinate of the position.</p> </dd></param>
            <param name = "unitType"><dd>  <p>A reference to a variable that receives a <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextUnitType"/></strong>-typed value that specifies the units in which the timed-text region is measured.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800319</doc-id>
            <unmanaged>HRESULT IMFTimedTextRegion::GetPosition([Out] double* pX,[Out] double* pY,[Out] MF_TIMED_TEXT_UNIT_TYPE* unitType)</unmanaged>
            <unmanaged-short>IMFTimedTextRegion::GetPosition</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextRegion.GetExtent(System.Double@,System.Double@,SharpDX.MediaFoundation.TimedTextUnitType@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the extent of the region.</p>
            </summary>
            <param name = "widthRef"><dd>  <p>A reference to a variable that receives the width of the region.</p> </dd></param>
            <param name = "heightRef"><dd>  <p>A reference to a variable that receives the height of the region.</p> </dd></param>
            <param name = "unitType"><dd>  <p>A reference to a variable that receives a <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextUnitType"/></strong>-typed value that specifies the units in which the timed-text region is measured.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800315</doc-id>
            <unmanaged>HRESULT IMFTimedTextRegion::GetExtent([Out] double* pWidth,[Out] double* pHeight,[Out] MF_TIMED_TEXT_UNIT_TYPE* unitType)</unmanaged>
            <unmanaged-short>IMFTimedTextRegion::GetExtent</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextRegion.GetBackgroundColor(SharpDX.Mathematics.Interop.RawColorBGRA@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the background color of the region.</p>
            </summary>
            <param name = "bgColor"><dd>  <p>A reference to a variable that receives a <strong><see cref = "T:SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> structure that describes the background color.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800312</doc-id>
            <unmanaged>HRESULT IMFTimedTextRegion::GetBackgroundColor([Out] MFARGB* bgColor)</unmanaged>
            <unmanaged-short>IMFTimedTextRegion::GetBackgroundColor</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextRegion.GetWritingMode(SharpDX.MediaFoundation.TimedTextWritingMode@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the writing mode of the region.</p>
            </summary>
            <param name = "writingMode"><dd>  <p>A reference to a variable that receives a <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextWritingMode"/></strong>-typed value that specifies the writing mode of the region.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800322</doc-id>
            <unmanaged>HRESULT IMFTimedTextRegion::GetWritingMode([Out] MF_TIMED_TEXT_WRITING_MODE* writingMode)</unmanaged>
            <unmanaged-short>IMFTimedTextRegion::GetWritingMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextRegion.GetDisplayAlignment(SharpDX.MediaFoundation.TimedTextDisplayAlignment@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the display alignment of the region.</p>
            </summary>
            <param name = "displayAlign"><dd>  <p>A reference to a variable that receives a <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextDisplayAlignment"/></strong>-typed value that specifies the display alignment of the region.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800314</doc-id>
            <unmanaged>HRESULT IMFTimedTextRegion::GetDisplayAlignment([Out] MF_TIMED_TEXT_DISPLAY_ALIGNMENT* displayAlign)</unmanaged>
            <unmanaged-short>IMFTimedTextRegion::GetDisplayAlignment</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextRegion.GetLineHeight(System.Double@,SharpDX.MediaFoundation.TimedTextUnitType@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the height of each line of text in the region.</p>
            </summary>
            <param name = "lineHeightRef"><dd>  <p>A reference to a variable that receives the height of each line of text in the region.</p> </dd></param>
            <param name = "unitType"><dd>  <p>A reference to a variable that receives a <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextUnitType"/></strong>-typed value that specifies the units in which the timed-text region is measured.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800316</doc-id>
            <unmanaged>HRESULT IMFTimedTextRegion::GetLineHeight([Out] double* pLineHeight,[Out] MF_TIMED_TEXT_UNIT_TYPE* unitType)</unmanaged>
            <unmanaged-short>IMFTimedTextRegion::GetLineHeight</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextRegion.GetClipOverflow(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether a clip of text overflowed the region.</p>
            </summary>
            <param name = "clipOverflow"><dd>  <p>A reference to a variable that receives a value that specifies whether a clip of text overflowed the region. The variable specifies <strong>TRUE</strong> if the clip overflowed; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800313</doc-id>
            <unmanaged>HRESULT IMFTimedTextRegion::GetClipOverflow([Out] BOOL* clipOverflow)</unmanaged>
            <unmanaged-short>IMFTimedTextRegion::GetClipOverflow</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextRegion.GetPadding(System.Double@,System.Double@,System.Double@,System.Double@,SharpDX.MediaFoundation.TimedTextUnitType@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the padding that surrounds the region.</p>
            </summary>
            <param name = "before"><dd>  <p>A reference to a variable that receives the padding before the start of the region.</p> </dd></param>
            <param name = "start"><dd>  <p>A reference to a variable that receives the start of the region.</p> </dd></param>
            <param name = "after"><dd>  <p>A reference to a variable that receives the padding after the end of the region.</p> </dd></param>
            <param name = "end"><dd>  <p>A reference to a variable that receives the end of the region.</p> </dd></param>
            <param name = "unitType"><dd>  <p>A reference to a variable that receives a <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextUnitType"/></strong>-typed value that specifies the units in which the timed-text region is measured.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800318</doc-id>
            <unmanaged>HRESULT IMFTimedTextRegion::GetPadding([Out] double* before,[Out] double* start,[Out] double* after,[Out] double* end,[Out] MF_TIMED_TEXT_UNIT_TYPE* unitType)</unmanaged>
            <unmanaged-short>IMFTimedTextRegion::GetPadding</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextRegion.GetWrap(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the word wrap feature is enabled in the region.</p>
            </summary>
            <param name = "wrap"><dd>  <p>A reference to a variable that receives a value that specifies whether the word wrap feature is enabled in the region. The variable specifies <strong>TRUE</strong> if word wrap is enabled; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800321</doc-id>
            <unmanaged>HRESULT IMFTimedTextRegion::GetWrap([Out] BOOL* wrap)</unmanaged>
            <unmanaged-short>IMFTimedTextRegion::GetWrap</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextRegion.GetZIndex(System.Int32@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the Z-index (depth) of the region.</p>
            </summary>
            <param name = "zIndex"><dd>  <p>A reference to a variable that receives the Z-index (depth) of the region.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800323</doc-id>
            <unmanaged>HRESULT IMFTimedTextRegion::GetZIndex([Out] int* zIndex)</unmanaged>
            <unmanaged-short>IMFTimedTextRegion::GetZIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextRegion.GetScrollMode(SharpDX.MediaFoundation.TimedTextScrollMode@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the scroll mode of the region.</p>
            </summary>
            <param name = "scrollMode"><dd>  <p>A reference to a variable that receives a <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextScrollMode"/></strong>-typed value that specifies the scroll mode of the region.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800320</doc-id>
            <unmanaged>HRESULT IMFTimedTextRegion::GetScrollMode([Out] MF_TIMED_TEXT_SCROLL_MODE* scrollMode)</unmanaged>
            <unmanaged-short>IMFTimedTextRegion::GetScrollMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextStyle.IsExternal">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the timed-text style is external.</p>
            </summary>
            <doc-id>dn800338</doc-id>
            <unmanaged>IsExternal</unmanaged>
            <unmanaged-short>IsExternal</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextStyle.Color">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the color of the timed-text style.</p>
            </summary>
            <doc-id>dn800327</doc-id>
            <unmanaged>GetColor</unmanaged>
            <unmanaged-short>GetColor</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextStyle.BackgroundColor">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the background color of the timed-text style.</p>
            </summary>
            <doc-id>dn800325</doc-id>
            <unmanaged>GetBackgroundColor</unmanaged>
            <unmanaged-short>GetBackgroundColor</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextStyle.ShowBackgroundAlways">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the style  of timed text always shows the background.</p>
            </summary>
            <doc-id>dn800334</doc-id>
            <unmanaged>GetShowBackgroundAlways</unmanaged>
            <unmanaged-short>GetShowBackgroundAlways</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextStyle.FontStyle">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the font style of the timed-text style.</p>
            </summary>
            <doc-id>dn800330</doc-id>
            <unmanaged>GetFontStyle</unmanaged>
            <unmanaged-short>GetFontStyle</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextStyle.Bold">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the style  of timed text is bold.</p>
            </summary>
            <doc-id>dn800326</doc-id>
            <unmanaged>GetBold</unmanaged>
            <unmanaged-short>GetBold</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextStyle.RightToLeft">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the right to left writing mode of the timed-text style  is enabled.</p>
            </summary>
            <doc-id>dn800332</doc-id>
            <unmanaged>GetRightToLeft</unmanaged>
            <unmanaged-short>GetRightToLeft</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextStyle.TextAlignment">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the text alignment of the timed-text style.</p>
            </summary>
            <doc-id>dn800335</doc-id>
            <unmanaged>GetTextAlignment</unmanaged>
            <unmanaged-short>GetTextAlignment</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextStyle.TextDecoration">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets how text is decorated for the timed-text style.</p>
            </summary>
            <doc-id>dn800336</doc-id>
            <unmanaged>GetTextDecoration</unmanaged>
            <unmanaged-short>GetTextDecoration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextStyle.GetName(System.IntPtr)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the name of the timed-text style.</p>
            </summary>
            <param name = "name"><dd>  <p>A reference to a variable that receives the null-terminated wide-character string that contains the name of the style.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800331</doc-id>
            <unmanaged>HRESULT IMFTimedTextStyle::GetName([Out] wchar_t** name)</unmanaged>
            <unmanaged-short>IMFTimedTextStyle::GetName</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextStyle.IsExternal_">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the timed-text style is external.</p>
            </summary>
            <returns><p>Returns whether the timed-text style is external. If <strong>TRUE</strong>, the timed-text style is external; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>. </p></returns>
            <doc-id>dn800338</doc-id>
            <unmanaged>BOOL IMFTimedTextStyle::IsExternal()</unmanaged>
            <unmanaged-short>IMFTimedTextStyle::IsExternal</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextStyle.GetFontFamily(System.IntPtr)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the font family of the timed-text style.</p>
            </summary>
            <param name = "fontFamily"><dd>  <p>A reference to a variable that receives the null-terminated wide-character string that contains the font family of the style.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800328</doc-id>
            <unmanaged>HRESULT IMFTimedTextStyle::GetFontFamily([Out] wchar_t** fontFamily)</unmanaged>
            <unmanaged-short>IMFTimedTextStyle::GetFontFamily</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextStyle.GetFontSize(System.Double@,SharpDX.MediaFoundation.TimedTextUnitType@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the font size  of the timed-text style.</p>
            </summary>
            <param name = "fontSize"><dd>  <p>A reference to a variable that receives the font size  of the timed-text style.</p> </dd></param>
            <param name = "unitType"><dd>  <p>A reference to a variable that receives a <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextUnitType"/></strong>-typed value that specifies the units in which the timed-text style is measured.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800329</doc-id>
            <unmanaged>HRESULT IMFTimedTextStyle::GetFontSize([Out] double* fontSize,[Out] MF_TIMED_TEXT_UNIT_TYPE* unitType)</unmanaged>
            <unmanaged-short>IMFTimedTextStyle::GetFontSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextStyle.GetColor(SharpDX.Mathematics.Interop.RawColorBGRA@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the color of the timed-text style.</p>
            </summary>
            <param name = "color"><dd>  <p>A reference to a variable that receives a <strong><see cref = "T:SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> structure that describes the color.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800327</doc-id>
            <unmanaged>HRESULT IMFTimedTextStyle::GetColor([Out] MFARGB* color)</unmanaged>
            <unmanaged-short>IMFTimedTextStyle::GetColor</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextStyle.GetBackgroundColor(SharpDX.Mathematics.Interop.RawColorBGRA@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the background color of the timed-text style.</p>
            </summary>
            <param name = "bgColor"><dd>  <p>A reference to a variable that receives a <strong><see cref = "T:SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> structure that describes the background color.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800325</doc-id>
            <unmanaged>HRESULT IMFTimedTextStyle::GetBackgroundColor([Out] MFARGB* bgColor)</unmanaged>
            <unmanaged-short>IMFTimedTextStyle::GetBackgroundColor</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextStyle.GetShowBackgroundAlways(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the style  of timed text always shows the background.</p>
            </summary>
            <param name = "showBackgroundAlways"><dd>  <p>A reference to a variable that receives a value that specifies whether the style  of timed text always shows the background. The variable specifies <strong>TRUE</strong> if the background is always shown; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800334</doc-id>
            <unmanaged>HRESULT IMFTimedTextStyle::GetShowBackgroundAlways([Out] BOOL* showBackgroundAlways)</unmanaged>
            <unmanaged-short>IMFTimedTextStyle::GetShowBackgroundAlways</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextStyle.GetFontStyle(SharpDX.MediaFoundation.TimedTextFontStyle@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the font style of the timed-text style.</p>
            </summary>
            <param name = "fontStyle"><dd>  <p>A reference to a variable that receives a <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextFontStyle"/></strong>-typed value that specifies the font style.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800330</doc-id>
            <unmanaged>HRESULT IMFTimedTextStyle::GetFontStyle([Out] MF_TIMED_TEXT_FONT_STYLE* fontStyle)</unmanaged>
            <unmanaged-short>IMFTimedTextStyle::GetFontStyle</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextStyle.GetBold(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the style  of timed text is bold.</p>
            </summary>
            <param name = "bold"><dd>  <p>A reference to a variable that receives a value that specifies whether the style  of timed text is bold. The variable specifies <strong>TRUE</strong> if the style is bold; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800326</doc-id>
            <unmanaged>HRESULT IMFTimedTextStyle::GetBold([Out] BOOL* bold)</unmanaged>
            <unmanaged-short>IMFTimedTextStyle::GetBold</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextStyle.GetRightToLeft(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the right to left writing mode of the timed-text style  is enabled.</p>
            </summary>
            <param name = "rightToLeft"><dd>  <p>A reference to a variable that receives a value that specifies whether the right to left writing mode is enabled. The variable specifies <strong>TRUE</strong> if the right to left writing mode is enabled; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800332</doc-id>
            <unmanaged>HRESULT IMFTimedTextStyle::GetRightToLeft([Out] BOOL* rightToLeft)</unmanaged>
            <unmanaged-short>IMFTimedTextStyle::GetRightToLeft</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextStyle.GetTextAlignment(SharpDX.MediaFoundation.TimedTextAlignment@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the text alignment of the timed-text style.</p>
            </summary>
            <param name = "textAlign"><dd>  <p>A reference to a variable that receives a <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextAlignment"/></strong>-typed value that specifies the text alignment.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800335</doc-id>
            <unmanaged>HRESULT IMFTimedTextStyle::GetTextAlignment([Out] MF_TIMED_TEXT_ALIGNMENT* textAlign)</unmanaged>
            <unmanaged-short>IMFTimedTextStyle::GetTextAlignment</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextStyle.GetTextDecoration(System.Int32@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets how text is decorated for the timed-text style.</p>
            </summary>
            <param name = "textDecoration"><dd>  <p>A reference to a variable that receives a combination of <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextDecoration"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies how text is decorated.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800336</doc-id>
            <unmanaged>HRESULT IMFTimedTextStyle::GetTextDecoration([Out] DWORD* textDecoration)</unmanaged>
            <unmanaged-short>IMFTimedTextStyle::GetTextDecoration</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextStyle.GetTextOutline(SharpDX.Mathematics.Interop.RawColorBGRA@,System.Double@,System.Double@,SharpDX.MediaFoundation.TimedTextUnitType@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the text outline for the timed-text style.</p>
            </summary>
            <param name = "color"><dd>  <p>A reference to a variable that receives a <strong><see cref = "T:SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> structure that describes the color.</p> </dd></param>
            <param name = "thickness"><dd>  <p>A reference to a variable that receives the thickness.</p> </dd></param>
            <param name = "blurRadius"><dd>  <p>A reference to a variable that receives the blur radius.</p> </dd></param>
            <param name = "unitType"><dd>  <p>A reference to a variable that receives a <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextUnitType"/></strong>-typed value that specifies the units in which the timed-text is measured.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800337</doc-id>
            <unmanaged>HRESULT IMFTimedTextStyle::GetTextOutline([Out] MFARGB* color,[Out] double* thickness,[Out] double* blurRadius,[Out] MF_TIMED_TEXT_UNIT_TYPE* unitType)</unmanaged>
            <unmanaged-short>IMFTimedTextStyle::GetTextOutline</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextTrack.Id">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the identifier of the track of timed text.</p>
            </summary>
            <doc-id>dn800344</doc-id>
            <unmanaged>GetId</unmanaged>
            <unmanaged-short>GetId</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextTrack.TrackKind">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the kind of timed-text track.</p>
            </summary>
            <doc-id>dn800348</doc-id>
            <unmanaged>GetTrackKind</unmanaged>
            <unmanaged-short>GetTrackKind</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextTrack.IsInBand">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the timed-text track is inband.</p>
            </summary>
            <doc-id>dn800350</doc-id>
            <unmanaged>IsInBand</unmanaged>
            <unmanaged-short>IsInBand</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextTrack.IsActive">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the timed-text track is active.</p>
            </summary>
            <doc-id>dn800349</doc-id>
            <unmanaged>IsActive</unmanaged>
            <unmanaged-short>IsActive</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextTrack.ErrorCode">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets a value indicating the error type of the latest error associated with the track.</p>
            </summary>
            <doc-id>dn859180</doc-id>
            <unmanaged>GetErrorCode</unmanaged>
            <unmanaged-short>GetErrorCode</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextTrack.ExtendedErrorCode">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the extended error code for the latest error associated with the track.</p>
            </summary>
            <remarks>
            <p>If the most recent error was associated with a track, this value will be the same <strong><see cref = "T:SharpDX.Result"/></strong> as returned by the <strong>IMFTimedTextNotify::Error</strong> method.</p>
            </remarks>
            <doc-id>dn859181</doc-id>
            <unmanaged>GetExtendedErrorCode</unmanaged>
            <unmanaged-short>GetExtendedErrorCode</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextTrack.DataFormat">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets a <see cref = "T:System.Guid"/> that identifies the track's underlying data format.</p>
            </summary>
            <doc-id>dn859179</doc-id>
            <unmanaged>GetDataFormat</unmanaged>
            <unmanaged-short>GetDataFormat</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextTrack.ReadyState">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetReadyState</unmanaged>
            <unmanaged-short>GetReadyState</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextTrack.CueList">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetCueList</unmanaged>
            <unmanaged-short>GetCueList</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextTrack.GetId">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the identifier of the track of timed text.</p>
            </summary>
            <returns><p>Returns the identifier of the track. </p></returns>
            <doc-id>dn800344</doc-id>
            <unmanaged>DWORD IMFTimedTextTrack::GetId()</unmanaged>
            <unmanaged-short>IMFTimedTextTrack::GetId</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextTrack.GetLabel(System.IntPtr)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the label of the track.</p>
            </summary>
            <param name = "label"><dd>  <p>A reference to a variable that receives the null-terminated wide-character string that contains the label of the track.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800346</doc-id>
            <unmanaged>HRESULT IMFTimedTextTrack::GetLabel([Out] wchar_t** label)</unmanaged>
            <unmanaged-short>IMFTimedTextTrack::GetLabel</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextTrack.SetLabel(System.String)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Sets the label of a timed-text track.</p>
            </summary>
            <param name = "label"><dd>  <p>A reference to a null-terminated wide-character string that contains the label of the track.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn859182</doc-id>
            <unmanaged>HRESULT IMFTimedTextTrack::SetLabel([In] const wchar_t* label)</unmanaged>
            <unmanaged-short>IMFTimedTextTrack::SetLabel</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextTrack.GetLanguage(System.IntPtr)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the language of the track.</p>
            </summary>
            <param name = "language"><dd>  <p>A reference to a variable that receives the null-terminated wide-character string that contains the language of the track.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800347</doc-id>
            <unmanaged>HRESULT IMFTimedTextTrack::GetLanguage([Out] wchar_t** language)</unmanaged>
            <unmanaged-short>IMFTimedTextTrack::GetLanguage</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextTrack.GetTrackKind">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the kind of timed-text track.</p>
            </summary>
            <returns><p>Returns a <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextTrackKind"/></strong>-typed value that specifies the kind of timed-text track.</p></returns>
            <doc-id>dn800348</doc-id>
            <unmanaged>MF_TIMED_TEXT_TRACK_KIND IMFTimedTextTrack::GetTrackKind()</unmanaged>
            <unmanaged-short>IMFTimedTextTrack::GetTrackKind</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextTrack.IsInBand_">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the timed-text track is inband.</p>
            </summary>
            <returns><p>Returns whether the timed-text track is inband. If <strong>TRUE</strong>, the timed-text track is inband; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>. </p></returns>
            <doc-id>dn800350</doc-id>
            <unmanaged>BOOL IMFTimedTextTrack::IsInBand()</unmanaged>
            <unmanaged-short>IMFTimedTextTrack::IsInBand</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextTrack.GetInBandMetadataTrackDispatchType(System.IntPtr)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the in-band metadata of the track.</p>
            </summary>
            <param name = "dispatchType"><dd>  <p>A reference to a variable that receives the null-terminated wide-character string that contains the in-band metadata of the track.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800345</doc-id>
            <unmanaged>HRESULT IMFTimedTextTrack::GetInBandMetadataTrackDispatchType([Out] wchar_t** dispatchType)</unmanaged>
            <unmanaged-short>IMFTimedTextTrack::GetInBandMetadataTrackDispatchType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextTrack.IsActive_">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Determines whether the timed-text track is active.</p>
            </summary>
            <returns><p>Returns whether the timed-text track is active. If <strong>TRUE</strong>, the timed-text track is active; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>. </p></returns>
            <doc-id>dn800349</doc-id>
            <unmanaged>BOOL IMFTimedTextTrack::IsActive()</unmanaged>
            <unmanaged-short>IMFTimedTextTrack::IsActive</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextTrack.GetErrorCode">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets a value indicating the error type of the latest error associated with the track.</p>
            </summary>
            <returns><p>A value indicating the error type of the latest error associated with the track.</p></returns>
            <doc-id>dn859180</doc-id>
            <unmanaged>MF_TIMED_TEXT_ERROR_CODE IMFTimedTextTrack::GetErrorCode()</unmanaged>
            <unmanaged-short>IMFTimedTextTrack::GetErrorCode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextTrack.GetExtendedErrorCode">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the extended error code for the latest error associated with the track.</p>
            </summary>
            <returns><p>The extended error code for the latest error associated with the track.</p></returns>
            <remarks>
            <p>If the most recent error was associated with a track, this value will be the same <strong><see cref = "T:SharpDX.Result"/></strong> as returned by the <strong>IMFTimedTextNotify::Error</strong> method.</p>
            </remarks>
            <doc-id>dn859181</doc-id>
            <unmanaged>HRESULT IMFTimedTextTrack::GetExtendedErrorCode()</unmanaged>
            <unmanaged-short>IMFTimedTextTrack::GetExtendedErrorCode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextTrack.GetDataFormat(System.Guid@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets a <see cref = "T:System.Guid"/> that identifies the track's underlying data format.</p>
            </summary>
            <param name = "format"><dd>  <p>A <see cref = "T:System.Guid"/> that identifies the track's underlying data format.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn859179</doc-id>
            <unmanaged>HRESULT IMFTimedTextTrack::GetDataFormat([Out] GUID* format)</unmanaged>
            <unmanaged-short>IMFTimedTextTrack::GetDataFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextTrack.GetReadyState">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>MF_TIMED_TEXT_TRACK_READY_STATE IMFTimedTextTrack::GetReadyState()</unmanaged>
            <unmanaged-short>IMFTimedTextTrack::GetReadyState</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextTrack.GetCueList(SharpDX.MediaFoundation.TimedTextCueList@)">
            <summary>
            No documentation.
            </summary>
            <param name = "cues">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IMFTimedTextTrack::GetCueList([Out] IMFTimedTextCueList** cues)</unmanaged>
            <unmanaged-short>IMFTimedTextTrack::GetCueList</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TimedTextTrackList.Length">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the length, in tracks, of the timed-text-track list.</p>
            </summary>
            <doc-id>dn800341</doc-id>
            <unmanaged>GetLength</unmanaged>
            <unmanaged-short>GetLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextTrackList.GetLength">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets the length, in tracks, of the timed-text-track list.</p>
            </summary>
            <returns><p>Returns the length, in tracks, of the timed-text-track list.</p></returns>
            <doc-id>dn800341</doc-id>
            <unmanaged>DWORD IMFTimedTextTrackList::GetLength()</unmanaged>
            <unmanaged-short>IMFTimedTextTrackList::GetLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextTrackList.GetTrack(System.Int32,SharpDX.MediaFoundation.TimedTextTrack@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets a text track in the list from the index of the track.</p>
            </summary>
            <param name = "index"><dd>  <p>The index of the track in the list to retrieve. </p> </dd></param>
            <param name = "track"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextTrack"/></strong> interface for the timed-text track.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800342</doc-id>
            <unmanaged>HRESULT IMFTimedTextTrackList::GetTrack([In] DWORD index,[Out] IMFTimedTextTrack** track)</unmanaged>
            <unmanaged-short>IMFTimedTextTrackList::GetTrack</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TimedTextTrackList.GetTrackById(System.Int32,SharpDX.MediaFoundation.TimedTextTrack@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Gets a text track in the list from the identifier of the track.</p>
            </summary>
            <param name = "trackId"><dd>  <p>The identifier of the track in the list to retrieve. </p> </dd></param>
            <param name = "track"><dd>  <p>A reference to a memory block that receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.TimedTextTrack"/></strong> interface for the timed-text track.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800343</doc-id>
            <unmanaged>HRESULT IMFTimedTextTrackList::GetTrackById([In] DWORD trackId,[Out] IMFTimedTextTrack** track)</unmanaged>
            <unmanaged-short>IMFTimedTextTrackList::GetTrackById</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Timer.SetTimer(System.Int32,System.Int64,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown,SharpDX.IUnknown@)">
            <summary>
            <p> </p><p>Sets a timer that invokes a callback at the specified time.</p>
            </summary>
            <param name = "dwFlags"><dd> <p>Bitwise OR of zero or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.TimerFlags"/></strong> enumeration.</p> </dd></param>
            <param name = "llClockTime"><dd> <p>The time at which the timer should fire, in units of the clock's frequency. The time is either absolute or relative to the current time, depending on the value of <em>dwFlags</em>.</p> </dd></param>
            <param name = "callbackRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. The callback's <strong>Invoke</strong> method is called at the time specified in the <em>llClockTime</em> parameter.</p> </dd></param>
            <param name = "unkStateRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>
            <param name = "unkKeyOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a cancellation object. The caller must release the interface. To cancel the timer, pass this reference to the <strong>IMFTimer::CancelTimer</strong> method. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The clock was shut down.</p> </td></tr> <tr><td> <dl> <dt><strong>MF_S_CLOCK_STOPPED</strong></dt> </dl> </td><td> <p>The method succeeded, but the clock is stopped.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the clock is stopped, the method returns MF_S_CLOCK_STOPPED. The callback will not be invoked until the clock is started.</p>
            </remarks>
            <doc-id>ms696252</doc-id>
            <unmanaged>HRESULT IMFTimer::SetTimer([In] DWORD dwFlags,[In] longlong llClockTime,[In] IMFAsyncCallback* pCallback,[In] IUnknown* punkState,[In] IUnknown** ppunkKey)</unmanaged>
            <unmanaged-short>IMFTimer::SetTimer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Timer.CancelTimer(SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Cancels a timer that was set using the <strong>IMFTimer::SetTimer</strong> method.</p>
            </summary>
            <param name = "unkKeyRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Because the timer is dispatched asynchronously, the application's timer callback might get invoked even if this method succeeds.</p>
            </remarks>
            <doc-id>ms696276</doc-id>
            <unmanaged>HRESULT IMFTimer::CancelTimer([In] IUnknown* punkKey)</unmanaged>
            <unmanaged-short>IMFTimer::CancelTimer</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopoLoader.Load(SharpDX.MediaFoundation.Topology,SharpDX.MediaFoundation.Topology@,SharpDX.MediaFoundation.Topology)">
            <summary>
            <p> Creates a fully loaded topology from the input partial topology. </p>
            </summary>
            <param name = "inputTopoRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Topology"/></strong> interface of the partial topology to be resolved.</p> </dd></param>
            <param name = "outputTopoOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Topology"/></strong> interface of the completed topology. The caller must release the interface.</p> </dd></param>
            <param name = "currentTopoRef"><dd> <p> A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Topology"/></strong> interface of the previous full topology. The topology loader can re-use objects from this topology in the new topology. This parameter can be <strong><c>null</c></strong>. See Remarks. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:TopoSinkActivatesUnsupported"/></strong></dt> </dl> </td><td> <p>One or more output nodes contain <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> references. The caller must bind the output nodes to media sinks. See  Binding Output Nodes to Media Sinks.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> This method creates any intermediate transforms that are needed to complete the topology. It also sets the input and output media types on all of the objects in the topology. If the method succeeds, the full topology is returned in the <em>ppOutputTopo</em> parameter. </p><p> You can use the <em>pCurrentTopo</em> parameter to provide a full topology that was previously loaded. If this topology contains objects that are needed in the new topology, the topology loader can re-use them without creating them again. This caching can potentially make the process faster. The objects from <em>pCurrentTopo</em> will not be reconfigured, so you can specify a topology that is actively streaming data. For example, while a topology is still running, you can pre-load the next topology. </p><p> Before calling this method, you must ensure that the output nodes in the partial topology have valid <strong><see cref = "T:SharpDX.MediaFoundation.StreamSink"/></strong> references, not <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> references. The Media Session automatically performs this action inside the <strong>IMFMediaSession::SetTopology</strong> method. However, if you call <strong>Load</strong> before calling <strong>SetTopology</strong>, you must bind the output nodes manually. For more information, see Binding Output Nodes to Media Sinks. </p>
            </remarks>
            <doc-id>ms693561</doc-id>
            <unmanaged>HRESULT IMFTopoLoader::Load([In] IMFTopology* pInputTopo,[Out] IMFTopology** ppOutputTopo,[In] IMFTopology* pCurrentTopo)</unmanaged>
            <unmanaged-short>IMFTopoLoader::Load</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.Topology.TopologyID">
            <summary>
            <p> Gets the identifier of the topology.</p>
            </summary>
            <doc-id>ms705620</doc-id>
            <unmanaged>GetTopologyID</unmanaged>
            <unmanaged-short>GetTopologyID</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.Topology.NodeCount">
            <summary>
            <p> Gets the number of nodes in the topology. </p>
            </summary>
            <doc-id>ms700175</doc-id>
            <unmanaged>GetNodeCount</unmanaged>
            <unmanaged-short>GetNodeCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.Topology.SourceNodeCollection">
            <summary>
            <p> Gets the source nodes in the topology. </p>
            </summary>
            <doc-id>ms701611</doc-id>
            <unmanaged>GetSourceNodeCollection</unmanaged>
            <unmanaged-short>GetSourceNodeCollection</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.Topology.OutputNodeCollection">
            <summary>
            <p> Gets the output nodes in the topology. </p>
            </summary>
            <doc-id>ms694029</doc-id>
            <unmanaged>GetOutputNodeCollection</unmanaged>
            <unmanaged-short>GetOutputNodeCollection</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Topology.GetTopologyID(System.Int64@)">
            <summary>
            <p> Gets the identifier of the topology.</p>
            </summary>
            <param name = "iDRef"><dd> <p> Receives the identifier, as a <strong>TOPOID</strong> value. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ms705620</doc-id>
            <unmanaged>HRESULT IMFTopology::GetTopologyID([Out] unsigned longlong* pID)</unmanaged>
            <unmanaged-short>IMFTopology::GetTopologyID</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Topology.AddNode(SharpDX.MediaFoundation.TopologyNode)">
            <summary>
            <p> </p><p>Adds a node to the topology.</p>
            </summary>
            <param name = "nodeRef"><dd> <p>Pointer to the node's <strong><see cref = "T:SharpDX.MediaFoundation.TopologyNode"/></strong> interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p><em>pNode</em> is invalid, possibly because the node already exists in the topology.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms697365</doc-id>
            <unmanaged>HRESULT IMFTopology::AddNode([In] IMFTopologyNode* pNode)</unmanaged>
            <unmanaged-short>IMFTopology::AddNode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Topology.RemoveNode(SharpDX.MediaFoundation.TopologyNode)">
            <summary>
            <p> </p><p>Removes a node from the topology.</p>
            </summary>
            <param name = "nodeRef"><dd> <p>Pointer to the node's <strong><see cref = "T:SharpDX.MediaFoundation.TopologyNode"/></strong> interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The specified node is not a member of this topology.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method does not destroy the node, so the <strong><see cref = "T:SharpDX.MediaFoundation.TopologyNode"/></strong> reference is still valid after the method returns.</p><p>The method breaks any connections between the specified node and other nodes.</p>
            </remarks>
            <doc-id>ms694226</doc-id>
            <unmanaged>HRESULT IMFTopology::RemoveNode([In] IMFTopologyNode* pNode)</unmanaged>
            <unmanaged-short>IMFTopology::RemoveNode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Topology.GetNodeCount(System.Int16@)">
            <summary>
            <p> Gets the number of nodes in the topology. </p>
            </summary>
            <param name = "wNodesRef"><dd> <p> Receives the number of nodes. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ms700175</doc-id>
            <unmanaged>HRESULT IMFTopology::GetNodeCount([Out] unsigned short* pwNodes)</unmanaged>
            <unmanaged-short>IMFTopology::GetNodeCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Topology.GetNode(System.Int16,SharpDX.MediaFoundation.TopologyNode@)">
            <summary>
            <p> Gets a node in the topology, specified by index. </p>
            </summary>
            <param name = "wIndex"><dd> <p> The zero-based index of the node. To get the number of nodes in the topology, call <strong>IMFTopology::GetNodeCount</strong>. </p> </dd></param>
            <param name = "nodeOut"><dd> <p> Receives a reference to the node's <strong><see cref = "T:SharpDX.MediaFoundation.TopologyNode"/></strong> interface. The caller must release the reference. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> The index is less than zero. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidIndex"/></strong></dt> </dl> </td><td> <p> No node can be found at the index <em>wIndex</em>. </p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms701569</doc-id>
            <unmanaged>HRESULT IMFTopology::GetNode([In] unsigned short wIndex,[Out] IMFTopologyNode** ppNode)</unmanaged>
            <unmanaged-short>IMFTopology::GetNode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Topology.Clear">
            <summary>
            <p> </p><p>Removes all nodes from the topology.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>You do not need to clear a topology before disposing of it. The <strong>Clear</strong> method is called automatically when the topology is destroyed.</p>
            </remarks>
            <doc-id>ms700800</doc-id>
            <unmanaged>HRESULT IMFTopology::Clear()</unmanaged>
            <unmanaged-short>IMFTopology::Clear</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Topology.CloneFrom(SharpDX.MediaFoundation.Topology)">
            <summary>
            <p> Converts this topology into a copy of another topology. </p>
            </summary>
            <param name = "topologyRef"><dd> <p> A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Topology"/></strong> interface of the topology to clone. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method does the following:</p><ul> <li> Removes all of the nodes from this topology. </li> <li> Clones the nodes from <em>pTopology</em> and adds them to this topology. The cloned nodes have the same node identifiers as the nodes from <em>pTopology</em>. </li> <li> Connects the cloned nodes to match the connections in <em>pTopology</em>. </li> <li> Copies the attributes from <em>pTopology</em> to this topology. </li> <li> Copies the topology identifier from <em>pTopology</em> to this topology.</li> </ul>
            </remarks>
            <doc-id>ms702242</doc-id>
            <unmanaged>HRESULT IMFTopology::CloneFrom([In, Optional] IMFTopology* pTopology)</unmanaged>
            <unmanaged-short>IMFTopology::CloneFrom</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Topology.GetNodeByID(System.Int64,SharpDX.MediaFoundation.TopologyNode@)">
            <summary>
            <p>Gets a node in the topology, specified by node identifier.</p>
            </summary>
            <param name = "qwTopoNodeID"><dd> <p> The identifier of the node to retrieve. To get a node's identifier, call <strong>IMFTopologyNode::GetTopoNodeID</strong>. </p> </dd></param>
            <param name = "nodeOut"><dd> <p> Receives a reference to the node's <strong><see cref = "T:SharpDX.MediaFoundation.TopologyNode"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotFound"/></strong></dt> </dl> </td><td> <p> The topology does not contain a node with this identifier. </p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms696224</doc-id>
            <unmanaged>HRESULT IMFTopology::GetNodeByID([In] unsigned longlong qwTopoNodeID,[Out] IMFTopologyNode** ppNode)</unmanaged>
            <unmanaged-short>IMFTopology::GetNodeByID</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Topology.GetSourceNodeCollection(SharpDX.MediaFoundation.Collection@)">
            <summary>
            <p> Gets the source nodes in the topology. </p>
            </summary>
            <param name = "collectionOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Collection"/></strong> interface. The caller must release the reference. The collection contains <strong><see cref = "T:SharpDX.IUnknown"/></strong> references to all of the source nodes in the topology. Each reference can be queried for the <strong><see cref = "T:SharpDX.MediaFoundation.TopologyNode"/></strong> interface. The collection might be empty.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ms701611</doc-id>
            <unmanaged>HRESULT IMFTopology::GetSourceNodeCollection([Out] IMFCollection** ppCollection)</unmanaged>
            <unmanaged-short>IMFTopology::GetSourceNodeCollection</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.Topology.GetOutputNodeCollection(SharpDX.MediaFoundation.Collection@)">
            <summary>
            <p> Gets the output nodes in the topology. </p>
            </summary>
            <param name = "collectionOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Collection"/></strong> interface. The caller must release the reference. The collection contains <strong><see cref = "T:SharpDX.IUnknown"/></strong> references to all of the output nodes in the topology. Each reference can be queried for the <strong><see cref = "T:SharpDX.MediaFoundation.TopologyNode"/></strong> interface. The collection might be empty. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ms694029</doc-id>
            <unmanaged>HRESULT IMFTopology::GetOutputNodeCollection([Out] IMFCollection** ppCollection)</unmanaged>
            <unmanaged-short>IMFTopology::GetOutputNodeCollection</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TopologyNode.Object">
            <summary>
            <p> </p><p>Sets the object associated with this node.</p>
            </summary>
            <remarks>
            <p>All node types support this method, but the object reference is not used by every node type.</p><table> <tr><th>Node type</th><th>Object reference</th></tr> <tr><td>Source node.</td><td>Not used.</td></tr> <tr><td>Transform node.</td><td> <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> or <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface.</td></tr> <tr><td>Output node</td><td> <strong><see cref = "T:SharpDX.MediaFoundation.StreamSink"/></strong> or <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface.</td></tr> <tr><td>Tee node.</td><td>Not used.</td></tr> </table><p>?</p><p>If the object supports <strong><see cref = "!:SharpDX.ComPersistBase"/></strong>, <strong>IPersistStorage</strong>, or <strong>IPersistPropertyBag</strong>, the method gets the object's CLSID and sets the <strong><see cref = "!:TransformObjectid"/></strong> attribute on the node.</p>
            </remarks>
            <doc-id>ms702992</doc-id>
            <unmanaged>SetObject</unmanaged>
            <unmanaged-short>SetObject</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TopologyNode.ObjectW">
            <summary>
            <p> Gets the object associated with this node. </p>
            </summary>
            <doc-id>ms693569</doc-id>
            <unmanaged>GetObjectW</unmanaged>
            <unmanaged-short>GetObjectW</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TopologyNode.NodeType">
            <summary>
            <p> </p><p>Retrieves the node type.</p>
            </summary>
            <doc-id>ms697514</doc-id>
            <unmanaged>GetNodeType</unmanaged>
            <unmanaged-short>GetNodeType</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TopologyNode.TopoNodeID">
            <summary>
            <p>Retrieves or sets the identifier of the node.</p>
            </summary>
            <remarks>
            <p> When a node is first created, it is assigned an identifier. Node identifiers are unique within a topology, but can be reused across several topologies. The topology loader uses the identifier to look up nodes in the previous topology, so that it can reuse objects from the previous topology. </p><p> To find a node in a topology by its identifier, call <strong>IMFTopology::GetNodeByID</strong>. </p>
            </remarks>
            <doc-id>ms701602</doc-id>
            <unmanaged>GetTopoNodeID / SetTopoNodeID</unmanaged>
            <unmanaged-short>GetTopoNodeID</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TopologyNode.InputCount">
            <summary>
            <p> </p><p>Retrieves the number of input streams that currently exist on this node.</p>
            </summary>
            <remarks>
            <p>The input streams may or may not be connected to output streams on other nodes. To get the node that is connected to a specified input stream, call <strong>IMFTopologyNode::GetInput</strong>.</p><p>The <strong>IMFTopologyNode::ConnectOutput</strong> and <strong>IMFTopologyNode::SetInputPrefType</strong> methods add new input streams as needed.</p>
            </remarks>
            <doc-id>ms700165</doc-id>
            <unmanaged>GetInputCount</unmanaged>
            <unmanaged-short>GetInputCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TopologyNode.OutputCount">
            <summary>
            <p> </p><p>Retrieves the number of output streams that currently exist on this node.</p>
            </summary>
            <remarks>
            <p>The output streams may or may not be connected to input streams on other nodes. To get the node that is connected to a specific output stream on this node, call <strong>IMFTopologyNode::GetOutput</strong>.</p><p>The <strong>IMFTopologyNode::ConnectOutput</strong> and <strong>IMFTopologyNode::SetOutputPrefType</strong> methods add new input streams as needed.</p>
            </remarks>
            <doc-id>ms704019</doc-id>
            <unmanaged>GetOutputCount</unmanaged>
            <unmanaged-short>GetOutputCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyNode.SetObject(SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Sets the object associated with this node.</p>
            </summary>
            <param name = "objectRef"><dd> <p>A reference to the object's <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface. Use the value <strong><c>null</c></strong> to clear an object that was previous set.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>All node types support this method, but the object reference is not used by every node type.</p><table> <tr><th>Node type</th><th>Object reference</th></tr> <tr><td>Source node.</td><td>Not used.</td></tr> <tr><td>Transform node.</td><td> <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> or <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface.</td></tr> <tr><td>Output node</td><td> <strong><see cref = "T:SharpDX.MediaFoundation.StreamSink"/></strong> or <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface.</td></tr> <tr><td>Tee node.</td><td>Not used.</td></tr> </table><p>?</p><p>If the object supports <strong><see cref = "!:SharpDX.ComPersistBase"/></strong>, <strong>IPersistStorage</strong>, or <strong>IPersistPropertyBag</strong>, the method gets the object's CLSID and sets the <strong><see cref = "!:TransformObjectid"/></strong> attribute on the node.</p>
            </remarks>
            <doc-id>ms702992</doc-id>
            <unmanaged>HRESULT IMFTopologyNode::SetObject([In, Optional] IUnknown* pObject)</unmanaged>
            <unmanaged-short>IMFTopologyNode::SetObject</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyNode.GetObjectW(SharpDX.IUnknown@)">
            <summary>
            <p> Gets the object associated with this node. </p>
            </summary>
            <param name = "objectOut"><dd> <p> Receives a reference to the object's <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p> There is no object associated with this node. </p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms693569</doc-id>
            <unmanaged>HRESULT IMFTopologyNode::GetObjectW([Out] IUnknown** ppObject)</unmanaged>
            <unmanaged-short>IMFTopologyNode::GetObjectW</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyNode.GetNodeType(SharpDX.MediaFoundation.TopologyType@)">
            <summary>
            <p> </p><p>Retrieves the node type.</p>
            </summary>
            <param name = "typeRef"><dd> <p>Receives the node type, specified as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.TopologyType"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms697514</doc-id>
            <unmanaged>HRESULT IMFTopologyNode::GetNodeType([Out] MF_TOPOLOGY_TYPE* pType)</unmanaged>
            <unmanaged-short>IMFTopologyNode::GetNodeType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyNode.GetTopoNodeID(System.Int64@)">
            <summary>
            <p> Retrieves the identifier of the node.</p>
            </summary>
            <param name = "iDRef"><dd> <p>Receives the identifier.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> When a node is first created, it is assigned an identifier. Node identifiers are unique within a topology, but can be reused across several topologies. The topology loader uses the identifier to look up nodes in the previous topology, so that it can reuse objects from the previous topology. </p><p> To find a node in a topology by its identifier, call <strong>IMFTopology::GetNodeByID</strong>. </p>
            </remarks>
            <doc-id>ms701602</doc-id>
            <unmanaged>HRESULT IMFTopologyNode::GetTopoNodeID([Out] unsigned longlong* pID)</unmanaged>
            <unmanaged-short>IMFTopologyNode::GetTopoNodeID</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyNode.SetTopoNodeID(System.Int64)">
            <summary>
            <p> Sets the identifier for the node.</p>
            </summary>
            <param name = "ullTopoID"><dd> <p> The identifier for the node. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> The <strong>TOPOID</strong> has already been set for this object. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> When a node is first created, it is assigned an identifier. Typically there is no reason for an application to override the identifier. Within a topology, each node identifier should be unique. </p>
            </remarks>
            <doc-id>bb970438</doc-id>
            <unmanaged>HRESULT IMFTopologyNode::SetTopoNodeID([In] unsigned longlong ullTopoID)</unmanaged>
            <unmanaged-short>IMFTopologyNode::SetTopoNodeID</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyNode.GetInputCount(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the number of input streams that currently exist on this node.</p>
            </summary>
            <param name = "cInputsRef"><dd> <p>Receives the number of input streams.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The input streams may or may not be connected to output streams on other nodes. To get the node that is connected to a specified input stream, call <strong>IMFTopologyNode::GetInput</strong>.</p><p>The <strong>IMFTopologyNode::ConnectOutput</strong> and <strong>IMFTopologyNode::SetInputPrefType</strong> methods add new input streams as needed.</p>
            </remarks>
            <doc-id>ms700165</doc-id>
            <unmanaged>HRESULT IMFTopologyNode::GetInputCount([Out] DWORD* pcInputs)</unmanaged>
            <unmanaged-short>IMFTopologyNode::GetInputCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyNode.GetOutputCount(System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the number of output streams that currently exist on this node.</p>
            </summary>
            <param name = "cOutputsRef"><dd> <p>Receives the number of output streams.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The output streams may or may not be connected to input streams on other nodes. To get the node that is connected to a specific output stream on this node, call <strong>IMFTopologyNode::GetOutput</strong>.</p><p>The <strong>IMFTopologyNode::ConnectOutput</strong> and <strong>IMFTopologyNode::SetOutputPrefType</strong> methods add new input streams as needed.</p>
            </remarks>
            <doc-id>ms704019</doc-id>
            <unmanaged>HRESULT IMFTopologyNode::GetOutputCount([Out] DWORD* pcOutputs)</unmanaged>
            <unmanaged-short>IMFTopologyNode::GetOutputCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyNode.ConnectOutput(System.Int32,SharpDX.MediaFoundation.TopologyNode,System.Int32)">
            <summary>
            <p> </p><p>Connects an output stream from this node to the input stream of another node.</p>
            </summary>
            <param name = "dwOutputIndex"><dd> <p>Zero-based index of the output stream on this node.</p> </dd></param>
            <param name = "downstreamNodeRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.TopologyNode"/></strong> interface of the node to connect to.</p> </dd></param>
            <param name = "dwInputIndexOnDownstreamNode"><dd> <p>Zero-based index of the input stream on the other node.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p>The method failed.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid parameter.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Node connections represent data flow from one node to the next. The streams are logical, and are specified by index.</p><p>If the node is already connected at the specified output, the method breaks the existing connection. If <em>dwOutputIndex</em> or <em>dwInputIndexOnDownstreamNode</em> specify streams that do not exist yet, the method adds as many streams as needed.</p><p>This method checks for certain invalid conditions:</p><ul> <li> <p>An output node cannot have any output connections. If you call this method on an output node, the method returns E_FAIL.</p> </li> <li> <p>A node cannot be connected to itself. If <em>pDownstreamNode</em> specifies the same node as the method call, the method returns E_INVALIDARG.</p> </li> </ul><p>However, if the method succeeds, it does not guarantee that the node connection is valid. It is possible to create a partial topology that the topology loader cannot resolve. If so, the <strong>IMFTopoLoader::Load</strong> method will fail.</p><p>To break an existing node connection, call <strong>IMFTopologyNode::DisconnectOutput</strong>.</p>
            </remarks>
            <doc-id>ms695284</doc-id>
            <unmanaged>HRESULT IMFTopologyNode::ConnectOutput([In] DWORD dwOutputIndex,[In] IMFTopologyNode* pDownstreamNode,[In] DWORD dwInputIndexOnDownstreamNode)</unmanaged>
            <unmanaged-short>IMFTopologyNode::ConnectOutput</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyNode.DisconnectOutput(System.Int32)">
            <summary>
            <p> </p><p>Disconnects an output stream on this node.</p>
            </summary>
            <param name = "dwOutputIndex"><dd> <p>Zero-based index of the output stream to disconnect.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The <em>dwOutputIndex</em> parameter is out of range.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotFound"/></strong></dt> </dl> </td><td> <p>The specified output stream is not connected to another node.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the specified output stream is connected to another node, this method breaks the connection.</p>
            </remarks>
            <doc-id>ms698991</doc-id>
            <unmanaged>HRESULT IMFTopologyNode::DisconnectOutput([In] DWORD dwOutputIndex)</unmanaged>
            <unmanaged-short>IMFTopologyNode::DisconnectOutput</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyNode.GetInput(System.Int32,SharpDX.MediaFoundation.TopologyNode@,System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the node that is connected to a specified input stream on this node.</p>
            </summary>
            <param name = "dwInputIndex"><dd> <p>Zero-based index of an input stream on this node.</p> </dd></param>
            <param name = "upstreamNodeOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.TopologyNode"/></strong> interface of the node that is connected to the specified input stream. The caller must release the interface.</p> </dd></param>
            <param name = "dwOutputIndexOnUpstreamNodeRef"><dd> <p>Receives the index of the output stream that is connected to this node's input stream.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The index is out of range.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotFound"/></strong></dt> </dl> </td><td> <p>The specified input stream is not connected to another node.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms697020</doc-id>
            <unmanaged>HRESULT IMFTopologyNode::GetInput([In] DWORD dwInputIndex,[Out] IMFTopologyNode** ppUpstreamNode,[Out] DWORD* pdwOutputIndexOnUpstreamNode)</unmanaged>
            <unmanaged-short>IMFTopologyNode::GetInput</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyNode.GetOutput(System.Int32,SharpDX.MediaFoundation.TopologyNode@,System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the node that is connected to a specified output stream on this node.</p>
            </summary>
            <param name = "dwOutputIndex"><dd> <p>Zero-based index of an output stream on this node.</p> </dd></param>
            <param name = "downstreamNodeOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.TopologyNode"/></strong> interface of the node that is connected to the specified output stream. The caller must release the interface.</p> </dd></param>
            <param name = "dwInputIndexOnDownstreamNodeRef"><dd> <p>Receives the index of the input stream that is connected to this node's output stream.</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The index is out of range.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotFound"/></strong></dt> </dl> </td><td> <p>The specified input stream is not connected to another node.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970327</doc-id>
            <unmanaged>HRESULT IMFTopologyNode::GetOutput([In] DWORD dwOutputIndex,[Out] IMFTopologyNode** ppDownstreamNode,[Out] DWORD* pdwInputIndexOnDownstreamNode)</unmanaged>
            <unmanaged-short>IMFTopologyNode::GetOutput</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyNode.SetOutputPrefType(System.Int32,SharpDX.MediaFoundation.MediaType)">
            <summary>
            <p> </p><p>Sets the preferred media type for an output stream on this node.</p>
            </summary>
            <param name = "dwOutputIndex"><dd> <p>Zero-based index of the output stream.</p> </dd></param>
            <param name = "typeRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>This node is an output node.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The preferred type is a hint for the topology loader.</p><p>Do not call this method after loading a topology or setting a topology on the Media Session. Changing the preferred type on a running topology can cause connection errors.</p><p>If no output stream exists at the specified index, the method creates new streams up to and including the specified index number.</p><p>Output nodes cannot have outputs. If this method is called on an output node, it returns E_NOTIMPL</p>
            </remarks>
            <doc-id>ms701546</doc-id>
            <unmanaged>HRESULT IMFTopologyNode::SetOutputPrefType([In] DWORD dwOutputIndex,[In] IMFMediaType* pType)</unmanaged>
            <unmanaged-short>IMFTopologyNode::SetOutputPrefType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyNode.GetOutputPrefType(System.Int32,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            <p> </p><p>Retrieves the preferred media type for an output stream on this node.</p>
            </summary>
            <param name = "dwOutputIndex"><dd> <p>Zero-based index of the output stream.</p> </dd></param>
            <param name = "typeOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p>This node does not have a preferred output type.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid stream index.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>This node is an output node.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Output nodes cannot have outputs. If this method is called on an output node, it returns E_NOTIMPL.</p><p>The preferred output type provides a hint to the topology loader. In a fully resolved topology, there is no guarantee that every topology node will have a preferred output type. To get the actual media type for a node, you must get a reference to the node's underlying object. (For more information, see <strong><see cref = "T:SharpDX.MediaFoundation.TopologyType"/></strong> enumeration.)</p>
            </remarks>
            <doc-id>ms701571</doc-id>
            <unmanaged>HRESULT IMFTopologyNode::GetOutputPrefType([In] DWORD dwOutputIndex,[Out] IMFMediaType** ppType)</unmanaged>
            <unmanaged-short>IMFTopologyNode::GetOutputPrefType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyNode.SetInputPrefType(System.Int32,SharpDX.MediaFoundation.MediaType)">
            <summary>
            <p> </p><p>Sets the preferred media type for an input stream on this node.</p>
            </summary>
            <param name = "dwInputIndex"><dd> <p>Zero-based index of the input stream.</p> </dd></param>
            <param name = "typeRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>This node is a source node.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The preferred type is a hint for the topology loader.</p><p>Do not call this method after loading a topology or setting a topology on the Media Session. Changing the preferred type on a running topology can cause connection errors.</p><p>If no input stream exists at the specified index, the method creates new streams up to and including the specified index number.</p><p>Source nodes cannot have inputs. If this method is called on a source node, it returns E_NOTIMPL.</p>
            </remarks>
            <doc-id>ms696223</doc-id>
            <unmanaged>HRESULT IMFTopologyNode::SetInputPrefType([In] DWORD dwInputIndex,[In] IMFMediaType* pType)</unmanaged>
            <unmanaged-short>IMFTopologyNode::SetInputPrefType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyNode.GetInputPrefType(System.Int32,SharpDX.MediaFoundation.MediaType@)">
            <summary>
            <p> </p><p>Retrieves the preferred media type for an input stream on this node.</p>
            </summary>
            <param name = "dwInputIndex"><dd> <p>Zero-based index of the input stream.</p> </dd></param>
            <param name = "typeOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of the media type. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_FAIL</strong></dt> </dl> </td><td> <p>This node does not have a preferred input type.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid stream index.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOTIMPL</strong></dt> </dl> </td><td> <p>This node is a source node.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Source nodes cannot have inputs. If this method is called on a source node, it returns E_NOTIMPL.</p><p>The preferred input type provides a hint to the topology loader. In a fully resolved topology, there is no guarantee that every topology node will have a preferred input type. To get the actual media type for a node, you must get a reference to the node's underlying object. (For more information, see <strong><see cref = "T:SharpDX.MediaFoundation.TopologyType"/></strong> enumeration.)</p>
            </remarks>
            <doc-id>ms696221</doc-id>
            <unmanaged>HRESULT IMFTopologyNode::GetInputPrefType([In] DWORD dwInputIndex,[Out] IMFMediaType** ppType)</unmanaged>
            <unmanaged-short>IMFTopologyNode::GetInputPrefType</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyNode.CloneFrom(SharpDX.MediaFoundation.TopologyNode)">
            <summary>
            <p> Copies the data from another topology node into this node.</p>
            </summary>
            <param name = "nodeRef"><dd> <p> A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.TopologyNode"/></strong> interface of the node to copy. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p> The node types do not match. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> The two nodes must have the same node type. To get the node type, call <strong>IMFTopologyNode::GetNodeType</strong>. </p><p> This method copies the object reference, preferred types, and attributes from <em>pNode</em> to this node. It also copies the <strong>TOPOID</strong> that uniquely identifies each node in a topology. It does not duplicate any of the connections from <em>pNode</em> to other nodes. </p><p> The purpose of this method is to copy nodes from one topology to another. Do not use duplicate nodes within the same topology. </p>
            </remarks>
            <doc-id>ms700790</doc-id>
            <unmanaged>HRESULT IMFTopologyNode::CloneFrom([In, Optional] IMFTopologyNode* pNode)</unmanaged>
            <unmanaged-short>IMFTopologyNode::CloneFrom</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyNodeAttributeEditor.UpdateNodeAttributes(System.Int64,System.Int32,SharpDX.MediaFoundation.ToponodeAttributeUpdate[])">
            <summary>
            <p> </p><p>Updates the attributes of one or more nodes in the current topology.</p>
            </summary>
            <param name = "topoId"><dd> <p>Reserved.</p> </dd></param>
            <param name = "cUpdates"><dd> <p>The number of elements in the <em>pUpdates</em> array.</p> </dd></param>
            <param name = "updatesRef"><dd> <p>Pointer to an array of <strong><see cref = "T:SharpDX.MediaFoundation.ToponodeAttributeUpdate"/></strong> structures. Each element of the array updates one attribute on a node.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Currently the only attribute that can be updated is the <strong><see cref = "!:Mediastop"/></strong> attribute. The method ignores any other attributes.</p>
            </remarks>
            <doc-id>aa371868</doc-id>
            <unmanaged>HRESULT IMFTopologyNodeAttributeEditor::UpdateNodeAttributes([In] unsigned longlong TopoId,[In] DWORD cUpdates,[In, Buffer] MFTOPONODE_ATTRIBUTE_UPDATE* pUpdates)</unmanaged>
            <unmanaged-short>IMFTopologyNodeAttributeEditor::UpdateNodeAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyServiceLookup.LookupService(SharpDX.MediaFoundation.ServiceLookupType,System.Int32,System.Guid,System.Guid,System.IntPtr,System.Int32@)">
            <summary>
            <p> </p><p>Retrieves an interface from the enhanced video renderer (EVR), or from the video mixer or video presenter.</p>
            </summary>
            <param name = "type"><dd> <p>Specifies the scope of the search. Currently this parameter is ignored. Use the value MF_SERVICE_LOOKUP_GLOBAL.</p> </dd></param>
            <param name = "dwIndex"><dd> <p>Reserved, must be zero.</p> </dd></param>
            <param name = "guidService"><dd> <p>Service <see cref = "T:System.Guid"/> of the requested interface.</p> </dd></param>
            <param name = "riid"><dd> <p>Interface identifier of the requested interface.</p> </dd></param>
            <param name = "vObjectsOut"><dd> <p>Array of interface references. If the method succeeds, each member of the array contains either a valid interface reference or <strong><c>null</c></strong>. The caller must release the interface references when the EVR calls <strong>IMFTopologyServiceLookupClient::ReleaseServicePointers</strong> (or earlier). If the method fails, every member of the array is <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "nObjectsRef"><dd> <p>Pointer to a value that specifies the size of the <em>ppvObjects</em> array. The value must be at least 1. In the current implementation, there is no reason to specify an array size larger than one element. The value is not changed on output.</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid argument.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOINTERFACE</strong></dt> </dl> </td><td> <p>The requested interface is not available.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotAccepting"/></strong></dt> </dl> </td><td> <p>The method was not called from inside the <strong>IMFTopologyServiceLookupClient::InitServicePointers</strong> method. See Remarks.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:UnsupportedService"/></strong></dt> </dl> </td><td> <p>The object does not support the specified service <see cref = "T:System.Guid"/>.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method can be called only from inside the <strong>IMFTopologyServiceLookupClient::InitServicePointers</strong> method. At any other time, the method returns <see cref = "!:NotAccepting"/>.</p><p>The presenter can use this method to query the EVR and the mixer. The mixer can use it to query the EVR and the presenter. Which objects are queried depends on the caller and the service <see cref = "T:System.Guid"/>, as shown in the following table.</p><table> <tr><th>Caller</th><th>Service <see cref = "T:System.Guid"/></th><th>Objects queried</th></tr> <tr><td>Presenter</td><td>MR_VIDEO_RENDER_SERVICE</td><td>EVR</td></tr> <tr><td>Presenter</td><td>MR_VIDEO_MIXER_SERVICE</td><td>Mixer</td></tr> <tr><td>Mixer</td><td>MR_VIDEO_RENDER_SERVICE</td><td>Presenter and EVR</td></tr> </table><p>?</p><p>The following interfaces are available from the EVR:</p><ul> <li> <p><strong>IMediaEventSink</strong>. This interface is documented in the DirectShow SDK documentation.</p> </li> <li> <p> <strong><see cref = "T:SharpDX.MediaFoundation.Clock"/></strong> interface. This interface is available if the EVR has access to a clock (reference clock in DirectShow or presentation clock in Media Foundation). This interface might not be available. Presenter and mixers must be able to process data without a clock. If the <strong><see cref = "T:SharpDX.MediaFoundation.Clock"/></strong> interface is available, you can also get these related interfaces:</p> <ul> <li> <p> <strong><see cref = "T:SharpDX.MediaFoundation.Timer"/></strong> </p> </li> <li> <p> <strong><see cref = "T:SharpDX.MediaFoundation.PresentationClock"/></strong> (Media Foundation EVR only)</p> </li> </ul> </li> </ul><p>The following interfaces are available from the mixer:</p><ul> <li> <p> <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> </p> </li> <li> <p> <strong><see cref = "T:SharpDX.MediaFoundation.VideoDeviceID"/></strong> </p> </li> </ul>
            </remarks>
            <doc-id>bb970504</doc-id>
            <unmanaged>HRESULT IMFTopologyServiceLookup::LookupService([In] MF_SERVICE_LOOKUP_TYPE Type,[In] DWORD dwIndex,[In] const GUID&amp; guidService,[In] const GUID&amp; riid,[Out, Buffer] void** ppvObjects,[InOut] DWORD* pnObjects)</unmanaged>
            <unmanaged-short>IMFTopologyServiceLookup::LookupService</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyServiceLookupClient.InitServicePointers(SharpDX.MediaFoundation.TopologyServiceLookup)">
            <summary>
            <p> </p><p>Signals the mixer or presenter to query the enhanced video renderer (EVR) for interface references.</p>
            </summary>
            <param name = "lookupRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.TopologyServiceLookup"/></strong> interface. To query the EVR for an interface, call <strong>IMFTopologyServiceLookup::LookupService</strong>.</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The <strong><see cref = "T:SharpDX.MediaFoundation.TopologyServiceLookup"/></strong> reference is guaranteed to be valid only during the call to <strong>InitServicePointers</strong>. The mixer or presenter should not store a reference to this interface after the method returns.</p><p>When the EVR calls <strong>IMFTopologyServiceLookupClient::ReleaseServicePointers</strong>, the mixer or presenter should release any references it obtained from the EVR.</p>
            </remarks>
            <doc-id>bb970502</doc-id>
            <unmanaged>HRESULT IMFTopologyServiceLookupClient::InitServicePointers([In] IMFTopologyServiceLookup* pLookup)</unmanaged>
            <unmanaged-short>IMFTopologyServiceLookupClient::InitServicePointers</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TopologyServiceLookupClient.ReleaseServicePointers">
            <summary>
            <p> </p><p>Signals the object to release the interface references obtained from the enhanced video renderer (EVR).</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>After this method is called, any interface references obtained during the previous call to <strong>IMFTopologyServiceLookupClient::InitServicePointers</strong> are no longer valid. The object must release them.</p>
            </remarks>
            <doc-id>ms693584</doc-id>
            <unmanaged>HRESULT IMFTopologyServiceLookupClient::ReleaseServicePointers()</unmanaged>
            <unmanaged-short>IMFTopologyServiceLookupClient::ReleaseServicePointers</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TrackedSample.SetAllocator(SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Sets the owner for the sample.</p>
            </summary>
            <param name = "sampleAllocatorRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>
            <param name = "unkStateRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotAccepting"/></strong></dt> </dl> </td><td> <p>The owner was already set. This method cannot be called twice on the sample.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>When this method is called, the sample holds an additional reference count on itself. When every other object releases its reference counts on the sample, the sample invokes the <em>pSampleAllocator</em> callback method. To get a reference to the sample, call <strong>IMFAsyncResult::GetObject</strong> on the asynchronous result object given to the callback's <strong>IMFAsyncCallback::Invoke</strong> method.</p><p>After the callback is invoked, the sample clears the callback. To reinstate the callback, you must call <strong>SetAllocator</strong> again.</p><p>It is safe to pass in the sample's <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface reference as the state object (<em>pUnkState</em>) for the callback. If <em>pUnkState</em> points to the sample, the <strong>SetAllocator</strong> method accounts for the additional reference count on <em>pUnkState</em>.</p>
            </remarks>
            <doc-id>ms704797</doc-id>
            <unmanaged>HRESULT IMFTrackedSample::SetAllocator([In] IMFAsyncCallback* pSampleAllocator,[In] IUnknown* pUnkState)</unmanaged>
            <unmanaged-short>IMFTrackedSample::SetAllocator</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TranscodeProfile.AudioAttributes">
            <summary>
            <p>Gets or sets the audio stream settings that are currently set in the transcode profile. </p>
            </summary>
            <remarks>
            <p>If there are no audio attributes set in the transcode profile, the call to <strong>GetAudioAttributes</strong> succeeds and  <em>ppAttrs</em> receives <strong><c>null</c></strong>.</p><p>To get a specific attribute value, the caller must call the appropriate <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> method depending on the data type of the attribute, and specify the attribute name. The following topics describe the audio attributes:</p><ul> <li> Audio Media Types </li> <li> <see cref = "!:TranscodeEncodingprofile"/> </li> <li> <see cref = "!:TranscodeQualityvsspeed"/> </li> </ul>
            </remarks>
            <doc-id>dd369140</doc-id>
            <unmanaged>GetAudioAttributes / SetAudioAttributes</unmanaged>
            <unmanaged-short>GetAudioAttributes</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TranscodeProfile.VideoAttributes">
            <summary>
            <p>Gets or sets the video stream settings that are currently set in the transcode profile.</p>
            </summary>
            <remarks>
            <p>If there are no container attributes set in the transcode profile, the <strong>GetVideoAttributes</strong> method  succeeds and  <em>ppAttrs</em> receives <strong><c>null</c></strong>.</p><p>To get a specific attribute value, the caller must call the appropriate <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> method depending on the data type of the attribute, and specify the attribute name. The following list shows the video attributes:</p><ul> <li> Video Media Types </li> <li> <see cref = "!:TranscodeEncodingprofile"/> </li> <li> <see cref = "!:TranscodeQualityvsspeed"/> </li> <li> <see cref = "!:TranscodeDonotInsertEncoder"/> </li> </ul>
            </remarks>
            <doc-id>dd369142</doc-id>
            <unmanaged>GetVideoAttributes / SetVideoAttributes</unmanaged>
            <unmanaged-short>GetVideoAttributes</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TranscodeProfile.ContainerAttributes">
            <summary>
            <p>Gets or sets the container settings that are currently set in the transcode profile.</p>
            </summary>
            <remarks>
            <p>If there are no container attributes set in the transcode profile, the call to <strong>GetContainerAttributes</strong> succeeds and  <em>ppAttrs</em> receives <strong><c>null</c></strong>.</p><p> To get a specific attribute value, the caller must call the appropriate <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> method depending on the data type of the attribute. The following list shows the container attributes:</p><ul> <li> <see cref = "!:TranscodeContainertype"/> </li> <li> <see cref = "!:TranscodeSkipMetadataTransfer"/> </li> <li> <see cref = "!:TranscodeTopologymode"/> </li> </ul>
            </remarks>
            <doc-id>dd369141</doc-id>
            <unmanaged>GetContainerAttributes / SetContainerAttributes</unmanaged>
            <unmanaged-short>GetContainerAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TranscodeProfile.SetAudioAttributes(SharpDX.MediaFoundation.MediaAttributes)">
            <summary>
            <p>Sets audio stream configuration settings  in the transcode profile.</p><p>To get a list of compatible audio media types supported by the Media Foundation transform (MFT) encoder , call  <strong>MFTranscodeGetAudioOutputAvailableTypes</strong>. You can get the attributes that are set on the required media type and set them on the transcode profile. To set the audio attributes properly, create a new attribute store and copy the attribute store from the required media media type by calling <strong>IMFAttributes::CopyAllItems</strong>. This makes sure that the caller does not hold the references to the media type retrieved from the encoder. For example code, see <strong>MFCreateTranscodeProfile</strong>.</p>
            </summary>
            <param name = "attrsRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd369143</doc-id>
            <unmanaged>HRESULT IMFTranscodeProfile::SetAudioAttributes([In, Optional] IMFAttributes* pAttrs)</unmanaged>
            <unmanaged-short>IMFTranscodeProfile::SetAudioAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TranscodeProfile.GetAudioAttributes(SharpDX.MediaFoundation.MediaAttributes@)">
            <summary>
            <p>Gets the audio stream settings that are currently set in the transcode profile. </p>
            </summary>
            <param name = "attrsOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of the attribute store containing the current audio stream settings. Caller must release the interface reference.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If there are no audio attributes set in the transcode profile, the call to <strong>GetAudioAttributes</strong> succeeds and  <em>ppAttrs</em> receives <strong><c>null</c></strong>.</p><p>To get a specific attribute value, the caller must call the appropriate <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> method depending on the data type of the attribute, and specify the attribute name. The following topics describe the audio attributes:</p><ul> <li> Audio Media Types </li> <li> <see cref = "!:TranscodeEncodingprofile"/> </li> <li> <see cref = "!:TranscodeQualityvsspeed"/> </li> </ul>
            </remarks>
            <doc-id>dd369140</doc-id>
            <unmanaged>HRESULT IMFTranscodeProfile::GetAudioAttributes([Out, Optional] IMFAttributes** ppAttrs)</unmanaged>
            <unmanaged-short>IMFTranscodeProfile::GetAudioAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TranscodeProfile.SetVideoAttributes(SharpDX.MediaFoundation.MediaAttributes)">
            <summary>
            <p>Sets video stream configuration settings  in the transcode profile.</p><p> For example code, see <strong>MFCreateTranscodeProfile</strong>.</p>
            </summary>
            <param name = "attrsRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd369145</doc-id>
            <unmanaged>HRESULT IMFTranscodeProfile::SetVideoAttributes([In, Optional] IMFAttributes* pAttrs)</unmanaged>
            <unmanaged-short>IMFTranscodeProfile::SetVideoAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TranscodeProfile.GetVideoAttributes(SharpDX.MediaFoundation.MediaAttributes@)">
            <summary>
            <p>Gets the video stream settings that are currently set in the transcode profile.</p>
            </summary>
            <param name = "attrsOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of the attribute store containing the current video stream settings. Caller must release the interface reference.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If there are no container attributes set in the transcode profile, the <strong>GetVideoAttributes</strong> method  succeeds and  <em>ppAttrs</em> receives <strong><c>null</c></strong>.</p><p>To get a specific attribute value, the caller must call the appropriate <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> method depending on the data type of the attribute, and specify the attribute name. The following list shows the video attributes:</p><ul> <li> Video Media Types </li> <li> <see cref = "!:TranscodeEncodingprofile"/> </li> <li> <see cref = "!:TranscodeQualityvsspeed"/> </li> <li> <see cref = "!:TranscodeDonotInsertEncoder"/> </li> </ul>
            </remarks>
            <doc-id>dd369142</doc-id>
            <unmanaged>HRESULT IMFTranscodeProfile::GetVideoAttributes([Out, Optional] IMFAttributes** ppAttrs)</unmanaged>
            <unmanaged-short>IMFTranscodeProfile::GetVideoAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TranscodeProfile.SetContainerAttributes(SharpDX.MediaFoundation.MediaAttributes)">
            <summary>
            <p>Sets container configuration settings  in the transcode profile.</p><p> For example code, see <strong>MFCreateTranscodeProfile</strong>.</p>
            </summary>
            <param name = "attrsRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd369144</doc-id>
            <unmanaged>HRESULT IMFTranscodeProfile::SetContainerAttributes([In, Optional] IMFAttributes* pAttrs)</unmanaged>
            <unmanaged-short>IMFTranscodeProfile::SetContainerAttributes</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TranscodeProfile.GetContainerAttributes(SharpDX.MediaFoundation.MediaAttributes@)">
            <summary>
            <p>Gets the container settings that are currently set in the transcode profile.</p>
            </summary>
            <param name = "attrsOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface of the attribute store containing the current container type for the output file. Caller must release the interface reference.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If there are no container attributes set in the transcode profile, the call to <strong>GetContainerAttributes</strong> succeeds and  <em>ppAttrs</em> receives <strong><c>null</c></strong>.</p><p> To get a specific attribute value, the caller must call the appropriate <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> method depending on the data type of the attribute. The following list shows the container attributes:</p><ul> <li> <see cref = "!:TranscodeContainertype"/> </li> <li> <see cref = "!:TranscodeSkipMetadataTransfer"/> </li> <li> <see cref = "!:TranscodeTopologymode"/> </li> </ul>
            </remarks>
            <doc-id>dd369141</doc-id>
            <unmanaged>HRESULT IMFTranscodeProfile::GetContainerAttributes([Out, Optional] IMFAttributes** ppAttrs)</unmanaged>
            <unmanaged-short>IMFTranscodeProfile::GetContainerAttributes</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TranscodeSinkInfoProvider.OutputFile">
            <summary>
            <p>Sets the name of the encoded output file.</p>
            </summary>
            <remarks>
            <p> The media sink will create a local file with the specified file name.</p><p>Alternately, you can call <strong>IMFTranscodeSinkInfoProvider::SetOutputByteStream</strong> to specify a byte stream  that will receive the transcoded data. These two methods are mutually exclusive.</p>
            </remarks>
            <doc-id>dd369149</doc-id>
            <unmanaged>SetOutputFile</unmanaged>
            <unmanaged-short>SetOutputFile</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TranscodeSinkInfoProvider.OutputByteStream">
            <summary>
            <p>Sets an output byte stream for the transcode media sink.</p>
            </summary>
            <remarks>
            <p>Call this method to provide a writeable byte stream  that will receive the transcoded data.</p><p>Alternatively, you can provide the name of an  output file, by calling <strong>IMFTranscodeSinkInfoProvider::SetOutputFile</strong>. These two methods are mutually exclusive.</p><p>The <em>pByteStreamActivate</em> parameter must specify an activation object that creates a writeable byte stream. Internally, the transcode media sink calls <strong>IMFActivate::ActivateObject</strong> to create the byte stream, as follows:</p><code><see cref = "T:SharpDX.MediaFoundation.IByteStream"/> *pByteStream = <c>null</c>; <see cref = "T:SharpDX.Result"/> hr = pByteStreamActivate-&gt;ActivateObject(IID_IMFByteStream, (void**)&amp;pByteStream);</code><p>Currently, Microsoft Media Foundation does not provide any byte-stream activation objects. To use this method, an application must provide a custom implementation of <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong>.</p>
            </remarks>
            <doc-id>dd369148</doc-id>
            <unmanaged>SetOutputByteStream</unmanaged>
            <unmanaged-short>SetOutputByteStream</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TranscodeSinkInfoProvider.Profile">
            <summary>
            <p>Sets the transcoding profile on the transcode sink activation object.</p>
            </summary>
            <remarks>
            <p>Before calling this method, initialize the profile object as follows:</p><ul> <li>Set the <see cref = "!:TranscodeContainertype"/> attribute to specify the container type of the output file.</li> <li>If the output file will have a video stream, set video attributes by calling the <strong>IMFTranscodeProfile::SetVideoAttributes</strong> method.</li> <li>If the output file will have an audio stream, set audio attributes by calling the <strong>IMFTranscodeProfile::SetAudioAttributes</strong> method.</li> </ul>
            </remarks>
            <doc-id>dd369150</doc-id>
            <unmanaged>SetProfile</unmanaged>
            <unmanaged-short>SetProfile</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TranscodeSinkInfoProvider.SinkInfo">
            <summary>
            <p> Gets the media types for the audio and video streams specified in the transcode profile.</p>
            </summary>
            <remarks>
            <p>Before calling this method, call <strong>IMFTranscodeSinkInfoProvider::SetProfile</strong> to set the transcode profile. The <strong>GetSinkInfo</strong> method  uses the profile to create media types for the audio and video streams. </p>
            </remarks>
            <doc-id>dd369147</doc-id>
            <unmanaged>GetSinkInfo</unmanaged>
            <unmanaged-short>GetSinkInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TranscodeSinkInfoProvider.SetOutputFile(System.String)">
            <summary>
            <p>Sets the name of the encoded output file.</p>
            </summary>
            <param name = "wszFileNameRef"><dd> <p>Pointer to a null-terminated string that contains the name of the output file.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The media sink will create a local file with the specified file name.</p><p>Alternately, you can call <strong>IMFTranscodeSinkInfoProvider::SetOutputByteStream</strong> to specify a byte stream  that will receive the transcoded data. These two methods are mutually exclusive.</p>
            </remarks>
            <doc-id>dd369149</doc-id>
            <unmanaged>HRESULT IMFTranscodeSinkInfoProvider::SetOutputFile([In] const wchar_t* pwszFileName)</unmanaged>
            <unmanaged-short>IMFTranscodeSinkInfoProvider::SetOutputFile</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TranscodeSinkInfoProvider.SetOutputByteStream(SharpDX.MediaFoundation.Activate)">
            <summary>
            <p>Sets an output byte stream for the transcode media sink.</p>
            </summary>
            <param name = "byteStreamActivateRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong> interface of a byte-stream activation object. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Call this method to provide a writeable byte stream  that will receive the transcoded data.</p><p>Alternatively, you can provide the name of an  output file, by calling <strong>IMFTranscodeSinkInfoProvider::SetOutputFile</strong>. These two methods are mutually exclusive.</p><p>The <em>pByteStreamActivate</em> parameter must specify an activation object that creates a writeable byte stream. Internally, the transcode media sink calls <strong>IMFActivate::ActivateObject</strong> to create the byte stream, as follows:</p><code><see cref = "T:SharpDX.MediaFoundation.IByteStream"/> *pByteStream = <c>null</c>; <see cref = "T:SharpDX.Result"/> hr = pByteStreamActivate-&gt;ActivateObject(IID_IMFByteStream, (void**)&amp;pByteStream);</code><p>Currently, Microsoft Media Foundation does not provide any byte-stream activation objects. To use this method, an application must provide a custom implementation of <strong><see cref = "T:SharpDX.MediaFoundation.Activate"/></strong>.</p>
            </remarks>
            <doc-id>dd369148</doc-id>
            <unmanaged>HRESULT IMFTranscodeSinkInfoProvider::SetOutputByteStream([In] IMFActivate* pByteStreamActivate)</unmanaged>
            <unmanaged-short>IMFTranscodeSinkInfoProvider::SetOutputByteStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TranscodeSinkInfoProvider.SetProfile(SharpDX.MediaFoundation.TranscodeProfile)">
            <summary>
            <p>Sets the transcoding profile on the transcode sink activation object.</p>
            </summary>
            <param name = "profileRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.TranscodeProfile"/></strong> interface. To get a reference to this interface, call <strong>MFCreateTranscodeProfile</strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Before calling this method, initialize the profile object as follows:</p><ul> <li>Set the <see cref = "!:TranscodeContainertype"/> attribute to specify the container type of the output file.</li> <li>If the output file will have a video stream, set video attributes by calling the <strong>IMFTranscodeProfile::SetVideoAttributes</strong> method.</li> <li>If the output file will have an audio stream, set audio attributes by calling the <strong>IMFTranscodeProfile::SetAudioAttributes</strong> method.</li> </ul>
            </remarks>
            <doc-id>dd369150</doc-id>
            <unmanaged>HRESULT IMFTranscodeSinkInfoProvider::SetProfile([In] IMFTranscodeProfile* pProfile)</unmanaged>
            <unmanaged-short>IMFTranscodeSinkInfoProvider::SetProfile</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TranscodeSinkInfoProvider.GetSinkInfo(SharpDX.MediaFoundation.TranscodeSinkInformation@)">
            <summary>
            <p> Gets the media types for the audio and video streams specified in the transcode profile.</p>
            </summary>
            <param name = "sinkInfoRef"><dd> <p>A reference to an <strong><see cref = "T:SharpDX.MediaFoundation.TranscodeSinkInformation"/></strong> structure.</p> <p>If the method succeeds, the method assigns <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> references to the <strong>pAudioMediaType</strong> and <strong>pVideoMediaType</strong> members of this structure. The method might set either member to <strong><c>null</c></strong>. If either member is non-<c>null</c> after the method returns, the caller must release the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> references.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Before calling this method, call <strong>IMFTranscodeSinkInfoProvider::SetProfile</strong> to set the transcode profile. The <strong>GetSinkInfo</strong> method  uses the profile to create media types for the audio and video streams. </p>
            </remarks>
            <doc-id>dd369147</doc-id>
            <unmanaged>HRESULT IMFTranscodeSinkInfoProvider::GetSinkInfo([Out] MF_TRANSCODE_SINK_INFO* pSinkInfo)</unmanaged>
            <unmanaged-short>IMFTranscodeSinkInfoProvider::GetSinkInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TrustedInput.GetInputTrustAuthority(System.Int32,System.Guid,SharpDX.IUnknown@)">
            <summary>
            <p> </p><p>Retrieves the input trust authority (ITA) for a specified stream.</p>
            </summary>
            <param name = "dwStreamID"><dd> <p>The stream identifier for which the ITA is being requested.</p> </dd></param>
            <param name = "riid"><dd> <p>The interface identifier (IID) of the interface being requested. Currently the only supported value is IID_IMFInputTrustAuthority.</p> </dd></param>
            <param name = "unkObjectOut"><dd> <p>Receives a reference to the ITA's <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface. The caller must release the interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_NOINTERFACE</strong></dt> </dl> </td><td> <p>The ITA does not expose the requested interface.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970501</doc-id>
            <unmanaged>HRESULT IMFTrustedInput::GetInputTrustAuthority([In] DWORD dwStreamID,[In] const GUID&amp; riid,[Out] IUnknown** ppunkObject)</unmanaged>
            <unmanaged-short>IMFTrustedInput::GetInputTrustAuthority</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TrustedOutput.OutputTrustAuthorityCount">
            <summary>
            <p> Gets the number of output trust authorities (OTAs) provided by this trusted output. Each OTA reports a single action.</p>
            </summary>
            <doc-id>bb970384</doc-id>
            <unmanaged>GetOutputTrustAuthorityCount</unmanaged>
            <unmanaged-short>GetOutputTrustAuthorityCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TrustedOutput.IsFinal">
            <summary>
            <p> </p><p>Queries whether this output is a policy sink, meaning it handles the rights and restrictions required by the input trust authority (ITA).</p>
            </summary>
            <remarks>
            <p>A trusted output is generally considered to be a policy sink if it does not pass the media content that it receives anywhere else; or, if it does pass the media content elsewhere, either it protects the content using some proprietary method such as encryption, or it sufficiently devalues the content so as not to require protection.</p>
            </remarks>
            <doc-id>bb970324</doc-id>
            <unmanaged>IsFinal</unmanaged>
            <unmanaged-short>IsFinal</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TrustedOutput.GetOutputTrustAuthorityCount(System.Int32@)">
            <summary>
            <p> Gets the number of output trust authorities (OTAs) provided by this trusted output. Each OTA reports a single action.</p>
            </summary>
            <param name = "cOutputTrustAuthoritiesRef"><dd> <p> Receives the number of OTAs. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>bb970384</doc-id>
            <unmanaged>HRESULT IMFTrustedOutput::GetOutputTrustAuthorityCount([Out] DWORD* pcOutputTrustAuthorities)</unmanaged>
            <unmanaged-short>IMFTrustedOutput::GetOutputTrustAuthorityCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TrustedOutput.GetOutputTrustAuthorityByIndex(System.Int32,SharpDX.MediaFoundation.OutputTrustAuthority@)">
            <summary>
            <p> Gets an output trust authority (OTA), specified by index.</p>
            </summary>
            <param name = "dwIndex"><dd> <p> Zero-based index of the OTA to retrieve. To get the number of OTAs provided by this object, call <strong>IMFTrustedOutput::GetOutputTrustAuthorityCount</strong>. </p> </dd></param>
            <param name = "authorityOut"><dd> <p> Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.OutputTrustAuthority"/></strong> interface of the OTA. The caller must release the interface. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>bb970401</doc-id>
            <unmanaged>HRESULT IMFTrustedOutput::GetOutputTrustAuthorityByIndex([In] DWORD dwIndex,[Out] IMFOutputTrustAuthority** ppauthority)</unmanaged>
            <unmanaged-short>IMFTrustedOutput::GetOutputTrustAuthorityByIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TrustedOutput.IsFinal_(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p> </p><p>Queries whether this output is a policy sink, meaning it handles the rights and restrictions required by the input trust authority (ITA).</p>
            </summary>
            <param name = "fIsFinalRef"><dd> <p>Receives a Boolean value. If <strong>TRUE</strong>, this object is a policy sink. If <strong><see cref = "F:SharpDX.Result.False"/></strong>, the policy must be enforced further downstream.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>A trusted output is generally considered to be a policy sink if it does not pass the media content that it receives anywhere else; or, if it does pass the media content elsewhere, either it protects the content using some proprietary method such as encryption, or it sufficiently devalues the content so as not to require protection.</p>
            </remarks>
            <doc-id>bb970324</doc-id>
            <unmanaged>HRESULT IMFTrustedOutput::IsFinal([Out] BOOL* pfIsFinal)</unmanaged>
            <unmanaged-short>IMFTrustedOutput::IsFinal</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.TrustedVideoPlugin.Constriction">
            <summary>
            <p> Limits the effective video resolution. </p>
            </summary>
            <remarks>
            <p>This method limits the effective resolution of the video image. The actual resolution on the target device might be higher, due to stretching the image.</p><p>The EVR might call this method at any time if the <strong>IEVRTrustedVideoPlugin::CanConstrict</strong> method returns <strong>TRUE</strong>.</p>
            </remarks>
            <doc-id>aa473833</doc-id>
            <unmanaged>SetConstriction</unmanaged>
            <unmanaged-short>SetConstriction</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TrustedVideoPlugin.IsInTrustedVideoMode(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p> Queries whether the plug-in has any transient vulnerabilities at this time. </p>
            </summary>
            <param name = "yesRef"><dd> <p>Receives a Boolean value. If <strong>TRUE</strong>, the plug-in has no transient vulnerabilities at the moment and can receive protected content. If <strong><see cref = "F:SharpDX.Result.False"/></strong>, the plug-in has a transient vulnerability. If the method fails, the EVR treats the value as <strong><see cref = "F:SharpDX.Result.False"/></strong> (untrusted).</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method provides a way for the plug-in to report temporary conditions that would cause the input trust authority (ITA) to distrust the plug-in. For example, if an EVR presenter is in windowed mode, it is vulnerable to GDI screen captures.</p><p>To disable screen capture in Direct3D, the plug-in must do the following:</p><ul> <li> <p>Create the Direct3D device in full-screen exlusive mode.</p> </li> <li> <p>Specify the D3DCREATE_DISABLE_PRINTSCREEN flag when you create the device. For more information, see <strong>IDirect3D9::CreateDevice</strong> in the DirectX documentation.</p> </li> </ul><p>In addition, the graphics adapter must support the Windows Vista Display Driver Model (WDDM) and the Direct3D extensions for Windows Vista (sometimes called D3D9Ex or D3D9L).</p><p>If these conditions are met, the presenter can return <strong>TRUE</strong> in the <em>pYes</em> parameter. Otherwise, it should return <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p><p>The EVR calls this method whenever the device changes. If the plug-in returns <strong><see cref = "F:SharpDX.Result.False"/></strong>, the EVR treats this condition as if the plug-in had a new output connector of unknown type. The policy object can then allow or block playback, depending on the ITA's policy.</p><p>This method should be used only to report transient conditions. A plug-in that is never in a trusted state should not implement the <strong><see cref = "T:SharpDX.MediaFoundation.TrustedVideoPlugin"/></strong> interface at all.</p>
            </remarks>
            <doc-id>aa473794</doc-id>
            <unmanaged>HRESULT IEVRTrustedVideoPlugin::IsInTrustedVideoMode([In] BOOL* pYes)</unmanaged>
            <unmanaged-short>IEVRTrustedVideoPlugin::IsInTrustedVideoMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TrustedVideoPlugin.CanConstrict(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p> Queries whether the plug-in can limit the effective video resolution. </p>
            </summary>
            <param name = "yesRef"><dd> <p>Receives a Boolean value. If <strong>TRUE</strong>, the plug-in can limit the effective video resolution. Otherwise, the plug-in cannot limit the video resolution. If the method fails, the EVR treats the value as <strong><see cref = "F:SharpDX.Result.False"/></strong> (not supported).</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Constriction is a protection mechanism that limits the effective resolution of the video frame to a specified maximum number of pixels.</p><p>Video constriction can be implemented by either the mixer or the presenter.</p><p>If the method returns <strong>TRUE</strong>, the EVR might call <strong>IEVRTrustedVideoPlugin::SetConstriction</strong> at any time.</p>
            </remarks>
            <doc-id>aa473782</doc-id>
            <unmanaged>HRESULT IEVRTrustedVideoPlugin::CanConstrict([In] BOOL* pYes)</unmanaged>
            <unmanaged-short>IEVRTrustedVideoPlugin::CanConstrict</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TrustedVideoPlugin.SetConstriction(System.Int32)">
            <summary>
            <p> Limits the effective video resolution. </p>
            </summary>
            <param name = "dwKPix"><dd> <p>Maximum number of source pixels that may appear in the final video image, in thousands of pixels. If the value is zero, the video is disabled. If the value is MAXDWORD (0xFFFFFFFF), video constriction is removed and the video may be rendered at full resolution.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method limits the effective resolution of the video image. The actual resolution on the target device might be higher, due to stretching the image.</p><p>The EVR might call this method at any time if the <strong>IEVRTrustedVideoPlugin::CanConstrict</strong> method returns <strong>TRUE</strong>.</p>
            </remarks>
            <doc-id>aa473833</doc-id>
            <unmanaged>HRESULT IEVRTrustedVideoPlugin::SetConstriction([In] DWORD dwKPix)</unmanaged>
            <unmanaged-short>IEVRTrustedVideoPlugin::SetConstriction</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.TrustedVideoPlugin.DisableImageExport(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p> Enables or disables the ability of the plug-in to export the video image. </p>
            </summary>
            <param name = "bDisable"><dd> <p>Boolean value. Specify <strong>TRUE</strong> to disable image exporting, or <strong><see cref = "F:SharpDX.Result.False"/></strong> to enable it.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>An EVR plug-in might expose a way for the application to get a copy of the video frames. For example, the standard EVR presenter implements <strong>IMFVideoDisplayControl::GetCurrentImage</strong>.</p><p>If the plug-in supports image exporting, this method enables or disables it. Before this method has been called for the first time, the EVR assumes that the mechanism is enabled.</p><p>If the plug-in does not support image exporting, this method should return <see cref = "F:SharpDX.Result.Ok"/> and ignore the value of <em>bDisable</em>. If the method fails, the EVR treats it as a failure to enforce the policy, which will probably cause playback to stop.</p><p>While image exporting is disabled, any associated export method, such as <strong>GetCurrentImage</strong>, should return <see cref = "!:LicenseIncorrectRights"/>.</p>
            </remarks>
            <doc-id>aa473830</doc-id>
            <unmanaged>HRESULT IEVRTrustedVideoPlugin::DisableImageExport([In] BOOL bDisable)</unmanaged>
            <unmanaged-short>IEVRTrustedVideoPlugin::DisableImageExport</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.VideoDeviceID.DeviceID">
            <summary>
            <p> </p><p>Returns the identifier of the video device supported by an EVR mixer or presenter.</p>
            </summary>
            <remarks>
            <p>If a mixer or presenter uses Direct3D 9, it must return the value IID_IDirect3DDevice9 in <em>pDeviceID</em>. The EVR's default mixer and presenter both return this value. If you write a custom mixer or presenter, it can return some other value. However, the mixer and presenter must use matching device identifiers.</p>
            </remarks>
            <doc-id>ms704630</doc-id>
            <unmanaged>GetDeviceID</unmanaged>
            <unmanaged-short>GetDeviceID</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoDeviceID.GetDeviceID(System.Guid@)">
            <summary>
            <p> </p><p>Returns the identifier of the video device supported by an EVR mixer or presenter.</p>
            </summary>
            <param name = "deviceIDRef"><dd> <p>Receives the device identifier. Generally, the value is IID_IDirect3DDevice9.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If a mixer or presenter uses Direct3D 9, it must return the value IID_IDirect3DDevice9 in <em>pDeviceID</em>. The EVR's default mixer and presenter both return this value. If you write a custom mixer or presenter, it can return some other value. However, the mixer and presenter must use matching device identifiers.</p>
            </remarks>
            <doc-id>ms704630</doc-id>
            <unmanaged>HRESULT IMFVideoDeviceID::GetDeviceID([Out] GUID* pDeviceID)</unmanaged>
            <unmanaged-short>IMFVideoDeviceID::GetDeviceID</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.VideoDisplayControl.AspectRatioMode">
            <summary>
            <p> Queries how the enhanced video renderer (EVR) handles the aspect ratio of the source video. </p>
            </summary>
            <doc-id>ms702253</doc-id>
            <unmanaged>GetAspectRatioMode / SetAspectRatioMode</unmanaged>
            <unmanaged-short>GetAspectRatioMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.VideoDisplayControl.VideoWindow">
            <summary>
            <p>Gets or sets the clipping window for the video. </p>
            </summary>
            <remarks>
            <p>There is no default clipping window. The application must set the clipping window.</p>
            </remarks>
            <doc-id>ms694138</doc-id>
            <unmanaged>GetVideoWindow / SetVideoWindow</unmanaged>
            <unmanaged-short>GetVideoWindow</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.VideoDisplayControl.BorderColor">
            <summary>
            <p>Gets or sets the border color for the video. </p>
            </summary>
            <remarks>
            <p>The border color is used for areas where the enhanced video renderer (EVR) does not draw any video.</p><p>The border color is not used for letterboxing. To get the letterbox color, call <strong>IMFVideoProcessor::GetBackgroundColor</strong>.</p>
            </remarks>
            <doc-id>ms694894</doc-id>
            <unmanaged>GetBorderColor / SetBorderColor</unmanaged>
            <unmanaged-short>GetBorderColor</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.VideoDisplayControl.RenderingPrefs">
            <summary>
            <p>Gets or sets various video rendering settings. </p>
            </summary>
            <doc-id>ms701592</doc-id>
            <unmanaged>GetRenderingPrefs / SetRenderingPrefs</unmanaged>
            <unmanaged-short>GetRenderingPrefs</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.VideoDisplayControl.Fullscreen">
            <summary>
            <p> Queries whether the enhanced video renderer (EVR) is currently in full-screen mode. </p>
            </summary>
            <doc-id>ms704817</doc-id>
            <unmanaged>GetFullscreen / SetFullscreen</unmanaged>
            <unmanaged-short>GetFullscreen</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoDisplayControl.GetNativeVideoSize(System.IntPtr,System.IntPtr)">
            <summary>
            <p> Gets the size and aspect ratio of the video, prior to any stretching by the video renderer. </p>
            </summary>
            <param name = "szVideoRef"><dd> <p>Receives the size of the native video rectangle. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "szARVideoRef"><dd> <p>Receives the aspect ratio of the video. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>At least one of the parameters must be non-<strong><c>null</c></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If no media types have been set on any video streams, the method succeeds but all parameters are set to zero.</p><p>You can set <em>pszVideo</em> or <em>pszARVideo</em> to <strong><c>null</c></strong>, but not both.</p>
            </remarks>
            <doc-id>ms694294</doc-id>
            <unmanaged>HRESULT IMFVideoDisplayControl::GetNativeVideoSize([InOut, Optional] SIZE* pszVideo,[InOut, Optional] SIZE* pszARVideo)</unmanaged>
            <unmanaged-short>IMFVideoDisplayControl::GetNativeVideoSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoDisplayControl.GetIdealVideoSize(System.IntPtr,System.IntPtr)">
            <summary>
            <p> Gets the range of sizes that the enhanced video renderer (EVR) can display without significantly degrading performance or image quality. </p>
            </summary>
            <param name = "szMinRef"><dd> <p>Receives the minimum ideal size. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "szMaxRef"><dd> <p>Receives the maximum ideal size. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>At least one parameter must be non-<strong><c>null</c></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>You can set <em>pszMin</em> or <em>pszMax</em> to <strong><c>null</c></strong>, but not both.</p>
            </remarks>
            <doc-id>ms703076</doc-id>
            <unmanaged>HRESULT IMFVideoDisplayControl::GetIdealVideoSize([InOut, Optional] SIZE* pszMin,[InOut, Optional] SIZE* pszMax)</unmanaged>
            <unmanaged-short>IMFVideoDisplayControl::GetIdealVideoSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoDisplayControl.SetVideoPosition(System.Nullable{SharpDX.MediaFoundation.VideoNormalizedRect},System.Nullable{SharpDX.Mathematics.Interop.RawRectangle})">
            <summary>
            <p> </p><p>Sets the source and destination rectangles for the video.</p>
            </summary>
            <param name = "nrcSourceRef"><dd> <p>Pointer to an <strong><see cref = "T:SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure that specifies the source rectangle. This parameter can be <strong><c>null</c></strong>. If this parameter is <strong><c>null</c></strong>, the source rectangle does not change.</p> </dd></param>
            <param name = "rcDestRef"><dd> <p>Specifies the destination rectangle. This parameter can be <strong><c>null</c></strong>. If this parameter is <strong><c>null</c></strong>, the destination rectangle does not change.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>At least one parameter must be non-<strong><c>null</c></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The source rectangle defines which portion of the video is displayed. It is specified in <em>normalized</em> coordinates. For more information, see <strong><see cref = "T:SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure. To display the entire video image, set the source rectangle to {0, 0, 1, 1}. The default source rectangle is {0, 0, 1, 1}.</p><p>The destination rectangle defines a rectangle within the clipping window where the video appears. It is specified in pixels, relative to the client area of the window. To fill the entire window, set the destination rectangle to {0, 0, <em>width</em>, <em>height</em>}, where <em>width</em> and <em>height</em> are dimensions of the window client area. The default destination rectangle is {0, 0, 0, 0}.</p><p>To update just one of these rectangles, set the other parameter to <strong><c>null</c></strong>. You can set <em>pnrcSource</em> or <em>prcDest</em> to <strong><c>null</c></strong>, but not both.</p><p>Before setting the destination rectangle (<em>prcDest</em>), you must set the video window by calling <strong>IMFVideoDisplayControl::SetVideoWindow</strong>. (For the Media Foundation version of the EVR, you can also provide the video window in the <strong>MFCreateVideoRendererActivate</strong> function.) If no video window was provided, <strong>SetVideoPosition</strong> returns E_POINTER.</p>
            </remarks>
            <doc-id>ms697352</doc-id>
            <unmanaged>HRESULT IMFVideoDisplayControl::SetVideoPosition([In, Optional] const MFVideoNormalizedRect* pnrcSource,[In, Optional] const RECT* prcDest)</unmanaged>
            <unmanaged-short>IMFVideoDisplayControl::SetVideoPosition</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoDisplayControl.GetVideoPosition(SharpDX.MediaFoundation.VideoNormalizedRect@,SharpDX.Mathematics.Interop.RawRectangle@)">
            <summary>
            <p> Gets the source and destination rectangles for the video. </p>
            </summary>
            <param name = "nrcSourceRef"><dd> <p>Pointer to an <strong><see cref = "T:SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure that receives the source rectangle.</p> </dd></param>
            <param name = "rcDestRef"><dd> <p>Receives the current destination rectangle.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>One or more required parameters are <strong><c>null</c></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970409</doc-id>
            <unmanaged>HRESULT IMFVideoDisplayControl::GetVideoPosition([Out] MFVideoNormalizedRect* pnrcSource,[Out] RECT* prcDest)</unmanaged>
            <unmanaged-short>IMFVideoDisplayControl::GetVideoPosition</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoDisplayControl.SetAspectRatioMode(System.Int32)">
            <summary>
            <p> </p><p>Specifies how the enhanced video renderer (EVR) handles the aspect ratio of the source video.</p>
            </summary>
            <param name = "dwAspectRatioMode"><dd> <p>Bitwise <strong>OR</strong> of one or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.VideoAspectRatioMode"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid flags.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms704027</doc-id>
            <unmanaged>HRESULT IMFVideoDisplayControl::SetAspectRatioMode([In] DWORD dwAspectRatioMode)</unmanaged>
            <unmanaged-short>IMFVideoDisplayControl::SetAspectRatioMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoDisplayControl.GetAspectRatioMode(System.Int32@)">
            <summary>
            <p> Queries how the enhanced video renderer (EVR) handles the aspect ratio of the source video. </p>
            </summary>
            <param name = "dwAspectRatioModeRef"><dd> <p>Receives a bitwise <strong>OR</strong> of one or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.VideoAspectRatioMode"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms702253</doc-id>
            <unmanaged>HRESULT IMFVideoDisplayControl::GetAspectRatioMode([Out] DWORD* pdwAspectRatioMode)</unmanaged>
            <unmanaged-short>IMFVideoDisplayControl::GetAspectRatioMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoDisplayControl.SetVideoWindow(System.IntPtr)">
            <summary>
            <p> </p><p>Sets the source and destination rectangles for the video.</p>
            </summary>
            <param name = "hwndVideo"><dd> <p>Pointer to an <strong><see cref = "T:SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure that specifies the source rectangle. This parameter can be <strong><c>null</c></strong>. If this parameter is <strong><c>null</c></strong>, the source rectangle does not change.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_POINTER</strong></dt> </dl> </td><td> <p>At least one parameter must be non-<strong><c>null</c></strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The source rectangle defines which portion of the video is displayed. It is specified in <em>normalized</em> coordinates. For more information, see <strong><see cref = "T:SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure. To display the entire video image, set the source rectangle to {0, 0, 1, 1}. The default source rectangle is {0, 0, 1, 1}.</p><p>The destination rectangle defines a rectangle within the clipping window where the video appears. It is specified in pixels, relative to the client area of the window. To fill the entire window, set the destination rectangle to {0, 0, <em>width</em>, <em>height</em>}, where <em>width</em> and <em>height</em> are dimensions of the window client area. The default destination rectangle is {0, 0, 0, 0}.</p><p>To update just one of these rectangles, set the other parameter to <strong><c>null</c></strong>. You can set <em>pnrcSource</em> or <em>prcDest</em> to <strong><c>null</c></strong>, but not both.</p><p>Before setting the destination rectangle (<em>prcDest</em>), you must set the video window by calling <strong>IMFVideoDisplayControl::SetVideoWindow</strong>. (For the Media Foundation version of the EVR, you can also provide the video window in the <strong>MFCreateVideoRendererActivate</strong> function.) If no video window was provided, <strong>SetVideoPosition</strong> returns E_POINTER.</p>
            </remarks>
            <doc-id>ms697352</doc-id>
            <unmanaged>HRESULT IMFVideoDisplayControl::SetVideoWindow([In] HWND hwndVideo)</unmanaged>
            <unmanaged-short>IMFVideoDisplayControl::SetVideoWindow</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoDisplayControl.GetVideoWindow(System.IntPtr@)">
            <summary>
            <p> Gets the clipping window for the video. </p>
            </summary>
            <param name = "hwndVideoRef"><dd> <p>Receives a handle to the window where the enhanced video renderer (EVR) will draw the video.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>There is no default clipping window. The application must set the clipping window.</p>
            </remarks>
            <doc-id>ms694138</doc-id>
            <unmanaged>HRESULT IMFVideoDisplayControl::GetVideoWindow([Out] HWND* phwndVideo)</unmanaged>
            <unmanaged-short>IMFVideoDisplayControl::GetVideoWindow</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoDisplayControl.RepaintVideo">
            <summary>
            <p> </p><p>Repaints the current video frame. Call this method whenever the application receives a WM_PAINT message.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The EVR cannot repaint the frame at this time. This error can occur while the EVR is switching between full-screen and windowed mode. The caller can safely ignore this error.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms703113</doc-id>
            <unmanaged>HRESULT IMFVideoDisplayControl::RepaintVideo()</unmanaged>
            <unmanaged-short>IMFVideoDisplayControl::RepaintVideo</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoDisplayControl.GetCurrentImage(SharpDX.Win32.BitmapInfoHeader@,System.Byte[],System.Int32@,System.IntPtr)">
            <summary>
            <p> Gets a copy of the current image being displayed by the video renderer. </p>
            </summary>
            <param name = "bihRef"><dd> <p>Pointer to a <strong><see cref = "T:SharpDX.Win32.BitmapInfoHeader"/></strong> structure that receives a description of the bitmap. Set the <strong>biSize</strong> member of the structure to <code>sizeof(<see cref = "T:SharpDX.Win32.BitmapInfoHeader"/>)</code> before calling the method.</p> </dd></param>
            <param name = "dibRef"><dd> <p>Receives a reference to a buffer that contains a packed Windows device-independent bitmap (DIB). The caller must free the memory for the bitmap by calling <strong>CoTaskMemFree</strong>.</p> </dd></param>
            <param name = "cbDibRef"><dd> <p>Receives the size of the buffer returned in <em>pDib</em>, in bytes.</p> </dd></param>
            <param name = "timeStampRef"><dd> <p>Receives the time stamp of the captured image.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:LicenseIncorrectRights"/></strong></dt> </dl> </td><td> <p>The content is protected and the license does not permit capturing the image.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method can be called at any time. However, calling the method too frequently degrades the video playback performance.</p><p>This method retrieves a copy of the final composited image, which includes any substreams, alpha-blended bitmap, aspect ratio correction, background color, and so forth.</p><p>In windowed mode, the bitmap is the size of the destination rectangle specified in <strong>IMFVideoDisplayControl::SetVideoPosition</strong>. In full-screen mode, the bitmap is the size of the display.</p>
            </remarks>
            <doc-id>ms695342</doc-id>
            <unmanaged>HRESULT IMFVideoDisplayControl::GetCurrentImage([InOut] BITMAPINFOHEADER* pBih,[Buffer, Optional] unsigned char** pDib,[Out] DWORD* pcbDib,[InOut, Optional] longlong* pTimeStamp)</unmanaged>
            <unmanaged-short>IMFVideoDisplayControl::GetCurrentImage</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoDisplayControl.SetBorderColor(System.Int32)">
            <summary>
            <p> </p><p>Sets the border color for the video.</p>
            </summary>
            <param name = "clr"><dd> <p>Specifies the border color as a <strong><see cref = "T:System.Int32"/></strong> value.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>By default, if the video window straddles two monitors, the enhanced video renderer (EVR) clips the video to one monitor and draws the border color on the remaining portion of the window. (To change the clipping behavior, call <strong>IMFVideoDisplayControl::SetRenderingPrefs</strong>.)</p><p>The border color is not used for letterboxing. To change the letterbox color, call <strong>IMFVideoProcessor::SetBackgroundColor</strong>.</p>
            </remarks>
            <doc-id>ms697024</doc-id>
            <unmanaged>HRESULT IMFVideoDisplayControl::SetBorderColor([In] COLORREF Clr)</unmanaged>
            <unmanaged-short>IMFVideoDisplayControl::SetBorderColor</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoDisplayControl.GetBorderColor(System.Int32@)">
            <summary>
            <p> Gets the border color for the video. </p>
            </summary>
            <param name = "clrRef"><dd> <p>Receives the border color, as a <strong><see cref = "T:System.Int32"/></strong> value.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The border color is used for areas where the enhanced video renderer (EVR) does not draw any video.</p><p>The border color is not used for letterboxing. To get the letterbox color, call <strong>IMFVideoProcessor::GetBackgroundColor</strong>.</p>
            </remarks>
            <doc-id>ms694894</doc-id>
            <unmanaged>HRESULT IMFVideoDisplayControl::GetBorderColor([Out] COLORREF* pClr)</unmanaged>
            <unmanaged-short>IMFVideoDisplayControl::GetBorderColor</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoDisplayControl.SetRenderingPrefs(System.Int32)">
            <summary>
            <p> </p><p>Sets various preferences related to video rendering.</p>
            </summary>
            <param name = "dwRenderFlags"><dd> <p>Bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.VideoRenderPrefs"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Invalid flags.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms698981</doc-id>
            <unmanaged>HRESULT IMFVideoDisplayControl::SetRenderingPrefs([In] DWORD dwRenderFlags)</unmanaged>
            <unmanaged-short>IMFVideoDisplayControl::SetRenderingPrefs</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoDisplayControl.GetRenderingPrefs(System.Int32@)">
            <summary>
            <p> Gets various video rendering settings. </p>
            </summary>
            <param name = "dwRenderFlagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.VideoRenderPrefs"/></strong> enumeration.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms701592</doc-id>
            <unmanaged>HRESULT IMFVideoDisplayControl::GetRenderingPrefs([Out] DWORD* pdwRenderFlags)</unmanaged>
            <unmanaged-short>IMFVideoDisplayControl::GetRenderingPrefs</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoDisplayControl.SetFullscreen(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>[This API is not supported and may be altered or unavailable in the future. ]</p><p> Sets or unsets full-screen rendering mode.</p><p>To implement full-screen playback, an application should simply resize the video window to cover the entire area of the monitor. Also set the window to be a topmost window, so that the application receives all mouse-click messages. For more information about topmost windows, see the documentation for the <strong>SetWindowPos</strong> function.</p>
            </summary>
            <param name = "fFullscreen">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p> The video renderer has been shut down. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> The default EVR presenter implements full-screen mode using Direct3D exclusive mode. </p><p> If you use this  method  to switch to full-screen mode, set the application window to be a topmost window and resize the window to cover the entire monitor. This ensures that the application window receives all mouse-click messages. Also set the keyboard focus to the application window. When you switch out of full-screen mode, restore the window's original size and position. </p><p> By default, the cursor is still visible in full-screen mode. To hide the cursor, call <strong>ShowCursor</strong>. </p><p>The transition to and from full-screen mode occurs asynchronously. To get the current mode, call <strong>IMFVideoDisplayControl::GetFullscreen</strong>.</p>
            </remarks>
            <doc-id>ms701561</doc-id>
            <unmanaged>HRESULT IMFVideoDisplayControl::SetFullscreen([In] BOOL fFullscreen)</unmanaged>
            <unmanaged-short>IMFVideoDisplayControl::SetFullscreen</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoDisplayControl.GetFullscreen(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p> Queries whether the enhanced video renderer (EVR) is currently in full-screen mode. </p>
            </summary>
            <param name = "fFullscreenRef"><dd> <p>Receives a Boolean value. If <strong>TRUE</strong>, the EVR is in full-screen mode. If <strong><see cref = "F:SharpDX.Result.False"/></strong>, the EVR will display the video inside the application-provided clipping window.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The EVR is currently switching between full-screen and windowed mode.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms704817</doc-id>
            <unmanaged>HRESULT IMFVideoDisplayControl::GetFullscreen([Out] BOOL* pfFullscreen)</unmanaged>
            <unmanaged-short>IMFVideoDisplayControl::GetFullscreen</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.VideoMediaType.VideoFormat">
            <summary>
            <p>Represents a description of a video format.</p>
            </summary>
            <remarks>
            <p>If the major type of a media type is <see cref = "!:Video"/>, you can query the media type object for the <strong><see cref = "T:SharpDX.MediaFoundation.VideoMediaType"/></strong> interface.</p><p>Applications should avoid using this interface except when a method or function requires an <strong><see cref = "T:SharpDX.MediaFoundation.VideoMediaType"/></strong> reference as a parameter. You can get all of the format information from a video media type through the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface, which <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> inherits.</p>
            </remarks>
            <doc-id>aa473814</doc-id>
            <unmanaged>GetVideoFormat</unmanaged>
            <unmanaged-short>GetVideoFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoMediaType.GetVideoFormat">
            <summary>
            <p>Represents a description of a video format.</p>
            </summary>
            <returns>No documentation.</returns>
            <remarks>
            <p>If the major type of a media type is <see cref = "!:Video"/>, you can query the media type object for the <strong><see cref = "T:SharpDX.MediaFoundation.VideoMediaType"/></strong> interface.</p><p>Applications should avoid using this interface except when a method or function requires an <strong><see cref = "T:SharpDX.MediaFoundation.VideoMediaType"/></strong> reference as a parameter. You can get all of the format information from a video media type through the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface, which <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> inherits.</p>
            </remarks>
            <doc-id>aa473814</doc-id>
            <unmanaged>const MFVIDEOFORMAT* IMFVideoMediaType::GetVideoFormat()</unmanaged>
            <unmanaged-short>IMFVideoMediaType::GetVideoFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoMediaType.GetVideoRepresentation(System.Guid,System.IntPtr@,System.Int32)">
            <summary>
            <p>[This API is not supported and may be altered or unavailable in the future. Instead, applications should set the <strong><see cref = "!:DefaultStride"/></strong> attribute on the media type to specify the surface stride and then call <strong>IMFMediaType::GetRepresentation</strong>.]</p><p> Retrieves an alternative representation of the media type.</p>
            </summary>
            <param name = "guidRepresentation">No documentation.</param>
            <param name = "vRepresentationOut">No documentation.</param>
            <param name = "lStride">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is equivalent to <strong>IMFMediaType::GetRepresentation</strong> but includes the <em>lStride</em> parameter.</p><p>Instead of calling this method, applications should set the <strong><see cref = "!:DefaultStride"/></strong> attribute on the media type to specify the surface stride and then call <strong>IMFMediaType::GetRepresentation</strong>.</p>
            </remarks>
            <doc-id>bb970371</doc-id>
            <unmanaged>HRESULT IMFVideoMediaType::GetVideoRepresentation([In] GUID guidRepresentation,[Out] void** ppvRepresentation,[In] LONG lStride)</unmanaged>
            <unmanaged-short>IMFVideoMediaType::GetVideoRepresentation</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoMixerControl.SetStreamZOrder(System.Int32,System.Int32)">
            <summary>
            <p> </p><p>Sets the z-order of a video stream.</p>
            </summary>
            <param name = "dwStreamID"><dd> <p>Identifier of the stream. For the EVR media sink, the stream identifier is defined when the <strong>IMFMediaSink::AddStreamSink</strong> method is called. For the DirectShow EVR filter, the stream identifier corresponds to the pin index. The reference stream is always stream 0.</p> </dd></param>
            <param name = "dwZ"><dd> <p>Z-order value. The z-order of the reference stream must be zero. The maximum z-order value is the number of streams minus one.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The value of <em>dwZ</em> is larger than the maximum z-order value.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>Invalid z-order for this stream. For the reference stream, <em>dwZ</em> must be zero. For all other streams, <em>dwZ</em> must be greater than zero.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>Invalid stream identifier.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The EVR draws the video streams in the order of their z-order values, starting with zero. The reference stream must be first in the z-order, and the remaining streams can be in any order.</p>
            </remarks>
            <doc-id>ms697453</doc-id>
            <unmanaged>HRESULT IMFVideoMixerControl::SetStreamZOrder([In] DWORD dwStreamID,[In] DWORD dwZ)</unmanaged>
            <unmanaged-short>IMFVideoMixerControl::SetStreamZOrder</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoMixerControl.GetStreamZOrder(System.Int32,System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the z-order of a video stream.</p>
            </summary>
            <param name = "dwStreamID"><dd> <p>Identifier of the stream. For the EVR media sink, the stream identifier is defined when the <strong>IMFMediaSink::AddStreamSink</strong> method is called. For the DirectShow EVR filter, the stream identifier corresponds to the pin index. The reference stream is always stream 0.</p> </dd></param>
            <param name = "dwZRef"><dd> <p>Receives the z-order value.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>Invalid stream identifier.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms701614</doc-id>
            <unmanaged>HRESULT IMFVideoMixerControl::GetStreamZOrder([In] DWORD dwStreamID,[Out] DWORD* pdwZ)</unmanaged>
            <unmanaged-short>IMFVideoMixerControl::GetStreamZOrder</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoMixerControl.SetStreamOutputRect(System.Int32,SharpDX.MediaFoundation.VideoNormalizedRect)">
            <summary>
            <p> Sets the position of a video stream within the composition rectangle. </p>
            </summary>
            <param name = "dwStreamID"><dd> <p>Identifier of the stream. For the EVR media sink, the stream identifier is defined when the <strong>IMFMediaSink::AddStreamSink</strong> method is called. For the DirectShow EVR filter, the stream identifier corresponds to the pin index. The reference stream is always stream 0.</p> </dd></param>
            <param name = "nrcOutputRef"><dd> <p>Pointer to an <strong><see cref = "T:SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure that defines the bounding rectangle for the video stream.</p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p> The coordinates of the bounding rectangle given in <em>pnrcOutput</em> are not valid. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p> Invalid stream identifier. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> The mixer draws each video stream inside a bounding rectangle that is specified relative to the final video image. This bounding rectangle is given in <em>normalized</em> coordinates. For more information, see <strong><see cref = "T:SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure. </p><p> The coordinates of the bounding rectangle must fall within the range [0.0, 1.0]. Also, the X and Y coordinates of the upper-left corner cannot exceed the X and Y coordinates of the lower-right corner. In other words, the bounding rectangle must fit entirely within the composition rectangle and cannot be flipped vertically or horizontally. </p><p>The following diagram shows how the EVR mixes substreams.</p><p>The output rectangle for the stream is specified by calling <strong>SetStreamOutputRect</strong>. The source rectangle is specified by calling <strong>IMFVideoDisplayControl::SetVideoPosition</strong>. The mixer applies the output rectangle first, when it mixes the streams into a single bounding rectangle. This bounding rectangle is called <em>composition space</em>. Then the presenter applies the source rectangle to the composited image.</p>
            </remarks>
            <doc-id>ms698959</doc-id>
            <unmanaged>HRESULT IMFVideoMixerControl::SetStreamOutputRect([In] DWORD dwStreamID,[In] const MFVideoNormalizedRect* pnrcOutput)</unmanaged>
            <unmanaged-short>IMFVideoMixerControl::SetStreamOutputRect</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoMixerControl.GetStreamOutputRect(System.Int32,SharpDX.MediaFoundation.VideoNormalizedRect@)">
            <summary>
            <p> </p><p>Retrieves the position of a video stream within the composition rectangle.</p>
            </summary>
            <param name = "dwStreamID"><dd> <p>The identifier of the stream. For the EVR media sink, the stream identifier is defined when the <strong>IMFMediaSink::AddStreamSink</strong> method is called. For the DirectShow EVR filter, the stream identifier corresponds to the pin index. The reference stream is always stream 0.</p> </dd></param>
            <param name = "nrcOutputRef"><dd> <p>Pointer to an <strong><see cref = "T:SharpDX.MediaFoundation.VideoNormalizedRect"/></strong> structure that receives the bounding rectangle, in normalized coordinates.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidStreamNumber"/></strong></dt> </dl> </td><td> <p>Invalid stream identifier.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms698911</doc-id>
            <unmanaged>HRESULT IMFVideoMixerControl::GetStreamOutputRect([In] DWORD dwStreamID,[Out] MFVideoNormalizedRect* pnrcOutput)</unmanaged>
            <unmanaged-short>IMFVideoMixerControl::GetStreamOutputRect</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.VideoMixerControl2.MixingPrefs">
            <summary>
            <p>Gets or sets the current preferences for video deinterlacing.</p>
            </summary>
            <doc-id>dd374896</doc-id>
            <unmanaged>GetMixingPrefs / SetMixingPrefs</unmanaged>
            <unmanaged-short>GetMixingPrefs</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoMixerControl2.SetMixingPrefs(System.Int32)">
            <summary>
            <p>Sets the preferences for video deinterlacing.</p>
            </summary>
            <param name = "dwMixFlags"><dd> <p>Bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.VideoMixPrefs"/></strong> enumeration. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd374898</doc-id>
            <unmanaged>HRESULT IMFVideoMixerControl2::SetMixingPrefs([In] DWORD dwMixFlags)</unmanaged>
            <unmanaged-short>IMFVideoMixerControl2::SetMixingPrefs</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoMixerControl2.GetMixingPrefs(System.Int32@)">
            <summary>
            <p>Gets the current preferences for video deinterlacing.</p>
            </summary>
            <param name = "dwMixFlagsRef"><dd> <p>Receives a bitwise <strong>OR</strong> of zero or more flags from the <strong><see cref = "T:SharpDX.MediaFoundation.VideoMixPrefs"/></strong> enumeration.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd374896</doc-id>
            <unmanaged>HRESULT IMFVideoMixerControl2::GetMixingPrefs([Out] DWORD* pdwMixFlags)</unmanaged>
            <unmanaged-short>IMFVideoMixerControl2::GetMixingPrefs</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoPositionMapper.MapOutputCoordinateToInputStream(System.Single,System.Single,System.Int32,System.Int32,System.Single@,System.Single@)">
            <summary>
            <p>Maps output image coordinates to input image coordinates. This method provides the reverse transformation for components that map coordinates on the input image to different coordinates on the output image. </p>
            </summary>
            <param name = "xOut"><dd> <p> X-coordinate of the output image, normalized to the range [0...1]. </p> </dd></param>
            <param name = "yOut"><dd> <p> Y-coordinate of the output image, normalized to the range [0...1]. </p> </dd></param>
            <param name = "dwOutputStreamIndex"><dd> <p> Output stream index for the coordinate mapping. </p> </dd></param>
            <param name = "dwInputStreamIndex"><dd> <p> Input stream index for the coordinate mapping. </p> </dd></param>
            <param name = "xInRef"><dd> <p> Receives the mapped x-coordinate of the input image, normalized to the range [0...1]. </p> </dd></param>
            <param name = "yInRef"><dd> <p> Receives the mapped y-coordinate of the input image, normalized to the range [0...1]. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p> The video renderer has been shut down. </p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>In the following diagram, R(dest) is the destination rectangle for the video. You can obtain this rectangle by calling <strong>IMFVideoDisplayControl::GetVideoPosition</strong>. The rectangle R1 is a substream within the video. The point P has pixel coordinates (x,y) relative to R(dest).</p><p></p><p>The position of P relative to R(dest) in <em>normalized</em> coordinates is calculated as follows:</p><code>float xn = float(x + 0.5) / widthDest;
            float xy = float(y + 0.5) / heightDest;
            </code><p>where <em>widthDest</em> and <em>heightDest</em> are the width and height of R(dest) in pixels.</p><p>To calculate the position of P relative to R1, call <strong>MapOutputCoordinateToInputStream</strong> as follows:</p><code>float x1 = 0, y1 = 0;
            hr = pMap-&gt;MapOutputCoordinateToInputStream(xn, yn, 0, dwInputStreamIndex, &amp;x1, &amp;y1);</code><p>The values returned in <em>x1</em> and <em>y1</em> are normalized to the range [0...1]. To convert back to pixel coordinates, scale these values by the size of R1:</p><code>int scaledx = int(floor(x1 * widthR1));
            int scaledy = int(floor(xy * heightR1));</code><p>Note that <em>x1</em> and <em>y1</em> might fall outside the range [0...1] if P lies outside of R1.</p>
            </remarks>
            <doc-id>ms703892</doc-id>
            <unmanaged>HRESULT IMFVideoPositionMapper::MapOutputCoordinateToInputStream([In] float xOut,[In] float yOut,[In] DWORD dwOutputStreamIndex,[In] DWORD dwInputStreamIndex,[Out] float* pxIn,[Out] float* pyIn)</unmanaged>
            <unmanaged-short>IMFVideoPositionMapper::MapOutputCoordinateToInputStream</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.VideoProcessorControl.BorderColor">
            <summary>
            <p>Sets the border color.</p>
            </summary>
            <doc-id>hh448070</doc-id>
            <unmanaged>SetBorderColor</unmanaged>
            <unmanaged-short>SetBorderColor</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.VideoProcessorControl.SourceRectangle">
            <summary>
            <p>Sets the source rectangle. The source rectangle is the portion of the input frame that is blitted to the destination surface.</p>
            </summary>
            <remarks>
            <p>See <strong>Video Processor MFT</strong> for info regarding source and destination rectangles in the <strong>Video Processor MFT</strong>.   </p>
            </remarks>
            <doc-id>hh448075</doc-id>
            <unmanaged>SetSourceRectangle</unmanaged>
            <unmanaged-short>SetSourceRectangle</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.VideoProcessorControl.DestinationRectangle">
            <summary>
            <p>Sets the destination rectangle. The destination rectangle is the portion of the output surface where the source rectangle is blitted.</p>
            </summary>
            <remarks>
            <p>See <strong>Video Processor MFT</strong> for info regarding source and destination rectangles in the <strong>Video Processor MFT</strong>.   </p>
            </remarks>
            <doc-id>hh448072</doc-id>
            <unmanaged>SetDestinationRectangle</unmanaged>
            <unmanaged-short>SetDestinationRectangle</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.VideoProcessorControl.Mirror">
            <summary>
            <p>Specifies whether to flip the video image.</p>
            </summary>
            <doc-id>hh448073</doc-id>
            <unmanaged>SetMirror</unmanaged>
            <unmanaged-short>SetMirror</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.VideoProcessorControl.Rotation">
            <summary>
            <p>Specifies whether to rotate the video to the correct orientation.</p>
            </summary>
            <remarks>
            <p>The original orientation of the video is specified by the <see cref = "!:VideoRotation"/> attribute of the input media type.</p><p> If <em>eRotation</em> is <strong>ROTATION_NONE</strong>, the video processor does not correct the orientation of the output video. If the original video is rotated, and <em>eRotation</em> is <strong>ROTATION_NORMAL</strong>, the video processor corrects the orientation, so that the ouput video is not rotated. The video processor letterboxes the output as needed.</p>
            </remarks>
            <doc-id>hh448074</doc-id>
            <unmanaged>SetRotation</unmanaged>
            <unmanaged-short>SetRotation</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.VideoProcessorControl.ConstrictionSize">
            <summary>
            <p>Specifies the amount of downsampling to perform on the output.</p>
            </summary>
            <doc-id>hh448071</doc-id>
            <unmanaged>SetConstrictionSize</unmanaged>
            <unmanaged-short>SetConstrictionSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoProcessorControl.SetBorderColor(System.Nullable{SharpDX.Mathematics.Interop.RawColorBGRA})">
            <summary>
            <p>Sets the border color.</p>
            </summary>
            <param name = "borderColorRef"><dd> <p>A reference to an <strong><see cref = "T:SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> structure that specifies the border color as an ARGB (alpha, red, green, blue) value.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh448070</doc-id>
            <unmanaged>HRESULT IMFVideoProcessorControl::SetBorderColor([In, Optional] MFARGB* pBorderColor)</unmanaged>
            <unmanaged-short>IMFVideoProcessorControl::SetBorderColor</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoProcessorControl.SetSourceRectangle(System.Nullable{SharpDX.Mathematics.Interop.RawRectangle})">
            <summary>
            <p>Sets the source rectangle. The source rectangle is the portion of the input frame that is blitted to the destination surface.</p>
            </summary>
            <param name = "srcRectRef"><dd> <p>A reference to a <strong><see cref = "T:SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that specifies the source rectangle.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>See <strong>Video Processor MFT</strong> for info regarding source and destination rectangles in the <strong>Video Processor MFT</strong>.   </p>
            </remarks>
            <doc-id>hh448075</doc-id>
            <unmanaged>HRESULT IMFVideoProcessorControl::SetSourceRectangle([In, Optional] RECT* pSrcRect)</unmanaged>
            <unmanaged-short>IMFVideoProcessorControl::SetSourceRectangle</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoProcessorControl.SetDestinationRectangle(System.Nullable{SharpDX.Mathematics.Interop.RawRectangle})">
            <summary>
            <p>Sets the destination rectangle. The destination rectangle is the portion of the output surface where the source rectangle is blitted.</p>
            </summary>
            <param name = "dstRectRef"><dd> <p>A reference to a <strong><see cref = "T:SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that specifies the destination rectangle.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>See <strong>Video Processor MFT</strong> for info regarding source and destination rectangles in the <strong>Video Processor MFT</strong>.   </p>
            </remarks>
            <doc-id>hh448072</doc-id>
            <unmanaged>HRESULT IMFVideoProcessorControl::SetDestinationRectangle([In, Optional] RECT* pDstRect)</unmanaged>
            <unmanaged-short>IMFVideoProcessorControl::SetDestinationRectangle</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoProcessorControl.SetMirror(SharpDX.MediaFoundation.VideoProcessorMirror)">
            <summary>
            <p>Specifies whether to flip the video image.</p>
            </summary>
            <param name = "eMirror"><dd> <p>An <strong><see cref = "T:SharpDX.MediaFoundation.VideoProcessorMirror"/></strong> value that specifies whether to flip the video image, either horizontally or vertically.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh448073</doc-id>
            <unmanaged>HRESULT IMFVideoProcessorControl::SetMirror([In] MF_VIDEO_PROCESSOR_MIRROR eMirror)</unmanaged>
            <unmanaged-short>IMFVideoProcessorControl::SetMirror</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoProcessorControl.SetRotation(SharpDX.MediaFoundation.VideoProcessorRotation)">
            <summary>
            <p>Specifies whether to rotate the video to the correct orientation.</p>
            </summary>
            <param name = "eRotation"><dd> <p>A <strong><see cref = "T:SharpDX.MediaFoundation.VideoProcessorRotation"/></strong> value that specifies whether to rotate the image.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The original orientation of the video is specified by the <see cref = "!:VideoRotation"/> attribute of the input media type.</p><p> If <em>eRotation</em> is <strong>ROTATION_NONE</strong>, the video processor does not correct the orientation of the output video. If the original video is rotated, and <em>eRotation</em> is <strong>ROTATION_NORMAL</strong>, the video processor corrects the orientation, so that the ouput video is not rotated. The video processor letterboxes the output as needed.</p>
            </remarks>
            <doc-id>hh448074</doc-id>
            <unmanaged>HRESULT IMFVideoProcessorControl::SetRotation([In] MF_VIDEO_PROCESSOR_ROTATION eRotation)</unmanaged>
            <unmanaged-short>IMFVideoProcessorControl::SetRotation</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoProcessorControl.SetConstrictionSize(System.Nullable{SharpDX.Size2})">
            <summary>
            <p>Specifies the amount of downsampling to perform on the output.</p>
            </summary>
            <param name = "constrictionSizeRef"><dd> <p>The sampling size. To disable constriction, set this parameter to <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh448071</doc-id>
            <unmanaged>HRESULT IMFVideoProcessorControl::SetConstrictionSize([In, Optional] SIZE* pConstrictionSize)</unmanaged>
            <unmanaged-short>IMFVideoProcessorControl::SetConstrictionSize</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.VideoProcessorControl2.RotationOverride">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Overrides the rotation operation that is performed in the video processor.</p>
            </summary>
            <doc-id>dn800744</doc-id>
            <unmanaged>SetRotationOverride</unmanaged>
            <unmanaged-short>SetRotationOverride</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.VideoProcessorControl2.SupportedHardwareEffects">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Returns the list of supported effects in the currently configured video processor.</p>
            </summary>
            <doc-id>dn800743</doc-id>
            <unmanaged>GetSupportedHardwareEffects</unmanaged>
            <unmanaged-short>GetSupportedHardwareEffects</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoProcessorControl2.SetRotationOverride(System.Int32)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Overrides the rotation operation that is performed in the video processor.</p>
            </summary>
            <param name = "uiRotation"><dd>  <p>Rotation value in degrees.  Typically, you can only use values from the <strong><see cref = "T:SharpDX.MediaFoundation.VideoRotationFormat"/></strong> enumeration.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800744</doc-id>
            <unmanaged>HRESULT IMFVideoProcessorControl2::SetRotationOverride([In] unsigned int uiRotation)</unmanaged>
            <unmanaged-short>IMFVideoProcessorControl2::SetRotationOverride</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoProcessorControl2.EnableHardwareEffects(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Enables effects that were implemented with <strong>IDirectXVideoProcessor::VideoProcessorBlt</strong>. </p>
            </summary>
            <param name = "fEnabled">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800742</doc-id>
            <unmanaged>HRESULT IMFVideoProcessorControl2::EnableHardwareEffects([In] BOOL fEnabled)</unmanaged>
            <unmanaged-short>IMFVideoProcessorControl2::EnableHardwareEffects</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoProcessorControl2.GetSupportedHardwareEffects(System.Int32@)">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Returns the list of supported effects in the currently configured video processor.</p>
            </summary>
            <param name = "uiSupportRef"><dd>  <p>A combination of <strong><see cref = "!:SharpDX.Direct3D11.VideoProcessorAutoStreamCaps"/></strong>-typed values that are combined by using a bitwise OR operation. The resulting value specifies the list of suppported effect capabilities.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn800743</doc-id>
            <unmanaged>HRESULT IMFVideoProcessorControl2::GetSupportedHardwareEffects([Out] unsigned int* puiSupport)</unmanaged>
            <unmanaged-short>IMFVideoProcessorControl2::GetSupportedHardwareEffects</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoRenderer.InitializeRenderer(SharpDX.MediaFoundation.Transform,SharpDX.MediaFoundation.VideoPresenter)">
            <summary>
            <p> </p><p>Sets a new mixer or presenter for the enhanced video renderer (EVR).</p>
            </summary>
            <param name = "videoMixerRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.Transform"/></strong> interface of the mixer to use. This parameter can be <strong><c>null</c></strong>. If this parameter is <strong><c>null</c></strong>, the EVR uses its default mixer.</p> </dd></param>
            <param name = "videoPresenterRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.VideoPresenter"/></strong> interface of the presenter to use. This parameter can be <strong><c>null</c></strong>. If this parameter is <strong><c>null</c></strong>, the EVR uses its default presenter.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>Either the mixer or the presenter is invalid.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidRequest"/></strong></dt> </dl> </td><td> <p>The mixer and presenter cannot be replaced in the current state. (EVR media sink.)</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Shutdown"/></strong></dt> </dl> </td><td> <p>The video renderer has been shut down.</p> </td></tr> <tr><td> <dl> <dt><strong>VFW_E_WRONG_STATE</strong></dt> </dl> </td><td> <p>One or more input pins are connected. (DirectShow EVR filter.)</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this method directly after creating the EVR, before you do any of the following:</p><ul> <li> <p>Call <strong>IMFGetService::GetService</strong> on the EVR.</p> </li> <li> <p>Call <strong>IEVRFilterConfig::SetNumberOfStreams</strong> on the EVR.</p> </li> <li> <p>Connect any pins on the EVR filter, or set any media types on EVR media sink.</p> </li> </ul><p>The EVR filter returns VFW_E_WRONG_STATE if any of the filter's pins are connected. The EVR media sink returns <see cref = "!:InvalidRequest"/> if a media type is set on any of the streams, or the presentation clock is running or paused.</p><p>The device identifiers for the mixer and the presenter must match. The <strong>IMFVideoDeviceID::GetDeviceID</strong> method returns the device identifier. If they do not match, the method returns E_INVALIDARG.</p><p>If the video renderer is in the protected media path (PMP), the mixer and presenter objects must be certified safe components and pass any trust authority verification that is being enforced. Otherwise, this method will fail.</p>
            </remarks>
            <doc-id>ms704667</doc-id>
            <unmanaged>HRESULT IMFVideoRenderer::InitializeRenderer([In, Optional] IMFTransform* pVideoMixer,[In, Optional] IMFVideoPresenter* pVideoPresenter)</unmanaged>
            <unmanaged-short>IMFVideoRenderer::InitializeRenderer</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.VideoSampleAllocator.DirectXManager">
            <summary>
            <p> </p><p>Specifies the Direct3D device manager for the video media sink to use.</p>
            </summary>
            <remarks>
            <p>The media sink uses the Direct3D device manager to obtain a reference to the Direct3D device, which it uses to allocate Direct3D surfaces. The device manager enables multiple objects in the pipeline (such as a video renderer and a video decoder) to share the same Direct3D device.</p>
            </remarks>
            <doc-id>aa473819</doc-id>
            <unmanaged>SetDirectXManager</unmanaged>
            <unmanaged-short>SetDirectXManager</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoSampleAllocator.SetDirectXManager(SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Specifies the Direct3D device manager for the video media sink to use.</p>
            </summary>
            <param name = "managerRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of the Direct3D device manager. The media sink queries this reference for the <strong>IDirect3DDeviceManager9</strong> interface.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The media sink uses the Direct3D device manager to obtain a reference to the Direct3D device, which it uses to allocate Direct3D surfaces. The device manager enables multiple objects in the pipeline (such as a video renderer and a video decoder) to share the same Direct3D device.</p>
            </remarks>
            <doc-id>aa473819</doc-id>
            <unmanaged>HRESULT IMFVideoSampleAllocator::SetDirectXManager([In] IUnknown* pManager)</unmanaged>
            <unmanaged-short>IMFVideoSampleAllocator::SetDirectXManager</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoSampleAllocator.UninitializeSampleAllocator">
            <summary>
            <p> </p><p>Releases all of the video samples that have been allocated.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>aa473807</doc-id>
            <unmanaged>HRESULT IMFVideoSampleAllocator::UninitializeSampleAllocator()</unmanaged>
            <unmanaged-short>IMFVideoSampleAllocator::UninitializeSampleAllocator</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoSampleAllocator.InitializeSampleAllocator(System.Int32,SharpDX.MediaFoundation.MediaType)">
            <summary>
            <p> Specifies the number of samples to allocate and the media type for the samples. </p>
            </summary>
            <param name = "cRequestedFrames"><dd> <p> Number of samples to allocate.		 </p> </dd></param>
            <param name = "mediaTypeRef"><dd> <p> Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of a media type that describes the video format. </p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:InvalidMediaType"/></strong></dt> </dl> </td><td> <p>Invalid media type.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970496</doc-id>
            <unmanaged>HRESULT IMFVideoSampleAllocator::InitializeSampleAllocator([In] DWORD cRequestedFrames,[In] IMFMediaType* pMediaType)</unmanaged>
            <unmanaged-short>IMFVideoSampleAllocator::InitializeSampleAllocator</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoSampleAllocator.AllocateSample(SharpDX.MediaFoundation.Sample@)">
            <summary>
            <p>Gets a video sample from the allocator. </p>
            </summary>
            <param name = "sampleOut"><dd> <p>Receives a reference to the <strong><see cref = "T:SharpDX.MediaFoundation.Sample"/></strong> interface. The caller must release the interface. </p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p> The method succeeded. </p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:NotInitializeD"/></strong></dt> </dl> </td><td> <p>The allocator was not initialized. Call <strong>IMFVideoSampleAllocator::InitializeSampleAllocator</strong> or <strong>InitializeSampleAllocatorEx::InitializeSampleAllocatorEx</strong>.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:SampleallocatorEmpty"/></strong></dt> </dl> </td><td> <p> No samples are available. </p> </td></tr> </table><p>?</p></returns>
            <doc-id>bb970553</doc-id>
            <unmanaged>HRESULT IMFVideoSampleAllocator::AllocateSample([In] IMFSample** ppSample)</unmanaged>
            <unmanaged-short>IMFVideoSampleAllocator::AllocateSample</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.VideoSampleAllocatorCallback.Callback">
            <summary>
            <p>Sets the callback object that receives notification whenever a video sample is returned to the allocator.</p>
            </summary>
            <remarks>
            <p>To get a video sample from the allocator, call the <strong>IMFVideoSampleAllocator::AllocateSample</strong> method. When the sample is released, it returns to the pool of available samples. When this happens, the allocator invokes the <strong>IMFVideoSampleAllocatorNotify::NotifyRelease</strong> callback.</p><p>The allocator holds at most one callback reference. Calling this method again replaces the previous callback reference.</p>
            </remarks>
            <doc-id>dd374904</doc-id>
            <unmanaged>SetCallback</unmanaged>
            <unmanaged-short>SetCallback</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoSampleAllocatorCallback.SetCallback(SharpDX.MediaFoundation.VideoSampleAllocatorNotify)">
            <summary>
            <p>Sets the callback object that receives notification whenever a video sample is returned to the allocator.</p>
            </summary>
            <param name = "notifyRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.VideoSampleAllocatorNotify"/></strong> interface that receives notification, or <strong><c>null</c></strong> to remove the callback.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>To get a video sample from the allocator, call the <strong>IMFVideoSampleAllocator::AllocateSample</strong> method. When the sample is released, it returns to the pool of available samples. When this happens, the allocator invokes the <strong>IMFVideoSampleAllocatorNotify::NotifyRelease</strong> callback.</p><p>The allocator holds at most one callback reference. Calling this method again replaces the previous callback reference.</p>
            </remarks>
            <doc-id>dd374904</doc-id>
            <unmanaged>HRESULT IMFVideoSampleAllocatorCallback::SetCallback([In] IMFVideoSampleAllocatorNotify* pNotify)</unmanaged>
            <unmanaged-short>IMFVideoSampleAllocatorCallback::SetCallback</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoSampleAllocatorCallback.GetFreeSampleCount(System.Int32)">
            <summary>
            <p>Gets the number of video samples that are currently available for use.</p>
            </summary>
            <param name = "lSamplesRef"><dd> <p>Receives the number of available samples.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>To get a video sample from the allocator, call the <strong>IMFVideoSampleAllocator::AllocateSample</strong> method. The <strong>AllocateSample</strong> method removes a sample from the sample pool and returns it to the caller. When a sample is released, it returns to the pool. The <strong>GetFreeSampleCount</strong> method returns the count of samples that remain in the sample pool.</p>
            </remarks>
            <doc-id>dd374902</doc-id>
            <unmanaged>HRESULT IMFVideoSampleAllocatorCallback::GetFreeSampleCount([In] LONG* plSamples)</unmanaged>
            <unmanaged-short>IMFVideoSampleAllocatorCallback::GetFreeSampleCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoSampleAllocatorEx.InitializeSampleAllocatorEx(System.Int32,System.Int32,SharpDX.MediaFoundation.MediaAttributes,SharpDX.MediaFoundation.MediaType)">
            <summary>
            <p>Initializes the video sample allocator object.</p>
            </summary>
            <param name = "cInitialSamples"><dd> <p>The initial number of samples to allocate. </p> </dd></param>
            <param name = "cMaximumSamples"><dd> <p>The maximum number of samples to allocate.</p> </dd></param>
            <param name = "attributesRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaAttributes"/></strong> interface. You can use this interface to configure the allocator. Currently, the following configuration attributes are defined:</p> <ul> <li> <see cref = "!:BuffersPerSample"/> </li> <li> <see cref = "!:D3D11Bindflags"/> </li> <li> <see cref = "!:D3D11Usage"/> </li> <li> MF_SA_D3D11_SHARED </li> <li> MF_SA_D3D11_SHARED_WITHOUT_MUTEX </li> </ul> </dd></param>
            <param name = "mediaTypeRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> interface of a media type that describes the video format. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh448077</doc-id>
            <unmanaged>HRESULT IMFVideoSampleAllocatorEx::InitializeSampleAllocatorEx([In] DWORD cInitialSamples,[In] DWORD cMaximumSamples,[In, Optional] IMFAttributes* pAttributes,[In] IMFMediaType* pMediaType)</unmanaged>
            <unmanaged-short>IMFVideoSampleAllocatorEx::InitializeSampleAllocatorEx</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoSampleAllocatorNotify.NotifyRelease">
            <summary>
            <p>Called when a video sample is returned to the allocator.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>To get a video sample from the allocator, call the <strong>IMFVideoSampleAllocator::AllocateSample</strong> method. When the sample is released and then returned to the pool of available samples, the allocator invokes the <strong>NotifyRelease</strong> method. </p>
            </remarks>
            <doc-id>dd374908</doc-id>
            <unmanaged>HRESULT IMFVideoSampleAllocatorNotify::NotifyRelease()</unmanaged>
            <unmanaged-short>IMFVideoSampleAllocatorNotify::NotifyRelease</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.VideoSampleAllocatorNotifyEx.NotifyPrune(SharpDX.MediaFoundation.Sample)">
            <summary>
            <p>Called when allocator samples are released for pruning by the allocator, or when the allocator is removed.</p>
            </summary>
            <param name = "midlIMFVideoSampleAllocatorNotifyEx0000"><dd> <p>The sample to be pruned.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>mt627757</doc-id>
            <unmanaged>HRESULT IMFVideoSampleAllocatorNotifyEx::NotifyPrune([In] IMFSample* __MIDL__IMFVideoSampleAllocatorNotifyEx0000)</unmanaged>
            <unmanaged-short>IMFVideoSampleAllocatorNotifyEx::NotifyPrune</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueServices.BeginRegisterTopologyWorkQueuesWithMMCSS(SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Registers the topology work queues with the Multimedia Class Scheduler Service (MMCSS).</p>
            </summary>
            <param name = "callbackRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>
            <param name = "stateRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Each source node in the topology defines one branch of the topology. The branch includes every topology node that receives data from that node. An application can assign each branch of a topology its own work queue and then associate those work queues with MMCSS tasks. </p><p>To use this method, perform the following steps.</p><ol> <li>Create the topology.</li> <li>Set the following attributes on the source nodes in the topology.<ul> <li> <strong><see cref = "!:WorkqueueId"/></strong>. Specifies an identifier for the work queue. The Media Session will allocate a new work queue.</li> <li> <strong><see cref = "!:WorkqueueMmcssClass"/></strong>. Specifies the MMCSS class. </li> <li> <strong><see cref = "!:WorkqueueMmcssTaskid"/></strong>. Specifies the MMCSS task identifier (optional). If this attribute is not set, MMCSS assigns a new task identifier. </li> </ul> </li> <li>Queue the topology by calling <strong>IMFMediaSession::SetTopology</strong>.</li> <li>Wait for the MESessionTopologyStatus event with the <strong>MF_TOPOSTATUS_READY</strong> status.</li> <li>Call <strong>BeginRegisterTopologyWorkQueuesWithMMCSS</strong>. This method registers all of the topology work queues with MMCSS.</li> </ol><p>The <strong>BeginRegisterTopologyWorkQueuesWithMMCSS</strong> method is asynchronous. When the operation completes, the callback object's <strong>IMFAsyncCallback::Invoke</strong> method is called. Within the callback method, call <strong>IMFWorkQueueServices::EndRegisterTopologyWorkQueuesWithMMCSS</strong> to complete the asynchronous request. After this operation completes, the Media Session automatically registers the work queues for every new topology that is queued on the Media Session. The application does not need to call the method again for new topologies.</p><p>To unregister the topology work queues from MMCSS, call <strong>IMFWorkQueueServices::BeginUnregisterTopologyWorkQueuesWithMMCSS</strong>.</p>
            </remarks>
            <doc-id>ms697485</doc-id>
            <unmanaged>HRESULT IMFWorkQueueServices::BeginRegisterTopologyWorkQueuesWithMMCSS([In] IMFAsyncCallback* pCallback,[In] IUnknown* pState)</unmanaged>
            <unmanaged-short>IMFWorkQueueServices::BeginRegisterTopologyWorkQueuesWithMMCSS</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueServices.EndRegisterTopologyWorkQueuesWithMMCSS(SharpDX.MediaFoundation.AsyncResult)">
            <summary>
            <p> </p><p>Completes an asynchronous request to register the topology work queues with the Multimedia Class Scheduler Service (MMCSS).</p>
            </summary>
            <param name = "resultRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>IMFAsyncCallback::Invoke</strong> method.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this method when the <strong>IMFWorkQueueServices::BeginRegisterTopologyWorkQueuesWithMMCSS</strong> method completes asynchronously.</p>
            </remarks>
            <doc-id>ms696983</doc-id>
            <unmanaged>HRESULT IMFWorkQueueServices::EndRegisterTopologyWorkQueuesWithMMCSS([In] IMFAsyncResult* pResult)</unmanaged>
            <unmanaged-short>IMFWorkQueueServices::EndRegisterTopologyWorkQueuesWithMMCSS</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueServices.BeginUnregisterTopologyWorkQueuesWithMMCSS(SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Unregisters the topology work queues from the Multimedia Class Scheduler Service (MMCSS).</p>
            </summary>
            <param name = "callbackRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>
            <param name = "stateRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is asynchronous. When the operation completes, the callback object's <strong>IMFAsyncCallback::Invoke</strong> method is called. At that point, the application should call <strong>IMFWorkQueueServices::EndUnregisterTopologyWorkQueuesWithMMCSS</strong> to complete the asynchronous request.</p>
            </remarks>
            <doc-id>ms702139</doc-id>
            <unmanaged>HRESULT IMFWorkQueueServices::BeginUnregisterTopologyWorkQueuesWithMMCSS([In] IMFAsyncCallback* pCallback,[In] IUnknown* pState)</unmanaged>
            <unmanaged-short>IMFWorkQueueServices::BeginUnregisterTopologyWorkQueuesWithMMCSS</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueServices.EndUnregisterTopologyWorkQueuesWithMMCSS(SharpDX.MediaFoundation.AsyncResult)">
            <summary>
            <p> </p><p>Completes an asynchronous request to unregister the topology work queues from the Multimedia Class Scheduler Service (MMCSS).</p>
            </summary>
            <param name = "resultRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>IMFAsyncCallback::Invoke</strong> method.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this method when the <strong>IMFWorkQueueServices::BeginRegisterTopologyWorkQueuesWithMMCSS</strong> method completes asynchronously.</p>
            </remarks>
            <doc-id>ms698872</doc-id>
            <unmanaged>HRESULT IMFWorkQueueServices::EndUnregisterTopologyWorkQueuesWithMMCSS([In] IMFAsyncResult* pResult)</unmanaged>
            <unmanaged-short>IMFWorkQueueServices::EndUnregisterTopologyWorkQueuesWithMMCSS</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueServices.GetTopologyWorkQueueMMCSSClass(System.Int32,System.IntPtr,System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the Multimedia Class Scheduler Service (MMCSS) class for a specified branch of the current topology.</p>
            </summary>
            <param name = "dwTopologyWorkQueueId"><dd> <p>Identifies the work queue assigned to this topology branch. The application defines this value by setting the <strong><see cref = "!:WorkqueueId"/></strong> attribute on the source node for the branch.</p> </dd></param>
            <param name = "wszClassRef"><dd> <p>Pointer to a buffer that receives the name of the MMCSS class. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "cchClassRef"><dd> <p>On input, specifies the size of the <em>pwszClass</em> buffer, in characters. On output, receives the required size of the buffer, in characters. The size includes the terminating null character.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>There is no work queue with the specified identifier.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:BufferTooSmall"/></strong></dt> </dl> </td><td> <p>The <em>pwszClass</em> buffer is too small to receive the class name.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms704762</doc-id>
            <unmanaged>HRESULT IMFWorkQueueServices::GetTopologyWorkQueueMMCSSClass([In] DWORD dwTopologyWorkQueueId,[Out, Buffer] wchar_t* pwszClass,[InOut] DWORD* pcchClass)</unmanaged>
            <unmanaged-short>IMFWorkQueueServices::GetTopologyWorkQueueMMCSSClass</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueServices.GetTopologyWorkQueueMMCSSTaskId(System.Int32,System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the Multimedia Class Scheduler Service (MMCSS) task identifier for a specified branch of the current topology.</p>
            </summary>
            <param name = "dwTopologyWorkQueueId"><dd> <p>Identifies the work queue assigned to this topology branch. The application defines this value by setting the <strong><see cref = "!:WorkqueueId"/></strong> attribute on the source node for the branch.</p> </dd></param>
            <param name = "dwTaskIdRef"><dd> <p>Receives the task identifier.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms694202</doc-id>
            <unmanaged>HRESULT IMFWorkQueueServices::GetTopologyWorkQueueMMCSSTaskId([In] DWORD dwTopologyWorkQueueId,[Out] DWORD* pdwTaskId)</unmanaged>
            <unmanaged-short>IMFWorkQueueServices::GetTopologyWorkQueueMMCSSTaskId</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueServices.BeginRegisterPlatformWorkQueueWithMMCSS(System.Int32,System.String,System.Int32,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p> Associates a platform work queue with a Multimedia Class Scheduler Service (MMCSS) task. </p>
            </summary>
            <param name = "dwPlatformWorkQueue"><dd> <p> The platform work queue to register with MMCSS. See Work Queue Identifiers. To register all of the standard work queues to the same MMCSS task, set this parameter to <strong>MFASYNC_CALLBACK_QUEUE_ALL</strong>.</p> </dd></param>
            <param name = "wszClass"><dd> <p>The name of the MMCSS task to be performed. </p> </dd></param>
            <param name = "dwTaskId"><dd> <p> The unique task identifier. To obtain a new task identifier, set this value to zero. </p> </dd></param>
            <param name = "callbackRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface. </p> </dd></param>
            <param name = "stateRef"><dd> <p>A reference to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method is asynchronous. When the operation completes, the callback object's <strong>IMFAsyncCallback::Invoke</strong> method is called. At that point, the application should call <strong>IMFWorkQueueServices::EndRegisterPlatformWorkQueueWithMMCSS</strong> to complete the asynchronous request.</p><p>To unregister the work queue from the MMCSS class, call <strong>IMFWorkQueueServices::BeginUnregisterPlatformWorkQueueWithMMCSS</strong>.</p>
            </remarks>
            <doc-id>ms702114</doc-id>
            <unmanaged>HRESULT IMFWorkQueueServices::BeginRegisterPlatformWorkQueueWithMMCSS([In] DWORD dwPlatformWorkQueue,[In] const wchar_t* wszClass,[In] DWORD dwTaskId,[In] IMFAsyncCallback* pCallback,[In] IUnknown* pState)</unmanaged>
            <unmanaged-short>IMFWorkQueueServices::BeginRegisterPlatformWorkQueueWithMMCSS</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueServices.EndRegisterPlatformWorkQueueWithMMCSS(SharpDX.MediaFoundation.AsyncResult,System.Int32@)">
            <summary>
            <p> </p><p>Completes an asynchronous request to associate a platform work queue with a Multimedia Class Scheduler Service (MMCSS) task.</p>
            </summary>
            <param name = "resultRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>IMFAsyncCallback::Invoke</strong> method.</p> </dd></param>
            <param name = "dwTaskIdRef"><dd> <p>The unique task identifier.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this function when the <strong>IMFWorkQueueServices::BeginRegisterPlatformWorkQueueWithMMCSS</strong> method completes asynchronously.</p><p>To unregister the work queue from the MMCSS class, call <strong>IMFWorkQueueServices::BeginUnregisterPlatformWorkQueueWithMMCSS</strong>.</p>
            </remarks>
            <doc-id>ms702284</doc-id>
            <unmanaged>HRESULT IMFWorkQueueServices::EndRegisterPlatformWorkQueueWithMMCSS([In] IMFAsyncResult* pResult,[Out] DWORD* pdwTaskId)</unmanaged>
            <unmanaged-short>IMFWorkQueueServices::EndRegisterPlatformWorkQueueWithMMCSS</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueServices.BeginUnregisterPlatformWorkQueueWithMMCSS(System.Int32,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p> </p><p>Unregisters a platform work queue from a Multimedia Class Scheduler Service (MMCSS) task.</p>
            </summary>
            <param name = "dwPlatformWorkQueue"><dd> <p>Platform work queue to register with MMCSS. See <strong>IMFWorkQueueServices::BeginRegisterPlatformWorkQueueWithMMCSS</strong>.</p> </dd></param>
            <param name = "callbackRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.IAsyncCallback"/></strong> interface of a callback object. The caller must implement this interface.</p> </dd></param>
            <param name = "stateRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.IUnknown"/></strong> interface of a state object, defined by the caller. This parameter can be <strong><c>null</c></strong>. You can use this object to hold state information. The object is returned to the caller when the callback is invoked.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is asynchronous. When the operation completes, the callback object's <strong>IMFAsyncCallback::Invoke</strong> method is called. At that point, the application should call <strong>IMFWorkQueueServices::EndUnregisterPlatformWorkQueueWithMMCSS</strong> to complete the asynchronous request.</p>
            </remarks>
            <doc-id>ms704603</doc-id>
            <unmanaged>HRESULT IMFWorkQueueServices::BeginUnregisterPlatformWorkQueueWithMMCSS([In] DWORD dwPlatformWorkQueue,[In] IMFAsyncCallback* pCallback,[In] IUnknown* pState)</unmanaged>
            <unmanaged-short>IMFWorkQueueServices::BeginUnregisterPlatformWorkQueueWithMMCSS</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueServices.EndUnregisterPlatformWorkQueueWithMMCSS(SharpDX.MediaFoundation.AsyncResult)">
            <summary>
            <p> </p><p>Completes an asynchronous request to unregister a platform work queue from a Multimedia Class Scheduler Service (MMCSS) task.</p>
            </summary>
            <param name = "resultRef"><dd> <p>Pointer to the <strong><see cref = "T:SharpDX.MediaFoundation.AsyncResult"/></strong> interface. Pass in the same reference that your callback object received in the <strong>IMFAsyncCallback::Invoke</strong> method.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Call this method when the <strong>IMFWorkQueueServices::BeginUnregisterPlatformWorkQueueWithMMCSS</strong> method completes asynchronously.</p>
            </remarks>
            <doc-id>ms704734</doc-id>
            <unmanaged>HRESULT IMFWorkQueueServices::EndUnregisterPlatformWorkQueueWithMMCSS([In] IMFAsyncResult* pResult)</unmanaged>
            <unmanaged-short>IMFWorkQueueServices::EndUnregisterPlatformWorkQueueWithMMCSS</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueServices.GetPlaftormWorkQueueMMCSSClass(System.Int32,System.IntPtr,System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the Multimedia Class Scheduler Service (MMCSS) class for a specified platform work queue.</p>
            </summary>
            <param name = "dwPlatformWorkQueueId"><dd> <p>Platform work queue to query. See <strong>IMFWorkQueueServices::BeginRegisterPlatformWorkQueueWithMMCSS</strong>.</p> </dd></param>
            <param name = "wszClassRef"><dd> <p>Pointer to a buffer that receives the name of the MMCSS class. This parameter can be <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "cchClassRef"><dd> <p>On input, specifies the size of the pwszClass buffer, in characters. On output, receives the required size of the buffer, in characters. The size includes the terminating null character.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:BufferTooSmall"/></strong></dt> </dl> </td><td> <p>The <em>pwszClass</em> buffer is too small to receive the class name.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms705624</doc-id>
            <unmanaged>HRESULT IMFWorkQueueServices::GetPlaftormWorkQueueMMCSSClass([In] DWORD dwPlatformWorkQueueId,[Out, Buffer] wchar_t* pwszClass,[InOut] DWORD* pcchClass)</unmanaged>
            <unmanaged-short>IMFWorkQueueServices::GetPlaftormWorkQueueMMCSSClass</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueServices.GetPlatformWorkQueueMMCSSTaskId(System.Int32,System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the Multimedia Class Scheduler Service (MMCSS) task identifier for a specified platform work queue.</p>
            </summary>
            <param name = "dwPlatformWorkQueueId"><dd> <p>Platform work queue to query. See <strong>IMFWorkQueueServices::BeginRegisterPlatformWorkQueueWithMMCSS</strong>.</p> </dd></param>
            <param name = "dwTaskIdRef"><dd> <p>Receives the task identifier.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>ms700183</doc-id>
            <unmanaged>HRESULT IMFWorkQueueServices::GetPlatformWorkQueueMMCSSTaskId([In] DWORD dwPlatformWorkQueueId,[Out] DWORD* pdwTaskId)</unmanaged>
            <unmanaged-short>IMFWorkQueueServices::GetPlatformWorkQueueMMCSSTaskId</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueServicesEx.GetTopologyWorkQueueMMCSSPriority(System.Int32,System.Int32@)">
            <summary>
            <p>Retrieves the Multimedia Class Scheduler Service (MMCSS)  string associated with the given topology work queue.</p>
            </summary>
            <param name = "dwTopologyWorkQueueId"><dd> <p>The id of the topology work queue. </p> </dd></param>
            <param name = "lPriorityRef"><dd> <p>Pointer to the buffer the work queue's MMCSS task id will be copied to.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>jj128328</doc-id>
            <unmanaged>HRESULT IMFWorkQueueServicesEx::GetTopologyWorkQueueMMCSSPriority([In] DWORD dwTopologyWorkQueueId,[Out] LONG* plPriority)</unmanaged>
            <unmanaged-short>IMFWorkQueueServicesEx::GetTopologyWorkQueueMMCSSPriority</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueServicesEx.BeginRegisterPlatformWorkQueueWithMMCSSEx(System.Int32,System.String,System.Int32,System.Int32,SharpDX.MediaFoundation.IAsyncCallback,SharpDX.IUnknown)">
            <summary>
            <p>Registers a platform work queue with Multimedia Class Scheduler Service (MMCSS) using the specified class and task id.</p>
            </summary>
            <param name = "dwPlatformWorkQueue"><dd> <p>The id of one of the standard platform work queues.</p> </dd></param>
            <param name = "wszClass"><dd> <p>The MMCSS class which the work queue should be registered with.</p> </dd></param>
            <param name = "dwTaskId"><dd> <p> The task id which the work queue should be registered with. If <em>dwTaskId</em> is 0, a new MMCSS bucket will be created.</p> </dd></param>
            <param name = "lPriority"><dd> <p>The priority.</p> </dd></param>
            <param name = "callbackRef"><dd> <p>Standard callback used for async operations in Media Foundation.</p> </dd></param>
            <param name = "stateRef"><dd> <p>Standard state used for async operations in Media Foundation.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>jj128326</doc-id>
            <unmanaged>HRESULT IMFWorkQueueServicesEx::BeginRegisterPlatformWorkQueueWithMMCSSEx([In] DWORD dwPlatformWorkQueue,[In] const wchar_t* wszClass,[In] DWORD dwTaskId,[In] LONG lPriority,[In] IMFAsyncCallback* pCallback,[In] IUnknown* pState)</unmanaged>
            <unmanaged-short>IMFWorkQueueServicesEx::BeginRegisterPlatformWorkQueueWithMMCSSEx</unmanaged-short>
        </member>
        <member name="M:SharpDX.MediaFoundation.WorkQueueServicesEx.GetPlatformWorkQueueMMCSSPriority(System.Int32,System.Int32@)">
            <summary>
            <p>Gets the priority of the Multimedia Class Scheduler Service (MMCSS)  priority associated with the specified platform work queue.</p>
            </summary>
            <param name = "dwPlatformWorkQueueId"><dd> <p>Topology work queue id for which the info will be returned.</p> </dd></param>
            <param name = "lPriorityRef"><dd></dd></param>
            <returns><p>Pointer to a buffer allocated by the caller that the work queue's MMCSS task id will be copied to.</p></returns>
            <doc-id>jj128327</doc-id>
            <unmanaged>HRESULT IMFWorkQueueServicesEx::GetPlatformWorkQueueMMCSSPriority([In] DWORD dwPlatformWorkQueueId,[Out] LONG* plPriority)</unmanaged>
            <unmanaged-short>IMFWorkQueueServicesEx::GetPlatformWorkQueueMMCSSPriority</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.AsfFlatPicture">
            <summary>
            <p> </p><p>Contains an image that is stored as metadata for a media source. This structure is used as the data item for the <strong>WM/Picture</strong> metadata attribute.</p>
            </summary>
            <remarks>
            <p>The <strong>WM/Picture</strong> attribute is defined in the Windows Media Format SDK. The attribute contains a picture related to the content, such as album art.</p><p>To get this attribute from a media source, call <strong>IMFMetadata::GetProperty</strong>, passing in the constant g_wszWMPicture for the <em>pwszName</em> parameter. The method retrieves a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that contains a binary array (VT_BLOB). The layout of the array is as follows:</p><ul> <li><strong><see cref = "T:SharpDX.MediaFoundation.AsfFlatPicture"/></strong> structure. </li> <li> Null-terminated wide-character string that contains the MIME type. </li> <li> Null-terminated wide-character string that contains a description. </li> <li> <p>Image data.</p> </li> </ul><p>This format differs from the <strong>WM_PICTURE</strong> structure used in the Windows Media Format SDK. The <strong>WM_PICTURE</strong> structure contains internal references to two strings and the image data. If the structure is copied, these references become invalid. The <strong><see cref = "T:SharpDX.MediaFoundation.AsfFlatPicture"/></strong> structure does not contain internal references, so it is safe to copy the structure.</p>
            </remarks>
            <doc-id>ms696178</doc-id>
            <unmanaged>ASF_FLAT_PICTURE</unmanaged>
            <unmanaged-short>ASF_FLAT_PICTURE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfFlatPicture.BPictureType">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms696178</doc-id>
            <unmanaged>bPictureType</unmanaged>
            <unmanaged-short>bPictureType</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfFlatPicture.DwDataLen">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms696178</doc-id>
            <unmanaged>dwDataLen</unmanaged>
            <unmanaged-short>dwDataLen</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.AsfFlatSynchronisedLyrics">
            <summary>
            <p> </p><p>Contains synchronized lyrics stored as metadata for a media source. This structure is used as the data item for the <strong>WM/Lyrics_Synchronised</strong> metadata attribute.</p>
            </summary>
            <remarks>
            <p>The <strong>WM/Lyrics_Synchronised</strong> attribute is defined in the Windows Media Format SDK. The attribute contains lyrics synchronized to times in the source file.</p><p>To get this attribute from a media source, call <strong>IMFMetadata::GetProperty</strong>, passing in the constant g_wszWMLyrics_Synchronised for the <em>pwszName</em> parameter. The method retrieves a <strong><see cref = "T:SharpDX.Win32.Variant"/></strong> that contains a binary array (VT_BLOB). The layout of the array is as follows:</p><ul> <li> <p><strong><see cref = "T:SharpDX.MediaFoundation.AsfFlatSynchronisedLyrics"/></strong> structure.</p> </li> <li> <p>Null-terminated wide-character string that contains a description.</p> </li> <li> <p>Lyric data. The format of the lyric data is described in the Windows Media Format SDK documentation.</p> </li> </ul><p>This format differs from the <strong>WM_SYNCHRONISED_LYRICS</strong> structure used in the Windows Media Format SDK. The <strong>WM_SYNCHRONISED_LYRICS</strong> structure contains internal references to two strings and the lyric data. If the structure is copied, these references become invalid. The <strong><see cref = "T:SharpDX.MediaFoundation.AsfFlatSynchronisedLyrics"/></strong> structure does not contain internal references, so it is safe to copy the structure.</p>
            </remarks>
            <doc-id>ms697057</doc-id>
            <unmanaged>ASF_FLAT_SYNCHRONISED_LYRICS</unmanaged>
            <unmanaged-short>ASF_FLAT_SYNCHRONISED_LYRICS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfFlatSynchronisedLyrics.BTimeStampFormat">
            <summary>
            <dd> <p>Specifies the format of time stamps in the lyrics. This member is equivalent to the <strong>bTimeStampFormat</strong> member in the <strong>WM_SYNCHRONISED_LYRICS</strong> structure. The <strong>WM_SYNCHRONISED_LYRICS</strong> structure is documented in the Windows Media Format SDK.</p> </dd>
            </summary>
            <doc-id>ms697057</doc-id>
            <unmanaged>bTimeStampFormat</unmanaged>
            <unmanaged-short>bTimeStampFormat</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfFlatSynchronisedLyrics.BContentType">
            <summary>
            <dd> <p>Specifies the type of synchronized strings that are in the lyric data. This member is equivalent to the <strong>bContentType</strong> member in the <strong>WM_SYNCHRONISED_LYRICS</strong> structure.</p> </dd>
            </summary>
            <doc-id>ms697057</doc-id>
            <unmanaged>bContentType</unmanaged>
            <unmanaged-short>bContentType</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfFlatSynchronisedLyrics.DwLyricsLen">
            <summary>
            <dd> <p>Size, in bytes, of the lyric data.</p> </dd>
            </summary>
            <doc-id>ms697057</doc-id>
            <unmanaged>dwLyricsLen</unmanaged>
            <unmanaged-short>dwLyricsLen</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.AsfIndexDescriptor">
            <summary>
            <p> </p><p>Describes the indexing configuration for a stream and type of index.</p>
            </summary>
            <doc-id>ms696174</doc-id>
            <unmanaged>ASF_INDEX_DESCRIPTOR</unmanaged>
            <unmanaged-short>ASF_INDEX_DESCRIPTOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfIndexDescriptor.Identifier">
            <summary>
            <dd> <p> <strong><see cref = "T:SharpDX.MediaFoundation.AsfIndexIdentifier"/></strong> structure that identifies the stream number and the type of index.</p> </dd>
            </summary>
            <doc-id>ms696174</doc-id>
            <unmanaged>Identifier</unmanaged>
            <unmanaged-short>Identifier</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfIndexDescriptor.CPerEntryBytes">
            <summary>
            <dd> <p>Number of bytes used for each index entry. If the value is MFASFINDEXER_PER_ENTRY_BYTES_DYNAMIC, the index entries have variable size.</p> </dd>
            </summary>
            <doc-id>ms696174</doc-id>
            <unmanaged>cPerEntryBytes</unmanaged>
            <unmanaged-short>cPerEntryBytes</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfIndexDescriptor.SzDescription">
            <summary>
            <dd> <p>Optional text description of the index.</p> </dd>
            </summary>
            <doc-id>ms696174</doc-id>
            <unmanaged>szDescription</unmanaged>
            <unmanaged-short>szDescription</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfIndexDescriptor.DwInterval">
            <summary>
            <dd> <p>Indexing interval. The units of this value depend on the index type. A value of MFASFINDEXER_NO_FIXED_INTERVAL indicates that there is no fixed indexing interval.</p> </dd>
            </summary>
            <doc-id>ms696174</doc-id>
            <unmanaged>dwInterval</unmanaged>
            <unmanaged-short>dwInterval</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.AsfIndexIdentifier">
            <summary>
            <p> Specifies an index for the ASF indexer object. </p>
            </summary>
            <remarks>
            <p> The index object of an ASF file can contain a number of distinct indexes. Each index is identified by the type of index and the stream number. No ASF index object can contain more than one index for a particular combination of stream number and index type.</p>
            </remarks>
            <doc-id>ms700100</doc-id>
            <unmanaged>ASF_INDEX_IDENTIFIER</unmanaged>
            <unmanaged-short>ASF_INDEX_IDENTIFIER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfIndexIdentifier.GuidIndexType">
            <summary>
            <dd> <p> The type of index. Currently this value must be GUID_NULL, which specifies time-based indexing. </p> </dd>
            </summary>
            <doc-id>ms700100</doc-id>
            <unmanaged>guidIndexType</unmanaged>
            <unmanaged-short>guidIndexType</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfIndexIdentifier.WStreamNumber">
            <summary>
            <dd> <p> The stream number to which this structure applies. </p> </dd>
            </summary>
            <doc-id>ms700100</doc-id>
            <unmanaged>wStreamNumber</unmanaged>
            <unmanaged-short>wStreamNumber</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.AsfMuxStatistics">
            <summary>
            <p> </p><p>Contains statistics about the progress of the ASF multiplexer.</p>
            </summary>
            <remarks>
            <p>Use <strong>IMFASFMultiplexer::GetStatistics</strong> to retrieve this structure.</p>
            </remarks>
            <doc-id>ms696231</doc-id>
            <unmanaged>ASF_MUX_STATISTICS</unmanaged>
            <unmanaged-short>ASF_MUX_STATISTICS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfMuxStatistics.CFramesWritten">
            <summary>
            <dd> <p>Number of frames written by the ASF multiplexer.</p> </dd>
            </summary>
            <doc-id>ms696231</doc-id>
            <unmanaged>cFramesWritten</unmanaged>
            <unmanaged-short>cFramesWritten</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AsfMuxStatistics.CFramesDropped">
            <summary>
            <dd> <p>Number of frames dropped by the ASF multiplexer.</p> </dd>
            </summary>
            <doc-id>ms696231</doc-id>
            <unmanaged>cFramesDropped</unmanaged>
            <unmanaged-short>cFramesDropped</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.AudioDecoderDegradationInfo">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFAudioDecoderDegradationInfo</unmanaged>
            <unmanaged-short>MFAudioDecoderDegradationInfo</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioDecoderDegradationInfo.EDegradationReason">
            <summary>
            No documentation.
            </summary>
            <unmanaged>eDegradationReason</unmanaged>
            <unmanaged-short>eDegradationReason</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AudioDecoderDegradationInfo.EType">
            <summary>
            No documentation.
            </summary>
            <unmanaged>eType</unmanaged>
            <unmanaged-short>eType</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.AYUVSample">
            <summary>
            <p> </p><p>Describes a 4:4:4:4 Y'Cb'Cr' sample.</p>
            </summary>
            <doc-id>ms701580</doc-id>
            <unmanaged>MFAYUVSample</unmanaged>
            <unmanaged-short>MFAYUVSample</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AYUVSample.BCrValue">
            <summary>
            <dd> <p>Cr (chroma difference) value.</p> </dd>
            </summary>
            <doc-id>ms701580</doc-id>
            <unmanaged>bCrValue</unmanaged>
            <unmanaged-short>bCrValue</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AYUVSample.BCbValue">
            <summary>
            <dd> <p>Cb (chroma difference) value.</p> </dd>
            </summary>
            <doc-id>ms701580</doc-id>
            <unmanaged>bCbValue</unmanaged>
            <unmanaged-short>bCbValue</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AYUVSample.BYValue">
            <summary>
            <dd> <p>Y (luma) value.</p> </dd>
            </summary>
            <doc-id>ms701580</doc-id>
            <unmanaged>bYValue</unmanaged>
            <unmanaged-short>bYValue</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.AYUVSample.BSampleAlpha8">
            <summary>
            <dd> <p>Alpha value.</p> </dd>
            </summary>
            <doc-id>ms701580</doc-id>
            <unmanaged>bSampleAlpha8</unmanaged>
            <unmanaged-short>bSampleAlpha8</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.ByteStreamBufferingParameters">
            <summary>
            <p> </p><p>Specifies the buffering parameters for a network byte stream.</p>
            </summary>
            <doc-id>aa370446</doc-id>
            <unmanaged>MFBYTESTREAM_BUFFERING_PARAMS</unmanaged>
            <unmanaged-short>MFBYTESTREAM_BUFFERING_PARAMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ByteStreamBufferingParameters.CbTotalFileSize">
            <summary>
            <dd> <p>Size of the file, in bytes. If the total size is unknown, set this member to -1.</p> </dd>
            </summary>
            <doc-id>aa370446</doc-id>
            <unmanaged>cbTotalFileSize</unmanaged>
            <unmanaged-short>cbTotalFileSize</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ByteStreamBufferingParameters.CbPlayableDataSize">
            <summary>
            <dd> <p>Size of the playable media data in the file, excluding any trailing data that is not useful for playback. If this value is unknown, set this member to -1.</p> </dd>
            </summary>
            <doc-id>aa370446</doc-id>
            <unmanaged>cbPlayableDataSize</unmanaged>
            <unmanaged-short>cbPlayableDataSize</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ByteStreamBufferingParameters.PrgBuckets">
            <summary>
            <dd> <p>Pointer to an array of <strong><see cref = "T:SharpDX.MediaFoundation.LeakyBucketPair"/></strong> structures. Each member of the array gives the buffer window for a particular bit rate.</p> </dd>
            </summary>
            <doc-id>aa370446</doc-id>
            <unmanaged>prgBuckets</unmanaged>
            <unmanaged-short>prgBuckets</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ByteStreamBufferingParameters.CBuckets">
            <summary>
            <dd> <p>The number of elements in the <strong>prgBuckets</strong> array.</p> </dd>
            </summary>
            <doc-id>aa370446</doc-id>
            <unmanaged>cBuckets</unmanaged>
            <unmanaged-short>cBuckets</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ByteStreamBufferingParameters.QwNetBufferingTime">
            <summary>
            <dd> <p>Amount of data to buffer from the network, in 100-nanosecond units. This value is in addition to the buffer windows defined in the <strong>prgBuckets</strong> member.</p> </dd>
            </summary>
            <doc-id>aa370446</doc-id>
            <unmanaged>qwNetBufferingTime</unmanaged>
            <unmanaged-short>qwNetBufferingTime</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ByteStreamBufferingParameters.QwExtraBufferingTimeDuringSeek">
            <summary>
            <dd> <p>Amount of additional data to buffer when seeking, in 100-nanosecond units. This value reflects the fact that downloading must start from the previous key frame before the seek point. If the value is unknown, set this member to zero.</p> </dd>
            </summary>
            <doc-id>aa370446</doc-id>
            <unmanaged>qwExtraBufferingTimeDuringSeek</unmanaged>
            <unmanaged-short>qwExtraBufferingTimeDuringSeek</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ByteStreamBufferingParameters.QwPlayDuration">
            <summary>
            <dd> <p>The playback duration of the file, in 100-nanosecond units. If the duration is unknown, set this member to zero.</p> </dd>
            </summary>
            <doc-id>aa370446</doc-id>
            <unmanaged>qwPlayDuration</unmanaged>
            <unmanaged-short>qwPlayDuration</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ByteStreamBufferingParameters.DRate">
            <summary>
            <dd> <p>Playback rate.</p> </dd>
            </summary>
            <doc-id>aa370446</doc-id>
            <unmanaged>dRate</unmanaged>
            <unmanaged-short>dRate</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.ByteStreamCacheRange">
            <summary>
            <p>Specifies a range of bytes.</p>
            </summary>
            <doc-id>hh162808</doc-id>
            <unmanaged>MF_BYTE_STREAM_CACHE_RANGE</unmanaged>
            <unmanaged-short>MF_BYTE_STREAM_CACHE_RANGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ByteStreamCacheRange.QwStartOffset">
            <summary>
            <dd> <p>The offset, in bytes, of the start of the range.</p> </dd>
            </summary>
            <doc-id>hh162808</doc-id>
            <unmanaged>qwStartOffset</unmanaged>
            <unmanaged-short>qwStartOffset</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ByteStreamCacheRange.QwEndOffset">
            <summary>
            <dd> <p>The offset, in bytes, of the end of the range.</p> </dd>
            </summary>
            <doc-id>hh162808</doc-id>
            <unmanaged>qwEndOffset</unmanaged>
            <unmanaged-short>qwEndOffset</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.CameraExtrinsicCalibratedTransform">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>A transform describing the location of a camera relative to other cameras or an established external reference.</p>
            </summary>
            <remarks>
            <p>The <strong>Position</strong> value should be expressed in real-world coordinates in units of meters. The coordinate system of both position and orientation should be right-handed Cartesian as shown in the following diagram. </p><strong>Important</strong>??<p>The position and orientation are expressed as transforms toward the reference frame or origin. For example, a <strong>Position</strong> value of {-5, 0, 0} means that the origin is 5 meters to the left of the sensor, and therefore the sensor is 5 meters to the right of the origin. A sensor that is positioned 2 meters above the origin should specify a <strong>Position</strong> of {0, -2, 0} because that is the translation from the sensor to the origin.</p> <p>If the sensor is aligned with the origin, the rotation is the identity quaternion and the forward vector is along the -Z axis  {0, 0, -1}. If the sensor is rotated +30 degrees around the Y axis from the origin, then the <strong>Orientation</strong> value should be a rotation of -30 degrees around the Y axis, because it represents the rotation from the sensor to the origin.</p>?
            </remarks>
            <doc-id>mt740393</doc-id>
            <unmanaged>MFCameraExtrinsic_CalibratedTransform</unmanaged>
            <unmanaged-short>MFCameraExtrinsic_CalibratedTransform</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CameraExtrinsicCalibratedTransform.CalibrationId">
            <summary>
            <dd> <p>A reference <see cref = "T:System.Guid"/> identifying the calibration process for the data, allowing different consumers to identify calibration data from the same process.</p> </dd>
            </summary>
            <doc-id>mt740393</doc-id>
            <unmanaged>CalibrationId</unmanaged>
            <unmanaged-short>CalibrationId</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CameraExtrinsicCalibratedTransform.Position">
            <summary>
            <dd> <p>The transform position.</p> </dd>
            </summary>
            <doc-id>mt740393</doc-id>
            <unmanaged>Position</unmanaged>
            <unmanaged-short>Position</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CameraExtrinsicCalibratedTransform.Orientation">
            <summary>
            <dd> <p>The transform rotation.</p> </dd>
            </summary>
            <doc-id>mt740393</doc-id>
            <unmanaged>Orientation</unmanaged>
            <unmanaged-short>Orientation</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.CameraExtrinsics">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Describes the location of a camera relative to other cameras or an established external reference.  </p>
            </summary>
            <doc-id>mt740392</doc-id>
            <unmanaged>MFCameraExtrinsics</unmanaged>
            <unmanaged-short>MFCameraExtrinsics</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CameraExtrinsics.TransformCount">
            <summary>
            <dd> <p>The number of transforms in the <em>CalibratedTransforms</em> array.</p> </dd>
            </summary>
            <doc-id>mt740392</doc-id>
            <unmanaged>TransformCount</unmanaged>
            <unmanaged-short>TransformCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.CameraExtrinsics.CalibratedTransforms">
            <summary>
            <dd> <p>The array of transforms in the extrinsic data.</p> </dd>
            </summary>
            <doc-id>mt740392</doc-id>
            <unmanaged>CalibratedTransforms</unmanaged>
            <unmanaged-short>CalibratedTransforms</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.CameraIntrinsicDistortionModel">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Represents a polynomial lens distortion model.</p>
            </summary>
            <doc-id>mt740394</doc-id>
            <unmanaged>MFCameraIntrinsic_DistortionModel</unmanaged>
            <unmanaged-short>MFCameraIntrinsic_DistortionModel</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CameraIntrinsicDistortionModel.RadialK1">
            <summary>
            <dd> <p>The first radial distortion coefficient.</p> </dd>
            </summary>
            <doc-id>mt740394</doc-id>
            <unmanaged>Radial_k1</unmanaged>
            <unmanaged-short>Radial_k1</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CameraIntrinsicDistortionModel.RadialK2">
            <summary>
            <dd> <p>The second radial distortion coefficient.</p> </dd>
            </summary>
            <doc-id>mt740394</doc-id>
            <unmanaged>Radial_k2</unmanaged>
            <unmanaged-short>Radial_k2</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CameraIntrinsicDistortionModel.RadialK3">
            <summary>
            <dd> <p>The third radial distortion coefficient.</p> </dd>
            </summary>
            <doc-id>mt740394</doc-id>
            <unmanaged>Radial_k3</unmanaged>
            <unmanaged-short>Radial_k3</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CameraIntrinsicDistortionModel.TangentialP1">
            <summary>
            <dd> <p>The first tangential distortion coefficient.</p> </dd>
            </summary>
            <doc-id>mt740394</doc-id>
            <unmanaged>Tangential_p1</unmanaged>
            <unmanaged-short>Tangential_p1</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CameraIntrinsicDistortionModel.TangentialP2">
            <summary>
            <dd> <p>The second tangential distortion coefficient.</p> </dd>
            </summary>
            <doc-id>mt740394</doc-id>
            <unmanaged>Tangential_p2</unmanaged>
            <unmanaged-short>Tangential_p2</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.CameraIntrinsicPinholeCameraModel">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Represents a pinhole camera model. </p>
            </summary>
            <remarks>
            <p>For square pixels, the X and Y fields of the <strong>FocalLength</strong> should be the same.</p><p>The <strong>PrincipalPoint</strong> field is expressed in pixels, not in normalized coordinates. The  origin [0,0] is the bottom, left corner of the image.</p>
            </remarks>
            <doc-id>mt740395</doc-id>
            <unmanaged>MFCameraIntrinsic_PinholeCameraModel</unmanaged>
            <unmanaged-short>MFCameraIntrinsic_PinholeCameraModel</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CameraIntrinsicPinholeCameraModel.FocalLength">
            <summary>
            <dd> <p>The focal length of the camera.</p> </dd>
            </summary>
            <doc-id>mt740395</doc-id>
            <unmanaged>FocalLength</unmanaged>
            <unmanaged-short>FocalLength</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CameraIntrinsicPinholeCameraModel.PrincipalPoint">
            <summary>
            <dd> <p>The principal point of the camera.</p> </dd>
            </summary>
            <doc-id>mt740395</doc-id>
            <unmanaged>PrincipalPoint</unmanaged>
            <unmanaged-short>PrincipalPoint</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.CapturedMetadataExposureCompensation">
            <summary>
            <p>This structure contains blob information for the EV compensation feedback for the photo captured.</p>
            </summary>
            <doc-id>dn897242</doc-id>
            <unmanaged>CapturedMetadataExposureCompensation</unmanaged>
            <unmanaged-short>CapturedMetadataExposureCompensation</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CapturedMetadataExposureCompensation.Flags">
            <summary>
            <dd> <p>A KSCAMERA_EXTENDEDPROP_EVCOMP_XXX step flag.</p> </dd>
            </summary>
            <doc-id>dn897242</doc-id>
            <unmanaged>Flags</unmanaged>
            <unmanaged-short>Flags</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CapturedMetadataExposureCompensation.Value">
            <summary>
            <dd> <p>The EV compensation value in units of the step specified.</p> </dd>
            </summary>
            <doc-id>dn897242</doc-id>
            <unmanaged>Value</unmanaged>
            <unmanaged-short>Value</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.CapturedMetadataISOGains">
            <summary>
            <p>The CapturedMetadataISOGains structure describes the blob format for <strong>MF_CAPTURE_METADATA_ISO_GAINS</strong>.</p>
            </summary>
            <remarks>
            <p>The <strong>CapturedMetadataISOGains</strong> structure only describes the blob format for the <strong>MF_CAPTURE_METADATA_ISO_GAINS</strong> attribute.  The metadata item structure for ISO gains (<strong>KSCAMERA_METADATA_ITEMHEADER</strong> + ISO gains metadata payload) is up to driver and must be 8-byte aligned.</p>
            </remarks>
            <doc-id>dn927550</doc-id>
            <unmanaged>CapturedMetadataISOGains</unmanaged>
            <unmanaged-short>CapturedMetadataISOGains</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CapturedMetadataISOGains.AnalogGain">
            <summary>
            <dd></dd>
            </summary>
            <doc-id>dn927550</doc-id>
            <unmanaged>AnalogGain</unmanaged>
            <unmanaged-short>AnalogGain</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CapturedMetadataISOGains.DigitalGain">
            <summary>
            <dd></dd>
            </summary>
            <doc-id>dn927550</doc-id>
            <unmanaged>DigitalGain</unmanaged>
            <unmanaged-short>DigitalGain</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.CapturedMetadataWhiteBalanceGains">
            <summary>
            <p>This structure describes the blob format for the <strong>MF_CAPTURE_METADATA_WHITEBALANCE_GAINS</strong> attribute.  </p>
            </summary>
            <remarks>
            <p>The <strong>MF_CAPTURE_METADATA_WHITEBALANCE_GAINS</strong> attribute contains the white balance gains applied to R, G, B by the sensor or ISP when the preview frame was captured. This is a unitless.</p><p>The <strong>CapturedMetadataWhiteBalanceGains</strong> structure only describes the blob format for the <strong>MF_CAPTURE_METADATA_WHITEBALANCE_GAINS</strong> attribute.  The metadata item structure for white balance gains (<strong>KSCAMERA_METADATA_ITEMHEADER</strong> + white balance gains metadata payload) is up to driver and must be 8-byte aligned.</p>
            </remarks>
            <doc-id>dn927556</doc-id>
            <unmanaged>CapturedMetadataWhiteBalanceGains</unmanaged>
            <unmanaged-short>CapturedMetadataWhiteBalanceGains</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CapturedMetadataWhiteBalanceGains.R">
            <summary>
            <dd> <p>The  <strong>R</strong> value of the blob.</p> </dd>
            </summary>
            <doc-id>dn927556</doc-id>
            <unmanaged>R</unmanaged>
            <unmanaged-short>R</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CapturedMetadataWhiteBalanceGains.G">
            <summary>
            <dd> <p>The  <strong>G</strong> value of the blob.</p> </dd>
            </summary>
            <doc-id>dn927556</doc-id>
            <unmanaged>G</unmanaged>
            <unmanaged-short>G</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.CapturedMetadataWhiteBalanceGains.B">
            <summary>
            <dd> <p>The  <strong>B</strong> value of the blob.</p> </dd>
            </summary>
            <doc-id>dn927556</doc-id>
            <unmanaged>B</unmanaged>
            <unmanaged-short>B</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.ClockProperties">
            <summary>
            <p> Defines the properties of a clock. </p>
            </summary>
            <doc-id>ms695206</doc-id>
            <unmanaged>MFCLOCK_PROPERTIES</unmanaged>
            <unmanaged-short>MFCLOCK_PROPERTIES</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ClockProperties.QwCorrelationRate">
            <summary>
            <dd> <p> The interval at which the clock correlates its clock time with the system time, in 100-nanosecond units. If the value is zero, the correlation is made whenever the <strong>IMFClock::GetCorrelatedTime</strong> method is called. </p> </dd>
            </summary>
            <doc-id>ms695206</doc-id>
            <unmanaged>qwCorrelationRate</unmanaged>
            <unmanaged-short>qwCorrelationRate</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ClockProperties.GuidClockId">
            <summary>
            <dd> <p> The unique identifier of the underlying device that provides the time. If two clocks have the same unique identifier, they are based on the same device. If the underlying device is not shared between two clocks, the value can be <strong>GUID_NULL</strong>. </p> </dd>
            </summary>
            <doc-id>ms695206</doc-id>
            <unmanaged>guidClockId</unmanaged>
            <unmanaged-short>guidClockId</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ClockProperties.DwClockFlags">
            <summary>
            <dd> <p> A bitwise <strong>OR</strong> of flags from the <strong><see cref = "T:SharpDX.MediaFoundation.ClockRelationalFlags"/></strong> enumeration. </p> </dd>
            </summary>
            <doc-id>ms695206</doc-id>
            <unmanaged>dwClockFlags</unmanaged>
            <unmanaged-short>dwClockFlags</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ClockProperties.QwClockFrequency">
            <summary>
            <dd> <p> The clock frequency in Hz. A value of <strong>MFCLOCK_FREQUENCY_HNS</strong> means that the clock has a frequency of 10 MHz (100-nanosecond ticks), which is the standard <strong>MFTIME</strong> time unit in Media Foundation. If the <strong>IMFClock::GetClockCharacteristics</strong> method returns the <strong>MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ</strong> flag, the value of this field must be <strong>MFCLOCK_FREQUENCY_HNS</strong>. </p> </dd>
            </summary>
            <doc-id>ms695206</doc-id>
            <unmanaged>qwClockFrequency</unmanaged>
            <unmanaged-short>qwClockFrequency</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ClockProperties.DwClockTolerance">
            <summary>
            <dd> <p> The amount of inaccuracy that may be present on the clock, in parts per billion (ppb). For example, an inaccuracy of 50 ppb means the clock might drift up to 50 seconds per billion seconds of real time. If the tolerance is not known, the value is <strong>MFCLOCK_TOLERANCE_UNKNOWN</strong>. This constant is equal to 50 parts per million (ppm). </p> </dd>
            </summary>
            <doc-id>ms695206</doc-id>
            <unmanaged>dwClockTolerance</unmanaged>
            <unmanaged-short>dwClockTolerance</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ClockProperties.DwClockJitter">
            <summary>
            <dd> <p> The amount of jitter that may be present, in 100-nanosecond units. Jitter is the variation in the frequency due to sampling the underlying clock. Jitter does not include inaccuracies caused by drift, which is reflected in the value of <strong>dwClockTolerance</strong>. </p> <p> For clocks based on a single device, the minimum jitter is the length of the tick period (the inverse of the frequency). For example, if the frequency is 10 Hz, the jitter is 0.1 second, which is 1,000,000 in <strong>MFTIME</strong> units. This value reflects the fact that the clock might be sampled just before the next tick, resulting in a clock time that is one period less than the actual time. If the frequency is greater than 10 MHz, the jitter should be set to 1 (the minimum value). </p> <p> If a clock's underlying hardware device does not directly time stamp the incoming data, the jitter also includes the time required to dispatch the driver's interrupt service routine (ISR). In that case, the expected jitter should include the following values: </p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MFCLOCK_JITTER_ISR</strong></dt> </dl> </td><td> <p> Jitter due to time stamping during the device driver's ISR. </p> </td></tr> <tr><td><dl> <dt><strong>MFCLOCK_JITTER_DPC</strong></dt> </dl> </td><td> <p> Jitter due to time stamping during the deferred procedure call (DPC) processing. </p> </td></tr> <tr><td><dl> <dt><strong>MFCLOCK_JITTER_PASSIVE</strong></dt> </dl> </td><td> <p> Jitter due to dropping to normal thread execution before time stamping. </p> </td></tr> </table> <p>?</p> </dd>
            </summary>
            <doc-id>ms695206</doc-id>
            <unmanaged>dwClockJitter</unmanaged>
            <unmanaged-short>dwClockJitter</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.ContentprotectiondeviceInputData">
            <summary>
            <p>Contains information about the data that you want to provide as input to a protection system function.</p>
            </summary>
            <doc-id>mt219216</doc-id>
            <unmanaged>MFCONTENTPROTECTIONDEVICE_INPUT_DATA</unmanaged>
            <unmanaged-short>MFCONTENTPROTECTIONDEVICE_INPUT_DATA</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ContentprotectiondeviceInputData.HWProtectionFunctionID">
            <summary>
            <dd> <p>The identifier of the function that you need to run. This value is defined by the implementation of the protection system.  </p> </dd>
            </summary>
            <doc-id>mt219216</doc-id>
            <unmanaged>HWProtectionFunctionID</unmanaged>
            <unmanaged-short>HWProtectionFunctionID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ContentprotectiondeviceInputData.PrivateDataByteCount">
            <summary>
            <dd> <p>The size of the private data that the implementation of  the security processor implementation reserved. You can determine this value by calling the <strong>IMFContentProtectionDevice::GetPrivateDataByteCount</strong> method.</p> </dd>
            </summary>
            <doc-id>mt219216</doc-id>
            <unmanaged>PrivateDataByteCount</unmanaged>
            <unmanaged-short>PrivateDataByteCount</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ContentprotectiondeviceInputData.HWProtectionDataByteCount">
            <summary>
            <dd> <p>The size of the data provided as input to the protection system function that you want to run.  </p> </dd>
            </summary>
            <doc-id>mt219216</doc-id>
            <unmanaged>HWProtectionDataByteCount</unmanaged>
            <unmanaged-short>HWProtectionDataByteCount</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ContentprotectiondeviceInputData.Reserved">
            <summary>
            <dd> <p>Reserved.</p> </dd>
            </summary>
            <doc-id>mt219216</doc-id>
            <unmanaged>Reserved</unmanaged>
            <unmanaged-short>Reserved</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.ContentprotectiondeviceInputData.InputData">
            <summary>
            <dd> <p>The data to provide as input to the protection system function.</p> <p>If the value of the <strong>PrivateDataByteCount</strong> member is greater than 0, bytes 0 through <strong>PrivateDataByteCount</strong> - 1 are reserved for use by the independent hardware vendor (IHV). Bytes <strong>PrivateDataByteCount</strong> through <strong>HWProtectionDataByteCount</strong> + <strong>PrivateDataByteCount</strong> - 1 contain the input data for the protection system function.    </p> <p>The protection system specification defines the format and size of the DRM function.</p> </dd>
            </summary>
            <doc-id>mt219216</doc-id>
            <unmanaged>InputData</unmanaged>
            <unmanaged-short>InputData</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.ContentprotectiondeviceOutputData">
            <summary>
            <p>Contains information about the data you received as output from a protection system function.</p>
            </summary>
            <doc-id>mt219217</doc-id>
            <unmanaged>MFCONTENTPROTECTIONDEVICE_OUTPUT_DATA</unmanaged>
            <unmanaged-short>MFCONTENTPROTECTIONDEVICE_OUTPUT_DATA</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ContentprotectiondeviceOutputData.PrivateDataByteCount">
            <summary>
            <dd> <p>The size of the private data that the implementation of the security processor reserves, in bytes. You can determine this value  by calling the <strong>IMFContentProtectionDevice::GetPrivateDataByteCount</strong> method.</p> </dd>
            </summary>
            <doc-id>mt219217</doc-id>
            <unmanaged>PrivateDataByteCount</unmanaged>
            <unmanaged-short>PrivateDataByteCount</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ContentprotectiondeviceOutputData.MaxHWProtectionDataByteCount">
            <summary>
            <dd> <p>The maximum size of data that the independent hardware vendor (IHV) can return in the output buffer, in bytes.</p> </dd>
            </summary>
            <doc-id>mt219217</doc-id>
            <unmanaged>MaxHWProtectionDataByteCount</unmanaged>
            <unmanaged-short>MaxHWProtectionDataByteCount</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ContentprotectiondeviceOutputData.HWProtectionDataByteCount">
            <summary>
            <dd> <p>The size of the data that the  IHV wrote to the output buffer, in bytes.</p> </dd>
            </summary>
            <doc-id>mt219217</doc-id>
            <unmanaged>HWProtectionDataByteCount</unmanaged>
            <unmanaged-short>HWProtectionDataByteCount</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ContentprotectiondeviceOutputData.Status">
            <summary>
            <dd> <p>The result of the protection system function.</p> </dd>
            </summary>
            <doc-id>mt219217</doc-id>
            <unmanaged>Status</unmanaged>
            <unmanaged-short>Status</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ContentprotectiondeviceOutputData.TransportTimeInHundredsOfNanoseconds">
            <summary>
            <dd> <p>The number of 100 nanosecond units spent transporting the data.   </p> </dd>
            </summary>
            <doc-id>mt219217</doc-id>
            <unmanaged>TransportTimeInHundredsOfNanoseconds</unmanaged>
            <unmanaged-short>TransportTimeInHundredsOfNanoseconds</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ContentprotectiondeviceOutputData.ExecutionTimeInHundredsOfNanoseconds">
            <summary>
            <dd> <p>The number of 100 nanosecond units spent running the protection system function.  
            </p> </dd>
            </summary>
            <doc-id>mt219217</doc-id>
            <unmanaged>ExecutionTimeInHundredsOfNanoseconds</unmanaged>
            <unmanaged-short>ExecutionTimeInHundredsOfNanoseconds</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.ContentprotectiondeviceOutputData.OutputData">
            <summary>
            <dd> <p>The output of the protection system function.</p> <p>If the value of the <strong>PrivateDataByteCount</strong> member is greater than 0, bytes 0 through <strong>PrivateDataByteCount</strong> - 1 are reserved for IHV use.   Bytes <strong>PrivateDataByteCount</strong> through <strong>MaxHWProtectionDataByteCount</strong> + <strong>PrivateDataByteCount</strong> - 1 contain the region    of the array into which the driver should return the output data from the protection system function.</p> <p>The protection system specification defines the format and size of the    function.</p> </dd>
            </summary>
            <doc-id>mt219217</doc-id>
            <unmanaged>OutputData</unmanaged>
            <unmanaged-short>OutputData</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.ContentprotectiondeviceRealtimeclientData">
            <summary>
            <p>Advises the secure processor of the  Multimedia Class Scheduler service (MMCSS) parameters so that real-time tasks can be scheduled at the expected priority.</p>
            </summary>
            <doc-id>mt219218</doc-id>
            <unmanaged>MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA</unmanaged>
            <unmanaged-short>MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ContentprotectiondeviceRealtimeclientData.TaskIndex">
            <summary>
            <dd> <p>The identifier for the MMCSS task.</p> </dd>
            </summary>
            <doc-id>mt219218</doc-id>
            <unmanaged>TaskIndex</unmanaged>
            <unmanaged-short>TaskIndex</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ContentprotectiondeviceRealtimeclientData.ClassName">
            <summary>
            <dd> <p>The name of the MMCSS task.</p> </dd>
            </summary>
            <doc-id>mt219218</doc-id>
            <unmanaged>ClassName</unmanaged>
            <unmanaged-short>ClassName</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ContentprotectiondeviceRealtimeclientData.BasePriority">
            <summary>
            <dd> <p>The base priority of the thread that runs the MMCSS task.</p> </dd>
            </summary>
            <doc-id>mt219218</doc-id>
            <unmanaged>BasePriority</unmanaged>
            <unmanaged-short>BasePriority</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.DirtyrectInformation">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DIRTYRECT_INFO</unmanaged>
            <unmanaged-short>DIRTYRECT_INFO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DirtyrectInformation.FrameNumber">
            <summary>
            No documentation.
            </summary>
            <unmanaged>FrameNumber</unmanaged>
            <unmanaged-short>FrameNumber</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DirtyrectInformation.NumDirtyRects">
            <summary>
            No documentation.
            </summary>
            <unmanaged>NumDirtyRects</unmanaged>
            <unmanaged-short>NumDirtyRects</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.DirtyrectInformation.DirtyRects">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DirtyRects</unmanaged>
            <unmanaged-short>DirtyRects</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.DmoMediaType">
            <summary>
            <p> </p><p>The <strong><see cref = "T:SharpDX.MediaFoundation.DmoMediaType"/></strong> structure describes the format of the data used by a stream in a Microsoft DirectX Media Object (DMO).</p>
            </summary>
            <remarks>
            <p>This structure is identical to the DirectShow <strong><see cref = "!:SharpDX.Win32.Unsupported.AMMediaType"/></strong> structure. The <strong>bFixedSizeSamples</strong>, <strong>bTemporalCompression</strong>, and <strong>lSampleSize</strong> members are for compatibility with DirectShow. Other DMO clients are not required to use them.</p>
            </remarks>
            <doc-id>dd375504</doc-id>
            <unmanaged>DMO_MEDIA_TYPE</unmanaged>
            <unmanaged-short>DMO_MEDIA_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoMediaType.Majortype">
            <summary>
            <dd> <p>Major type <see cref = "T:System.Guid"/> of the stream.</p> </dd>
            </summary>
            <doc-id>dd375504</doc-id>
            <unmanaged>majortype</unmanaged>
            <unmanaged-short>majortype</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoMediaType.Subtype">
            <summary>
            <dd> <p>Subtype <see cref = "T:System.Guid"/> of the stream.</p> </dd>
            </summary>
            <doc-id>dd375504</doc-id>
            <unmanaged>subtype</unmanaged>
            <unmanaged-short>subtype</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoMediaType.BFixedSizeSamples">
            <summary>
            <dd> <p>If <strong>TRUE</strong>, samples are of a fixed size. This field is informational only. For audio, it is generally set to <strong>TRUE</strong>. For video, it is usually <strong>TRUE</strong> for uncompressed video and <strong><see cref = "F:SharpDX.Result.False"/></strong> for compressed video.</p> </dd>
            </summary>
            <doc-id>dd375504</doc-id>
            <unmanaged>bFixedSizeSamples</unmanaged>
            <unmanaged-short>bFixedSizeSamples</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoMediaType.BTemporalCompression">
            <summary>
            <dd> <p>If <strong>TRUE</strong>, samples are compressed using temporal (interframe) compression. (A value of <strong>TRUE</strong> indicates that not all frames are key frames.) This field is informational only.</p> </dd>
            </summary>
            <doc-id>dd375504</doc-id>
            <unmanaged>bTemporalCompression</unmanaged>
            <unmanaged-short>bTemporalCompression</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoMediaType.LSampleSize">
            <summary>
            <dd> <p>Size of the sample in bytes. For compressed data, the value can be zero.</p> </dd>
            </summary>
            <doc-id>dd375504</doc-id>
            <unmanaged>lSampleSize</unmanaged>
            <unmanaged-short>lSampleSize</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoMediaType.Formattype">
            <summary>
            <dd> <p><see cref = "T:System.Guid"/> specifying the format type. The <strong>pbFormat</strong> member points to the corresponding format structure. Format types include the following.</p> <table> <tr><th>Format type</th><th>Format structure</th></tr> <tr><td><dl> <dt><strong>FORMAT_DvInfo</strong></dt> </dl> </td><td> <p> <strong>DVINFO</strong> </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_MPEG2Video</strong></dt> </dl> </td><td> <p> <strong><see cref = "!:SharpDX.MediaFoundation.Mpeg2VideoInformation"/></strong> </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_MPEGVideo</strong></dt> </dl> </td><td> <p> <strong><see cref = "!:SharpDX.MediaFoundation.Mpeg1VideoInformation"/></strong> </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_None</strong></dt> </dl> </td><td> <p>None.</p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_VideoInfo</strong></dt> </dl> </td><td> <p> <strong><see cref = "!:SharpDX.Win32.Unsupported.VideoInfoHeader"/></strong> </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_VideoInfo2</strong></dt> </dl> </td><td> <p> <strong><see cref = "!:SharpDX.MediaFoundation.VideoInformationHeader2"/></strong> </p> </td></tr> <tr><td><dl> <dt><strong>FORMAT_WaveFormatEx</strong></dt> </dl> </td><td> <p> <strong><see cref = "T:SharpDX.Multimedia.WaveFormat"/></strong> </p> </td></tr> </table> <p>?</p> </dd>
            </summary>
            <doc-id>dd375504</doc-id>
            <unmanaged>formattype</unmanaged>
            <unmanaged-short>formattype</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoMediaType.PUnk">
            <summary>
            <dd> <p>Not used. Set to <strong><c>null</c></strong>.</p> </dd>
            </summary>
            <doc-id>dd375504</doc-id>
            <unmanaged>pUnk</unmanaged>
            <unmanaged-short>pUnk</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoMediaType.CbFormat">
            <summary>
            <dd> <p>Size of the format block of the media type.</p> </dd>
            </summary>
            <doc-id>dd375504</doc-id>
            <unmanaged>cbFormat</unmanaged>
            <unmanaged-short>cbFormat</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoMediaType.PbFormat">
            <summary>
            <dd> <p>Pointer to the format structure. The structure type is specified by the <strong>formattype</strong> member. The format structure must be present, unless <strong>formattype</strong> is GUID_NULL or FORMAT_None.</p> </dd>
            </summary>
            <doc-id>dd375504</doc-id>
            <unmanaged>pbFormat</unmanaged>
            <unmanaged-short>pbFormat</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.DmoOutputDataBuffer">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DMO_OUTPUT_DATA_BUFFER</unmanaged>
            <unmanaged-short>DMO_OUTPUT_DATA_BUFFER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoOutputDataBuffer.PBuffer">
            <summary>
            No documentation.
            </summary>
            <unmanaged>pBuffer</unmanaged>
            <unmanaged-short>pBuffer</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoOutputDataBuffer.DwStatus">
            <summary>
            No documentation.
            </summary>
            <unmanaged>dwStatus</unmanaged>
            <unmanaged-short>dwStatus</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoOutputDataBuffer.RtTimestamp">
            <summary>
            No documentation.
            </summary>
            <unmanaged>rtTimestamp</unmanaged>
            <unmanaged-short>rtTimestamp</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.DmoOutputDataBuffer.RtTimelength">
            <summary>
            No documentation.
            </summary>
            <unmanaged>rtTimelength</unmanaged>
            <unmanaged-short>rtTimelength</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.FaceCharacterization">
            <summary>
            <p>The <strong>FaceCharacterization</strong> structure describes the blob format for the <strong>MF_CAPTURE_METADATA_FACEROICHARACTERIZATIONS</strong> attribute.</p>
            </summary>
            <remarks>
            <p>The <strong>MF_CAPTURE_METADATA_FACEROICHARACTERIZATIONS</strong> attribute contains the blink and facial expression state for the face ROIs identified in <strong>MF_CAPTURE_METADATA_FACEROIS</strong>.  For a  device that does not support blink or facial expression detection, this attribute should be omitted.</p><p>The facial expressions that can be detected are defined as follows:</p><pre>#define MF_METADATAFACIALEXPRESSION_SMILE             0x00000001</pre><p>The <strong>FaceCharacterizationBlobHeader</strong> and <strong>FaceCharacterization</strong> structures only describe the blob format for the <strong>MF_CAPTURE_METADATA_FACEROICHARACTERIZATIONS</strong> attribute.  The metadata item structure for the face characterizations (<strong>KSCAMERA_METADATA_ITEMHEADER</strong> + face characterizations metadata payload) is up to driver and must be 8-byte aligned. </p>
            </remarks>
            <doc-id>dn927642</doc-id>
            <unmanaged>FaceCharacterization</unmanaged>
            <unmanaged-short>FaceCharacterization</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FaceCharacterization.BlinkScoreLeft">
            <summary>
            <dd> <p>0 indicates no blink for the left eye, 100 indicates definite blink for the left eye (0 - 100).</p> </dd>
            </summary>
            <doc-id>dn927642</doc-id>
            <unmanaged>BlinkScoreLeft</unmanaged>
            <unmanaged-short>BlinkScoreLeft</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FaceCharacterization.BlinkScoreRight">
            <summary>
            <dd> <p>0 indicates no blink for the right eye, 100 indicates definite blink for the right eye (0 - 100).</p> </dd>
            </summary>
            <doc-id>dn927642</doc-id>
            <unmanaged>BlinkScoreRight</unmanaged>
            <unmanaged-short>BlinkScoreRight</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FaceCharacterization.FacialExpression">
            <summary>
            <dd> <p>A  defined facial expression value.</p> </dd>
            </summary>
            <doc-id>dn927642</doc-id>
            <unmanaged>FacialExpression</unmanaged>
            <unmanaged-short>FacialExpression</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FaceCharacterization.FacialExpressionScore">
            <summary>
            <dd> <p>0 indicates no such facial expression as identified, 100 indicates definite such facial expression as defined (0 - 100).</p> </dd>
            </summary>
            <doc-id>dn927642</doc-id>
            <unmanaged>FacialExpressionScore</unmanaged>
            <unmanaged-short>FacialExpressionScore</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.FaceCharacterizationBlobHeader">
            <summary>
            <p>The <strong>FaceCharacterizationBlobHeader</strong> structure  describes the size and count information of the blob format for the <strong>MF_CAPTURE_METADATA_FACEROICHARACTERIZATIONS</strong> attribute.</p>
            </summary>
            <doc-id>dn927643</doc-id>
            <unmanaged>FaceCharacterizationBlobHeader</unmanaged>
            <unmanaged-short>FaceCharacterizationBlobHeader</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FaceCharacterizationBlobHeader.Size">
            <summary>
            <dd> <p>Size of this header + all following <strong>FaceCharacterization</strong> structures.</p> </dd>
            </summary>
            <doc-id>dn927643</doc-id>
            <unmanaged>Size</unmanaged>
            <unmanaged-short>Size</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FaceCharacterizationBlobHeader.Count">
            <summary>
            <dd> <p>Number of <strong>FaceCharacterization</strong> structures in the blob. Must match the number of <strong>FaceRectInfo</strong> structures in <strong>FaceRectInfoBlobHeader</strong>.</p> </dd>
            </summary>
            <doc-id>dn927643</doc-id>
            <unmanaged>Count</unmanaged>
            <unmanaged-short>Count</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.FaceRectInfo">
            <summary>
            <p>The <strong>FaceRectInfo</strong> structure describes the blob format for the <strong>MF_CAPTURE_METADATA_FACEROIS</strong> attribute.</p>
            </summary>
            <remarks>
            <p>The <strong>MF_CAPTURE_METADATA_FACEROIS</strong> attribute contains the face rectangle info detected by the driver.   By default driver\MFT0 should provide the face information on preview stream.  If the driver advertises the capability on other streams, driver\MFT must provide the face info on the corresponding streams if the application enables face detection on those streams.  When video stabilization is enabled on the driver, the face information should be provided post-video stabilization. The dominate face must be the first <strong>FaceRectInfo</strong> in the blob.</p><p>The <strong>FaceRectInfoBlobHeader</strong> and <strong>FaceRectInfo</strong> structures only describe the blob format for the <strong>MF_CAPTURE_METADATA_FACEROIS</strong> attribute.  The metadata item structure for face ROIs (<strong>KSCAMERA_METADATA_ITEMHEADER</strong> + face ROIs metadata payload) is up to driver and must be 8-byte aligned.</p>
            </remarks>
            <doc-id>dn927644</doc-id>
            <unmanaged>FaceRectInfo</unmanaged>
            <unmanaged-short>FaceRectInfo</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FaceRectInfo.Region">
            <summary>
            <dd> <p>Relative coordinates on the frame that face detection is running (Q31 format).</p> </dd>
            </summary>
            <doc-id>dn927644</doc-id>
            <unmanaged>Region</unmanaged>
            <unmanaged-short>Region</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FaceRectInfo.ConfidenceLevel">
            <summary>
            <dd> <p>Confidence level of the region being a face (0 - 100).</p> </dd>
            </summary>
            <doc-id>dn927644</doc-id>
            <unmanaged>confidenceLevel</unmanaged>
            <unmanaged-short>confidenceLevel</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.FaceRectInfoBlobHeader">
            <summary>
            <p>The <strong>FaceRectInfoBlobHeader</strong> structure describes the size and count information of the blob format for the <strong>MF_CAPTURE_METADATA_FACEROIS</strong> attribute.</p>
            </summary>
            <doc-id>dn927645</doc-id>
            <unmanaged>FaceRectInfoBlobHeader</unmanaged>
            <unmanaged-short>FaceRectInfoBlobHeader</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FaceRectInfoBlobHeader.Size">
            <summary>
            <dd> <p>Size of this header + all following <strong>FaceRectInfo</strong> structures.</p> </dd>
            </summary>
            <doc-id>dn927645</doc-id>
            <unmanaged>Size</unmanaged>
            <unmanaged-short>Size</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FaceRectInfoBlobHeader.Count">
            <summary>
            <dd> <p>Number of <strong>FaceRectInfo</strong> structures in the blob.</p> </dd>
            </summary>
            <doc-id>dn927645</doc-id>
            <unmanaged>Count</unmanaged>
            <unmanaged-short>Count</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.Float2">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>A vector with two components.</p>
            </summary>
            <doc-id>mt740402</doc-id>
            <unmanaged>MF_FLOAT2</unmanaged>
            <unmanaged-short>MF_FLOAT2</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Float2.X">
            <summary>
            <dd> <p>X component of the vector.</p> </dd>
            </summary>
            <doc-id>mt740402</doc-id>
            <unmanaged>x</unmanaged>
            <unmanaged-short>x</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Float2.Y">
            <summary>
            <dd> <p>Y component of the vector.</p> </dd>
            </summary>
            <doc-id>mt740402</doc-id>
            <unmanaged>y</unmanaged>
            <unmanaged-short>y</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.Float3">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>A vector with three components.</p>
            </summary>
            <doc-id>mt740403</doc-id>
            <unmanaged>MF_FLOAT3</unmanaged>
            <unmanaged-short>MF_FLOAT3</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Float3.X">
            <summary>
            <dd> <p>X component of the vector.</p> </dd>
            </summary>
            <doc-id>mt740403</doc-id>
            <unmanaged>x</unmanaged>
            <unmanaged-short>x</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Float3.Y">
            <summary>
            <dd> <p>Y component of the vector.</p> </dd>
            </summary>
            <doc-id>mt740403</doc-id>
            <unmanaged>y</unmanaged>
            <unmanaged-short>y</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Float3.Z">
            <summary>
            <dd> <p>Z component of the vector.</p> </dd>
            </summary>
            <doc-id>mt740403</doc-id>
            <unmanaged>z</unmanaged>
            <unmanaged-short>z</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.FolddownMatrix">
            <summary>
            <p> </p><p>Contains coefficients used to transform multichannel audio into a smaller number of audio channels. This process is called <em>fold-down</em>.</p>
            </summary>
            <remarks>
            <p>To specify this information in the media type, set the <strong><see cref = "!:AudioFolddownMatrix"/></strong> attribute.</p><p>The ASF media source supports fold-down from six channels (5.1 audio) to two channels (stereo). It gets the information from the g_wszFold6To2Channels3 attribute in the ASF header. This attribute is documented in the Windows Media Format SDK documentation.</p>
            </remarks>
            <doc-id>aa369731</doc-id>
            <unmanaged>MFFOLDDOWN_MATRIX</unmanaged>
            <unmanaged-short>MFFOLDDOWN_MATRIX</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FolddownMatrix.CbSize">
            <summary>
            <dd> <p>Size of the structure, in bytes.</p> </dd>
            </summary>
            <doc-id>aa369731</doc-id>
            <unmanaged>cbSize</unmanaged>
            <unmanaged-short>cbSize</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FolddownMatrix.CSrcChannels">
            <summary>
            <dd> <p>Number of source channels.</p> </dd>
            </summary>
            <doc-id>aa369731</doc-id>
            <unmanaged>cSrcChannels</unmanaged>
            <unmanaged-short>cSrcChannels</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FolddownMatrix.CDstChannels">
            <summary>
            <dd> <p>Number of destination channels.</p> </dd>
            </summary>
            <doc-id>aa369731</doc-id>
            <unmanaged>cDstChannels</unmanaged>
            <unmanaged-short>cDstChannels</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.FolddownMatrix.DwChannelMask">
            <summary>
            <dd> <p>Specifies the assignment of audio channels to speaker positions in the transformed audio. This member is a bitwise <strong>OR</strong> of flags that define the speaker positions. For a list of valid flags, see <strong><see cref = "!:AudioChannelMask"/></strong> attribute.</p> </dd>
            </summary>
            <doc-id>aa369731</doc-id>
            <unmanaged>dwChannelMask</unmanaged>
            <unmanaged-short>dwChannelMask</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.FolddownMatrix.Coeff">
            <summary>
            <dd> <p>Array that contains the fold-down coefficients. The number of coefficients is <strong>cSrcChannels</strong>?<strong>cDstChannels</strong>. If the number of coefficients is less than the size of the array, the remaining elements in the array are ignored. For more information about how the coefficients are applied, see Windows Media Audio Professional Codec Features.</p> </dd>
            </summary>
            <doc-id>aa369731</doc-id>
            <unmanaged>Coeff</unmanaged>
            <unmanaged-short>Coeff</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.HistogramBlobHeader">
            <summary>
            <p>The <strong>HistogramBlobHeader</strong> structure describes the blob size and the number of histograms in the blob for the <strong>MF_CAPTURE_METADATA_HISTOGRAM</strong> attribute.</p>
            </summary>
            <doc-id>dn927646</doc-id>
            <unmanaged>HistogramBlobHeader</unmanaged>
            <unmanaged-short>HistogramBlobHeader</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.HistogramBlobHeader.Size">
            <summary>
            <dd> <p>Size of the entire histogram blob in bytes.</p> </dd>
            </summary>
            <doc-id>dn927646</doc-id>
            <unmanaged>Size</unmanaged>
            <unmanaged-short>Size</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.HistogramBlobHeader.Histograms">
            <summary>
            <dd> <p>Number of histograms in the blob. Each histogram is identified by a <strong>HistogramHeader</strong>.</p> </dd>
            </summary>
            <doc-id>dn927646</doc-id>
            <unmanaged>Histograms</unmanaged>
            <unmanaged-short>Histograms</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.HistogramDataHeader">
            <summary>
            <p>The  <strong>HistogramDataHeader</strong> structure describes the blob format for the <strong>MF_CAPTURE_METADATA_HISTOGRAM</strong> attribute.  </p>
            </summary>
            <doc-id>dn927647</doc-id>
            <unmanaged>HistogramDataHeader</unmanaged>
            <unmanaged-short>HistogramDataHeader</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.HistogramDataHeader.Size">
            <summary>
            <dd> <p>Size in bytes of this header + all following histogram data.</p> </dd>
            </summary>
            <doc-id>dn927647</doc-id>
            <unmanaged>Size</unmanaged>
            <unmanaged-short>Size</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.HistogramDataHeader.ChannelMask">
            <summary>
            <dd> <p>Mask of the color channel for the histogram data.</p> </dd>
            </summary>
            <doc-id>dn927647</doc-id>
            <unmanaged>ChannelMask</unmanaged>
            <unmanaged-short>ChannelMask</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.HistogramDataHeader.Linear">
            <summary>
            <dd> <p>1 if linear, 0 if nonlinear.</p> </dd>
            </summary>
            <doc-id>dn927647</doc-id>
            <unmanaged>Linear</unmanaged>
            <unmanaged-short>Linear</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.HistogramGrid">
            <summary>
            <p>The  <strong>HistogramGrid</strong> structure describes the blob format for <strong>MF_CAPTURE_METADATA_HISTOGRAM</strong>.</p>
            </summary>
            <doc-id>dn927648</doc-id>
            <unmanaged>HistogramGrid</unmanaged>
            <unmanaged-short>HistogramGrid</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.HistogramGrid.Width">
            <summary>
            <dd> <p>Width of the sensor output that histogram is collected from.</p> </dd>
            </summary>
            <doc-id>dn927648</doc-id>
            <unmanaged>Width</unmanaged>
            <unmanaged-short>Width</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.HistogramGrid.Height">
            <summary>
            <dd> <p>Height of the sensor output that histogram is collected from.</p> </dd>
            </summary>
            <doc-id>dn927648</doc-id>
            <unmanaged>Height</unmanaged>
            <unmanaged-short>Height</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.HistogramGrid.Region">
            <summary>
            <dd> <p>Absolute coordinates of the region on the sensor output that the histogram is collected for.</p> </dd>
            </summary>
            <doc-id>dn927648</doc-id>
            <unmanaged>Region</unmanaged>
            <unmanaged-short>Region</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.HistogramHeader">
            <summary>
            <p>The <strong>HistogramHeader</strong> structure describes the blob format for <strong>MF_CAPTURE_METADATA_HISTOGRAM</strong>.</p>
            </summary>
            <remarks>
            <p>The <strong>MF_CAPTURE_METADATA_HISTOGRAM</strong> attribute contains a  histogram when a preview frame is captured.</p><p>For the <strong>ChannelMasks</strong> field, the following bitmasks indicate the available channels in the histogram:</p><pre>#define MF_HISTOGRAM_CHANNEL_Y  0x00000001
            #define MF_HISTOGRAM_CHANNEL_R  0x00000002
            #define MF_HISTOGRAM_CHANNEL_G  0x00000004
            #define MF_HISTOGRAM_CHANNEL_B  0x00000008
            #define MF_HISTOGRAM_CHANNEL_Cb 0x00000010
            #define MF_HISTOGRAM_CHANNEL_Cr 0x00000020</pre><p>Each blob can contain multiple histograms collected from different regions or different color spaces of the same frame. Each histogram in the blob is identified by its own <strong>HistogramHeader</strong>. Each histogram has its own region and sensor output size associated. For full frame histogram, the region will match the sensor output size specified in <strong>HistogramGrid</strong>.</p><p>Histogram data for all available channels are grouped under one histogram. Histogram data for each channel is identified by a <strong>HistogramDataHeader</strong> immediate above the data. <strong>ChannelMasks</strong> indicate how many and what channels are having the histogram data, which is the bitwise OR of the supported <strong>MF_HISTOGRAM_CHANNEL_*</strong> bitmasks as defined above. <strong>ChannelMask</strong> indicates what channel the data is for, which is identified by any one of the <strong>MF_HISTOGRAM_CHANNEL_*</strong> bitmasks.</p><p>Histogram data is an array of <strong><see cref = "T:System.Int32"/></strong> with each entry representing the number of pixels falling under a set of tonal values as categorized by the bin.  The data in the array should start from bin 0 to bin N-1, where N is the number of bins in the histogram, for example, <strong>HistogramBlobHeader.Bins</strong>.</p><p>For Windows?10, if <strong>KSPROPERTY_CAMERACONTROL_EXTENDED_HISTOGRAM</strong> is supported, at minimum a full frame histogram with Y channel must be provided which should be the first histogram in the histogram blob.
            Note that <strong>HistogramBlobHeader</strong>, <strong>HistogramHeader</strong>, <strong>HistogramDataHeader</strong> and Histogram data only describe the blob format for the <strong>MF_CAPTURE_METADATA_HISTOGRAM</strong> attribute.  The metadata item structure for the histogram (<strong>KSCAMERA_METADATA_ITEMHEADER</strong> + all histogram metadata payload) is up to driver and must be 8-byte aligned.</p>
            </remarks>
            <doc-id>dn927649</doc-id>
            <unmanaged>HistogramHeader</unmanaged>
            <unmanaged-short>HistogramHeader</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.HistogramHeader.Size">
            <summary>
            <dd> <p>Size of this header + (<strong>HistogramDataHeader</strong> + histogram data following) * number of channels available.</p> </dd>
            </summary>
            <doc-id>dn927649</doc-id>
            <unmanaged>Size</unmanaged>
            <unmanaged-short>Size</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.HistogramHeader.Bins">
            <summary>
            <dd> <p>Number of bins in the histogram.</p> </dd>
            </summary>
            <doc-id>dn927649</doc-id>
            <unmanaged>Bins</unmanaged>
            <unmanaged-short>Bins</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.HistogramHeader.FourCC">
            <summary>
            <dd> <p>Color space that the histogram is collected from</p> </dd>
            </summary>
            <doc-id>dn927649</doc-id>
            <unmanaged>FourCC</unmanaged>
            <unmanaged-short>FourCC</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.HistogramHeader.ChannelMasks">
            <summary>
            <dd> <p>Masks of the color channels that the histogram is collected for.</p> </dd>
            </summary>
            <doc-id>dn927649</doc-id>
            <unmanaged>ChannelMasks</unmanaged>
            <unmanaged-short>ChannelMasks</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.HistogramHeader.Grid">
            <summary>
            <dd> <p>Grid that the histogram is collected from.</p> </dd>
            </summary>
            <doc-id>dn927649</doc-id>
            <unmanaged>Grid</unmanaged>
            <unmanaged-short>Grid</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.InputTrustauthorityAccessAction">
            <summary>
            <p> </p><p>Describes an action requested by an output trust authority (OTA). The request is sent to an input trust authority (ITA).</p>
            </summary>
            <doc-id>ms695312</doc-id>
            <unmanaged>MFINPUTTRUSTAUTHORITY_ACCESS_ACTION</unmanaged>
            <unmanaged-short>MFINPUTTRUSTAUTHORITY_ACCESS_ACTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.InputTrustauthorityAccessAction.Action">
            <summary>
            <dd> <p>Specifies the action as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.PolicymanagerAction"/></strong> enumeration.</p> </dd>
            </summary>
            <doc-id>ms695312</doc-id>
            <unmanaged>Action</unmanaged>
            <unmanaged-short>Action</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.InputTrustauthorityAccessAction.PbTicket">
            <summary>
            <dd> <p>Pointer to a buffer that contains a ticket object, provided by the OTA.</p> </dd>
            </summary>
            <doc-id>ms695312</doc-id>
            <unmanaged>pbTicket</unmanaged>
            <unmanaged-short>pbTicket</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.InputTrustauthorityAccessAction.CbTicket">
            <summary>
            <dd> <p>Size of the ticket object, in bytes.</p> </dd>
            </summary>
            <doc-id>ms695312</doc-id>
            <unmanaged>cbTicket</unmanaged>
            <unmanaged-short>cbTicket</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.InputTrustauthorityAccessParameters">
            <summary>
            <p> </p><p>Contains parameters for the <strong>IMFInputTrustAuthority::BindAccess</strong> or <strong>IMFInputTrustAuthority::UpdateAccess</strong> method.</p>
            </summary>
            <doc-id>ms697403</doc-id>
            <unmanaged>MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS</unmanaged>
            <unmanaged-short>MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.InputTrustauthorityAccessParameters.DwSize">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697403</doc-id>
            <unmanaged>dwSize</unmanaged>
            <unmanaged-short>dwSize</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.InputTrustauthorityAccessParameters.DwVer">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697403</doc-id>
            <unmanaged>dwVer</unmanaged>
            <unmanaged-short>dwVer</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.InputTrustauthorityAccessParameters.CbSignatureOffset">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697403</doc-id>
            <unmanaged>cbSignatureOffset</unmanaged>
            <unmanaged-short>cbSignatureOffset</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.InputTrustauthorityAccessParameters.CbSignatureSize">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697403</doc-id>
            <unmanaged>cbSignatureSize</unmanaged>
            <unmanaged-short>cbSignatureSize</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.InputTrustauthorityAccessParameters.CbExtensionOffset">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697403</doc-id>
            <unmanaged>cbExtensionOffset</unmanaged>
            <unmanaged-short>cbExtensionOffset</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.InputTrustauthorityAccessParameters.CbExtensionSize">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697403</doc-id>
            <unmanaged>cbExtensionSize</unmanaged>
            <unmanaged-short>cbExtensionSize</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.InputTrustauthorityAccessParameters.CActions">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697403</doc-id>
            <unmanaged>cActions</unmanaged>
            <unmanaged-short>cActions</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.InputTrustauthorityAccessParameters.RgOutputActions">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697403</doc-id>
            <unmanaged>rgOutputActions</unmanaged>
            <unmanaged-short>rgOutputActions</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.LeakyBucketPair">
            <summary>
            <p> </p><p>Specifies the buffering requirements of a file.</p>
            </summary>
            <remarks>
            <p>This structure describes the buffering requirements for content encoded at the bit rate specified in the <strong>dwBitrate</strong>. The <strong>msBufferWindow</strong> member indicates how much data should be buffered before starting playback. The size of the buffer in bytes is <strong>msBufferWinow</strong>?<strong>dwBitrate</strong> / 8000.</p>
            </remarks>
            <doc-id>aa371870</doc-id>
            <unmanaged>MF_LEAKY_BUCKET_PAIR</unmanaged>
            <unmanaged-short>MF_LEAKY_BUCKET_PAIR</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.LeakyBucketPair.DwBitrate">
            <summary>
            <dd> <p>Bit rate, in bits per second.</p> </dd>
            </summary>
            <doc-id>aa371870</doc-id>
            <unmanaged>dwBitrate</unmanaged>
            <unmanaged-short>dwBitrate</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.LeakyBucketPair.MsBufferWindow">
            <summary>
            <dd> <p>Size of the buffer window, in milliseconds.</p> </dd>
            </summary>
            <doc-id>aa371870</doc-id>
            <unmanaged>msBufferWindow</unmanaged>
            <unmanaged-short>msBufferWindow</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MediaKeyStatus">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFMediaKeyStatus</unmanaged>
            <unmanaged-short>MFMediaKeyStatus</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeyStatus.PbKeyId">
            <summary>
            No documentation.
            </summary>
            <unmanaged>pbKeyId</unmanaged>
            <unmanaged-short>pbKeyId</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeyStatus.CbKeyId">
            <summary>
            No documentation.
            </summary>
            <unmanaged>cbKeyId</unmanaged>
            <unmanaged-short>cbKeyId</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MediaKeyStatus.EMediaKeyStatus">
            <summary>
            No documentation.
            </summary>
            <unmanaged>eMediaKeyStatus</unmanaged>
            <unmanaged-short>eMediaKeyStatus</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MetadataTimeStamps">
            <summary>
            <p>The <strong>MetadataTimeStamps</strong> structure describes the blob format for the <strong>MF_CAPTURE_METADATA_FACEROITIMESTAMPS</strong> attribute.</p>
            </summary>
            <remarks>
            <p>The <strong>MF_CAPTURE_METADATA_FACEROITIMESTAMPS</strong> attribute contains the time stamp information for the face ROIs identified in <strong>MF_CAPTURE_METADATA_FACEROIS</strong>.  For a  device that cannot provide the time stamp for face ROIs, this attribute should be omitted.</p><p>For the <strong>Flags</strong> field, the following bit flags  indicate which time stamp is valid:</p><pre>#define MF_METADATATIMESTAMPS_DEVICE        0x00000001
            #define MF_METADATATIMESTAMPS_PRESENTATION  0x00000002</pre><p>MFT0 must set <strong>Flags</strong> to <strong>MF_METADATATIEMSTAMPS_DEVICE</strong> and the appropriate QPC time for <strong>Device</strong>, if the driver provides the timestamp metadata for the face ROIs.</p><p>The <strong>MetadataTimeStamps</strong> structure only describes the blob format for the <strong>MF_CAPTURE_METADATA_FACEROITIMESTAMPS</strong> attribute.  The metadata item structure for timestamp (<strong>KSCAMERA_METADATA_ITEMHEADER</strong> + timestamp metadata payload) is up to driver and must be 8-byte aligned.</p>
            </remarks>
            <doc-id>dn898736</doc-id>
            <unmanaged>MetadataTimeStamps</unmanaged>
            <unmanaged-short>MetadataTimeStamps</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MetadataTimeStamps.Flags">
            <summary>
            <dd> <p>Bitwise OR of the <strong>MF_METADATATIMESTAMPS_*</strong> flags.</p> </dd>
            </summary>
            <doc-id>dn898736</doc-id>
            <unmanaged>Flags</unmanaged>
            <unmanaged-short>Flags</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MetadataTimeStamps.Device">
            <summary>
            <dd> <p>QPC time for the sample  the face rectangle is derived from (in 100ns).</p> </dd>
            </summary>
            <doc-id>dn898736</doc-id>
            <unmanaged>Device</unmanaged>
            <unmanaged-short>Device</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MetadataTimeStamps.Presentation">
            <summary>
            <dd> <p>PTS for the sample  the face rectangle is derived from (in 100ns).</p> </dd>
            </summary>
            <doc-id>dn898736</doc-id>
            <unmanaged>Presentation</unmanaged>
            <unmanaged-short>Presentation</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MoveRectangle">
            <summary>
            <p>Provides information on a screen-to-screen move and a dirty rectangle copy operation.</p>
            </summary>
            <doc-id>hh406478</doc-id>
            <unmanaged>MOVE_RECT</unmanaged>
            <unmanaged-short>MOVE_RECT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MoveRectangle.SourcePoint">
            <summary>
            <dd> <p>A <strong><see cref = "T:SharpDX.Mathematics.Interop.RawPoint"/></strong> structure that describes the source (<em>x, y</em>) point where the source rectangle is copied from.</p> </dd>
            </summary>
            <doc-id>hh406478</doc-id>
            <unmanaged>SourcePoint</unmanaged>
            <unmanaged-short>SourcePoint</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MoveRectangle.DestRect">
            <summary>
            <dd> <p>A <strong><see cref = "T:SharpDX.Mathematics.Interop.RawRectangle"/></strong> structure that contains the destination rectangle where the dirty rectangle is copied to.</p> </dd>
            </summary>
            <doc-id>hh406478</doc-id>
            <unmanaged>DestRect</unmanaged>
            <unmanaged-short>DestRect</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MoveregionInformation">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MOVEREGION_INFO</unmanaged>
            <unmanaged-short>MOVEREGION_INFO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MoveregionInformation.FrameNumber">
            <summary>
            No documentation.
            </summary>
            <unmanaged>FrameNumber</unmanaged>
            <unmanaged-short>FrameNumber</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MoveregionInformation.NumMoveRegions">
            <summary>
            No documentation.
            </summary>
            <unmanaged>NumMoveRegions</unmanaged>
            <unmanaged-short>NumMoveRegions</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.MoveregionInformation.MoveRegions">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MoveRegions</unmanaged>
            <unmanaged-short>MoveRegions</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.Mpeg2dlnasinkstats">
            <summary>
            <p>Contains encoding statistics from the Digital Living Network Alliance (DLNA) media sink.</p><p>This structure is used with the <see cref = "!:Statistics"/> attribute.</p>
            </summary>
            <doc-id>dd388511</doc-id>
            <unmanaged>MFMPEG2DLNASINKSTATS</unmanaged>
            <unmanaged-short>MFMPEG2DLNASINKSTATS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Mpeg2dlnasinkstats.CBytesWritten">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388511</doc-id>
            <unmanaged>cBytesWritten</unmanaged>
            <unmanaged-short>cBytesWritten</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Mpeg2dlnasinkstats.FPAL">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388511</doc-id>
            <unmanaged>fPAL</unmanaged>
            <unmanaged-short>fPAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Mpeg2dlnasinkstats.FccVideo">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388511</doc-id>
            <unmanaged>fccVideo</unmanaged>
            <unmanaged-short>fccVideo</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Mpeg2dlnasinkstats.DwVideoWidth">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388511</doc-id>
            <unmanaged>dwVideoWidth</unmanaged>
            <unmanaged-short>dwVideoWidth</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Mpeg2dlnasinkstats.DwVideoHeight">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388511</doc-id>
            <unmanaged>dwVideoHeight</unmanaged>
            <unmanaged-short>dwVideoHeight</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Mpeg2dlnasinkstats.CVideoFramesReceived">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388511</doc-id>
            <unmanaged>cVideoFramesReceived</unmanaged>
            <unmanaged-short>cVideoFramesReceived</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Mpeg2dlnasinkstats.CVideoFramesEncoded">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388511</doc-id>
            <unmanaged>cVideoFramesEncoded</unmanaged>
            <unmanaged-short>cVideoFramesEncoded</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Mpeg2dlnasinkstats.CVideoFramesSkipped">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388511</doc-id>
            <unmanaged>cVideoFramesSkipped</unmanaged>
            <unmanaged-short>cVideoFramesSkipped</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Mpeg2dlnasinkstats.CBlackVideoFramesEncoded">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388511</doc-id>
            <unmanaged>cBlackVideoFramesEncoded</unmanaged>
            <unmanaged-short>cBlackVideoFramesEncoded</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Mpeg2dlnasinkstats.CVideoFramesDuplicated">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388511</doc-id>
            <unmanaged>cVideoFramesDuplicated</unmanaged>
            <unmanaged-short>cVideoFramesDuplicated</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Mpeg2dlnasinkstats.CAudioSamplesPerSec">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388511</doc-id>
            <unmanaged>cAudioSamplesPerSec</unmanaged>
            <unmanaged-short>cAudioSamplesPerSec</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Mpeg2dlnasinkstats.CAudioChannels">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388511</doc-id>
            <unmanaged>cAudioChannels</unmanaged>
            <unmanaged-short>cAudioChannels</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Mpeg2dlnasinkstats.CAudioBytesReceived">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388511</doc-id>
            <unmanaged>cAudioBytesReceived</unmanaged>
            <unmanaged-short>cAudioBytesReceived</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Mpeg2dlnasinkstats.CAudioFramesEncoded">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388511</doc-id>
            <unmanaged>cAudioFramesEncoded</unmanaged>
            <unmanaged-short>cAudioFramesEncoded</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MtArbitraryHeader">
            <summary>
            <p>Contains format data for a binary stream in an Advanced Streaming Format (ASF) file.</p>
            </summary>
            <remarks>
            <p>This structure is used with the <see cref = "!:ArbitraryHeader"/> media type attribute.</p><p>This structure corresponds to the first 60 bytes of the Type-Specific Data field of the Stream Properties Object, in files where the stream type is ASF_Binary_Media. For more information, see the ASF specification.</p><p>The Format Data field of the Type-Specific Data field is contained in the <see cref = "!:ArbitraryFormat"/> attribute of the media type.</p>
            </remarks>
            <doc-id>dd388931</doc-id>
            <unmanaged>MT_ARBITRARY_HEADER</unmanaged>
            <unmanaged-short>MT_ARBITRARY_HEADER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MtArbitraryHeader.Majortype">
            <summary>
            <dd> <p>Major media type. This value is the <see cref = "T:System.Guid"/> stored in the Major Media Type field of the Type-Specific Data field of the ASF file. It might not match the major type <see cref = "T:System.Guid"/> from the Media Foundation media type. </p> </dd>
            </summary>
            <doc-id>dd388931</doc-id>
            <unmanaged>majortype</unmanaged>
            <unmanaged-short>majortype</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MtArbitraryHeader.Subtype">
            <summary>
            <dd> <p>Media subtype. </p> </dd>
            </summary>
            <doc-id>dd388931</doc-id>
            <unmanaged>subtype</unmanaged>
            <unmanaged-short>subtype</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MtArbitraryHeader.BFixedSizeSamples">
            <summary>
            <dd> <p>If <strong>TRUE</strong>, samples have a fixed size in bytes. Otherwise, samples have variable size.</p> </dd>
            </summary>
            <doc-id>dd388931</doc-id>
            <unmanaged>bFixedSizeSamples</unmanaged>
            <unmanaged-short>bFixedSizeSamples</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MtArbitraryHeader.BTemporalCompression">
            <summary>
            <dd> <p> If <strong>TRUE</strong>, the data in this stream uses temporal compression. Otherwise, samples are independent of each other.</p> </dd>
            </summary>
            <doc-id>dd388931</doc-id>
            <unmanaged>bTemporalCompression</unmanaged>
            <unmanaged-short>bTemporalCompression</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MtArbitraryHeader.LSampleSize">
            <summary>
            <dd> <p>If <strong>bFixedSizeSamples</strong> is <strong>TRUE</strong>, this member specifies the sample size in bytes. Otherwise, the value is ignored and should be 0.</p> </dd>
            </summary>
            <doc-id>dd388931</doc-id>
            <unmanaged>lSampleSize</unmanaged>
            <unmanaged-short>lSampleSize</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MtArbitraryHeader.Formattype">
            <summary>
            <dd> <p>Format type <see cref = "T:System.Guid"/>. This <see cref = "T:System.Guid"/> identifies the structure of the additional format data, which is stored in the  <see cref = "!:ArbitraryFormat"/> attribute of the media type. If no additional format data is present, <strong>formattype</strong> equals GUID_NULL.</p> </dd>
            </summary>
            <doc-id>dd388931</doc-id>
            <unmanaged>formattype</unmanaged>
            <unmanaged-short>formattype</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.MtCustomVideoPrimaries">
            <summary>
            <p> </p><p>Defines custom color primaries for a video source. The color primaries define how to convert colors from RGB color space to CIE XYZ color space.</p>
            </summary>
            <remarks>
            <p>This structure is used with the <strong><see cref = "!:CustomVideoPrimaries"/></strong> attribute.</p>
            </remarks>
            <doc-id>ms696187</doc-id>
            <unmanaged>MT_CUSTOM_VIDEO_PRIMARIES</unmanaged>
            <unmanaged-short>MT_CUSTOM_VIDEO_PRIMARIES</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MtCustomVideoPrimaries.FRx">
            <summary>
            <dd> <p>Red x-coordinate.</p> </dd>
            </summary>
            <doc-id>ms696187</doc-id>
            <unmanaged>fRx</unmanaged>
            <unmanaged-short>fRx</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MtCustomVideoPrimaries.FRy">
            <summary>
            <dd> <p>Red y-coordinate.</p> </dd>
            </summary>
            <doc-id>ms696187</doc-id>
            <unmanaged>fRy</unmanaged>
            <unmanaged-short>fRy</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MtCustomVideoPrimaries.FGx">
            <summary>
            <dd> <p>Green x-coordinate.</p> </dd>
            </summary>
            <doc-id>ms696187</doc-id>
            <unmanaged>fGx</unmanaged>
            <unmanaged-short>fGx</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MtCustomVideoPrimaries.FGy">
            <summary>
            <dd> <p>Green y-coordinate.</p> </dd>
            </summary>
            <doc-id>ms696187</doc-id>
            <unmanaged>fGy</unmanaged>
            <unmanaged-short>fGy</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MtCustomVideoPrimaries.FBx">
            <summary>
            <dd> <p>Blue x-coordinate.</p> </dd>
            </summary>
            <doc-id>ms696187</doc-id>
            <unmanaged>fBx</unmanaged>
            <unmanaged-short>fBx</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MtCustomVideoPrimaries.FBy">
            <summary>
            <dd> <p>Blue y-coordinate.</p> </dd>
            </summary>
            <doc-id>ms696187</doc-id>
            <unmanaged>fBy</unmanaged>
            <unmanaged-short>fBy</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MtCustomVideoPrimaries.FWx">
            <summary>
            <dd> <p>White point x-coordinate.</p> </dd>
            </summary>
            <doc-id>ms696187</doc-id>
            <unmanaged>fWx</unmanaged>
            <unmanaged-short>fWx</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.MtCustomVideoPrimaries.FWy">
            <summary>
            <dd> <p>White point y-coordinate.</p> </dd>
            </summary>
            <doc-id>ms696187</doc-id>
            <unmanaged>fWy</unmanaged>
            <unmanaged-short>fWy</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.NetCredentialManagerGetParam">
            <summary>
            <p> </p><p>Contains the authentication information for the credential manager.</p>
            </summary>
            <doc-id>ms701554</doc-id>
            <unmanaged>MFNetCredentialManagerGetParam</unmanaged>
            <unmanaged-short>MFNetCredentialManagerGetParam</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetCredentialManagerGetParam.HrOp">
            <summary>
            <dd> <p>The response code of the authentication challenge. For example, NS_E_PROXY_ACCESSDENIED.</p> </dd>
            </summary>
            <doc-id>ms701554</doc-id>
            <unmanaged>hrOp</unmanaged>
            <unmanaged-short>hrOp</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetCredentialManagerGetParam.FAllowLoggedOnUser">
            <summary>
            <dd> <p>Set this flag to <strong>TRUE</strong> if the currently logged on user's credentials should be used as the default credentials.</p> </dd>
            </summary>
            <doc-id>ms701554</doc-id>
            <unmanaged>fAllowLoggedOnUser</unmanaged>
            <unmanaged-short>fAllowLoggedOnUser</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetCredentialManagerGetParam.FClearTextPackage">
            <summary>
            <dd> <p>If <strong>TRUE</strong>, the authentication package will send unencrypted credentials over the network. Otherwise, the authentication package encrypts the credentials.</p> </dd>
            </summary>
            <doc-id>ms701554</doc-id>
            <unmanaged>fClearTextPackage</unmanaged>
            <unmanaged-short>fClearTextPackage</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetCredentialManagerGetParam.PszUrl">
            <summary>
            <dd> <p>The original URL that requires authentication.</p> </dd>
            </summary>
            <doc-id>ms701554</doc-id>
            <unmanaged>pszUrl</unmanaged>
            <unmanaged-short>pszUrl</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetCredentialManagerGetParam.PszSite">
            <summary>
            <dd> <p>The name of the site or proxy that requires authentication.</p> </dd>
            </summary>
            <doc-id>ms701554</doc-id>
            <unmanaged>pszSite</unmanaged>
            <unmanaged-short>pszSite</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetCredentialManagerGetParam.PszRealm">
            <summary>
            <dd> <p>The name of the realm for this authentication.</p> </dd>
            </summary>
            <doc-id>ms701554</doc-id>
            <unmanaged>pszRealm</unmanaged>
            <unmanaged-short>pszRealm</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetCredentialManagerGetParam.PszPackage">
            <summary>
            <dd> <p>The name of the authentication package. For example, "Digest" or "MBS_BASIC".</p> </dd>
            </summary>
            <doc-id>ms701554</doc-id>
            <unmanaged>pszPackage</unmanaged>
            <unmanaged-short>pszPackage</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.NetCredentialManagerGetParam.NRetries">
            <summary>
            <dd> <p>The number of times that the credential manager should retry after authentication fails.</p> </dd>
            </summary>
            <doc-id>ms701554</doc-id>
            <unmanaged>nRetries</unmanaged>
            <unmanaged-short>nRetries</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.Offset">
            <summary>
            <p> Specifies an offset as a fixed-point real number. </p>
            </summary>
            <remarks>
            <p> The value of the number is <strong>value</strong> + (<strong>fract</strong> / 65536.0f).</p>
            </remarks>
            <doc-id>ms704775</doc-id>
            <unmanaged>MFOffset</unmanaged>
            <unmanaged-short>MFOffset</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Offset.Fract">
            <summary>
            <dd> <p> The fractional part of the number. </p> </dd>
            </summary>
            <doc-id>ms704775</doc-id>
            <unmanaged>fract</unmanaged>
            <unmanaged-short>fract</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Offset.Value">
            <summary>
            <dd> <p> The integer part of the number. </p> </dd>
            </summary>
            <doc-id>ms704775</doc-id>
            <unmanaged>value</unmanaged>
            <unmanaged-short>value</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PAcquireUserCredentialEvent">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_ACQUIRE_USER_CREDENTIAL</strong> event. This event is sent if the application plays a media file from a server that requires authentication. The application can respond by providing the user credentials.</p>
            </summary>
            <remarks>
            <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> callback method.  You can use the <strong>MFP_GET_ACQUIRE_USER_CREDENTIAL_EVENT</strong> macro for this purpose.</p><p>If the <strong>flags</strong> member contains the <strong>MFP_CREDENTIAL_PROMPT</strong> flag, the application should do the following:</p><ol> <li>Prompt the user to enter a user name and password.</li> <li>Store the user name in the credentials object by calling <strong>IMFNetCredential::SetUser</strong> on the <strong>pCredential</strong> reference.</li> <li>Store the password by calling <strong>IMFNetCredential::SetPassword</strong> on the <strong>pCredential</strong> reference.</li> </ol><p>To cancel authentication, set <strong>fProceedWithAuthentication</strong> equal to <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p><p>By default, MFPlay uses the network source's implementation of <strong><see cref = "T:SharpDX.MediaFoundation.NetCredentialManager"/></strong> to manage credentials. An application can provide its own implementation of this interface as follows:</p><ol> <li>Call <strong>QueryInterface</strong> on the <strong><see cref = "T:SharpDX.MediaFoundation.PMediaPlayer"/></strong> reference to get the <strong><see cref = "T:SharpDX.ComObject"/></strong> interface.</li> <li>Call <strong>IPropertyStore::SetValue</strong> to set the <strong>MFNETSOURCE_CREDENTIAL_MANAGER</strong> property.</li> </ol>
            </remarks>
            <doc-id>dd375527</doc-id>
            <unmanaged>MFP_ACQUIRE_USER_CREDENTIAL_EVENT</unmanaged>
            <unmanaged-short>MFP_ACQUIRE_USER_CREDENTIAL_EVENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PAcquireUserCredentialEvent.Header">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375527</doc-id>
            <unmanaged>header</unmanaged>
            <unmanaged-short>header</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PAcquireUserCredentialEvent.DwUserData">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375527</doc-id>
            <unmanaged>dwUserData</unmanaged>
            <unmanaged-short>dwUserData</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PAcquireUserCredentialEvent.FProceedWithAuthentication">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375527</doc-id>
            <unmanaged>fProceedWithAuthentication</unmanaged>
            <unmanaged-short>fProceedWithAuthentication</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PAcquireUserCredentialEvent.HrAuthenticationStatus">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375527</doc-id>
            <unmanaged>hrAuthenticationStatus</unmanaged>
            <unmanaged-short>hrAuthenticationStatus</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PAcquireUserCredentialEvent.PwszURL">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375527</doc-id>
            <unmanaged>pwszURL</unmanaged>
            <unmanaged-short>pwszURL</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PAcquireUserCredentialEvent.PwszSite">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375527</doc-id>
            <unmanaged>pwszSite</unmanaged>
            <unmanaged-short>pwszSite</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PAcquireUserCredentialEvent.PwszRealm">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375527</doc-id>
            <unmanaged>pwszRealm</unmanaged>
            <unmanaged-short>pwszRealm</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PAcquireUserCredentialEvent.PwszPackage">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375527</doc-id>
            <unmanaged>pwszPackage</unmanaged>
            <unmanaged-short>pwszPackage</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PAcquireUserCredentialEvent.NRetries">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375527</doc-id>
            <unmanaged>nRetries</unmanaged>
            <unmanaged-short>nRetries</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PAcquireUserCredentialEvent.Flags">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375527</doc-id>
            <unmanaged>flags</unmanaged>
            <unmanaged-short>flags</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PAcquireUserCredentialEvent.PCredential">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375527</doc-id>
            <unmanaged>pCredential</unmanaged>
            <unmanaged-short>pCredential</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PaletteEntry">
            <summary>
            <p>Contains one palette entry in a color table.</p>
            </summary>
            <remarks>
            <p>This union can be used to represent both RGB palettes and Y'Cb'Cr' palettes. The video format that defines the palette determines which union member should be used.</p>
            </remarks>
            <doc-id>ms698970</doc-id>
            <unmanaged>MFPaletteEntry</unmanaged>
            <unmanaged-short>MFPaletteEntry</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PaletteEntry.Argb">
            <summary>
            <dd> <p> <strong><see cref = "T:SharpDX.Mathematics.Interop.RawColorBGRA"/></strong> structure that contains an RGB color.</p> </dd>
            </summary>
            <doc-id>ms698970</doc-id>
            <unmanaged>ARGB</unmanaged>
            <unmanaged-short>ARGB</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PaletteEntry.AYCbCr">
            <summary>
            <dd> <p> <strong><see cref = "T:SharpDX.MediaFoundation.AYUVSample"/></strong> structure that contains a Y'Cb'Cr' color.</p> </dd>
            </summary>
            <doc-id>ms698970</doc-id>
            <unmanaged>AYCbCr</unmanaged>
            <unmanaged-short>AYCbCr</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PErrorEvent">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_ERROR</strong> event. This event is sent if an error occurs during playback.  </p>
            </summary>
            <remarks>
            <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_ERROR_EVENT</strong> macro for this purpose.</p><p>This event is not used to signal the failure of an asynchronous <strong><see cref = "T:SharpDX.MediaFoundation.PMediaPlayer"/></strong> method. If an asynchronous method fails, the error is reported in the standard event listed for that method. The <strong>MFP_EVENT_TYPE_ERROR</strong> event is used for errors that happen outside the context of an asynchronous method call.</p>
            </remarks>
            <doc-id>dd375530</doc-id>
            <unmanaged>MFP_ERROR_EVENT</unmanaged>
            <unmanaged-short>MFP_ERROR_EVENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PErrorEvent.Header">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375530</doc-id>
            <unmanaged>header</unmanaged>
            <unmanaged-short>header</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PEventHeader">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Contains information that is common to  every type of MFPlay event.</p>
            </summary>
            <doc-id>dd375531</doc-id>
            <unmanaged>MFP_EVENT_HEADER</unmanaged>
            <unmanaged-short>MFP_EVENT_HEADER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PEventHeader.EEventType">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375531</doc-id>
            <unmanaged>eEventType</unmanaged>
            <unmanaged-short>eEventType</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PEventHeader.HrEvent">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375531</doc-id>
            <unmanaged>hrEvent</unmanaged>
            <unmanaged-short>hrEvent</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PEventHeader.PMediaPlayer">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375531</doc-id>
            <unmanaged>pMediaPlayer</unmanaged>
            <unmanaged-short>pMediaPlayer</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PEventHeader.EState">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375531</doc-id>
            <unmanaged>eState</unmanaged>
            <unmanaged-short>eState</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PEventHeader.PPropertyStore">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375531</doc-id>
            <unmanaged>pPropertyStore</unmanaged>
            <unmanaged-short>pPropertyStore</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PFrameStepEvent">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_FRAME_STEP</strong> event. This event is sent when the <strong>IMFPMediaPlayer::FrameStep</strong> method completes.</p>
            </summary>
            <remarks>
            <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_FRAME_STEP_EVENT</strong> macro for this purpose.</p>
            </remarks>
            <doc-id>dd375533</doc-id>
            <unmanaged>MFP_FRAME_STEP_EVENT</unmanaged>
            <unmanaged-short>MFP_FRAME_STEP_EVENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PFrameStepEvent.Header">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375533</doc-id>
            <unmanaged>header</unmanaged>
            <unmanaged-short>header</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PFrameStepEvent.PMediaItem">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375533</doc-id>
            <unmanaged>pMediaItem</unmanaged>
            <unmanaged-short>pMediaItem</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PinholeCameraIntrinsicIntrinsicModel">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Represents a pinhole camera intrinsic model for a specified resolution.</p>
            </summary>
            <doc-id>mt740397</doc-id>
            <unmanaged>MFPinholeCameraIntrinsic_IntrinsicModel</unmanaged>
            <unmanaged-short>MFPinholeCameraIntrinsic_IntrinsicModel</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PinholeCameraIntrinsicIntrinsicModel.Width">
            <summary>
            <dd> <p>The width for the pinhole camera intrinsic model.</p> </dd>
            </summary>
            <doc-id>mt740397</doc-id>
            <unmanaged>Width</unmanaged>
            <unmanaged-short>Width</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PinholeCameraIntrinsicIntrinsicModel.Height">
            <summary>
            <dd> <p>The height for the pinhole camera intrinsic model.</p> </dd>
            </summary>
            <doc-id>mt740397</doc-id>
            <unmanaged>Height</unmanaged>
            <unmanaged-short>Height</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PinholeCameraIntrinsicIntrinsicModel.CameraModel">
            <summary>
            <dd> <p> The pinhole camera model.</p> </dd>
            </summary>
            <doc-id>mt740397</doc-id>
            <unmanaged>CameraModel</unmanaged>
            <unmanaged-short>CameraModel</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PinholeCameraIntrinsicIntrinsicModel.DistortionModel">
            <summary>
            <dd> <p> The lens distortion model.</p> </dd>
            </summary>
            <doc-id>mt740397</doc-id>
            <unmanaged>DistortionModel</unmanaged>
            <unmanaged-short>DistortionModel</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PinholeCameraIntrinsics">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>Contains zero or 1 pinhole camera intrinsic models that describe how to project a 3D point in physical world onto the 2D image frame of a camera.</p>
            </summary>
            <doc-id>mt740396</doc-id>
            <unmanaged>MFPinholeCameraIntrinsics</unmanaged>
            <unmanaged-short>MFPinholeCameraIntrinsics</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PinholeCameraIntrinsics.IntrinsicModelCount">
            <summary>
            <dd> <p>The number of camera intrinsic models in the <em>IntrinsicModels</em> array.</p> </dd>
            </summary>
            <doc-id>mt740396</doc-id>
            <unmanaged>IntrinsicModelCount</unmanaged>
            <unmanaged-short>IntrinsicModelCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.PinholeCameraIntrinsics.IntrinsicModels">
            <summary>
            <dd> <p>The array of camera intrinsic models in the intrinsic data.</p> </dd>
            </summary>
            <doc-id>mt740396</doc-id>
            <unmanaged>IntrinsicModels</unmanaged>
            <unmanaged-short>IntrinsicModels</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PMediaItemClearedEvent">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_MEDIAITEM_CLEARED</strong> event. This event is sent when the <strong>IMFPMediaPlayer::ClearMediaItem</strong> method completes.</p>
            </summary>
            <remarks>
            <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_MEDIAITEM_CLEARED_EVENT</strong> macro for this purpose.</p>
            </remarks>
            <doc-id>dd375549</doc-id>
            <unmanaged>MFP_MEDIAITEM_CLEARED_EVENT</unmanaged>
            <unmanaged-short>MFP_MEDIAITEM_CLEARED_EVENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PMediaItemClearedEvent.Header">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375549</doc-id>
            <unmanaged>header</unmanaged>
            <unmanaged-short>header</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PMediaItemClearedEvent.PMediaItem">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375549</doc-id>
            <unmanaged>pMediaItem</unmanaged>
            <unmanaged-short>pMediaItem</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PMediaItemCreateDEvent">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_MEDIAITEM_CREATED</strong> event. This event is sent when the <strong>IMFPMediaPlayer::CreateMediaItemFromURL</strong> or  <strong>IMFPMediaPlayer::CreateMediaItemFromObject</strong> method completes.</p>
            </summary>
            <remarks>
            <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_MEDIAITEM_CREATED_EVENT</strong> macro for this purpose.</p><p>Media items are created asynchronously. If multiple items are created, the operations can complete in any order, not necessarily in the same order as the method calls. You can use  the <strong>dwUserData</strong> member to identify the items, if you have simultaneous requests pending. </p>
            </remarks>
            <doc-id>dd375560</doc-id>
            <unmanaged>MFP_MEDIAITEM_CREATED_EVENT</unmanaged>
            <unmanaged-short>MFP_MEDIAITEM_CREATED_EVENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PMediaItemCreateDEvent.Header">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375560</doc-id>
            <unmanaged>header</unmanaged>
            <unmanaged-short>header</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PMediaItemCreateDEvent.PMediaItem">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375560</doc-id>
            <unmanaged>pMediaItem</unmanaged>
            <unmanaged-short>pMediaItem</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PMediaItemCreateDEvent.DwUserData">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375560</doc-id>
            <unmanaged>dwUserData</unmanaged>
            <unmanaged-short>dwUserData</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PMediaItemSetEvent">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_MEDIAITEM_SET</strong> event. This event is sent when the <strong>IMFPMediaPlayer::SetMediaItem</strong> method completes.</p>
            </summary>
            <remarks>
            <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_MEDIAITEM_SET_EVENT</strong> macro for this purpose.</p><p>If one or more streams could not be connected to a media sink, the event property store contains the MFP_PKEY_StreamRenderingResults property. The value of the property is an array of <strong><see cref = "T:SharpDX.Result"/></strong> values, indicating which streams were connected successfully.  The event property store can be accessed through the <strong>header.pPropertyStore</strong> member.</p>
            </remarks>
            <doc-id>dd375561</doc-id>
            <unmanaged>MFP_MEDIAITEM_SET_EVENT</unmanaged>
            <unmanaged-short>MFP_MEDIAITEM_SET_EVENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PMediaItemSetEvent.Header">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375561</doc-id>
            <unmanaged>header</unmanaged>
            <unmanaged-short>header</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PMediaItemSetEvent.PMediaItem">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375561</doc-id>
            <unmanaged>pMediaItem</unmanaged>
            <unmanaged-short>pMediaItem</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PMfEvent">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_MF</strong> event. The MFPlay player object uses this event to forward certain events from the Media Foundation pipeline to the application.</p>
            </summary>
            <remarks>
            <p> To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method. You can use the <strong>MFP_GET_MF_EVENT</strong> macro for this purpose.</p><p>If <strong>MFEventType</strong> is MEStreamSinkFormatChanged, the following property may be stored in the event property store, which can be accessed through the <strong>header.pPropertyStore</strong> member.</p><table> <tr><th>Property</th><th>Description</th></tr> <tr><td> MFP_PKEY_StreamIndex </td><td>The index of the stream whose format changed. </td></tr> </table><p>?</p>
            </remarks>
            <doc-id>dd375563</doc-id>
            <unmanaged>MFP_MF_EVENT</unmanaged>
            <unmanaged-short>MFP_MF_EVENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PMfEvent.Header">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375563</doc-id>
            <unmanaged>header</unmanaged>
            <unmanaged-short>header</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PMfEvent.MFEventType">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375563</doc-id>
            <unmanaged>MFEventType</unmanaged>
            <unmanaged-short>MFEventType</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PMfEvent.PMFMediaEvent">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375563</doc-id>
            <unmanaged>pMFMediaEvent</unmanaged>
            <unmanaged-short>pMFMediaEvent</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PMfEvent.PMediaItem">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375563</doc-id>
            <unmanaged>pMediaItem</unmanaged>
            <unmanaged-short>pMediaItem</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PPauseEvent">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_PAUSE</strong> event. This event is sent when the <strong>IMFPMediaPlayer::Pause</strong> method completes.</p>
            </summary>
            <remarks>
            <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_PAUSE_EVENT</strong> macro for this purpose.</p>
            </remarks>
            <doc-id>dd375564</doc-id>
            <unmanaged>MFP_PAUSE_EVENT</unmanaged>
            <unmanaged-short>MFP_PAUSE_EVENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PPauseEvent.Header">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375564</doc-id>
            <unmanaged>header</unmanaged>
            <unmanaged-short>header</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PPauseEvent.PMediaItem">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375564</doc-id>
            <unmanaged>pMediaItem</unmanaged>
            <unmanaged-short>pMediaItem</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PPlaybackEndedEvent">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_PLAYBACK_ENDED</strong> event. This event is sent when the current media item finishes playing.</p>
            </summary>
            <remarks>
            <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_PLAYBACK_ENDED_EVENT</strong> macro for this purpose.</p>
            </remarks>
            <doc-id>dd375566</doc-id>
            <unmanaged>MFP_PLAYBACK_ENDED_EVENT</unmanaged>
            <unmanaged-short>MFP_PLAYBACK_ENDED_EVENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PPlaybackEndedEvent.Header">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375566</doc-id>
            <unmanaged>header</unmanaged>
            <unmanaged-short>header</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PPlaybackEndedEvent.PMediaItem">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375566</doc-id>
            <unmanaged>pMediaItem</unmanaged>
            <unmanaged-short>pMediaItem</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PPlayEvent">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_PLAY</strong> event. This event is sent when the <strong>IMFPMediaPlayer::Play</strong> method completes.</p>
            </summary>
            <remarks>
            <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_PLAY_EVENT</strong> macro for this purpose.</p>
            </remarks>
            <doc-id>dd375567</doc-id>
            <unmanaged>MFP_PLAY_EVENT</unmanaged>
            <unmanaged-short>MFP_PLAY_EVENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PPlayEvent.Header">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375567</doc-id>
            <unmanaged>header</unmanaged>
            <unmanaged-short>header</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PPlayEvent.PMediaItem">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375567</doc-id>
            <unmanaged>pMediaItem</unmanaged>
            <unmanaged-short>pMediaItem</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PPositionSetEvent">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_POSITION_SET</strong> event. This event is sent when the <strong>IMFPMediaPlayer::SetPosition</strong> method completes.</p>
            </summary>
            <remarks>
            <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_POSITION_SET_EVENT</strong> macro for this purpose.</p>
            </remarks>
            <doc-id>dd375568</doc-id>
            <unmanaged>MFP_POSITION_SET_EVENT</unmanaged>
            <unmanaged-short>MFP_POSITION_SET_EVENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PPositionSetEvent.Header">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375568</doc-id>
            <unmanaged>header</unmanaged>
            <unmanaged-short>header</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PPositionSetEvent.PMediaItem">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375568</doc-id>
            <unmanaged>pMediaItem</unmanaged>
            <unmanaged-short>pMediaItem</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PRateSetEvent">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the MFP_EVENT_TYPE_RATE_SET event. This event is sent when the <strong>IMFPMediaPlayer::SetRate</strong> method completes.</p>
            </summary>
            <remarks>
            <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_RATE_SET_EVENT</strong> macro for this purpose.</p>
            </remarks>
            <doc-id>dd375569</doc-id>
            <unmanaged>MFP_RATE_SET_EVENT</unmanaged>
            <unmanaged-short>MFP_RATE_SET_EVENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PRateSetEvent.Header">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375569</doc-id>
            <unmanaged>header</unmanaged>
            <unmanaged-short>header</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PRateSetEvent.PMediaItem">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375569</doc-id>
            <unmanaged>pMediaItem</unmanaged>
            <unmanaged-short>pMediaItem</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PRateSetEvent.FlRate">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375569</doc-id>
            <unmanaged>flRate</unmanaged>
            <unmanaged-short>flRate</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.PStopEvent">
            <summary>
            <p> </p><strong>Important</strong>??Deprecated. This API may be removed from future releases of Windows. Applications should use the Media Session for playback.?<p>Event structure for the <strong>MFP_EVENT_TYPE_STOP</strong> event. This event is sent when the <strong>IMFPMediaPlayer::Stop</strong> method completes.</p>
            </summary>
            <remarks>
            <p>To get a reference to this structure, cast the <em>pEventHeader</em> parameter of the <strong>IMFPMediaPlayerCallback::OnMediaPlayerEvent</strong> method.  You can use the <strong>MFP_GET_STOP_EVENT</strong> macro for this purpose.</p>
            </remarks>
            <doc-id>dd375570</doc-id>
            <unmanaged>MFP_STOP_EVENT</unmanaged>
            <unmanaged-short>MFP_STOP_EVENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PStopEvent.Header">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375570</doc-id>
            <unmanaged>header</unmanaged>
            <unmanaged-short>header</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.PStopEvent.PMediaItem">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd375570</doc-id>
            <unmanaged>pMediaItem</unmanaged>
            <unmanaged-short>pMediaItem</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.Quaternion">
            <summary>
            <p>[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.]</p><p>A four dimensional vector, used to represent a rotation.</p>
            </summary>
            <doc-id>mt740404</doc-id>
            <unmanaged>MF_QUATERNION</unmanaged>
            <unmanaged-short>MF_QUATERNION</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Quaternion.X">
            <summary>
            <dd> <p>X component of the vector.</p> </dd>
            </summary>
            <doc-id>mt740404</doc-id>
            <unmanaged>x</unmanaged>
            <unmanaged-short>x</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Quaternion.Y">
            <summary>
            <dd> <p>Y component of the vector.</p> </dd>
            </summary>
            <doc-id>mt740404</doc-id>
            <unmanaged>y</unmanaged>
            <unmanaged-short>y</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Quaternion.Z">
            <summary>
            <dd> <p>Z component of the vector.</p> </dd>
            </summary>
            <doc-id>mt740404</doc-id>
            <unmanaged>z</unmanaged>
            <unmanaged-short>z</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Quaternion.W">
            <summary>
            <dd> <p>W component of the vector.</p> </dd>
            </summary>
            <doc-id>mt740404</doc-id>
            <unmanaged>w</unmanaged>
            <unmanaged-short>w</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.Ratio">
            <summary>
            <p> </p><p>Represents a ratio.</p>
            </summary>
            <doc-id>aa473788</doc-id>
            <unmanaged>MFRatio</unmanaged>
            <unmanaged-short>MFRatio</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Ratio.Numerator">
            <summary>
            <dd> <p>Numerator of the ratio.</p> </dd>
            </summary>
            <doc-id>aa473788</doc-id>
            <unmanaged>Numerator</unmanaged>
            <unmanaged-short>Numerator</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.Ratio.Denominator">
            <summary>
            <dd> <p>Denominator of the ratio.</p> </dd>
            </summary>
            <doc-id>aa473788</doc-id>
            <unmanaged>Denominator</unmanaged>
            <unmanaged-short>Denominator</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.RoiArea">
            <summary>
            <p>Defines a regions of interest. </p>
            </summary>
            <doc-id>dn302212</doc-id>
            <unmanaged>ROI_AREA</unmanaged>
            <unmanaged-short>ROI_AREA</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.RoiArea.Rect">
            <summary>
            <dd> <p>The bounds of the region.</p> </dd>
            </summary>
            <doc-id>dn302212</doc-id>
            <unmanaged>rect</unmanaged>
            <unmanaged-short>rect</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.RoiArea.QPDelta">
            <summary>
            <dd> <p>Specifies the  quantization parameter delta for the specified region from the rest of the frame.</p> </dd>
            </summary>
            <doc-id>dn302212</doc-id>
            <unmanaged>QPDelta</unmanaged>
            <unmanaged-short>QPDelta</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.RrComponentHashInformation">
            <summary>
            <p> </p><p>Contains information about a revoked component.</p>
            </summary>
            <doc-id>aa376487</doc-id>
            <unmanaged>MFRR_COMPONENT_HASH_INFO</unmanaged>
            <unmanaged-short>MFRR_COMPONENT_HASH_INFO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.RrComponentHashInformation.UlReason">
            <summary>
            <dd> <p>Specifies the reason for the revocation. The following values are defined.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MF_BOOT_DRIVER_VERIFICATION_FAILED</strong></dt> </dl> </td><td> <p>A boot driver could not be verified.</p> </td></tr> <tr><td><dl> <dt><strong>MF_COMPONENT_CERT_REVOKED</strong></dt> </dl> </td><td> <p>A certificate in a trusted component's certificate chain was revoked.</p> </td></tr> <tr><td><dl> <dt><strong>MF_COMPONENT_HS_CERT_REVOKED</strong></dt> </dl> </td><td> <p>The high-security certificate for authenticating the protected environment (PE) was revoked.</p> <p>The high-security certificate is typically used by ITAs that handle high-definition content and next-generation formats such as HD-DVD.</p> </td></tr> <tr><td><dl> <dt><strong>MF_COMPONENT_INVALID_EKU</strong></dt> </dl> </td><td> <p>A certificate's extended key usage (EKU) object is invalid.</p> </td></tr> <tr><td><dl> <dt><strong>MF_COMPONENT_INVALID_ROOT</strong></dt> </dl> </td><td> <p>The root certificate is not valid.</p> </td></tr> <tr><td><dl> <dt><strong>MF_COMPONENT_LS_CERT_REVOKED</strong></dt> </dl> </td><td> <p>The low-security certificate for authenticating the PE was revoked.</p> <p>The low-security certificate is typically used by ITAs that handle standard-definition content and current-generation formats.</p> </td></tr> <tr><td><dl> <dt><strong>MF_COMPONENT_REVOKED</strong></dt> </dl> </td><td> <p>A trusted component was revoked.</p> </td></tr> <tr><td><dl> <dt><strong>MF_GRL_ABSENT</strong></dt> </dl> </td><td> <p>The GRL was not found.</p> </td></tr> <tr><td><dl> <dt><strong>MF_GRL_LOAD_FAILED</strong></dt> </dl> </td><td> <p>Could not load the global revocation list (GRL).</p> </td></tr> <tr><td><dl> <dt><strong>MF_INVALID_GRL_SIGNATURE</strong></dt> </dl> </td><td> <p>The GRL signature is invalid.</p> </td></tr> <tr><td><dl> <dt><strong>MF_MINCRYPT_FAILURE</strong></dt> </dl> </td><td> <p>A certificate chain was not well-formed, or a boot driver is unsigned or is signed with an untrusted certificate.</p> </td></tr> <tr><td><dl> <dt><strong>MF_TEST_SIGNED_COMPONENT_LOADING</strong></dt> </dl> </td><td> <p>A component was signed by a test certificate.</p> </td></tr> </table> <p>?</p> <p>In addition, one of the following flags might be present, indicating the type of component that failed to load.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>MF_USER_MODE_COMPONENT_LOAD</strong></dt> </dl> </td><td> <p>User-mode component.</p> </td></tr> <tr><td><dl> <dt><strong>MF_KERNEL_MODE_COMPONENT_LOAD</strong></dt> </dl> </td><td> <p>Kernel-mode component.</p> </td></tr> </table> <p>?</p> </dd>
            </summary>
            <doc-id>aa376487</doc-id>
            <unmanaged>ulReason</unmanaged>
            <unmanaged-short>ulReason</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.RrComponentHashInformation.RgHeaderHash">
            <summary>
            <dd> <p>Contains a hash of the file header.</p> </dd>
            </summary>
            <doc-id>aa376487</doc-id>
            <unmanaged>rgHeaderHash</unmanaged>
            <unmanaged-short>rgHeaderHash</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.RrComponentHashInformation.RgPublicKeyHash">
            <summary>
            <dd> <p>Contains a hash of the public key in the component's certificate.</p> </dd>
            </summary>
            <doc-id>aa376487</doc-id>
            <unmanaged>rgPublicKeyHash</unmanaged>
            <unmanaged-short>rgPublicKeyHash</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.RrComponentHashInformation.WszName">
            <summary>
            <dd> <p>File name of the revoked component.</p> </dd>
            </summary>
            <doc-id>aa376487</doc-id>
            <unmanaged>wszName</unmanaged>
            <unmanaged-short>wszName</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.RrComponents">
            <summary>
            <p> </p><p>Contains information about one or more revoked components.</p>
            </summary>
            <doc-id>aa375568</doc-id>
            <unmanaged>MFRR_COMPONENTS</unmanaged>
            <unmanaged-short>MFRR_COMPONENTS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.RrComponents.DwRRInfoVersion">
            <summary>
            <dd> <p>Revocation information version.</p> </dd>
            </summary>
            <doc-id>aa375568</doc-id>
            <unmanaged>dwRRInfoVersion</unmanaged>
            <unmanaged-short>dwRRInfoVersion</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.RrComponents.DwRRComponents">
            <summary>
            <dd> <p>Number of elements in the <strong>pRRComponents</strong> array.</p> </dd>
            </summary>
            <doc-id>aa375568</doc-id>
            <unmanaged>dwRRComponents</unmanaged>
            <unmanaged-short>dwRRComponents</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.RrComponents.PRRComponents">
            <summary>
            <dd> <p>Array of <strong><see cref = "T:SharpDX.MediaFoundation.RrComponentHashInformation"/></strong> structures.</p> </dd>
            </summary>
            <doc-id>aa375568</doc-id>
            <unmanaged>pRRComponents</unmanaged>
            <unmanaged-short>pRRComponents</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.SinkWriterStatistics">
            <summary>
            <p>Contains statistics about the performance of the sink writer.</p>
            </summary>
            <doc-id>dd375769</doc-id>
            <unmanaged>MF_SINK_WRITER_STATISTICS</unmanaged>
            <unmanaged-short>MF_SINK_WRITER_STATISTICS</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterStatistics.Cb">
            <summary>
            <dd> <p>The size of the structure, in bytes.</p> </dd>
            </summary>
            <doc-id>dd375769</doc-id>
            <unmanaged>cb</unmanaged>
            <unmanaged-short>cb</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterStatistics.LlLastTimestampReceived">
            <summary>
            <dd> <p>The time stamp of the most recent sample given to the sink writer. The sink writer updates this value each time the application calls <strong>IMFSinkWriter::WriteSample</strong>.</p> </dd>
            </summary>
            <doc-id>dd375769</doc-id>
            <unmanaged>llLastTimestampReceived</unmanaged>
            <unmanaged-short>llLastTimestampReceived</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterStatistics.LlLastTimestampEncoded">
            <summary>
            <dd> <p>The time stamp of the most recent sample to be encoded. The sink writer updates this value whenever it calls <strong>IMFTransform::ProcessOutput</strong> on the encoder.</p> </dd>
            </summary>
            <doc-id>dd375769</doc-id>
            <unmanaged>llLastTimestampEncoded</unmanaged>
            <unmanaged-short>llLastTimestampEncoded</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterStatistics.LlLastTimestampProcessed">
            <summary>
            <dd> <p>The time stamp of the most recent sample given to the media sink. The sink writer updates this value whenever it calls <strong>IMFStreamSink::ProcessSample</strong> on the media sink.</p> </dd>
            </summary>
            <doc-id>dd375769</doc-id>
            <unmanaged>llLastTimestampProcessed</unmanaged>
            <unmanaged-short>llLastTimestampProcessed</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterStatistics.LlLastStreamTickReceived">
            <summary>
            <dd> <p>The time stamp of the most recent stream tick. The sink writer updates this value whenever the application calls <strong>IMFSinkWriter::SendStreamTick</strong>.</p> </dd>
            </summary>
            <doc-id>dd375769</doc-id>
            <unmanaged>llLastStreamTickReceived</unmanaged>
            <unmanaged-short>llLastStreamTickReceived</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterStatistics.LlLastSinkSampleRequest">
            <summary>
            <dd> <p>The system time of the most recent sample request from the media sink. The sink writer updates this value whenever it receives an MEStreamSinkRequestSample event from the media sink. The value is the current system time.</p> </dd>
            </summary>
            <doc-id>dd375769</doc-id>
            <unmanaged>llLastSinkSampleRequest</unmanaged>
            <unmanaged-short>llLastSinkSampleRequest</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterStatistics.QwNumSamplesReceived">
            <summary>
            <dd> <p>The number of samples received.</p> </dd>
            </summary>
            <doc-id>dd375769</doc-id>
            <unmanaged>qwNumSamplesReceived</unmanaged>
            <unmanaged-short>qwNumSamplesReceived</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterStatistics.QwNumSamplesEncoded">
            <summary>
            <dd> <p>The number of samples encoded.</p> </dd>
            </summary>
            <doc-id>dd375769</doc-id>
            <unmanaged>qwNumSamplesEncoded</unmanaged>
            <unmanaged-short>qwNumSamplesEncoded</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterStatistics.QwNumSamplesProcessed">
            <summary>
            <dd> <p>The number of samples given to the media sink.</p> </dd>
            </summary>
            <doc-id>dd375769</doc-id>
            <unmanaged>qwNumSamplesProcessed</unmanaged>
            <unmanaged-short>qwNumSamplesProcessed</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterStatistics.QwNumStreamTicksReceived">
            <summary>
            <dd> <p>The number of stream ticks received.</p> </dd>
            </summary>
            <doc-id>dd375769</doc-id>
            <unmanaged>qwNumStreamTicksReceived</unmanaged>
            <unmanaged-short>qwNumStreamTicksReceived</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterStatistics.DwByteCountQueued">
            <summary>
            <dd> <p>The amount of data, in bytes, currently waiting to be processed. </p> </dd>
            </summary>
            <doc-id>dd375769</doc-id>
            <unmanaged>dwByteCountQueued</unmanaged>
            <unmanaged-short>dwByteCountQueued</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterStatistics.QwByteCountProcessed">
            <summary>
            <dd> <p>The total amount of data, in bytes, that has been sent to the media sink.</p> </dd>
            </summary>
            <doc-id>dd375769</doc-id>
            <unmanaged>qwByteCountProcessed</unmanaged>
            <unmanaged-short>qwByteCountProcessed</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterStatistics.DwNumOutstandingSinkSampleRequests">
            <summary>
            <dd> <p>The number of pending sample requests.</p> </dd>
            </summary>
            <doc-id>dd375769</doc-id>
            <unmanaged>dwNumOutstandingSinkSampleRequests</unmanaged>
            <unmanaged-short>dwNumOutstandingSinkSampleRequests</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterStatistics.DwAverageSampleRateReceived">
            <summary>
            <dd> <p>The average rate, in media samples per 100-nanoseconds, at which the application sent samples to the sink writer.</p> </dd>
            </summary>
            <doc-id>dd375769</doc-id>
            <unmanaged>dwAverageSampleRateReceived</unmanaged>
            <unmanaged-short>dwAverageSampleRateReceived</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterStatistics.DwAverageSampleRateEncoded">
            <summary>
            <dd> <p>The average rate, in media samples per 100-nanoseconds, at which the sink writer sent samples to the encoder.</p> </dd>
            </summary>
            <doc-id>dd375769</doc-id>
            <unmanaged>dwAverageSampleRateEncoded</unmanaged>
            <unmanaged-short>dwAverageSampleRateEncoded</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.SinkWriterStatistics.DwAverageSampleRateProcessed">
            <summary>
            <dd> <p>The average rate, in media samples per 100-nanoseconds, at which the sink writer sent samples to the media sink.</p> </dd>
            </summary>
            <doc-id>dd375769</doc-id>
            <unmanaged>dwAverageSampleRateProcessed</unmanaged>
            <unmanaged-short>dwAverageSampleRateProcessed</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.StreamMedium">
            <summary>
            <p>Not for application use.</p>
            </summary>
            <remarks>
            <p>This structure is used internally by the Microsoft Media Foundation AVStream proxy.</p>
            </remarks>
            <doc-id>dd940437</doc-id>
            <unmanaged>STREAM_MEDIUM</unmanaged>
            <unmanaged-short>STREAM_MEDIUM</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamMedium.GidMedium">
            <summary>
            <dd> <p>Reserved.</p> </dd>
            </summary>
            <doc-id>dd940437</doc-id>
            <unmanaged>gidMedium</unmanaged>
            <unmanaged-short>gidMedium</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.StreamMedium.UnMediumInstance">
            <summary>
            <dd> <p>Reserved.</p> </dd>
            </summary>
            <doc-id>dd940437</doc-id>
            <unmanaged>unMediumInstance</unmanaged>
            <unmanaged-short>unMediumInstance</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TInputStreamInformation">
            <summary>
            <p> </p><p>Contains information about an input stream on a Media Foundation transform (MFT). To get these values, call <strong>IMFTransform::GetInputStreamInfo</strong>.</p>
            </summary>
            <remarks>
            <p>Before the media types are set, the only values that should be considered valid are the MFT_INPUT_STREAM_REMOVABLE and MFT_INPUT_STREAM_OPTIONAL flags in the <strong>dwFlags</strong> member.</p><ul> <li> <p>The MFT_INPUT_STREAM_REMOVABLE flag indicates that the stream can be deleted.</p> </li> <li> <p>The MFT_INPUT_STREAM_OPTIONAL flag indicates that the stream is optional and does not require a media type.</p> </li> </ul><p>After you set a media type on all of the input and output streams (not including optional streams), all of the values returned by the <strong>GetInputStreamInfo</strong> method are valid. They might change if you set different media types.</p>
            </remarks>
            <doc-id>ms704067</doc-id>
            <unmanaged>MFT_INPUT_STREAM_INFO</unmanaged>
            <unmanaged-short>MFT_INPUT_STREAM_INFO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TInputStreamInformation.HnsMaxLatency">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms704067</doc-id>
            <unmanaged>hnsMaxLatency</unmanaged>
            <unmanaged-short>hnsMaxLatency</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TInputStreamInformation.DwFlags">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms704067</doc-id>
            <unmanaged>dwFlags</unmanaged>
            <unmanaged-short>dwFlags</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TInputStreamInformation.CbSize">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms704067</doc-id>
            <unmanaged>cbSize</unmanaged>
            <unmanaged-short>cbSize</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TInputStreamInformation.CbMaxLookahead">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms704067</doc-id>
            <unmanaged>cbMaxLookahead</unmanaged>
            <unmanaged-short>cbMaxLookahead</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TInputStreamInformation.CbAlignment">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms704067</doc-id>
            <unmanaged>cbAlignment</unmanaged>
            <unmanaged-short>cbAlignment</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.ToponodeAttributeUpdate">
            <summary>
            <p>Specifies a new attribute value for a topology node.</p>
            </summary>
            <remarks>
            <p> Due to an error in the structure declaration, the <strong>u64</strong> member is declared as a 32-bit integer, not a 64-bit integer. Therefore, any 64-bit value passed to the <strong>IMFTopologyNodeAttributeEditor::UpdateNodeAttributes</strong> method is truncated to 32 bits. </p>
            </remarks>
            <doc-id>aa371336</doc-id>
            <unmanaged>MFTOPONODE_ATTRIBUTE_UPDATE</unmanaged>
            <unmanaged-short>MFTOPONODE_ATTRIBUTE_UPDATE</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ToponodeAttributeUpdate.NodeId">
            <summary>
            <dd> <p> The identifier of the topology node to update. To get the identifier of a topology node, call <strong>IMFTopologyNode::GetTopoNodeID</strong>. </p> </dd>
            </summary>
            <doc-id>aa371336</doc-id>
            <unmanaged>NodeId</unmanaged>
            <unmanaged-short>NodeId</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ToponodeAttributeUpdate.GuidAttributeKey">
            <summary>
            <dd> <p> <see cref = "T:System.Guid"/> that specifies the attribute to update. </p> </dd>
            </summary>
            <doc-id>aa371336</doc-id>
            <unmanaged>guidAttributeKey</unmanaged>
            <unmanaged-short>guidAttributeKey</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ToponodeAttributeUpdate.AttrType">
            <summary>
            <dd> <p> Attribute type, specified as a member of the <strong><see cref = "T:SharpDX.MediaFoundation.AttributeType"/></strong> enumeration. </p> </dd>
            </summary>
            <doc-id>aa371336</doc-id>
            <unmanaged>attrType</unmanaged>
            <unmanaged-short>attrType</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ToponodeAttributeUpdate.U32">
            <summary>
            <dd> <p> Attribute value (unsigned 32-bit integer). This member is used when <strong>attrType</strong> equals <strong>MF_ATTRIBUTE_UINT32</strong>. </p> </dd>
            </summary>
            <doc-id>aa371336</doc-id>
            <unmanaged>u32</unmanaged>
            <unmanaged-short>u32</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ToponodeAttributeUpdate.U64">
            <summary>
            <dd> <p> Attribute value (unsigned 32-bit integer). This member is used when <strong>attrType</strong> equals <strong>MF_ATTRIBUTE_UINT64</strong>. See Remarks. </p> </dd>
            </summary>
            <doc-id>aa371336</doc-id>
            <unmanaged>u64</unmanaged>
            <unmanaged-short>u64</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.ToponodeAttributeUpdate.D">
            <summary>
            <dd> <p> Attribute value (floating point). This member is used when <strong>attrType</strong> equals <strong>MF_ATTRIBUTE_DOUBLE</strong>. </p> </dd>
            </summary>
            <doc-id>aa371336</doc-id>
            <unmanaged>d</unmanaged>
            <unmanaged-short>d</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TOutputDataBuffer">
            <summary>
            <p> </p><p>Contains information about an output buffer for a Media Foundation transform. This structure is used in the <strong>IMFTransform::ProcessOutput</strong> method.</p>
            </summary>
            <remarks>
            <p>You must provide an <strong><see cref = "T:SharpDX.MediaFoundation.TOutputDataBuffer"/></strong> structure for each selected output stream.</p><p>MFTs can support two different allocation models for output samples:</p><ul> <li> The MFT allocates the output sample. </li> <li> The client allocates the output sample. </li> </ul><p>To find which model the MFT supports for a given output stream, call <strong>IMFTransform::GetOutputStreamInfo</strong> and check the value of <strong>dwFlags</strong>.</p><table> <tr><th>Flag</th><th>Allocation Model</th></tr> <tr><td>MFT_OUTPUT_STREAM_PROVIDES_SAMPLES</td><td>The MFT allocates the output samples for the stream. Set <strong>pSample</strong> to <strong><c>null</c></strong> for this stream.</td></tr> <tr><td>MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES</td><td>The MFT supports both allocation models.</td></tr> <tr><td>Neither (default)</td><td>The client must allocate the output samples for the stream.</td></tr> </table><p>?</p><p>The behavior of <strong>ProcessOutput</strong> depends on the initial value of <strong>pSample</strong> and the value of the <em>dwFlags</em> parameter in the <strong>ProcessOutput</strong> method.</p><ul> <li> <p>If <strong>pSample</strong> is <strong><c>null</c></strong> and <em>dwFlags</em> contains the MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER flag, the MFT discards the output data.</p> <p>Restriction: This output stream must have the MFT_OUTPUT_STREAM_DISCARDABLE or MFT_OUTPUT_STREAM_LAZY_READ flag. (To get the flags for the output stream, call the <strong>IMFTransform::GetOutputStreamInfo</strong> method.)</p> </li> <li> <p>If <strong>pSample</strong> is <strong><c>null</c></strong> and <em>dwFlags</em> does not contain the MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER, the MFT provides a sample for the output data. The MFT sets <strong>pSample</strong> to point to the sample that it provides. The MFT can either allocate a new sample or re-use an input sample.</p> <p>Restriction: This output stream must have the MFT_OUTPUT_STREAM_PROVIDES_SAMPLES or MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES flag.</p> </li> <li> <p>If <strong>pSample</strong> is non-<strong><c>null</c></strong>, the MFT uses the sample provided by the caller.</p> <p>Restriction: This output stream must not have the MFT_OUTPUT_STREAM_PROVIDES_SAMPLES flag.</p> </li> </ul><p>Any other combinations are invalid and cause <strong>ProcessOutput</strong> to return E_INVALIDARG.</p><p>Each call to <strong>ProcessOutput</strong> can produce zero or more events and up to one sample per output stream.</p>
            </remarks>
            <doc-id>ms697247</doc-id>
            <unmanaged>MFT_OUTPUT_DATA_BUFFER</unmanaged>
            <unmanaged-short>MFT_OUTPUT_DATA_BUFFER</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TOutputDataBuffer.DwStreamID">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697247</doc-id>
            <unmanaged>dwStreamID</unmanaged>
            <unmanaged-short>dwStreamID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TOutputDataBuffer.PSample">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697247</doc-id>
            <unmanaged>pSample</unmanaged>
            <unmanaged-short>pSample</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TOutputDataBuffer.DwStatus">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697247</doc-id>
            <unmanaged>dwStatus</unmanaged>
            <unmanaged-short>dwStatus</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TOutputDataBuffer.PEvents">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms697247</doc-id>
            <unmanaged>pEvents</unmanaged>
            <unmanaged-short>pEvents</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TOutputStreamInformation">
            <summary>
            <p> </p><p>Contains information about an output stream on a Media Foundation transform (MFT). To get these values, call <strong>IMFTransform::GetOutputStreamInfo</strong>.</p>
            </summary>
            <remarks>
            <p>Before the media types are set, the only values that should be considered valid is the MFT_OUTPUT_STREAM_OPTIONAL flag in the <strong>dwFlags</strong> member. This flag indicates that the stream is optional and does not require a media type.</p><p>After you set a media type on all of the input and output streams (not including optional streams), all of the values returned by the <strong>GetOutputStreamInfo</strong> method are valid. They might change if you set different media types.</p>
            </remarks>
            <doc-id>ms696974</doc-id>
            <unmanaged>MFT_OUTPUT_STREAM_INFO</unmanaged>
            <unmanaged-short>MFT_OUTPUT_STREAM_INFO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TOutputStreamInformation.DwFlags">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms696974</doc-id>
            <unmanaged>dwFlags</unmanaged>
            <unmanaged-short>dwFlags</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TOutputStreamInformation.CbSize">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms696974</doc-id>
            <unmanaged>cbSize</unmanaged>
            <unmanaged-short>cbSize</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TOutputStreamInformation.CbAlignment">
            <summary>
            No documentation.
            </summary>
            <doc-id>ms696974</doc-id>
            <unmanaged>cbAlignment</unmanaged>
            <unmanaged-short>cbAlignment</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TranscodeSinkInformation">
            <summary>
            <p>Contains information about the audio and video streams for the transcode sink activation object.</p><p>To get the information stored in this structure, call <strong>IMFTranscodeSinkInfoProvider::GetSinkInfo</strong>.</p>
            </summary>
            <remarks>
            <p>The <strong>IMFTranscodeSinkInfoProvider::GetSinkInfo</strong> method assigns <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> references to the <strong>pAudioMediaType</strong> and <strong>pVideoMediaType</strong> members of this structure. The method might set either member to <strong><c>null</c></strong>. If either member is non-<strong><c>null</c></strong> after the method returns, the caller must release the <strong><see cref = "T:SharpDX.MediaFoundation.MediaType"/></strong> references.</p>
            </remarks>
            <doc-id>dd388923</doc-id>
            <unmanaged>MF_TRANSCODE_SINK_INFO</unmanaged>
            <unmanaged-short>MF_TRANSCODE_SINK_INFO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeSinkInformation.DwVideoStreamID">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388923</doc-id>
            <unmanaged>dwVideoStreamID</unmanaged>
            <unmanaged-short>dwVideoStreamID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeSinkInformation.PVideoMediaType">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388923</doc-id>
            <unmanaged>pVideoMediaType</unmanaged>
            <unmanaged-short>pVideoMediaType</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeSinkInformation.DwAudioStreamID">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388923</doc-id>
            <unmanaged>dwAudioStreamID</unmanaged>
            <unmanaged-short>dwAudioStreamID</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TranscodeSinkInformation.PAudioMediaType">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388923</doc-id>
            <unmanaged>pAudioMediaType</unmanaged>
            <unmanaged-short>pAudioMediaType</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TRegisterTypeInformation">
            <summary>
            <p>Contains media type information for registering a Media Foundation transform (MFT). </p>
            </summary>
            <doc-id>ms694919</doc-id>
            <unmanaged>MFT_REGISTER_TYPE_INFO</unmanaged>
            <unmanaged-short>MFT_REGISTER_TYPE_INFO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TRegisterTypeInformation.GuidMajorType">
            <summary>
            <dd> <p>The major media type. For a list of possible values, see Major Media Types. </p> </dd>
            </summary>
            <doc-id>ms694919</doc-id>
            <unmanaged>guidMajorType</unmanaged>
            <unmanaged-short>guidMajorType</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TRegisterTypeInformation.GuidSubtype">
            <summary>
            <dd> <p>The media subtype. For a list of possible values, see the following topics:</p> <ul> <li> Audio Subtype GUIDs </li> <li> Video Subtype GUIDs </li> </ul> </dd>
            </summary>
            <doc-id>ms694919</doc-id>
            <unmanaged>guidSubtype</unmanaged>
            <unmanaged-short>guidSubtype</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TRegistrationInformation">
            <summary>
            <p>Contains parameters for the <strong>IMFLocalMFTRegistration::RegisterMFTs</strong> method.</p>
            </summary>
            <doc-id>dd388673</doc-id>
            <unmanaged>MFT_REGISTRATION_INFO</unmanaged>
            <unmanaged-short>MFT_REGISTRATION_INFO</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TRegistrationInformation.Clsid">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388673</doc-id>
            <unmanaged>clsid</unmanaged>
            <unmanaged-short>clsid</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TRegistrationInformation.GuidCategory">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388673</doc-id>
            <unmanaged>guidCategory</unmanaged>
            <unmanaged-short>guidCategory</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TRegistrationInformation.UiFlags">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388673</doc-id>
            <unmanaged>uiFlags</unmanaged>
            <unmanaged-short>uiFlags</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TRegistrationInformation.PszName">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388673</doc-id>
            <unmanaged>pszName</unmanaged>
            <unmanaged-short>pszName</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TRegistrationInformation.CInTypes">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388673</doc-id>
            <unmanaged>cInTypes</unmanaged>
            <unmanaged-short>cInTypes</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TRegistrationInformation.PInTypes">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388673</doc-id>
            <unmanaged>pInTypes</unmanaged>
            <unmanaged-short>pInTypes</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TRegistrationInformation.COutTypes">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388673</doc-id>
            <unmanaged>cOutTypes</unmanaged>
            <unmanaged-short>cOutTypes</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TRegistrationInformation.POutTypes">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd388673</doc-id>
            <unmanaged>pOutTypes</unmanaged>
            <unmanaged-short>pOutTypes</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.TStreamStateParam">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MFT_STREAM_STATE_PARAM</unmanaged>
            <unmanaged-short>MFT_STREAM_STATE_PARAM</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TStreamStateParam.StreamId">
            <summary>
            No documentation.
            </summary>
            <unmanaged>StreamId</unmanaged>
            <unmanaged-short>StreamId</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.TStreamStateParam.State">
            <summary>
            No documentation.
            </summary>
            <unmanaged>State</unmanaged>
            <unmanaged-short>State</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoArea">
            <summary>
            <p> Specifies a rectangular area within a video frame. </p>
            </summary>
            <doc-id>ms703850</doc-id>
            <unmanaged>MFVideoArea</unmanaged>
            <unmanaged-short>MFVideoArea</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoArea.OffsetX">
            <summary>
            <dd> <p> An <strong><see cref = "T:SharpDX.MediaFoundation.Offset"/></strong> structure that contains the x-coordinate of the upper-left corner of the rectangle. This coordinate might have a fractional value. </p> </dd>
            </summary>
            <doc-id>ms703850</doc-id>
            <unmanaged>OffsetX</unmanaged>
            <unmanaged-short>OffsetX</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoArea.OffsetY">
            <summary>
            <dd> <p> An <strong><see cref = "T:SharpDX.MediaFoundation.Offset"/></strong> structure that contains the y-coordinate of the upper-left corner of the rectangle. This coordinate might have a fractional value. </p> </dd>
            </summary>
            <doc-id>ms703850</doc-id>
            <unmanaged>OffsetY</unmanaged>
            <unmanaged-short>OffsetY</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoArea.Area">
            <summary>
            <dd> <p> A <strong><see cref = "T:SharpDX.Size2"/></strong> structure that contains the width and height of the rectangle. </p> </dd>
            </summary>
            <doc-id>ms703850</doc-id>
            <unmanaged>Area</unmanaged>
            <unmanaged-short>Area</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoCompressedInfo">
            <summary>
            <p> </p><p>Contains information about a video compression format. This structure is used in the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure.</p>
            </summary>
            <remarks>
            <p>For uncompressed video formats, set the structure members to zero.</p>
            </remarks>
            <doc-id>aa473839</doc-id>
            <unmanaged>MFVideoCompressedInfo</unmanaged>
            <unmanaged-short>MFVideoCompressedInfo</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoCompressedInfo.AvgBitrate">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473839</doc-id>
            <unmanaged>AvgBitrate</unmanaged>
            <unmanaged-short>AvgBitrate</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoCompressedInfo.AvgBitErrorRate">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473839</doc-id>
            <unmanaged>AvgBitErrorRate</unmanaged>
            <unmanaged-short>AvgBitErrorRate</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoCompressedInfo.MaxKeyFrameSpacing">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473839</doc-id>
            <unmanaged>MaxKeyFrameSpacing</unmanaged>
            <unmanaged-short>MaxKeyFrameSpacing</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoFormat">
            <summary>
            <p> </p><p>Describes a video format.</p>
            </summary>
            <remarks>
            <p>Applications should avoid using this structure. Instead, it is recommended that applications use attributes to describe the video format. For a list of media type attributes, see Media Type Attributes. With attributes, you can set just the format information that you know, which is easier (and more likely to be accurate) than trying to fill in complete format information for the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure.</p><p>To initialize a media type object from an <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure, call <strong>MFInitMediaTypeFromMFVideoFormat</strong>.</p><p>You can use the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure as the format block for a DirectShow media type. Set the format <see cref = "T:System.Guid"/> to FORMAT_MFVideoFormat.</p>
            </remarks>
            <doc-id>aa473808</doc-id>
            <unmanaged>MFVIDEOFORMAT</unmanaged>
            <unmanaged-short>MFVIDEOFORMAT</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormat.DwSize">
            <summary>
            <dd> <p>Size of the structure, in bytes. This value includes the size of the palette entries that may appear after the <strong>surfaceInfo</strong> member.</p> </dd>
            </summary>
            <doc-id>aa473808</doc-id>
            <unmanaged>dwSize</unmanaged>
            <unmanaged-short>dwSize</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormat.VideoInfo">
            <summary>
            <dd> <p> <strong><see cref = "T:SharpDX.MediaFoundation.VideoInfo"/></strong> structure. This structure contains information that applies to both compressed and uncompressed formats.</p> </dd>
            </summary>
            <doc-id>aa473808</doc-id>
            <unmanaged>videoInfo</unmanaged>
            <unmanaged-short>videoInfo</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormat.GuidFormat">
            <summary>
            <dd> <p>Video subtype. See Video Subtype GUIDs.</p> </dd>
            </summary>
            <doc-id>aa473808</doc-id>
            <unmanaged>guidFormat</unmanaged>
            <unmanaged-short>guidFormat</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormat.CompressedInfo">
            <summary>
            <dd> <p> <strong><see cref = "T:SharpDX.MediaFoundation.VideoCompressedInfo"/></strong> structure. This structure contains information that applies only to compressed formats.</p> </dd>
            </summary>
            <doc-id>aa473808</doc-id>
            <unmanaged>compressedInfo</unmanaged>
            <unmanaged-short>compressedInfo</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoFormat.SurfaceInfo">
            <summary>
            <dd> <p> <strong><see cref = "T:SharpDX.MediaFoundation.VideoSurfaceInfo"/></strong> structure. This structure contains information that applies only to uncompressed formats.</p> </dd>
            </summary>
            <doc-id>aa473808</doc-id>
            <unmanaged>surfaceInfo</unmanaged>
            <unmanaged-short>surfaceInfo</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoInfo">
            <summary>
            <p> </p><p>Contains video format information that applies to both compressed and uncompressed formats.</p><p>This structure is used in the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure.</p>
            </summary>
            <remarks>
            <p>Developers are encouraged to use media type attributes instead of using the <strong><see cref = "T:SharpDX.MediaFoundation.VideoInfo"/></strong> structure. The following table lists the attributes that correspond to the members of this structure.</p><table> <tr><th>Structure Member</th><th>Media Type Attribute</th></tr> <tr><td><strong>dwWidth</strong>, <strong>dwHeight</strong></td><td> <strong><see cref = "!:FrameSize"/></strong> </td></tr> <tr><td><strong>PixelAspectRatio</strong></td><td> <strong><see cref = "F:SharpDX.MediaFoundation.VideoInfo.PixelAspectRatio"/></strong> </td></tr> <tr><td><strong>SourceChromaSubsampling</strong></td><td> <strong><see cref = "!:VideoChromaSiting"/></strong> </td></tr> <tr><td><strong>InterlaceMode</strong></td><td> <strong><see cref = "F:SharpDX.MediaFoundation.VideoInfo.InterlaceMode"/></strong> </td></tr> <tr><td><strong>TransferFunction</strong></td><td> <strong><see cref = "F:SharpDX.MediaFoundation.VideoInfo.TransferFunction"/></strong> </td></tr> <tr><td><strong>ColorPrimaries</strong></td><td> <strong><see cref = "T:SharpDX.MediaFoundation.VideoPrimaries"/></strong> </td></tr> <tr><td><strong>TransferMatrix</strong></td><td> <strong><see cref = "!:YuvMatrix"/></strong> </td></tr> <tr><td><strong>SourceLighting</strong></td><td> <strong><see cref = "T:SharpDX.MediaFoundation.VideoLighting"/></strong> </td></tr> <tr><td><strong>FramesPerSecond</strong></td><td> <strong><see cref = "!:FrameRate"/></strong> </td></tr> <tr><td><strong>NominalRange</strong></td><td> <strong><see cref = "!:VideoNominalRange"/></strong> </td></tr> <tr><td><strong>GeometricAperture</strong></td><td> <strong><see cref = "F:SharpDX.MediaFoundation.VideoInfo.GeometricAperture"/></strong> </td></tr> <tr><td><strong>MinimumDisplayAperture</strong></td><td> <strong><see cref = "F:SharpDX.MediaFoundation.VideoInfo.MinimumDisplayAperture"/></strong> </td></tr> <tr><td><strong>PanScanAperture</strong></td><td> <strong><see cref = "F:SharpDX.MediaFoundation.VideoInfo.PanScanAperture"/></strong> </td></tr> <tr><td><strong>VideoFlags</strong></td><td>See <strong><see cref = "T:SharpDX.MediaFoundation.VideoFlags"/></strong>.</td></tr> </table><p>?</p>
            </remarks>
            <doc-id>aa473804</doc-id>
            <unmanaged>MFVideoInfo</unmanaged>
            <unmanaged-short>MFVideoInfo</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInfo.DwWidth">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473804</doc-id>
            <unmanaged>dwWidth</unmanaged>
            <unmanaged-short>dwWidth</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInfo.DwHeight">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473804</doc-id>
            <unmanaged>dwHeight</unmanaged>
            <unmanaged-short>dwHeight</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInfo.PixelAspectRatio">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473804</doc-id>
            <unmanaged>PixelAspectRatio</unmanaged>
            <unmanaged-short>PixelAspectRatio</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInfo.SourceChromaSubsampling">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473804</doc-id>
            <unmanaged>SourceChromaSubsampling</unmanaged>
            <unmanaged-short>SourceChromaSubsampling</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInfo.InterlaceMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473804</doc-id>
            <unmanaged>InterlaceMode</unmanaged>
            <unmanaged-short>InterlaceMode</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInfo.TransferFunction">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473804</doc-id>
            <unmanaged>TransferFunction</unmanaged>
            <unmanaged-short>TransferFunction</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInfo.ColorPrimaries">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473804</doc-id>
            <unmanaged>ColorPrimaries</unmanaged>
            <unmanaged-short>ColorPrimaries</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInfo.TransferMatrix">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473804</doc-id>
            <unmanaged>TransferMatrix</unmanaged>
            <unmanaged-short>TransferMatrix</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInfo.SourceLighting">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473804</doc-id>
            <unmanaged>SourceLighting</unmanaged>
            <unmanaged-short>SourceLighting</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInfo.FramesPerSecond">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473804</doc-id>
            <unmanaged>FramesPerSecond</unmanaged>
            <unmanaged-short>FramesPerSecond</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInfo.NominalRange">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473804</doc-id>
            <unmanaged>NominalRange</unmanaged>
            <unmanaged-short>NominalRange</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInfo.GeometricAperture">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473804</doc-id>
            <unmanaged>GeometricAperture</unmanaged>
            <unmanaged-short>GeometricAperture</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInfo.MinimumDisplayAperture">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473804</doc-id>
            <unmanaged>MinimumDisplayAperture</unmanaged>
            <unmanaged-short>MinimumDisplayAperture</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInfo.PanScanAperture">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473804</doc-id>
            <unmanaged>PanScanAperture</unmanaged>
            <unmanaged-short>PanScanAperture</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoInfo.VideoFlags">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473804</doc-id>
            <unmanaged>VideoFlags</unmanaged>
            <unmanaged-short>VideoFlags</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoNormalizedRect">
            <summary>
            <p> </p><p>Defines a normalized rectangle, which is used to specify sub-rectangles in a video rectangle. When a rectangle N is <em>normalized</em> relative to some other rectangle R, it means the following:</p><ul> <li> <p>The coordinate (0.0, 0.0) on N is mapped to the upper-left corner of R.</p> </li> <li> <p>The coordinate (1.0, 1.0) on N is mapped to the lower-right corner of R.</p> </li> </ul><p>Any coordinates of N that fall outside the range [0...1] are mapped to positions outside the rectangle R. A normalized rectangle can be used to specify a region within a video rectangle without knowing the resolution or even the aspect ratio of the video. For example, the upper-left quadrant is defined as {0.0, 0.0, 0.5, 0.5}.</p>
            </summary>
            <doc-id>ms703049</doc-id>
            <unmanaged>MFVideoNormalizedRect</unmanaged>
            <unmanaged-short>MFVideoNormalizedRect</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoNormalizedRect.Left">
            <summary>
            <dd> <p>X-coordinate of the upper-left corner of the rectangle.</p> </dd>
            </summary>
            <doc-id>ms703049</doc-id>
            <unmanaged>left</unmanaged>
            <unmanaged-short>left</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoNormalizedRect.Top">
            <summary>
            <dd> <p>Y-coordinate of the upper-left corner of the rectangle.</p> </dd>
            </summary>
            <doc-id>ms703049</doc-id>
            <unmanaged>top</unmanaged>
            <unmanaged-short>top</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoNormalizedRect.Right">
            <summary>
            <dd> <p>X-coordinate of the lower-right corner of the rectangle.</p> </dd>
            </summary>
            <doc-id>ms703049</doc-id>
            <unmanaged>right</unmanaged>
            <unmanaged-short>right</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoNormalizedRect.Bottom">
            <summary>
            <dd> <p>Y-coordinate of the lower-right corner of the rectangle.</p> </dd>
            </summary>
            <doc-id>ms703049</doc-id>
            <unmanaged>bottom</unmanaged>
            <unmanaged-short>bottom</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoSphericalViewDirection">
            <summary>
            No documentation.
            </summary>
            <unmanaged>MF_VIDEO_SPHERICAL_VIEWDIRECTION</unmanaged>
            <unmanaged-short>MF_VIDEO_SPHERICAL_VIEWDIRECTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoSphericalViewDirection.IHeading">
            <summary>
            No documentation.
            </summary>
            <unmanaged>iHeading</unmanaged>
            <unmanaged-short>iHeading</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoSphericalViewDirection.IPitch">
            <summary>
            No documentation.
            </summary>
            <unmanaged>iPitch</unmanaged>
            <unmanaged-short>iPitch</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoSphericalViewDirection.IRoll">
            <summary>
            No documentation.
            </summary>
            <unmanaged>iRoll</unmanaged>
            <unmanaged-short>iRoll</unmanaged-short>
        </member>
        <member name="T:SharpDX.MediaFoundation.VideoSurfaceInfo">
            <summary>
            <p> </p><p>Contains information about an uncompressed video format. This structure is used in the <strong><see cref = "T:SharpDX.MediaFoundation.VideoFormat"/></strong> structure.</p>
            </summary>
            <doc-id>aa473817</doc-id>
            <unmanaged>MFVideoSurfaceInfo</unmanaged>
            <unmanaged-short>MFVideoSurfaceInfo</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoSurfaceInfo.Format">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473817</doc-id>
            <unmanaged>Format</unmanaged>
            <unmanaged-short>Format</unmanaged-short>
        </member>
        <member name="F:SharpDX.MediaFoundation.VideoSurfaceInfo.PaletteEntries">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473817</doc-id>
            <unmanaged>PaletteEntries</unmanaged>
            <unmanaged-short>PaletteEntries</unmanaged-short>
        </member>
        <member name="P:SharpDX.MediaFoundation.VideoSurfaceInfo.Palette">
            <summary>
            No documentation.
            </summary>
            <doc-id>aa473817</doc-id>
            <unmanaged>Palette</unmanaged>
            <unmanaged-short>Palette</unmanaged-short>
        </member>
    </members>
</doc>
